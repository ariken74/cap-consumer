var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
        while (++index < length) {
          result2[index] = iteratee(array[index], index, array);
        }
        return result2;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result2;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result2 = key;
            return false;
          }
        });
        return result2;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result2, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result2 = result2 === undefined2 ? current : result2 + current;
          }
        }
        return result2;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result2 = Array(n);
        while (++index < n) {
          result2[index] = iteratee(index);
        }
        return result2;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result2 = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result2;
          }
        }
        return result2;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result2 = [];
        while (!(data = iterator.next()).done) {
          result2.push(data.value);
        }
        return result2;
      }
      function mapToArray(map2) {
        var index = -1, result2 = Array(map2.size);
        map2.forEach(function(value, key) {
          result2[++index] = [key, value];
        });
        return result2;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result2[resIndex++] = index;
          }
        }
        return result2;
      }
      function setToArray(set) {
        var index = -1, result2 = Array(set.size);
        set.forEach(function(value) {
          result2[++index] = value;
        });
        return result2;
      }
      function setToPairs(set) {
        var index = -1, result2 = Array(set.size);
        set.forEach(function(value) {
          result2[++index] = [value, value];
        });
        return result2;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result2 = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result2;
        }
        return result2;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result3 = new object();
            object.prototype = undefined2;
            return result3;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result3 = new LazyWrapper(this.__wrapped__);
          result3.__actions__ = copyArray(this.__actions__);
          result3.__dir__ = this.__dir__;
          result3.__filtered__ = this.__filtered__;
          result3.__iteratees__ = copyArray(this.__iteratees__);
          result3.__takeCount__ = this.__takeCount__;
          result3.__views__ = copyArray(this.__views__);
          return result3;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result3 = new LazyWrapper(this);
            result3.__dir__ = -1;
            result3.__filtered__ = true;
          } else {
            result3 = this.clone();
            result3.__dir__ *= -1;
          }
          return result3;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result3 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result3[resIndex++] = value;
            }
          return result3;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result3 = this.has(key) && delete this.__data__[key];
          this.size -= result3 ? 1 : 0;
          return result3;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result3 = data[key];
            return result3 === HASH_UNDEFINED ? undefined2 : result3;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result3 = getMapData(this, key)["delete"](key);
          this.size -= result3 ? 1 : 0;
          return result3;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result3 = data["delete"](key);
          this.size = data.size;
          return result3;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes(value.length, String2) : [], length = result3.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result3.push(key);
            }
          }
          return result3;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result3 = Array2(length), skip = object == null;
          while (++index < length) {
            result3[index] = skip ? undefined2 : get2(object, paths[index]);
          }
          return result3;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result3, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result3 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result3 !== undefined2) {
            return result3;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result3 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result3);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result3 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result3, value)) : copySymbols(value, baseAssign(result3, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result3 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result3);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result3.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result3.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result3, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result3;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result3 = [], valuesLength = values2.length;
          if (!length) {
            return result3;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result3.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result3.push(value);
              }
            }
          return result3;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result3 = true;
          baseEach(collection, function(value, index, collection2) {
            result3 = !!predicate(value, index, collection2);
            return result3;
          });
          return result3;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result3 = value;
            }
          }
          return result3;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result3 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result3.push(value);
            }
          });
          return result3;
        }
        function baseFlatten(array, depth, predicate, isStrict, result3) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result3 || (result3 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result3);
              } else {
                arrayPush(result3, value);
              }
            } else if (!isStrict) {
              result3[result3.length] = value;
            }
          }
          return result3;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result3 = keysFunc(object);
          return isArray(object) ? result3 : arrayPush(result3, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result3 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result3.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result3, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result3.push(value);
              }
            }
          return result3;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result3 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result3 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result3)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result3 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result3.push(key);
            }
          }
          return result3;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result3 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result3.push(key);
            }
          }
          return result3;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result3 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result3[++index] = iteratee2(value, key, collection2);
          });
          return result3;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get2(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result3 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result3, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result3 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result3, castPath(path, object), value);
            }
          }
          return result3;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result3 = Array2(length);
          while (length--) {
            result3[fromRight ? length : ++index] = start;
            start += step;
          }
          return result3;
        }
        function baseRepeat(string, n) {
          var result3 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result3;
          }
          do {
            if (n % 2) {
              result3 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result3;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result3 = Array2(length);
          while (++index < length) {
            result3[index] = array[index + start];
          }
          return result3;
        }
        function baseSome(collection, predicate) {
          var result3;
          baseEach(collection, function(value, index, collection2) {
            result3 = predicate(value, index, collection2);
            return !result3;
          });
          return !!result3;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result3 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result3[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result3;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result3 = value + "";
          return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result3 = [], seen = result3;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result3;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result3.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result3) {
                  seen.push(computed);
                }
                result3.push(value);
              }
            }
          return result3;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result3 = value;
          if (result3 instanceof LazyWrapper) {
            result3 = result3.value();
          }
          return arrayReduce(actions, function(result4, action) {
            return action.func.apply(action.thisArg, arrayPush([result4], action.args));
          }, result3);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result3 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result3[index] = baseDifference(result3[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result3, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result3 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result3, props[index], value);
          }
          return result3;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result3);
          return result3;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result3).set(new Uint8Array2(arrayBuffer));
          return result3;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result3 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result3.lastIndex = regexp.lastIndex;
          return result3;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result3 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result3) {
              if (index >= ordersLength) {
                return result3;
              }
              var order = orders[index];
              return result3 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result3[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result3[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result3[leftIndex++] = args[argsIndex++];
          }
          return result3;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result3[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result3[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result3[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result3;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result3 = Ctor.apply(thisBinding, args);
            return isObject(result3) ? result3 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result3 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result3 = funcs[index2].call(this, result3);
              }
              return result3;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result3;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result3 = value;
            }
            if (other !== undefined2) {
              if (result3 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result3 = operator(value, other);
            }
            return result3;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result3 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result3), 0, length).join("") : result3.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result3 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result3, newData);
          }
          result3.placeholder = placeholder;
          return setWrapToString(result3, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result3 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result3 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result3 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result3 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result3, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result3 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result3 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result3 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result3 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result3;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result3 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result3;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result3 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result3 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result3 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result3 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result3;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result3 = func.name + "", array = realNames[result3], length = hasOwnProperty.call(realNames, result3) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result3;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result3 = lodash.iteratee || iteratee;
          result3 = result3 === iteratee ? baseIteratee : result3;
          return arguments.length ? result3(arguments[0], arguments[1]) : result3;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result3 = keys(object), length = result3.length;
          while (length--) {
            var key = result3[length], value = object[key];
            result3[length] = [key, value, isStrictComparable(value)];
          }
          return result3;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result3 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result3;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result3 = [];
          while (object) {
            arrayPush(result3, getSymbols(object));
            object = getPrototype(object);
          }
          return result3;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result3 = baseGetTag(value), Ctor = result3 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result3;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result3 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result3 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result3 || ++index != length) {
            return result3;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result3 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result3.index = array.index;
            result3.input = array.input;
          }
          return result3;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result3 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result3.cache;
          return result3;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result3 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result3.push(key);
            }
          }
          return result3;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result3 = [];
          if (string.charCodeAt(0) === 46) {
            result3.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result3.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result3;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result3 = value + "";
          return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result3 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result3.__actions__ = copyArray(wrapper.__actions__);
          result3.__index__ = wrapper.__index__;
          result3.__values__ = wrapper.__values__;
          return result3;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result3 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result3[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result3;
        }
        function compact2(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result3 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result3[resIndex++] = value;
            }
          }
          return result3;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result3 = {};
          while (++index < length) {
            var pair = pairs[index];
            result3[pair[0]] = pair[1];
          }
          return result3;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result3 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result3;
        });
        function remove(array, predicate) {
          var result3 = [];
          if (!(array && array.length)) {
            return result3;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result3.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result3;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result3 = unzip(array);
          if (iteratee2 == null) {
            return result3;
          }
          return arrayMap(result3, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result3 = lodash(value);
          result3.__chain__ = true;
          return result3;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result3, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result3) {
              previous.__wrapped__ = clone2;
            } else {
              result3 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result3;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result3, value, key) {
          if (hasOwnProperty.call(result3, key)) {
            ++result3[key];
          } else {
            baseAssignValue(result3, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result3, value, key) {
          if (hasOwnProperty.call(result3, key)) {
            result3[key].push(value);
          } else {
            baseAssignValue(result3, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result3 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result3[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result3;
        });
        var keyBy = createAggregator(function(result3, value, key) {
          baseAssignValue(result3, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result3, value, key) {
          result3[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result3;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result3 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result3;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result3 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result3.placeholder = curry.placeholder;
          return result3;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result3 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result3.placeholder = curryRight.placeholder;
          return result3;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result3 = func.apply(thisArg, args);
            return result3;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result3;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result3;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result3 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result3;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result3 = func.apply(this, args);
            memoized.cache = cache.set(key, result3) || cache;
            return result3;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result3 = customizer ? customizer(value, other) : undefined2;
          return result3 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result3;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result3 = toFinite(value), remainder = result3 % 1;
          return result3 === result3 ? remainder ? result3 - remainder : result3 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result3 = baseCreate(prototype);
          return properties == null ? result3 : baseAssign(result3, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get2(object, path, defaultValue) {
          var result3 = object == null ? undefined2 : baseGet(object, path);
          return result3 === undefined2 ? defaultValue : result3;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result3, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result3[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result3, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result3, value)) {
            result3[value].push(key);
          } else {
            result3[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result3 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result3, iteratee2(value, key, object2), value);
          });
          return result3;
        }
        function mapValues(object, iteratee2) {
          var result3 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result3, key, iteratee2(value, key, object2));
          });
          return result3;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result3 = {};
          if (object == null) {
            return result3;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result3);
          if (isDeep) {
            result3 = baseClone(result3, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result3, paths[length]);
          }
          return result3;
        });
        function omitBy2(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result2(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result3, word, index) {
          word = word.toLowerCase();
          return result3 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith2(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result3 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result3.source = source;
          if (isError(result3)) {
            throw result3;
          }
          return result3;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result3 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result3 + omission;
          }
          if (strSymbols) {
            end += result3.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result3;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result3 = result3.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result3.lastIndexOf(separator);
            if (index > -1) {
              result3 = result3.slice(0, index);
            }
          }
          return result3 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result3, word, index) {
          return result3 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result3 = object(this.__wrapped__), actions = result3.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result3.__chain__ = chainAll;
                  return result3;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result3 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result3;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact2;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy2;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get2;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result2;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith2;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result3 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result3.__filtered__) {
              result3.__takeCount__ = nativeMin(n, result3.__takeCount__);
            } else {
              result3.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result3.__dir__ < 0 ? "Right" : "")
              });
            }
            return result3;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result3 = this.clone();
            result3.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result3.__filtered__ = result3.__filtered__ || isFilter;
            return result3;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result3 = this;
          if (result3.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result3);
          }
          if (start < 0) {
            result3 = result3.takeRight(-start);
          } else if (start) {
            result3 = result3.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result3 = end < 0 ? result3.dropRight(-end) : result3.take(end - start);
          }
          return result3;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result4 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result4[0] : result4;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result3 = func.apply(value, args);
              result3.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result3, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result3 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports2, module2) {
    module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/flat/index.js
var require_flat = __commonJS({
  "node_modules/flat/index.js"(exports2, module2) {
    module2.exports = flatten;
    flatten.flatten = flatten;
    flatten.unflatten = unflatten;
    function isBuffer(obj) {
      return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function keyIdentity(key) {
      return key;
    }
    function flatten(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const maxDepth = opts.maxDepth;
      const transformKey = opts.transformKey || keyIdentity;
      const output = {};
      function step(object, prev, currentDepth) {
        currentDepth = currentDepth || 1;
        Object.keys(object).forEach(function(key) {
          const value = object[key];
          const isarray = opts.safe && Array.isArray(value);
          const type = Object.prototype.toString.call(value);
          const isbuffer = isBuffer(value);
          const isobject = type === "[object Object]" || type === "[object Array]";
          const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
          if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
            return step(value, newKey, currentDepth + 1);
          }
          output[newKey] = value;
        });
      }
      step(target);
      return output;
    }
    function unflatten(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const overwrite = opts.overwrite || false;
      const transformKey = opts.transformKey || keyIdentity;
      const result2 = {};
      const isbuffer = isBuffer(target);
      if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
        return target;
      }
      function getkey(key) {
        const parsedKey = Number(key);
        return isNaN(parsedKey) || key.indexOf(".") !== -1 || opts.object ? key : parsedKey;
      }
      function addKeys(keyPrefix, recipient, target2) {
        return Object.keys(target2).reduce(function(result3, key) {
          result3[keyPrefix + delimiter + key] = target2[key];
          return result3;
        }, recipient);
      }
      function isEmpty(val) {
        const type = Object.prototype.toString.call(val);
        const isArray = type === "[object Array]";
        const isObject = type === "[object Object]";
        if (!val) {
          return true;
        } else if (isArray) {
          return !val.length;
        } else if (isObject) {
          return !Object.keys(val).length;
        }
      }
      target = Object.keys(target).reduce(function(result3, key) {
        const type = Object.prototype.toString.call(target[key]);
        const isObject = type === "[object Object]" || type === "[object Array]";
        if (!isObject || isEmpty(target[key])) {
          result3[key] = target[key];
          return result3;
        } else {
          return addKeys(
            key,
            result3,
            flatten(target[key], opts)
          );
        }
      }, {});
      Object.keys(target).forEach(function(key) {
        const split = key.split(delimiter).map(transformKey);
        let key1 = getkey(split.shift());
        let key2 = getkey(split[0]);
        let recipient = result2;
        while (key2 !== void 0) {
          if (key1 === "__proto__") {
            return;
          }
          const type = Object.prototype.toString.call(recipient[key1]);
          const isobject = type === "[object Object]" || type === "[object Array]";
          if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
            return;
          }
          if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
            recipient[key1] = typeof key2 === "number" && !opts.object ? [] : {};
          }
          recipient = recipient[key1];
          if (split.length > 0) {
            key1 = getkey(split.shift());
            key2 = getkey(split[0]);
          }
        }
        recipient[key1] = unflatten(target[key], opts);
      });
      return result2;
    }
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports2, module2) {
    "use strict";
    var codes = require_codes();
    module2.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map2 = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        map2[message.toLowerCase()] = status2;
      });
      return map2;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status.message[code];
    }
    function status(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// node_modules/inflection/lib/inflection.js
var require_inflection = __commonJS({
  "node_modules/inflection/lib/inflection.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory();
      } else {
        root.inflection = factory();
      }
    })(exports2, function() {
      var uncountable_words = [
        // 'access',
        "accommodation",
        "adulthood",
        "advertising",
        "advice",
        "aggression",
        "aid",
        "air",
        "aircraft",
        "alcohol",
        "anger",
        "applause",
        "arithmetic",
        // 'art',
        "assistance",
        "athletics",
        // 'attention',
        "bacon",
        "baggage",
        // 'ballet',
        // 'beauty',
        "beef",
        // 'beer',
        // 'behavior',
        "biology",
        // 'billiards',
        "blood",
        "botany",
        // 'bowels',
        "bread",
        // 'business',
        "butter",
        "carbon",
        "cardboard",
        "cash",
        "chalk",
        "chaos",
        "chess",
        "crossroads",
        "countryside",
        // 'damage',
        "dancing",
        // 'danger',
        "deer",
        // 'delight',
        // 'dessert',
        "dignity",
        "dirt",
        // 'distribution',
        "dust",
        "economics",
        "education",
        "electricity",
        // 'employment',
        // 'energy',
        "engineering",
        "enjoyment",
        // 'entertainment',
        "envy",
        "equipment",
        "ethics",
        "evidence",
        "evolution",
        // 'failure',
        // 'faith',
        "fame",
        "fiction",
        // 'fish',
        "flour",
        "flu",
        "food",
        // 'freedom',
        // 'fruit',
        "fuel",
        "fun",
        // 'funeral',
        "furniture",
        "gallows",
        "garbage",
        "garlic",
        // 'gas',
        "genetics",
        // 'glass',
        "gold",
        "golf",
        "gossip",
        // 'grass',
        "gratitude",
        "grief",
        // 'ground',
        "guilt",
        "gymnastics",
        // 'hair',
        "happiness",
        "hardware",
        "harm",
        "hate",
        "hatred",
        "health",
        "heat",
        // 'height',
        "help",
        "homework",
        "honesty",
        "honey",
        "hospitality",
        "housework",
        "humour",
        "hunger",
        "hydrogen",
        "ice",
        "importance",
        "inflation",
        "information",
        // 'injustice',
        "innocence",
        // 'intelligence',
        "iron",
        "irony",
        "jam",
        // 'jealousy',
        // 'jelly',
        "jewelry",
        // 'joy',
        "judo",
        // 'juice',
        // 'justice',
        "karate",
        // 'kindness',
        "knowledge",
        // 'labour',
        "lack",
        // 'land',
        "laughter",
        "lava",
        "leather",
        "leisure",
        "lightning",
        "linguine",
        "linguini",
        "linguistics",
        "literature",
        "litter",
        "livestock",
        "logic",
        "loneliness",
        // 'love',
        "luck",
        "luggage",
        "macaroni",
        "machinery",
        "magic",
        // 'mail',
        "management",
        "mankind",
        "marble",
        "mathematics",
        "mayonnaise",
        "measles",
        // 'meat',
        // 'metal',
        "methane",
        "milk",
        "minus",
        "money",
        // 'moose',
        "mud",
        "music",
        "mumps",
        "nature",
        "news",
        "nitrogen",
        "nonsense",
        "nurture",
        "nutrition",
        "obedience",
        "obesity",
        // 'oil',
        "oxygen",
        // 'paper',
        // 'passion',
        "pasta",
        "patience",
        // 'permission',
        "physics",
        "poetry",
        "pollution",
        "poverty",
        // 'power',
        "pride",
        // 'production',
        // 'progress',
        // 'pronunciation',
        "psychology",
        "publicity",
        "punctuation",
        // 'quality',
        // 'quantity',
        "quartz",
        "racism",
        // 'rain',
        // 'recreation',
        "relaxation",
        "reliability",
        "research",
        "respect",
        "revenge",
        "rice",
        "rubbish",
        "rum",
        "safety",
        // 'salad',
        // 'salt',
        // 'sand',
        // 'satire',
        "scenery",
        "seafood",
        "seaside",
        "series",
        "shame",
        "sheep",
        "shopping",
        // 'silence',
        "sleep",
        // 'slang'
        "smoke",
        "smoking",
        "snow",
        "soap",
        "software",
        "soil",
        // 'sorrow',
        // 'soup',
        "spaghetti",
        // 'speed',
        "species",
        // 'spelling',
        // 'sport',
        "steam",
        // 'strength',
        "stuff",
        "stupidity",
        // 'success',
        // 'sugar',
        "sunshine",
        "symmetry",
        // 'tea',
        "tennis",
        "thirst",
        "thunder",
        "timber",
        // 'time',
        // 'toast',
        // 'tolerance',
        // 'trade',
        "traffic",
        "transportation",
        // 'travel',
        "trust",
        // 'understanding',
        "underwear",
        "unemployment",
        "unity",
        // 'usage',
        "validity",
        "veal",
        "vegetation",
        "vegetarianism",
        "vengeance",
        "violence",
        // 'vision',
        "vitality",
        "warmth",
        // 'water',
        "wealth",
        "weather",
        // 'weight',
        "welfare",
        "wheat",
        // 'whiskey',
        // 'width',
        "wildlife",
        // 'wine',
        "wisdom",
        // 'wood',
        // 'wool',
        // 'work',
        // 'yeast',
        "yoga",
        "zinc",
        "zoology"
      ];
      var regex = {
        plural: {
          men: new RegExp("^(m|wom)en$", "gi"),
          people: new RegExp("(pe)ople$", "gi"),
          children: new RegExp("(child)ren$", "gi"),
          tia: new RegExp("([ti])a$", "gi"),
          analyses: new RegExp("((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$", "gi"),
          hives: new RegExp("(hi|ti)ves$", "gi"),
          curves: new RegExp("(curve)s$", "gi"),
          lrves: new RegExp("([lr])ves$", "gi"),
          aves: new RegExp("([a])ves$", "gi"),
          foves: new RegExp("([^fo])ves$", "gi"),
          movies: new RegExp("(m)ovies$", "gi"),
          aeiouyies: new RegExp("([^aeiouy]|qu)ies$", "gi"),
          series: new RegExp("(s)eries$", "gi"),
          xes: new RegExp("(x|ch|ss|sh)es$", "gi"),
          mice: new RegExp("([m|l])ice$", "gi"),
          buses: new RegExp("(bus)es$", "gi"),
          oes: new RegExp("(o)es$", "gi"),
          shoes: new RegExp("(shoe)s$", "gi"),
          crises: new RegExp("(cris|ax|test)es$", "gi"),
          octopuses: new RegExp("(octop|vir)uses$", "gi"),
          aliases: new RegExp("(alias|canvas|status|campus)es$", "gi"),
          summonses: new RegExp("^(summons|bonus)es$", "gi"),
          oxen: new RegExp("^(ox)en", "gi"),
          matrices: new RegExp("(matr)ices$", "gi"),
          vertices: new RegExp("(vert|ind)ices$", "gi"),
          feet: new RegExp("^feet$", "gi"),
          teeth: new RegExp("^teeth$", "gi"),
          geese: new RegExp("^geese$", "gi"),
          quizzes: new RegExp("(quiz)zes$", "gi"),
          whereases: new RegExp("^(whereas)es$", "gi"),
          criteria: new RegExp("^(criteri)a$", "gi"),
          genera: new RegExp("^genera$", "gi"),
          ss: new RegExp("ss$", "gi"),
          s: new RegExp("s$", "gi")
        },
        singular: {
          man: new RegExp("^(m|wom)an$", "gi"),
          person: new RegExp("(pe)rson$", "gi"),
          child: new RegExp("(child)$", "gi"),
          ox: new RegExp("^(ox)$", "gi"),
          axis: new RegExp("(ax|test)is$", "gi"),
          octopus: new RegExp("(octop|vir)us$", "gi"),
          alias: new RegExp("(alias|status|canvas|campus)$", "gi"),
          summons: new RegExp("^(summons|bonus)$", "gi"),
          bus: new RegExp("(bu)s$", "gi"),
          buffalo: new RegExp("(buffal|tomat|potat)o$", "gi"),
          tium: new RegExp("([ti])um$", "gi"),
          sis: new RegExp("sis$", "gi"),
          ffe: new RegExp("(?:([^f])fe|([lr])f)$", "gi"),
          hive: new RegExp("(hi|ti)ve$", "gi"),
          aeiouyy: new RegExp("([^aeiouy]|qu)y$", "gi"),
          x: new RegExp("(x|ch|ss|sh)$", "gi"),
          matrix: new RegExp("(matr)ix$", "gi"),
          vertex: new RegExp("(vert|ind)ex$", "gi"),
          mouse: new RegExp("([m|l])ouse$", "gi"),
          foot: new RegExp("^foot$", "gi"),
          tooth: new RegExp("^tooth$", "gi"),
          goose: new RegExp("^goose$", "gi"),
          quiz: new RegExp("(quiz)$", "gi"),
          whereas: new RegExp("^(whereas)$", "gi"),
          criterion: new RegExp("^(criteri)on$", "gi"),
          genus: new RegExp("^genus$", "gi"),
          s: new RegExp("s$", "gi"),
          common: new RegExp("$", "gi")
        }
      };
      var plural_rules = [
        // do not replace if its already a plural word
        [regex.plural.men],
        [regex.plural.people],
        [regex.plural.children],
        [regex.plural.tia],
        [regex.plural.analyses],
        [regex.plural.hives],
        [regex.plural.curves],
        [regex.plural.lrves],
        [regex.plural.foves],
        [regex.plural.aeiouyies],
        [regex.plural.series],
        [regex.plural.movies],
        [regex.plural.xes],
        [regex.plural.mice],
        [regex.plural.buses],
        [regex.plural.oes],
        [regex.plural.shoes],
        [regex.plural.crises],
        [regex.plural.octopuses],
        [regex.plural.aliases],
        [regex.plural.summonses],
        [regex.plural.oxen],
        [regex.plural.matrices],
        [regex.plural.feet],
        [regex.plural.teeth],
        [regex.plural.geese],
        [regex.plural.quizzes],
        [regex.plural.whereases],
        [regex.plural.criteria],
        [regex.plural.genera],
        // original rule
        [regex.singular.man, "$1en"],
        [regex.singular.person, "$1ople"],
        [regex.singular.child, "$1ren"],
        [regex.singular.ox, "$1en"],
        [regex.singular.axis, "$1es"],
        [regex.singular.octopus, "$1uses"],
        [regex.singular.alias, "$1es"],
        [regex.singular.summons, "$1es"],
        [regex.singular.bus, "$1ses"],
        [regex.singular.buffalo, "$1oes"],
        [regex.singular.tium, "$1a"],
        [regex.singular.sis, "ses"],
        [regex.singular.ffe, "$1$2ves"],
        [regex.singular.hive, "$1ves"],
        [regex.singular.aeiouyy, "$1ies"],
        [regex.singular.matrix, "$1ices"],
        [regex.singular.vertex, "$1ices"],
        [regex.singular.x, "$1es"],
        [regex.singular.mouse, "$1ice"],
        [regex.singular.foot, "feet"],
        [regex.singular.tooth, "teeth"],
        [regex.singular.goose, "geese"],
        [regex.singular.quiz, "$1zes"],
        [regex.singular.whereas, "$1es"],
        [regex.singular.criterion, "$1a"],
        [regex.singular.genus, "genera"],
        [regex.singular.s, "s"],
        [regex.singular.common, "s"]
      ];
      var singular_rules = [
        // do not replace if its already a singular word
        [regex.singular.man],
        [regex.singular.person],
        [regex.singular.child],
        [regex.singular.ox],
        [regex.singular.axis],
        [regex.singular.octopus],
        [regex.singular.alias],
        [regex.singular.summons],
        [regex.singular.bus],
        [regex.singular.buffalo],
        [regex.singular.tium],
        [regex.singular.sis],
        [regex.singular.ffe],
        [regex.singular.hive],
        [regex.singular.aeiouyy],
        [regex.singular.x],
        [regex.singular.matrix],
        [regex.singular.mouse],
        [regex.singular.foot],
        [regex.singular.tooth],
        [regex.singular.goose],
        [regex.singular.quiz],
        [regex.singular.whereas],
        [regex.singular.criterion],
        [regex.singular.genus],
        // original rule
        [regex.plural.men, "$1an"],
        [regex.plural.people, "$1rson"],
        [regex.plural.children, "$1"],
        [regex.plural.genera, "genus"],
        [regex.plural.criteria, "$1on"],
        [regex.plural.tia, "$1um"],
        [regex.plural.analyses, "$1$2sis"],
        [regex.plural.hives, "$1ve"],
        [regex.plural.curves, "$1"],
        [regex.plural.lrves, "$1f"],
        [regex.plural.aves, "$1ve"],
        [regex.plural.foves, "$1fe"],
        [regex.plural.movies, "$1ovie"],
        [regex.plural.aeiouyies, "$1y"],
        [regex.plural.series, "$1eries"],
        [regex.plural.xes, "$1"],
        [regex.plural.mice, "$1ouse"],
        [regex.plural.buses, "$1"],
        [regex.plural.oes, "$1"],
        [regex.plural.shoes, "$1"],
        [regex.plural.crises, "$1is"],
        [regex.plural.octopuses, "$1us"],
        [regex.plural.aliases, "$1"],
        [regex.plural.summonses, "$1"],
        [regex.plural.oxen, "$1"],
        [regex.plural.matrices, "$1ix"],
        [regex.plural.vertices, "$1ex"],
        [regex.plural.feet, "foot"],
        [regex.plural.teeth, "tooth"],
        [regex.plural.geese, "goose"],
        [regex.plural.quizzes, "$1"],
        [regex.plural.whereases, "$1"],
        [regex.plural.ss, "ss"],
        [regex.plural.s, ""]
      ];
      var non_titlecased_words = [
        "and",
        "or",
        "nor",
        "a",
        "an",
        "the",
        "so",
        "but",
        "to",
        "of",
        "at",
        "by",
        "from",
        "into",
        "on",
        "onto",
        "off",
        "out",
        "in",
        "over",
        "with",
        "for"
      ];
      var id_suffix = new RegExp("(_ids|_id)$", "g");
      var underbar = new RegExp("_", "g");
      var space_or_underbar = new RegExp("[ _]", "g");
      var uppercase = new RegExp("([A-Z])", "g");
      var underbar_prefix = new RegExp("^_");
      var inflector = {
        /**
         * A helper method that applies rules based replacement to a String.
         * @private
         * @function
         * @param {String} str String to modify and return based on the passed rules.
         * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
         * @param {Array: [String]} skip Strings to skip if they match
         * @param {String} override String to return as though this method succeeded (used to conform to APIs)
         * @returns {String} Return passed String modified by passed rules.
         * @example
         *
         *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
         */
        _apply_rules: function(str, rules, skip, override) {
          if (override) {
            str = override;
          } else {
            var ignore = inflector.indexOf(skip, str.toLowerCase()) > -1;
            if (!ignore) {
              var i = 0;
              var j = rules.length;
              for (; i < j; i++) {
                if (str.match(rules[i][0])) {
                  if (rules[i][1] !== void 0) {
                    str = str.replace(rules[i][0], rules[i][1]);
                  }
                  break;
                }
              }
            }
          }
          return str;
        },
        /**
         * This lets us detect if an Array contains a given element.
         * @public
         * @function
         * @param {Array} arr The subject array.
         * @param {Object} item Object to locate in the Array.
         * @param {Number} from_index Starts checking from this position in the Array.(optional)
         * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
         * @returns {Number} Return index position in the Array of the passed item.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
         *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
         */
        indexOf: function(arr, item, from_index, compare_func) {
          if (!from_index) {
            from_index = -1;
          }
          var index = -1;
          var i = from_index;
          var j = arr.length;
          for (; i < j; i++) {
            if (arr[i] === item || compare_func && compare_func(arr[i], item)) {
              index = i;
              break;
            }
          }
          return index;
        },
        /**
         * This function adds pluralization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {String} plural Overrides normal output with said String.(optional)
         * @returns {String} Singular English language nouns are returned in plural form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.pluralize( 'person' ); // === 'people'
         *     inflection.pluralize( 'octopus' ); // === 'octopuses'
         *     inflection.pluralize( 'Hat' ); // === 'Hats'
         *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
         */
        pluralize: function(str, plural) {
          return inflector._apply_rules(str, plural_rules, uncountable_words, plural);
        },
        /**
         * This function adds singularization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {String} singular Overrides normal output with said String.(optional)
         * @returns {String} Plural English language nouns are returned in singular form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.singularize( 'people' ); // === 'person'
         *     inflection.singularize( 'octopuses' ); // === 'octopus'
         *     inflection.singularize( 'Hats' ); // === 'Hat'
         *     inflection.singularize( 'guys', 'person' ); // === 'person'
         */
        singularize: function(str, singular) {
          return inflector._apply_rules(str, singular_rules, uncountable_words, singular);
        },
        /**
         * This function will pluralize or singularlize a String appropriately based on an integer value
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Number} count The number to base pluralization off of.
         * @param {String} singular Overrides normal output with said String.(optional)
         * @param {String} plural Overrides normal output with said String.(optional)
         * @returns {String} English language nouns are returned in the plural or singular form based on the count.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.inflect( 'people' 1 ); // === 'person'
         *     inflection.inflect( 'octopuses' 1 ); // === 'octopus'
         *     inflection.inflect( 'Hats' 1 ); // === 'Hat'
         *     inflection.inflect( 'guys', 1 , 'person' ); // === 'person'
         *     inflection.inflect( 'person', 2 ); // === 'people'
         *     inflection.inflect( 'octopus', 2 ); // === 'octopuses'
         *     inflection.inflect( 'Hat', 2 ); // === 'Hats'
         *     inflection.inflect( 'person', 2, null, 'guys' ); // === 'guys'
         */
        inflect: function(str, count, singular, plural) {
          count = parseInt(count, 10);
          if (isNaN(count)) return str;
          if (count === 0 || count > 1) {
            return inflector._apply_rules(str, plural_rules, uncountable_words, plural);
          } else {
            return inflector._apply_rules(str, singular_rules, uncountable_words, singular);
          }
        },
        /**
         * This function adds camelization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
         *                                 Passing true will lowercase it.
         * @returns {String} Lower case underscored words will be returned in camel case.
         *                  additionally '/' is translated to '::'
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
         *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
         */
        camelize: function(str, low_first_letter) {
          var str_path = str.split("/");
          var i = 0;
          var j = str_path.length;
          var str_arr, init_x, k, l, first;
          for (; i < j; i++) {
            str_arr = str_path[i].split("_");
            k = 0;
            l = str_arr.length;
            for (; k < l; k++) {
              if (k !== 0) {
                str_arr[k] = str_arr[k].toLowerCase();
              }
              first = str_arr[k].charAt(0);
              first = low_first_letter && i === 0 && k === 0 ? first.toLowerCase() : first.toUpperCase();
              str_arr[k] = first + str_arr[k].substring(1);
            }
            str_path[i] = str_arr.join("");
          }
          return str_path.join("::");
        },
        /**
         * This function adds underscore support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
         *                  Passing true will return as entered.
         * @returns {String} Camel cased words are returned as lower cased and underscored.
         *                  additionally '::' is translated to '/'.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
         *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
         *     inflection.underscore( 'MP', true ); // === 'MP'
         */
        underscore: function(str, all_upper_case) {
          if (all_upper_case && str === str.toUpperCase()) return str;
          var str_path = str.split("::");
          var i = 0;
          var j = str_path.length;
          for (; i < j; i++) {
            str_path[i] = str_path[i].replace(uppercase, "_$1");
            str_path[i] = str_path[i].replace(underbar_prefix, "");
          }
          return str_path.join("/").toLowerCase();
        },
        /**
         * This function adds humanize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
         *                                 Passing true will lowercase it.
         * @returns {String} Lower case underscored words will be returned in humanized form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.humanize( 'message_properties' ); // === 'Message properties'
         *     inflection.humanize( 'message_properties', true ); // === 'message properties'
         */
        humanize: function(str, low_first_letter) {
          str = str.toLowerCase();
          str = str.replace(id_suffix, "");
          str = str.replace(underbar, " ");
          if (!low_first_letter) {
            str = inflector.capitalize(str);
          }
          return str;
        },
        /**
         * This function adds capitalization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} All characters will be lower case and the first will be upper.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
         *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
         */
        capitalize: function(str) {
          str = str.toLowerCase();
          return str.substring(0, 1).toUpperCase() + str.substring(1);
        },
        /**
         * This function replaces underscores with dashes in the string.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Replaces all spaces or underscores with dashes.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
         *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
         */
        dasherize: function(str) {
          return str.replace(space_or_underbar, "-");
        },
        /**
         * This function adds titleize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Capitalizes words as you would for a book title.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
         *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
         */
        titleize: function(str) {
          str = str.toLowerCase().replace(underbar, " ");
          var str_arr = str.split(" ");
          var i = 0;
          var j = str_arr.length;
          var d, k, l;
          for (; i < j; i++) {
            d = str_arr[i].split("-");
            k = 0;
            l = d.length;
            for (; k < l; k++) {
              if (inflector.indexOf(non_titlecased_words, d[k].toLowerCase()) < 0) {
                d[k] = inflector.capitalize(d[k]);
              }
            }
            str_arr[i] = d.join("-");
          }
          str = str_arr.join(" ");
          str = str.substring(0, 1).toUpperCase() + str.substring(1);
          return str;
        },
        /**
         * This function adds demodulize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Removes module names leaving only class names.(Ruby style)
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
         */
        demodulize: function(str) {
          var str_arr = str.split("::");
          return str_arr[str_arr.length - 1];
        },
        /**
         * This function adds tableize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Return camel cased words into their underscored plural form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
         */
        tableize: function(str) {
          str = inflector.underscore(str);
          str = inflector.pluralize(str);
          return str;
        },
        /**
         * This function adds classification support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Underscored plural nouns become the camel cased singular form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
         */
        classify: function(str) {
          str = inflector.camelize(str);
          str = inflector.singularize(str);
          return str;
        },
        /**
         * This function adds foreign key support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                       you can pass true to skip it.(optional)
         * @returns {String} Underscored plural nouns become the camel cased singular form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
         *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
         */
        foreign_key: function(str, drop_id_ubar) {
          str = inflector.demodulize(str);
          str = inflector.underscore(str) + (drop_id_ubar ? "" : "_") + "id";
          return str;
        },
        /**
         * This function adds ordinalize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Return all found numbers their sequence like '22nd'.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
         */
        ordinalize: function(str) {
          var str_arr = str.split(" ");
          var i = 0;
          var j = str_arr.length;
          for (; i < j; i++) {
            var k = parseInt(str_arr[i], 10);
            if (!isNaN(k)) {
              var ltd = str_arr[i].substring(str_arr[i].length - 2);
              var ld = str_arr[i].substring(str_arr[i].length - 1);
              var suf = "th";
              if (ltd != "11" && ltd != "12" && ltd != "13") {
                if (ld === "1") {
                  suf = "st";
                } else if (ld === "2") {
                  suf = "nd";
                } else if (ld === "3") {
                  suf = "rd";
                }
              }
              str_arr[i] += suf;
            }
          }
          return str_arr.join(" ");
        },
        /**
         * This function performs multiple inflection methods on a string
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Array} arr An array of inflection methods.
         * @returns {String}
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
         */
        transform: function(str, arr) {
          var i = 0;
          var j = arr.length;
          for (; i < j; i++) {
            var method = arr[i];
            if (inflector.hasOwnProperty(method)) {
              str = inflector[method](str);
            }
          }
          return str;
        }
      };
      inflector.version = "1.13.1";
      return inflector;
    });
  }
});

// node_modules/randomcolor/randomColor.js
var require_randomColor = __commonJS({
  "node_modules/randomcolor/randomColor.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof exports2 === "object") {
        var randomColor = factory();
        if (typeof module2 === "object" && module2 && module2.exports) {
          exports2 = module2.exports = randomColor;
        }
        exports2.randomColor = randomColor;
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.randomColor = factory();
      }
    })(exports2, function() {
      var seed = null;
      var colorDictionary = {};
      loadColorBounds();
      var colorRanges = [];
      var randomColor = function(options) {
        options = options || {};
        if (options.seed !== void 0 && options.seed !== null && options.seed === parseInt(options.seed, 10)) {
          seed = options.seed;
        } else if (typeof options.seed === "string") {
          seed = stringToInteger(options.seed);
        } else if (options.seed !== void 0 && options.seed !== null) {
          throw new TypeError("The seed value must be an integer or string");
        } else {
          seed = null;
        }
        var H, S, B;
        if (options.count !== null && options.count !== void 0) {
          var totalColors = options.count, colors = [];
          for (var i = 0; i < options.count; i++) {
            colorRanges.push(false);
          }
          options.count = null;
          while (totalColors > colors.length) {
            var color = randomColor(options);
            if (seed !== null) {
              options.seed = seed;
            }
            colors.push(color);
          }
          options.count = totalColors;
          return colors;
        }
        H = pickHue(options);
        S = pickSaturation(H, options);
        B = pickBrightness(H, S, options);
        return setFormat([H, S, B], options);
      };
      function pickHue(options) {
        if (colorRanges.length > 0) {
          var hueRange = getRealHueRange(options.hue);
          var hue = randomWithin(hueRange);
          var step = (hueRange[1] - hueRange[0]) / colorRanges.length;
          var j = parseInt((hue - hueRange[0]) / step);
          if (colorRanges[j] === true) {
            j = (j + 2) % colorRanges.length;
          } else {
            colorRanges[j] = true;
          }
          var min = (hueRange[0] + j * step) % 359, max = (hueRange[0] + (j + 1) * step) % 359;
          hueRange = [min, max];
          hue = randomWithin(hueRange);
          if (hue < 0) {
            hue = 360 + hue;
          }
          return hue;
        } else {
          var hueRange = getHueRange(options.hue);
          hue = randomWithin(hueRange);
          if (hue < 0) {
            hue = 360 + hue;
          }
          return hue;
        }
      }
      function pickSaturation(hue, options) {
        if (options.hue === "monochrome") {
          return 0;
        }
        if (options.luminosity === "random") {
          return randomWithin([0, 100]);
        }
        var saturationRange = getSaturationRange(hue);
        var sMin = saturationRange[0], sMax = saturationRange[1];
        switch (options.luminosity) {
          case "bright":
            sMin = 55;
            break;
          case "dark":
            sMin = sMax - 10;
            break;
          case "light":
            sMax = 55;
            break;
        }
        return randomWithin([sMin, sMax]);
      }
      function pickBrightness(H, S, options) {
        var bMin = getMinimumBrightness(H, S), bMax = 100;
        switch (options.luminosity) {
          case "dark":
            bMax = bMin + 20;
            break;
          case "light":
            bMin = (bMax + bMin) / 2;
            break;
          case "random":
            bMin = 0;
            bMax = 100;
            break;
        }
        return randomWithin([bMin, bMax]);
      }
      function setFormat(hsv, options) {
        switch (options.format) {
          case "hsvArray":
            return hsv;
          case "hslArray":
            return HSVtoHSL(hsv);
          case "hsl":
            var hsl = HSVtoHSL(hsv);
            return "hsl(" + hsl[0] + ", " + hsl[1] + "%, " + hsl[2] + "%)";
          case "hsla":
            var hslColor = HSVtoHSL(hsv);
            var alpha = options.alpha || Math.random();
            return "hsla(" + hslColor[0] + ", " + hslColor[1] + "%, " + hslColor[2] + "%, " + alpha + ")";
          case "rgbArray":
            return HSVtoRGB(hsv);
          case "rgb":
            var rgb = HSVtoRGB(hsv);
            return "rgb(" + rgb.join(", ") + ")";
          case "rgba":
            var rgbColor = HSVtoRGB(hsv);
            var alpha = options.alpha || Math.random();
            return "rgba(" + rgbColor.join(", ") + ", " + alpha + ")";
          default:
            return HSVtoHex(hsv);
        }
      }
      function getMinimumBrightness(H, S) {
        var lowerBounds = getColorInfo(H).lowerBounds;
        for (var i = 0; i < lowerBounds.length - 1; i++) {
          var s1 = lowerBounds[i][0], v12 = lowerBounds[i][1];
          var s2 = lowerBounds[i + 1][0], v2 = lowerBounds[i + 1][1];
          if (S >= s1 && S <= s2) {
            var m = (v2 - v12) / (s2 - s1), b = v12 - m * s1;
            return m * S + b;
          }
        }
        return 0;
      }
      function getHueRange(colorInput) {
        if (typeof parseInt(colorInput) === "number") {
          var number = parseInt(colorInput);
          if (number < 360 && number > 0) {
            return [number, number];
          }
        }
        if (typeof colorInput === "string") {
          if (colorDictionary[colorInput]) {
            var color = colorDictionary[colorInput];
            if (color.hueRange) {
              return color.hueRange;
            }
          } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
            var hue = HexToHSB(colorInput)[0];
            return [hue, hue];
          }
        }
        return [0, 360];
      }
      function getSaturationRange(hue) {
        return getColorInfo(hue).saturationRange;
      }
      function getColorInfo(hue) {
        if (hue >= 334 && hue <= 360) {
          hue -= 360;
        }
        for (var colorName in colorDictionary) {
          var color = colorDictionary[colorName];
          if (color.hueRange && hue >= color.hueRange[0] && hue <= color.hueRange[1]) {
            return colorDictionary[colorName];
          }
        }
        return "Color not found";
      }
      function randomWithin(range) {
        if (seed === null) {
          var golden_ratio = 0.618033988749895;
          var r = Math.random();
          r += golden_ratio;
          r %= 1;
          return Math.floor(range[0] + r * (range[1] + 1 - range[0]));
        } else {
          var max = range[1] || 1;
          var min = range[0] || 0;
          seed = (seed * 9301 + 49297) % 233280;
          var rnd = seed / 233280;
          return Math.floor(min + rnd * (max - min));
        }
      }
      function HSVtoHex(hsv) {
        var rgb = HSVtoRGB(hsv);
        function componentToHex(c) {
          var hex2 = c.toString(16);
          return hex2.length == 1 ? "0" + hex2 : hex2;
        }
        var hex = "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
        return hex;
      }
      function defineColor(name, hueRange, lowerBounds) {
        var sMin = lowerBounds[0][0], sMax = lowerBounds[lowerBounds.length - 1][0], bMin = lowerBounds[lowerBounds.length - 1][1], bMax = lowerBounds[0][1];
        colorDictionary[name] = {
          hueRange,
          lowerBounds,
          saturationRange: [sMin, sMax],
          brightnessRange: [bMin, bMax]
        };
      }
      function loadColorBounds() {
        defineColor(
          "monochrome",
          null,
          [[0, 0], [100, 0]]
        );
        defineColor(
          "red",
          [-26, 18],
          [[20, 100], [30, 92], [40, 89], [50, 85], [60, 78], [70, 70], [80, 60], [90, 55], [100, 50]]
        );
        defineColor(
          "orange",
          [18, 46],
          [[20, 100], [30, 93], [40, 88], [50, 86], [60, 85], [70, 70], [100, 70]]
        );
        defineColor(
          "yellow",
          [46, 62],
          [[25, 100], [40, 94], [50, 89], [60, 86], [70, 84], [80, 82], [90, 80], [100, 75]]
        );
        defineColor(
          "green",
          [62, 178],
          [[30, 100], [40, 90], [50, 85], [60, 81], [70, 74], [80, 64], [90, 50], [100, 40]]
        );
        defineColor(
          "blue",
          [178, 257],
          [[20, 100], [30, 86], [40, 80], [50, 74], [60, 60], [70, 52], [80, 44], [90, 39], [100, 35]]
        );
        defineColor(
          "purple",
          [257, 282],
          [[20, 100], [30, 87], [40, 79], [50, 70], [60, 65], [70, 59], [80, 52], [90, 45], [100, 42]]
        );
        defineColor(
          "pink",
          [282, 334],
          [[20, 100], [30, 90], [40, 86], [60, 84], [80, 80], [90, 75], [100, 73]]
        );
      }
      function HSVtoRGB(hsv) {
        var h = hsv[0];
        if (h === 0) {
          h = 1;
        }
        if (h === 360) {
          h = 359;
        }
        h = h / 360;
        var s = hsv[1] / 100, v = hsv[2] / 100;
        var h_i = Math.floor(h * 6), f = h * 6 - h_i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), r = 256, g = 256, b = 256;
        switch (h_i) {
          case 0:
            r = v;
            g = t;
            b = p;
            break;
          case 1:
            r = q;
            g = v;
            b = p;
            break;
          case 2:
            r = p;
            g = v;
            b = t;
            break;
          case 3:
            r = p;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p;
            b = v;
            break;
          case 5:
            r = v;
            g = p;
            b = q;
            break;
        }
        var result2 = [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
        return result2;
      }
      function HexToHSB(hex) {
        hex = hex.replace(/^#/, "");
        hex = hex.length === 3 ? hex.replace(/(.)/g, "$1$1") : hex;
        var red = parseInt(hex.substr(0, 2), 16) / 255, green = parseInt(hex.substr(2, 2), 16) / 255, blue = parseInt(hex.substr(4, 2), 16) / 255;
        var cMax = Math.max(red, green, blue), delta = cMax - Math.min(red, green, blue), saturation = cMax ? delta / cMax : 0;
        switch (cMax) {
          case red:
            return [60 * ((green - blue) / delta % 6) || 0, saturation, cMax];
          case green:
            return [60 * ((blue - red) / delta + 2) || 0, saturation, cMax];
          case blue:
            return [60 * ((red - green) / delta + 4) || 0, saturation, cMax];
        }
      }
      function HSVtoHSL(hsv) {
        var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, k = (2 - s) * v;
        return [
          h,
          Math.round(s * v / (k < 1 ? k : 2 - k) * 1e4) / 100,
          k / 2 * 100
        ];
      }
      function stringToInteger(string) {
        var total = 0;
        for (var i = 0; i !== string.length; i++) {
          if (total >= Number.MAX_SAFE_INTEGER) break;
          total += string.charCodeAt(i);
        }
        return total;
      }
      function getRealHueRange(colorHue) {
        if (!isNaN(colorHue)) {
          var number = parseInt(colorHue);
          if (number < 360 && number > 0) {
            return getColorInfo(colorHue).hueRange;
          }
        } else if (typeof colorHue === "string") {
          if (colorDictionary[colorHue]) {
            var color = colorDictionary[colorHue];
            if (color.hueRange) {
              return color.hueRange;
            }
          } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
            var hue = HexToHSB(colorHue)[0];
            return getColorInfo(hue).hueRange;
          }
        }
        return [0, 360];
      }
      return randomColor;
    });
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports2, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get2(this, unit);
          }
        };
      }
      function get2(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get2(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result2 = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result2.push(parseInt(secondStr, 10));
        }
        return result2;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get2(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          // 1000
          case "minute":
            output = (this - that) / 6e4;
            break;
          // 1000 * 60
          case "hour":
            output = (this - that) / 36e5;
            break;
          // 1000 * 60 * 60
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          // 1000 * 60 * 60 * 24, negate dst
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          // 1000 * 60 * 60 * 24 * 7, negate dst
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            // Math.floor prevents floating point math errors here
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/object-hash/index.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/index.js"(exports2, module2) {
    "use strict";
    var crypto4 = require("crypto");
    exports2 = module2.exports = objectHash;
    function objectHash(object, options) {
      options = applyDefaults(object, options);
      return hash(object, options);
    }
    exports2.sha1 = function(object) {
      return objectHash(object);
    };
    exports2.keys = function(object) {
      return objectHash(object, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
    };
    exports2.MD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex" });
    };
    exports2.keysMD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex", excludeValues: true });
    };
    var hashes = crypto4.getHashes ? crypto4.getHashes().slice() : ["sha1", "md5"];
    hashes.push("passthrough");
    var encodings = ["buffer", "hex", "binary", "base64"];
    function applyDefaults(object, sourceOptions) {
      sourceOptions = sourceOptions || {};
      var options = {};
      options.algorithm = sourceOptions.algorithm || "sha1";
      options.encoding = sourceOptions.encoding || "hex";
      options.excludeValues = sourceOptions.excludeValues ? true : false;
      options.algorithm = options.algorithm.toLowerCase();
      options.encoding = options.encoding.toLowerCase();
      options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true;
      options.respectType = sourceOptions.respectType === false ? false : true;
      options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
      options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
      options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true;
      options.unorderedSets = sourceOptions.unorderedSets === false ? false : true;
      options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true;
      options.replacer = sourceOptions.replacer || void 0;
      options.excludeKeys = sourceOptions.excludeKeys || void 0;
      if (typeof object === "undefined") {
        throw new Error("Object argument required.");
      }
      for (var i = 0; i < hashes.length; ++i) {
        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
          options.algorithm = hashes[i];
        }
      }
      if (hashes.indexOf(options.algorithm) === -1) {
        throw new Error('Algorithm "' + options.algorithm + '"  not supported. supported values: ' + hashes.join(", "));
      }
      if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough") {
        throw new Error('Encoding "' + options.encoding + '"  not supported. supported values: ' + encodings.join(", "));
      }
      return options;
    }
    function isNativeFunction(f) {
      if (typeof f !== "function") {
        return false;
      }
      var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
      return exp.exec(Function.prototype.toString.call(f)) != null;
    }
    function hash(object, options) {
      var hashingStream;
      if (options.algorithm !== "passthrough") {
        hashingStream = crypto4.createHash(options.algorithm);
      } else {
        hashingStream = new PassThrough();
      }
      if (typeof hashingStream.write === "undefined") {
        hashingStream.write = hashingStream.update;
        hashingStream.end = hashingStream.update;
      }
      var hasher = typeHasher(options, hashingStream);
      hasher.dispatch(object);
      if (!hashingStream.update) {
        hashingStream.end("");
      }
      if (hashingStream.digest) {
        return hashingStream.digest(options.encoding === "buffer" ? void 0 : options.encoding);
      }
      var buf = hashingStream.read();
      if (options.encoding === "buffer") {
        return buf;
      }
      return buf.toString(options.encoding);
    }
    exports2.writeToStream = function(object, options, stream) {
      if (typeof stream === "undefined") {
        stream = options;
        options = {};
      }
      options = applyDefaults(object, options);
      return typeHasher(options, stream).dispatch(object);
    };
    function typeHasher(options, writeTo, context) {
      context = context || [];
      var write = function(str) {
        if (writeTo.update) {
          return writeTo.update(str, "utf8");
        } else {
          return writeTo.write(str, "utf8");
        }
      };
      return {
        dispatch: function(value) {
          if (options.replacer) {
            value = options.replacer(value);
          }
          var type = typeof value;
          if (value === null) {
            type = "null";
          }
          return this["_" + type](value);
        },
        _object: function(object) {
          var pattern = /\[object (.*)\]/i;
          var objString = Object.prototype.toString.call(object);
          var objType = pattern.exec(objString);
          if (!objType) {
            objType = "unknown:[" + objString + "]";
          } else {
            objType = objType[1];
          }
          objType = objType.toLowerCase();
          var objectNumber = null;
          if ((objectNumber = context.indexOf(object)) >= 0) {
            return this.dispatch("[CIRCULAR:" + objectNumber + "]");
          } else {
            context.push(object);
          }
          if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
            write("buffer:");
            return write(object);
          }
          if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
            if (this["_" + objType]) {
              this["_" + objType](object);
            } else if (options.ignoreUnknown) {
              return write("[" + objType + "]");
            } else {
              throw new Error('Unknown object type "' + objType + '"');
            }
          } else {
            var keys = Object.keys(object);
            if (options.unorderedObjects) {
              keys = keys.sort();
            }
            if (options.respectType !== false && !isNativeFunction(object)) {
              keys.splice(0, 0, "prototype", "__proto__", "constructor");
            }
            if (options.excludeKeys) {
              keys = keys.filter(function(key) {
                return !options.excludeKeys(key);
              });
            }
            write("object:" + keys.length + ":");
            var self2 = this;
            return keys.forEach(function(key) {
              self2.dispatch(key);
              write(":");
              if (!options.excludeValues) {
                self2.dispatch(object[key]);
              }
              write(",");
            });
          }
        },
        _array: function(arr, unordered) {
          unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false;
          var self2 = this;
          write("array:" + arr.length + ":");
          if (!unordered || arr.length <= 1) {
            return arr.forEach(function(entry) {
              return self2.dispatch(entry);
            });
          }
          var contextAdditions = [];
          var entries = arr.map(function(entry) {
            var strm = new PassThrough();
            var localContext = context.slice();
            var hasher = typeHasher(options, strm, localContext);
            hasher.dispatch(entry);
            contextAdditions = contextAdditions.concat(localContext.slice(context.length));
            return strm.read().toString();
          });
          context = context.concat(contextAdditions);
          entries.sort();
          return this._array(entries, false);
        },
        _date: function(date) {
          return write("date:" + date.toJSON());
        },
        _symbol: function(sym) {
          return write("symbol:" + sym.toString());
        },
        _error: function(err) {
          return write("error:" + err.toString());
        },
        _boolean: function(bool) {
          return write("bool:" + bool.toString());
        },
        _string: function(string) {
          write("string:" + string.length + ":");
          write(string.toString());
        },
        _function: function(fn) {
          write("fn:");
          if (isNativeFunction(fn)) {
            this.dispatch("[native]");
          } else {
            this.dispatch(fn.toString());
          }
          if (options.respectFunctionNames !== false) {
            this.dispatch("function-name:" + String(fn.name));
          }
          if (options.respectFunctionProperties) {
            this._object(fn);
          }
        },
        _number: function(number) {
          return write("number:" + number.toString());
        },
        _xml: function(xml) {
          return write("xml:" + xml.toString());
        },
        _null: function() {
          return write("Null");
        },
        _undefined: function() {
          return write("Undefined");
        },
        _regexp: function(regex) {
          return write("regex:" + regex.toString());
        },
        _uint8array: function(arr) {
          write("uint8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint8clampedarray: function(arr) {
          write("uint8clampedarray:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int8array: function(arr) {
          write("uint8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint16array: function(arr) {
          write("uint16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int16array: function(arr) {
          write("uint16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint32array: function(arr) {
          write("uint32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int32array: function(arr) {
          write("uint32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float32array: function(arr) {
          write("float32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float64array: function(arr) {
          write("float64array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _arraybuffer: function(arr) {
          write("arraybuffer:");
          return this.dispatch(new Uint8Array(arr));
        },
        _url: function(url) {
          return write("url:" + url.toString(), "utf8");
        },
        _map: function(map2) {
          write("map:");
          var arr = Array.from(map2);
          return this._array(arr, options.unorderedSets !== false);
        },
        _set: function(set) {
          write("set:");
          var arr = Array.from(set);
          return this._array(arr, options.unorderedSets !== false);
        },
        _file: function(file) {
          write("file:");
          return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
        },
        _blob: function() {
          if (options.ignoreUnknown) {
            return write("[blob]");
          }
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        },
        _domwindow: function() {
          return write("domwindow");
        },
        _bigint: function(number) {
          return write("bigint:" + number.toString());
        },
        /* Node.js standard native objects */
        _process: function() {
          return write("process");
        },
        _timer: function() {
          return write("timer");
        },
        _pipe: function() {
          return write("pipe");
        },
        _tcp: function() {
          return write("tcp");
        },
        _udp: function() {
          return write("udp");
        },
        _tty: function() {
          return write("tty");
        },
        _statwatcher: function() {
          return write("statwatcher");
        },
        _securecontext: function() {
          return write("securecontext");
        },
        _connection: function() {
          return write("connection");
        },
        _zlib: function() {
          return write("zlib");
        },
        _context: function() {
          return write("context");
        },
        _nodescript: function() {
          return write("nodescript");
        },
        _httpparser: function() {
          return write("httpparser");
        },
        _dataview: function() {
          return write("dataview");
        },
        _signal: function() {
          return write("signal");
        },
        _fsevent: function() {
          return write("fsevent");
        },
        _tlswrap: function() {
          return write("tlswrap");
        }
      };
    }
    function PassThrough() {
      return {
        buf: "",
        write: function(b) {
          this.buf += b;
        },
        end: function(b) {
          this.buf += b;
        },
        read: function() {
          return this.buf;
        }
      };
    }
  }
});

// node_modules/string-template/index.js
var require_string_template = __commonJS({
  "node_modules/string-template/index.js"(exports2, module2) {
    var nargs = /\{([0-9a-zA-Z_]+)\}/g;
    module2.exports = template;
    function template(string) {
      var args;
      if (arguments.length === 2 && typeof arguments[1] === "object") {
        args = arguments[1];
      } else {
        args = new Array(arguments.length - 1);
        for (var i = 1; i < arguments.length; ++i) {
          args[i - 1] = arguments[i];
        }
      }
      if (!args || !args.hasOwnProperty) {
        args = {};
      }
      return string.replace(nargs, function replaceArg(match, i2, index) {
        var result2;
        if (string[index - 1] === "{" && string[index + match.length] === "}") {
          return i2;
        } else {
          result2 = args.hasOwnProperty(i2) ? args[i2] : null;
          if (result2 === null || result2 === void 0) {
            return "";
          }
          return result2;
        }
      });
    }
  }
});

// node_modules/striptags/src/striptags.js
var require_striptags = __commonJS({
  "node_modules/striptags/src/striptags.js"(exports2, module2) {
    "use strict";
    (function(global2) {
      if (typeof Symbol2 !== "function") {
        var Symbol2 = function(name) {
          return name;
        };
        Symbol2.nonNative = true;
      }
      const STATE_PLAINTEXT = Symbol2("plaintext");
      const STATE_HTML = Symbol2("html");
      const STATE_COMMENT = Symbol2("comment");
      const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
      const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
      function striptags(html, allowable_tags, tag_replacement) {
        html = html || "";
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return striptags_internal(html, context);
      }
      function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return function striptags_stream(html) {
          return striptags_internal(html || "", context);
        };
      }
      striptags.init_streaming_mode = init_striptags_stream;
      function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);
        return {
          allowable_tags,
          tag_replacement,
          state: STATE_PLAINTEXT,
          tag_buffer: "",
          depth: 0,
          in_quote_char: ""
        };
      }
      function striptags_internal(html, context) {
        if (typeof html != "string") {
          throw new TypeError("'html' parameter must be a string");
        }
        let allowable_tags = context.allowable_tags;
        let tag_replacement = context.tag_replacement;
        let state = context.state;
        let tag_buffer = context.tag_buffer;
        let depth = context.depth;
        let in_quote_char = context.in_quote_char;
        let output = "";
        for (let idx = 0, length = html.length; idx < length; idx++) {
          let char = html[idx];
          if (state === STATE_PLAINTEXT) {
            switch (char) {
              case "<":
                state = STATE_HTML;
                tag_buffer += char;
                break;
              default:
                output += char;
                break;
            }
          } else if (state === STATE_HTML) {
            switch (char) {
              case "<":
                if (in_quote_char) {
                  break;
                }
                depth++;
                break;
              case ">":
                if (in_quote_char) {
                  break;
                }
                if (depth) {
                  depth--;
                  break;
                }
                in_quote_char = "";
                state = STATE_PLAINTEXT;
                tag_buffer += ">";
                if (allowable_tags.has(normalize_tag(tag_buffer))) {
                  output += tag_buffer;
                } else {
                  output += tag_replacement;
                }
                tag_buffer = "";
                break;
              case '"':
              case "'":
                if (char === in_quote_char) {
                  in_quote_char = "";
                } else {
                  in_quote_char = in_quote_char || char;
                }
                tag_buffer += char;
                break;
              case "-":
                if (tag_buffer === "<!-") {
                  state = STATE_COMMENT;
                }
                tag_buffer += char;
                break;
              case " ":
              case "\n":
                if (tag_buffer === "<") {
                  state = STATE_PLAINTEXT;
                  output += "< ";
                  tag_buffer = "";
                  break;
                }
                tag_buffer += char;
                break;
              default:
                tag_buffer += char;
                break;
            }
          } else if (state === STATE_COMMENT) {
            switch (char) {
              case ">":
                if (tag_buffer.slice(-2) == "--") {
                  state = STATE_PLAINTEXT;
                }
                tag_buffer = "";
                break;
              default:
                tag_buffer += char;
                break;
            }
          }
        }
        context.state = state;
        context.tag_buffer = tag_buffer;
        context.depth = depth;
        context.in_quote_char = in_quote_char;
        return output;
      }
      function parse_allowable_tags(allowable_tags) {
        let tag_set = /* @__PURE__ */ new Set();
        if (typeof allowable_tags === "string") {
          let match;
          while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
            tag_set.add(match[1]);
          }
        } else if (!Symbol2.nonNative && typeof allowable_tags[Symbol2.iterator] === "function") {
          tag_set = new Set(allowable_tags);
        } else if (typeof allowable_tags.forEach === "function") {
          allowable_tags.forEach(tag_set.add, tag_set);
        }
        return tag_set;
      }
      function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
        return match ? match[1].toLowerCase() : null;
      }
      if (typeof define === "function" && define.amd) {
        define(function module_factory() {
          return striptags;
        });
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = striptags;
      } else {
        global2.striptags = striptags;
      }
    })(exports2);
  }
});

// node_modules/noop6/lib/index.js
var require_lib = __commonJS({
  "node_modules/noop6/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// node_modules/function.name/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/function.name/lib/index.js"(exports2, module2) {
    "use strict";
    var noop6 = require_lib();
    (function() {
      var NAME_FIELD = "name";
      if (typeof noop6.name === "string") {
        return;
      }
      try {
        Object.defineProperty(Function.prototype, NAME_FIELD, {
          get: function get2() {
            var nameMatch = this.toString().trim().match(/^function\s*([^\s(]+)/);
            var name = nameMatch ? nameMatch[1] : "";
            Object.defineProperty(this, NAME_FIELD, { value: name });
            return name;
          }
        });
      } catch (e) {
      }
    })();
    module2.exports = function functionName(input) {
      return input.name;
    };
  }
});

// node_modules/typpy/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/typpy/lib/index.js"(exports2, module2) {
    "use strict";
    require_lib2();
    function Typpy(input, target) {
      if (arguments.length === 2) {
        return Typpy.is(input, target);
      }
      return Typpy.get(input, true);
    }
    Typpy.is = function(input, target) {
      return Typpy.get(input, typeof target === "string") === target;
    };
    Typpy.get = function(input, str) {
      if (typeof input === "string") {
        return str ? "string" : String;
      }
      if (null === input) {
        return str ? "null" : null;
      }
      if (void 0 === input) {
        return str ? "undefined" : void 0;
      }
      if (input !== input) {
        return str ? "nan" : NaN;
      }
      return str ? input.constructor.name.toLowerCase() : input.constructor;
    };
    module2.exports = Typpy;
  }
});

// node_modules/auto-parse/index.js
var require_auto_parse = __commonJS({
  "node_modules/auto-parse/index.js"(exports2, module2) {
    module2.exports = autoParse;
    var typpy = require_lib3();
    function stripTrimLower(value) {
      return value.replace(/[""'']/ig, "").trim().toLowerCase();
    }
    function toBoolean(value) {
      return checkBoolean(value) || false;
    }
    function checkBoolean(value) {
      if (!value) {
        return false;
      }
      if (typeof value === "number" || typeof value === "boolean") {
        return !!value;
      }
      value = stripTrimLower(value);
      if (value === "true" || value === "1") return true;
      if (value === "false" || value === "0") return false;
      return null;
    }
    function parseObject(value) {
      if (typpy(value, Array)) {
        return value.map(function(n2, key) {
          return autoParse(n2);
        });
      } else if (typpy(value, Object) || value.constructor === void 0) {
        for (var n in value) {
          value[n] = autoParse(value[n]);
        }
        return value;
      }
      return {};
    }
    function parseFunction(value) {
      return autoParse(value());
    }
    function parseType(value, type) {
      if (value && value.constructor === type || typpy(value, type)) {
        return value;
      }
      var typeName = type;
      if (type && type.name) {
        typeName = type.name.toLowerCase();
      }
      typeName = stripTrimLower(typeName);
      switch (typeName) {
        case "string":
          if (typeof value === "object") return JSON.stringify(value);
          return String(value);
        case "function":
          if (typpy(value, Function)) {
            return value;
          }
          return function(cb) {
            if (typeof cb === "function") {
              cb(value);
            }
            return value;
          };
        case "date":
          return new Date(value);
        case "object":
          var jsonParsed;
          try {
            jsonParsed = JSON.parse(value);
          } catch (e) {
          }
          if (typpy(jsonParsed, Object) || typpy(jsonParsed, Array)) {
            return autoParse(jsonParsed);
          } else if (!typpy(jsonParsed, "undefined")) {
            return {};
          }
          return parseObject(value);
        case "boolean":
          return toBoolean(value);
        case "number":
          return Number(value);
        case "undefined":
          return void 0;
        case "null":
          return null;
        case "array":
          return [value];
        default:
          if (typeof type === "function") {
            return new type(value);
          }
          throw new Error("Unsupported type.");
      }
    }
    function autoParse(value, type) {
      if (type) {
        return parseType(value, type);
      }
      var orignalValue = value;
      if (value === null) {
        return null;
      }
      if (value === void 0) {
        return void 0;
      }
      if (value instanceof Date || value instanceof RegExp) {
        return value;
      }
      if (typeof value === "number" || typeof value === "boolean") {
        return value;
      }
      if (typeof value === "function") {
        return parseFunction(value);
      }
      if (typeof value === "object") {
        return parseObject(value);
      }
      if (value === "NaN") {
        return NaN;
      }
      var jsonParsed = null;
      try {
        jsonParsed = JSON.parse(value);
      } catch (e) {
        try {
          jsonParsed = JSON.parse(
            value.trim().replace(/(\\\\")|(\\")/gi, '"').replace(/(\\n|\\\\n)/gi, "").replace(/(^"|"$)|(^'|'$)/gi, "")
          );
        } catch (e2) {
          try {
            jsonParsed = JSON.parse(
              value.trim().replace(/'/gi, '"')
            );
          } catch (e3) {
          }
        }
      }
      if (jsonParsed && typeof jsonParsed === "object") {
        return autoParse(jsonParsed);
      }
      value = stripTrimLower(value);
      if (value === "undefined" || value === "") {
        return void 0;
      }
      if (value === "null") {
        return null;
      }
      var num = Number(value);
      if (typpy(num, Number)) {
        return num;
      }
      var boo = checkBoolean(value);
      if (typpy(boo, Boolean)) {
        return boo;
      }
      return String(orignalValue);
    }
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/md5.js"() {
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/sha1.js"() {
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/@lykmapipo/common/node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/browser-or-node/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/browser-or-node/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    var isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
    var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
    var isJsDom = function isJsDom2() {
      return typeof window !== "undefined" && window.name === "nodejs" || navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
    };
    exports2.isBrowser = isBrowser;
    exports2.isWebWorker = isWebWorker;
    exports2.isNode = isNode;
    exports2.isJsDom = isJsDom;
  }
});

// node_modules/@lykmapipo/common/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@lykmapipo/common/lib/index.js"(exports2) {
    "use strict";
    var path = require("path");
    var fs = require("fs");
    var os = require("os");
    var lodash = require_lodash();
    var mime = require_mime();
    var flat$1 = require_flat();
    var statuses = require_statuses();
    var inflection = require_inflection();
    var generateColor = require_randomColor();
    var moment = require_moment();
    var hashObject = require_object_hash();
    var renderTemplate = require_string_template();
    var stripTags = require_striptags();
    var parseValue = require_auto_parse();
    var uuid = (init_esm_node(), __toCommonJS(esm_node_exports));
    var browserOrNode = require_lib4();
    var RESOURCE_ACTIONS = [
      // PERMISSION_SEED_ACTIONS
      // RESOURCE_ACTIONS
      "list",
      "create",
      "view",
      "edit",
      "delete",
      "share",
      "print",
      "import",
      "export",
      "download"
    ];
    var isNotValue = (value) => {
      if (lodash.isNaN(value)) {
        return true;
      }
      if (lodash.isBoolean(value) || lodash.isNumber(value) || lodash.isError(value) || lodash.isFunction(value)) {
        return false;
      }
      if (lodash.isString(value)) {
        return !value || lodash.isEmpty(lodash.trim(value));
      }
      if (lodash.isDate(value)) {
        return !value || !value.getTime();
      }
      return !value || lodash.isEmpty(value);
    };
    var isValue = (value) => {
      return !isNotValue(value);
    };
    var firstValue = (...values) => {
      return lodash.first(lodash.filter([...values], (value) => !isNotValue(value)));
    };
    var copyOf = (value) => lodash.cloneDeep(value);
    var mapToUpper = (...values) => {
      const convertToUpper = (value) => lodash.toUpper(value);
      const lowerValues = lodash.flattenDeep([...values]);
      const upperValues = lodash.map(lowerValues, convertToUpper);
      return upperValues;
    };
    var mapToLower = (...values) => {
      const convertToLower = (value) => lodash.toLower(value);
      const upperValues = lodash.flattenDeep([...values]);
      const lowerValues = lodash.map(upperValues, convertToLower);
      return lowerValues;
    };
    var areNotEmpty = (...values) => {
      const copyOfValues = [...values];
      const checkForEmpties = (arePreviousEmpty, nextValue) => {
        return arePreviousEmpty && !lodash.isEmpty(lodash.toString(nextValue));
      };
      const notEmpty = lodash.reduce(copyOfValues, checkForEmpties, true);
      return notEmpty;
    };
    var compact2 = (value) => {
      const copyOfValue = copyOf(value);
      if (lodash.isArray(copyOfValue)) {
        return lodash.compact(copyOfValue);
      }
      if (lodash.isPlainObject(copyOfValue)) {
        return lodash.omitBy(copyOfValue, isNotValue);
      }
      return copyOfValue;
    };
    var uniq = (value) => {
      if (value) {
        let copyOfValue = compact2(value);
        copyOfValue = lodash.isArray(value) ? lodash.uniq(copyOfValue) : copyOfValue;
        return copyOfValue;
      }
      return value;
    };
    var sortedUniq = (value) => {
      if (value) {
        let copyOfValue = uniq(value);
        copyOfValue = lodash.isArray(copyOfValue) ? lodash.orderBy(copyOfValue) : copyOfValue;
        return copyOfValue;
      }
      return value;
    };
    var assign = (object = {}, ...objects) => {
      let sources = lodash.compact([...objects]);
      sources = lodash.map(sources, compact2);
      lodash.assign(object, ...sources);
      return object;
    };
    var mergeObjects3 = (...objects) => {
      let sources = lodash.compact([...objects]);
      sources = lodash.map(sources, compact2);
      const merged = lodash.merge({}, ...sources);
      return merged;
    };
    var safeMergeObjects = (...objects) => {
      const sources = lodash.compact([...objects]);
      const merged = lodash.merge({}, ...sources);
      return merged;
    };
    var pkg = (path$1, ...field) => {
      const read = () => {
        try {
          const filePath = path.resolve(path$1, "package.json");
          const json = JSON.parse(fs.readFileSync(filePath, "utf8"));
          return json;
        } catch (e) {
          const filePath = path.resolve(process.cwd(), "package.json");
          const json = JSON.parse(fs.readFileSync(filePath, "utf8"));
          return json;
        }
      };
      try {
        const packageInfo = mergeObjects3(read());
        const fields = uniq([...field, path$1]);
        if (!lodash.isEmpty(fields)) {
          const info = { ...lodash.pick(packageInfo, ...fields) };
          return lodash.isEmpty(info) ? { ...packageInfo } : info;
        }
        return packageInfo;
      } catch (e) {
        return {};
      }
    };
    var scopesFor = (...resources) => {
      let scopes;
      const toActions = (resource) => {
        const toWildcard = (action) => {
          const scope = lodash.toLower([resource, action].join(":"));
          return scope;
        };
        return lodash.map(RESOURCE_ACTIONS, toWildcard);
      };
      if (resources) {
        const copyOfResources = uniq([...resources]);
        scopes = lodash.map(copyOfResources, toActions);
        scopes = sortedUniq(lodash.flattenDeep(scopes));
      }
      return scopes;
    };
    var permissionsFor = (...resources) => {
      let permissions = [];
      if (resources) {
        const copyOfResources = uniq([...resources]);
        lodash.forEach(copyOfResources, (resource) => {
          const resourcePermissions = lodash.map(RESOURCE_ACTIONS, (action) => {
            return {
              resource,
              action: lodash.toLower(action),
              description: lodash.startCase(`${action} ${resource}`),
              wildcard: lodash.toLower([resource, action].join(":"))
            };
          });
          permissions = [...permissions, ...resourcePermissions];
        });
      }
      return permissions;
    };
    var abbreviate = (...words) => {
      let phrases = lodash.flattenDeep([...words]);
      phrases = lodash.words(phrases.join(" "));
      const pickFirstLetters = (abbr, phrase) => {
        return lodash.toUpper(abbr + lodash.first(phrase));
      };
      const abbreviation = lodash.reduce(phrases, pickFirstLetters, "");
      return abbreviation;
    };
    var idOf = (data) => lodash.get(data, "_id") || lodash.get(data, "id");
    var variableNameFor = (...names) => lodash.camelCase([...names].join(" "));
    var has = (collection, value) => lodash.includes(collection, value);
    var hasAll = (collection, ...values) => {
      const checkIfIsInCollection = (value) => has(collection, value);
      const flatValues = lodash.flattenDeep([...values]);
      const areAllInCollection = lodash.every(flatValues, checkIfIsInCollection);
      return areAllInCollection;
    };
    var hasAny = (collection, ...values) => {
      const checkIfIsInCollection = (value) => has(collection, value);
      const flatValues = lodash.flattenDeep([...values]);
      const isAnyInCollection = lodash.some(flatValues, checkIfIsInCollection);
      return isAnyInCollection;
    };
    var normalizeError = (error, options = {}) => {
      let { name = "Error", code = 500, status, message } = mergeObjects3(options);
      code = error.code || error.statusCode || code;
      status = error.status || error.statusCode || status || code;
      name = error.name || name;
      message = error.message || message || statuses.message[code];
      assign(error, { code, status, name, message });
      return error;
    };
    var bagify = (errors = {}) => {
      const bag = {};
      lodash.forEach(errors, (error = {}, key) => {
        const {
          message,
          name,
          type,
          kind,
          path: path2,
          value,
          index,
          properties = {}
        } = error;
        const normalized = mergeObjects3(
          { message, name, type, kind, path: path2, value, index },
          properties
        );
        const props = ["message", "name", "type", "kind", "path", "value", "index"];
        bag[key] = lodash.pick(normalized, ...props);
      });
      return bag;
    };
    var mapErrorToObject = (error, options = {}) => {
      const {
        name = "Error",
        code = 500,
        stack = false,
        status,
        message,
        description
      } = mergeObjects3(options);
      const body = {};
      body.code = error.code || error.statusCode || code;
      body.status = error.status || error.statusCode || status || code;
      body.name = error.name || name;
      body.message = error.message || message || statuses.message[code];
      body.description = error.description || description || body.message;
      body.errors = error.errors ? bagify(error.errors) : void 0;
      body.stack = stack ? error.stack : void 0;
      body.uri = lodash.get(error, "error_uri", error.uri);
      body.error = error.error || body.name;
      body.error_description = body.description;
      body.error_uri = body.uri;
      return mergeObjects3(body);
    };
    var osInfo = () => {
      const info = {
        arch: os.arch(),
        cpus: os.cpus(),
        endianness: os.endianness(),
        freemem: os.freemem(),
        homedir: os.homedir(),
        hostname: os.hostname(),
        loadavg: os.loadavg(),
        networkInterfaces: os.networkInterfaces(),
        platform: os.platform(),
        release: os.release(),
        tmpdir: os.tmpdir(),
        totalmem: os.totalmem(),
        type: os.type(),
        uptime: os.uptime()
      };
      return info;
    };
    var processInfo = () => {
      const info = {
        arch: process.arch,
        cpuUsage: process.cpuUsage(),
        cwd: process.cwd(),
        features: process.features,
        egid: process.getegid(),
        euid: process.geteuid(),
        gid: process.getgid(),
        groups: process.getgroups(),
        uid: process.getuid(),
        hrtime: process.hrtime(),
        memoryUsage: process.memoryUsage(),
        pid: process.pid,
        platform: process.platform,
        ppid: process.ppid,
        title: process.title,
        uptime: process.uptime(),
        version: process.version,
        versions: process.versions
      };
      return info;
    };
    var randomColor = (optns = { luminosity: "light" }) => {
      const options = mergeObjects3(optns);
      const color = lodash.toUpper(generateColor(options));
      return color;
    };
    var formatDate = (date = /* @__PURE__ */ new Date(), format = "YYYY-MM-DD") => {
      const formatted = moment.utc(date).format(format);
      return formatted;
    };
    var parseDate = (date, format = "YYYY-MM-DD") => {
      const parsed = moment.utc(date, format).toDate();
      return parsed;
    };
    var hashOf = (object, ...ignore) => {
      let copyOfObject = mergeObjects3(object);
      copyOfObject = lodash.omit(copyOfObject, ...ignore);
      const hash = hashObject(copyOfObject);
      return hash;
    };
    var parseTemplate = (template, data) => {
      const copyOfTemplate = copyOf(template);
      const copyOfData = mergeObjects3(data);
      const formatted = renderTemplate(copyOfTemplate, copyOfData);
      return formatted;
    };
    var stripHtmlTags = (html) => {
      const copyOfHtml = copyOf(html);
      const formatted = stripTags(copyOfHtml);
      return formatted;
    };
    var stringify2 = (value) => {
      try {
        return JSON.stringify(value);
      } catch (e) {
        return value;
      }
    };
    var parse2 = (value) => {
      try {
        return JSON.parse(value);
      } catch (e) {
        return value;
      }
    };
    var pluralize = (value) => {
      let plural = copyOf(value);
      plural = inflection.pluralize(plural);
      return plural;
    };
    var singularize = (value) => {
      let singular = copyOf(value);
      singular = inflection.singularize(singular);
      return singular;
    };
    var autoParse = (value, ...fields) => {
      const copyOfValue = copyOf(value);
      if (lodash.isPlainObject(copyOfValue)) {
        let parsed = lodash.pick(copyOfValue, ...fields);
        parsed = lodash.isEmpty(parsed) ? copyOfValue : parsed;
        parsed = parseValue(parsed);
        return lodash.merge(copyOfValue, parsed);
      }
      return parseValue(copyOfValue);
    };
    var flat = (value) => {
      let flattened = copyOf(value);
      flattened = flat$1.flatten(flattened);
      return flattened;
    };
    var unflat = (value) => {
      let unflatted = copyOf(value);
      unflatted = flat$1.unflatten(unflatted);
      return unflatted;
    };
    var join = (values = [], separator = ", ", property = "") => {
      const copies = lodash.flattenDeep([].concat(values));
      const parts = lodash.map(copies, (copy) => {
        if (lodash.isPlainObject(copy)) {
          return lodash.get(copy, property);
        }
        return copy;
      });
      const joined = lodash.join(parts, separator);
      return joined;
    };
    var transform = (vals, ...transformers) => {
      const values = compact2([].concat(vals));
      const defaultTransformer = (value) => value;
      const preprocessors = lodash.map(
        compact2([defaultTransformer].concat(...transformers)),
        (transformer) => {
          return lodash.isFunction(transformer) ? transformer : defaultTransformer;
        }
      );
      let transformed = lodash.map(values, (value) => {
        let data;
        lodash.forEach(preprocessors, (transformer) => {
          data = transformer(value);
        });
        return data;
      });
      transformed = compact2(transformed);
      transformed = lodash.size(transformed) === 1 ? lodash.first(transformed) : transformed;
      return transformed;
    };
    var arrayToObject = (array, transformer) => {
      const keys = compact2([].concat(array));
      const defaultTransformer = (object2, value) => value;
      const valueFor = lodash.isFunction(transformer) ? transformer : defaultTransformer;
      const object = {};
      lodash.forEach(keys, (key) => {
        object[key] = valueFor(object, key);
      });
      return object;
    };
    var parseMs = (ms) => {
      const value = Math.abs(ms);
      const parsed = {
        days: Math.trunc(value / 864e5),
        hours: Math.trunc(value / 36e5) % 24,
        minutes: Math.trunc(value / 6e4) % 60,
        seconds: Math.trunc(value / 1e3) % 60,
        milliseconds: Math.trunc(value) % 1e3,
        microseconds: Math.trunc(value * 1e3) % 1e3,
        nanoseconds: Math.trunc(value * 1e6) % 1e3
      };
      return parsed;
    };
    var wrapCallback = (cb, ...defaultArgs) => (...replyArgs) => {
      const args = compact2([...replyArgs, ...defaultArgs]);
      const error = lodash.find(args, (arg) => lodash.isError(arg));
      const replies = lodash.filter(args, (arg) => !lodash.isError(arg));
      if (lodash.isFunction(cb)) {
        return cb(error, ...replies);
      }
      return lodash.noop(error, ...replies);
    };
    var classify = (value) => {
      let className = lodash.snakeCase(copyOf(value));
      className = inflection.classify(className);
      return className;
    };
    var tryCatch = (func, defaultValue) => {
      try {
        return func();
      } catch (e) {
        return defaultValue;
      }
    };
    Object.defineProperty(exports2, "mimeExtensionOf", {
      enumerable: true,
      get: function() {
        return mime.getExtension;
      }
    });
    Object.defineProperty(exports2, "mimeTypeOf", {
      enumerable: true,
      get: function() {
        return mime.getType;
      }
    });
    Object.defineProperty(exports2, "STATUS_CODES", {
      enumerable: true,
      get: function() {
        return statuses.message;
      }
    });
    Object.defineProperty(exports2, "uuidv1", {
      enumerable: true,
      get: function() {
        return uuid.v1;
      }
    });
    Object.defineProperty(exports2, "uuidv3", {
      enumerable: true,
      get: function() {
        return uuid.v3;
      }
    });
    Object.defineProperty(exports2, "uuidv4", {
      enumerable: true,
      get: function() {
        return uuid.v4;
      }
    });
    Object.defineProperty(exports2, "uuidv5", {
      enumerable: true,
      get: function() {
        return uuid.v5;
      }
    });
    Object.defineProperty(exports2, "isBrowser", {
      enumerable: true,
      get: function() {
        return browserOrNode.isBrowser;
      }
    });
    Object.defineProperty(exports2, "isNode", {
      enumerable: true,
      get: function() {
        return browserOrNode.isNode;
      }
    });
    Object.defineProperty(exports2, "isWebWorker", {
      enumerable: true,
      get: function() {
        return browserOrNode.isWebWorker;
      }
    });
    exports2.RESOURCE_ACTIONS = RESOURCE_ACTIONS;
    exports2.abbreviate = abbreviate;
    exports2.areNotEmpty = areNotEmpty;
    exports2.arrayToObject = arrayToObject;
    exports2.assign = assign;
    exports2.autoParse = autoParse;
    exports2.bagify = bagify;
    exports2.classify = classify;
    exports2.compact = compact2;
    exports2.copyOf = copyOf;
    exports2.firstValue = firstValue;
    exports2.flat = flat;
    exports2.formatDate = formatDate;
    exports2.has = has;
    exports2.hasAll = hasAll;
    exports2.hasAny = hasAny;
    exports2.hashOf = hashOf;
    exports2.idOf = idOf;
    exports2.isNotValue = isNotValue;
    exports2.isValue = isValue;
    exports2.join = join;
    exports2.mapErrorToObject = mapErrorToObject;
    exports2.mapToLower = mapToLower;
    exports2.mapToUpper = mapToUpper;
    exports2.mergeObjects = mergeObjects3;
    exports2.normalizeError = normalizeError;
    exports2.osInfo = osInfo;
    exports2.parse = parse2;
    exports2.parseDate = parseDate;
    exports2.parseMs = parseMs;
    exports2.parseTemplate = parseTemplate;
    exports2.permissionsFor = permissionsFor;
    exports2.pkg = pkg;
    exports2.pluralize = pluralize;
    exports2.processInfo = processInfo;
    exports2.randomColor = randomColor;
    exports2.safeMergeObjects = safeMergeObjects;
    exports2.scopesFor = scopesFor;
    exports2.singularize = singularize;
    exports2.sortedUniq = sortedUniq;
    exports2.stringify = stringify2;
    exports2.stripHtmlTags = stripHtmlTags;
    exports2.transform = transform;
    exports2.tryCatch = tryCatch;
    exports2.unflat = unflat;
    exports2.uniq = uniq;
    exports2.variableNameFor = variableNameFor;
    exports2.wrapCallback = wrapCallback;
  }
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports2) {
    (function() {
      exports2.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports2, module2) {
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key)) continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      };
      isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };
      isArray = function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };
      isEmpty = function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key)) continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      };
      getValue = function(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
      module2.exports.getValue = getValue;
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports2, module2) {
    (function() {
      var XMLDOMImplementation;
      module2.exports = XMLDOMImplementation = function() {
        function XMLDOMImplementation2() {
        }
        XMLDOMImplementation2.prototype.hasFeature = function(feature, version2) {
          return true;
        };
        XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.getFeature = function(feature, version2) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports2, module2) {
    (function() {
      var XMLDOMErrorHandler;
      module2.exports = XMLDOMErrorHandler = function() {
        function XMLDOMErrorHandler2() {
        }
        XMLDOMErrorHandler2.prototype.handleError = function(error) {
          throw new Error(error);
        };
        return XMLDOMErrorHandler2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports2, module2) {
    (function() {
      var XMLDOMStringList;
      module2.exports = XMLDOMStringList = function() {
        function XMLDOMStringList2(arr) {
          this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList2.prototype, "length", {
          get: function() {
            return this.arr.length;
          }
        });
        XMLDOMStringList2.prototype.item = function(index) {
          return this.arr[index] || null;
        };
        XMLDOMStringList2.prototype.contains = function(str) {
          return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports2, module2) {
    (function() {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module2.exports = XMLDOMConfiguration = function() {
        function XMLDOMConfiguration2() {
          var clonedSelf;
          this.defaultParams = {
            "canonical-form": false,
            "cdata-sections": false,
            "comments": false,
            "datatype-normalization": false,
            "element-content-whitespace": true,
            "entities": true,
            "error-handler": new XMLDOMErrorHandler(),
            "infoset": true,
            "validate-if-schema": false,
            "namespaces": true,
            "namespace-declarations": true,
            "normalize-characters": false,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": true,
            "validate": false,
            "well-formed": true
          };
          this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
          get: function() {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          }
        });
        XMLDOMConfiguration2.prototype.getParameter = function(name) {
          if (this.params.hasOwnProperty(name)) {
            return this.params[name];
          } else {
            return null;
          }
        };
        XMLDOMConfiguration2.prototype.canSetParameter = function(name, value) {
          return true;
        };
        XMLDOMConfiguration2.prototype.setParameter = function(name, value) {
          if (value != null) {
            return this.params[name] = value;
          } else {
            return delete this.params[name];
          }
        };
        return XMLDOMConfiguration2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  "node_modules/xmlbuilder/lib/NodeType.js"(exports2, module2) {
    (function() {
      module2.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports2, module2) {
    (function() {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name, value) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.value = this.stringify.attValue(value);
          this.type = NodeType.Attribute;
          this.isId = false;
          this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "specified", {
          get: function() {
            return true;
          }
        });
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute2.prototype.debugInfo = function(name) {
          name = name || this.name;
          if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
          }
        };
        XMLAttribute2.prototype.isEqualNode = function(node) {
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.value !== this.value) {
            return false;
          }
          return true;
        };
        return XMLAttribute2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports2, module2) {
    (function() {
      var XMLNamedNodeMap;
      module2.exports = XMLNamedNodeMap = function() {
        function XMLNamedNodeMap2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
          get: function() {
            return Object.keys(this.nodes).length || 0;
          }
        });
        XMLNamedNodeMap2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
          return this.nodes[name];
        };
        XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
          var oldNode;
          oldNode = this.nodes[node.nodeName];
          this.nodes[node.nodeName] = node;
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
          var oldNode;
          oldNode = this.nodes[name];
          delete this.nodes[name];
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.item = function(index) {
          return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports2, module2) {
    (function() {
      var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          var child, j, len, ref1;
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.Element;
          this.attribs = {};
          this.schemaTypeInfo = null;
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.type === NodeType.Document) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
            if (parent.children) {
              ref1 = parent.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.type === NodeType.DocType) {
                  child.name = this.name;
                  break;
                }
              }
            }
          }
        }
        Object.defineProperty(XMLElement2.prototype, "tagName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "id", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "className", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "classList", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "attributes", {
          get: function() {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          }
        });
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attribs = {};
          ref1 = this.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName)) continue;
            att = ref1[attName];
            clonedSelf.attribs[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, j, len;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name = getValue(name);
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              attName = name[j];
              delete this.attribs[attName];
            }
          } else {
            delete this.attribs[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement2.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.getAttribute = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].value;
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttribute = function(name, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNode = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name];
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttributeNode = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.hasAttribute = function(name) {
          return this.attribs.hasOwnProperty(name);
        };
        XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttribute = function(name, isId) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].isId;
          } else {
            return isId;
          }
        };
        XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.isEqualNode = function(node) {
          var i, j, ref1;
          if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.attribs.length !== this.attribs.length) {
            return false;
          }
          for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
            if (!this.attribs[i].isEqualNode(node.attribs[i])) {
              return false;
            }
          }
          return true;
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports2, module2) {
    (function() {
      var XMLCharacterData, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCharacterData = function(superClass) {
        extend(XMLCharacterData2, superClass);
        function XMLCharacterData2(parent) {
          XMLCharacterData2.__super__.constructor.call(this, parent);
          this.value = "";
        }
        Object.defineProperty(XMLCharacterData2.prototype, "data", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "length", {
          get: function() {
            return this.value.length;
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        XMLCharacterData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCharacterData2.prototype.substringData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.appendData = function(arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.insertData = function(offset, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.deleteData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.isEqualNode = function(node) {
          if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.data !== this.data) {
            return false;
          }
          return true;
        };
        return XMLCharacterData2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text);
        }
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text);
        }
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version2, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject(version2)) {
            ref = version2, version2 = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version2) {
            version2 = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version2);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name));
          }
          this.pe = !!pe;
          this.name = this.stringify.name(name);
          this.type = NodeType.EntityDeclaration;
          if (!isObject(value)) {
            this.value = this.stringify.dtdEntityValue(value);
            this.internal = true;
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
            }
            this.internal = false;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
          }
        }
        Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
          get: function() {
            return this.nData || null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
          get: function() {
            return null;
          }
        });
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name));
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.NotationDeclaration;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var child, i, len, ref, ref1, ref2;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.type = NodeType.DocType;
          if (parent.children) {
            ref = parent.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.Element) {
                this.name = child.name;
                break;
              }
            }
          }
          this.documentObject = parent;
          if (isObject(pubID)) {
            ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
          }
          if (sysID == null) {
            ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        Object.defineProperty(XMLDocType2.prototype, "entities", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "notations", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLDocType2.prototype.element = function(name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType2.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        XMLDocType2.prototype.isEqualNode = function(node) {
          if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.name !== this.name) {
            return false;
          }
          if (node.publicId !== this.publicId) {
            return false;
          }
          if (node.systemId !== this.systemId) {
            return false;
          }
          return true;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports2, module2) {
    (function() {
      var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text);
        }
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.name = "#text";
          this.type = NodeType.Text;
          this.value = this.stringify.text(text);
        }
        Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLText2.prototype, "wholeText", {
          get: function() {
            var next, prev, str;
            str = "";
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          }
        });
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText2.prototype.splitText = function(offset) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText2.prototype.replaceWholeText = function(content) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
          if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        };
        return XMLProcessingInstruction2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDummy = function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.type = NodeType.Dummy;
        }
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options) {
          return "";
        };
        return XMLDummy2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports2, module2) {
    (function() {
      var XMLNodeList;
      module2.exports = XMLNodeList = function() {
        function XMLNodeList2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList2.prototype, "length", {
          get: function() {
            return this.nodes.length || 0;
          }
        });
        XMLNodeList2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNodeList2.prototype.item = function(index) {
          return this.nodes[index] || null;
        };
        return XMLNodeList2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports2, module2) {
    (function() {
      module2.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports2, module2) {
    (function() {
      var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
      ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition = null;
      module2.exports = XMLNode = function() {
        function XMLNode2(parent1) {
          this.parent = parent1;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.value = null;
          this.children = [];
          this.baseURI = null;
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
            NodeType = require_NodeType();
            XMLNodeList = require_XMLNodeList();
            XMLNamedNodeMap = require_XMLNamedNodeMap();
            DocumentPosition = require_DocumentPosition();
          }
        }
        Object.defineProperty(XMLNode2.prototype, "nodeName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeValue", {
          get: function() {
            return this.value;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "parentNode", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "childNodes", {
          get: function() {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "firstChild", {
          get: function() {
            return this.children[0] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "lastChild", {
          get: function() {
            return this.children[this.children.length - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "previousSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nextSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i + 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
          get: function() {
            return this.document() || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "textContent", {
          get: function() {
            var child, j, len, ref2, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = "";
              ref2 = this.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function(value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLNode2.prototype.setParent = function(parent) {
          var child, j, len, ref2, results;
          this.parent = parent;
          if (parent) {
            this.options = parent.options;
            this.stringify = parent.stringify;
          }
          ref2 = this.children;
          results = [];
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            results.push(child.setParent(this));
          }
          return results;
        };
        XMLNode2.prototype.element = function(name, attributes, text) {
          var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
          lastChild = null;
          if (attributes === null && text == null) {
            ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
          }
          if (name != null) {
            name = getValue(name);
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject(name)) {
            for (key in name) {
              if (!hasProp.call(name, key)) continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                lastChild = this.dummy();
              } else if (isObject(val) && isEmpty(val)) {
                lastChild = this.element(key);
              } else if (!this.options.keepNullNodes && val == null) {
                lastChild = this.dummy();
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item = val[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val)) {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.element(val);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val);
                }
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (!this.options.keepNullNodes && text === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes, text) {
          var child, i, newChild, refChild, removed;
          if (name != null ? name.type : void 0) {
            newChild = name;
            refChild = attributes;
            newChild.setParent(this);
            if (refChild) {
              i = children.indexOf(refChild);
              removed = children.splice(i);
              children.push(newChild);
              Array.prototype.push.apply(children, removed);
            } else {
              children.push(newChild);
            }
            return newChild;
          } else {
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
        };
        XMLNode2.prototype.insertAfter = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i, ref2;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes, text) {
          var child, ref2;
          if (name != null) {
            name = getValue(name);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          if (isObject(value)) {
            this.element(value);
          }
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version2, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version2, encoding, standalone);
          if (doc.children.length === 0) {
            doc.children.unshift(xmldec);
          } else if (doc.children[0].type === NodeType.Declaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref2 = doc.children;
          for (i = j = 0, len = ref2.length; j < len; i = ++j) {
            child = ref2[i];
            if (child.type === NodeType.DocType) {
              doc.children[i] = doctype;
              return doctype;
            }
          }
          ref3 = doc.children;
          for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
            child = ref3[i];
            if (child.isRoot) {
              doc.children.splice(i, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i - 1];
        };
        XMLNode2.prototype.next = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name) {
          var ref2, ref3;
          name = name || this.name;
          if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "";
          } else if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
            return "node: <" + name + ">";
          } else {
            return "node: <" + name + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLNode2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.removeChild = function(oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.appendChild = function(newChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.hasChildNodes = function() {
          return this.children.length !== 0;
        };
        XMLNode2.prototype.cloneNode = function(deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.normalize = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isSupported = function(feature, version2) {
          return true;
        };
        XMLNode2.prototype.hasAttributes = function() {
          return this.attribs.length !== 0;
        };
        XMLNode2.prototype.compareDocumentPosition = function(other) {
          var ref, res;
          ref = this;
          if (ref === other) {
            return 0;
          } else if (this.document() !== other.document()) {
            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
            if (Math.random() < 0.5) {
              res |= DocumentPosition.Preceding;
            } else {
              res |= DocumentPosition.Following;
            }
            return res;
          } else if (ref.isAncestor(other)) {
            return DocumentPosition.Contains | DocumentPosition.Preceding;
          } else if (ref.isDescendant(other)) {
            return DocumentPosition.Contains | DocumentPosition.Following;
          } else if (ref.isPreceding(other)) {
            return DocumentPosition.Preceding;
          } else {
            return DocumentPosition.Following;
          }
        };
        XMLNode2.prototype.isSameNode = function(other) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isEqualNode = function(node) {
          var i, j, ref2;
          if (node.nodeType !== this.nodeType) {
            return false;
          }
          if (node.children.length !== this.children.length) {
            return false;
          }
          for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
            if (!this.children[i].isEqualNode(node.children[i])) {
              return false;
            }
          }
          return true;
        };
        XMLNode2.prototype.getFeature = function(feature, version2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.setUserData = function(key, data, handler) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.getUserData = function(key) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.contains = function(other) {
          if (!other) {
            return false;
          }
          return other === this || this.isDescendant(other);
        };
        XMLNode2.prototype.isDescendant = function(node) {
          var child, isDescendantChild, j, len, ref2;
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (node === child) {
              return true;
            }
            isDescendantChild = child.isDescendant(node);
            if (isDescendantChild) {
              return true;
            }
          }
          return false;
        };
        XMLNode2.prototype.isAncestor = function(node) {
          return node.isDescendant(this);
        };
        XMLNode2.prototype.isPreceding = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos < thisPos;
          }
        };
        XMLNode2.prototype.isFollowing = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos > thisPos;
          }
        };
        XMLNode2.prototype.treePosition = function(node) {
          var found, pos;
          pos = 0;
          found = false;
          this.foreachTreeNode(this.document(), function(childNode) {
            pos++;
            if (!found && childNode === node) {
              return found = true;
            }
          });
          if (found) {
            return pos;
          } else {
            return -1;
          }
        };
        XMLNode2.prototype.foreachTreeNode = function(node, func) {
          var child, j, len, ref2, res;
          node || (node = this.document());
          ref2 = node.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (res = func(child)) {
              return res;
            } else {
              res = this.foreachTreeNode(child, func);
              if (res) {
                return res;
              }
            }
          }
        };
        return XMLNode2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports2, module2) {
    (function() {
      var XMLStringifier, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalName = bind(this.assertLegalName, this);
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.options = options;
          if (!this.options.version) {
            this.options.version = "1.0";
          }
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this[key] = value;
          }
        }
        XMLStringifier2.prototype.name = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalName("" + val || "");
        };
        XMLStringifier2.prototype.text = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.textEscape("" + val || ""));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.attEscape(val = "" + val || ""));
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.insValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var regex, res;
          if (this.options.noValidation) {
            return str;
          }
          regex = "";
          if (this.options.version === "1.0") {
            regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          } else if (this.options.version === "1.1") {
            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          }
          return str;
        };
        XMLStringifier2.prototype.assertLegalName = function(str) {
          var regex;
          if (this.options.noValidation) {
            return str;
          }
          this.assertLegalChar(str);
          regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
          if (!str.match(regex)) {
            throw new Error("Invalid character in name");
          }
          return str;
        };
        XMLStringifier2.prototype.textEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  "node_modules/xmlbuilder/lib/WriterState.js"(exports2, module2) {
    (function() {
      module2.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
      assign = require_Utility().assign;
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module2.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, value;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this["_" + key] = this[key];
            this[key] = value;
          }
        }
        XMLWriterBase2.prototype.filterOptions = function(options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
          filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
          filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        };
        XMLWriterBase2.prototype.indent = function(node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        };
        XMLWriterBase2.prototype.endline = function(node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else {
            return options.newline;
          }
        };
        XMLWriterBase2.prototype.attribute = function(att, options, level) {
          var r;
          this.openAttribute(att, options, level);
          r = " " + att.name + '="' + att.value + '"';
          this.closeAttribute(att, options, level);
          return r;
        };
        XMLWriterBase2.prototype.cdata = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<![CDATA[";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += "]]>" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.comment = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!-- ";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += " -->" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.declaration = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?xml";
          options.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.docType = function(node, options, level) {
          var child, i, len, r, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += "]";
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
          level || (level = 0);
          prettySuppressed = false;
          r = "";
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r += this.indent(node, options, level) + "<" + node.name;
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            att = ref[name];
            r += this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              r += ">";
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            r += ">";
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            if (options.dontPrettyTextNodes) {
              ref1 = node.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r += ">" + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += this.indent(node, options, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error("Unknown XML node type: " + node.constructor.name);
          }
        };
        XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?";
          options.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += " " + node.value;
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.raw = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.text = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ATTLIST";
          options.state = WriterState.InsideTag;
          r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ELEMENT";
          options.state = WriterState.InsideTag;
          r += " " + node.name + " " + node.value;
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ENTITY";
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!NOTATION";
          options.state = WriterState.InsideTag;
          r += " " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.openNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.closeNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
        };
        XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
        };
        return XMLWriterBase2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports2, module2) {
    (function() {
      var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        XMLStringWriter2.prototype.document = function(doc, options) {
          var child, i, len, r, ref;
          options = this.filterOptions(options);
          r = "";
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, 0);
          }
          if (options.pretty && r.slice(-options.newline.length) === options.newline) {
            r = r.slice(0, -options.newline.length);
          }
          return r;
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "#document";
          this.type = NodeType.Document;
          this.documentURI = null;
          this.domConfig = new XMLDOMConfiguration();
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument2.prototype, "implementation", {
          value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument2.prototype, "doctype", {
          get: function() {
            var child, i, len, ref;
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "documentElement", {
          get: function() {
            return this.rootObject || null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
          get: function() {
            return false;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "URL", {
          get: function() {
            return this.documentURI;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "origin", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "compatMode", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "characterSet", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "contentType", {
          get: function() {
            return null;
          }
        });
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          writerOptions = {};
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer;
          }
          return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument2.prototype.createElement = function(tagName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createDocumentFragment = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTextNode = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createComment = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createCDATASection = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttribute = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEntityReference = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.importNode = function(importedNode, deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementById = function(elementId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.adoptNode = function(source) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.normalizeDocument = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEvent = function(eventInterface) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createRange = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module2.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.createChildNode = function(node) {
          var att, attName, attributes, child, i, len, ref1, ref2;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref1 = node.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName)) continue;
                att = ref1[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
          }
          ref2 = node.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.dummy = function() {
          return this;
        };
        XMLDocumentCB2.prototype.node = function(name, attributes, text) {
          var ref1;
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes, text) {
          var child, i, len, oldValidationFlag, ref1, root;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement.apply(this, arguments);
          } else {
            if (Array.isArray(name) || isObject(name) || isFunction(name)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root = new XMLDocument(this.options).element("TEMP_ROOT");
              root.element(name);
              this.options.noValidation = oldValidationFlag;
              ref1 = root.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name, attributes, text);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version2, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version2, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          var att, chunk, name, ref1;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
              ref1 = node.attribs;
              for (name in ref1) {
                if (!hasProp.call(ref1, name)) continue;
                att = ref1[name];
                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += ">";
              }
              chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk, this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          var chunk;
          if (!node.isClosed) {
            chunk = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module2.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          this.stream = stream;
          XMLStreamWriter2.__super__.constructor.call(this, options);
        }
        XMLStreamWriter2.prototype.endline = function(node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return "";
          } else {
            return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
          }
        };
        XMLStreamWriter2.prototype.document = function(doc, options) {
          var child, i, j, k, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            child = ref[i];
            child.isLastRootNode = i === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter2.prototype.cdata = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.comment = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.declaration = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.docType = function(node, options, level) {
          var child, j, len, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level) + "<" + node.name);
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            att = ref[name];
            this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              this.stream.write(">");
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + "/>");
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            this.stream.write(">");
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.raw = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.text = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module2.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
      module2.exports.implementation = new XMLDOMImplementation();
      module2.exports.nodeType = NodeType;
      module2.exports.writerState = WriterState;
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports2) {
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib6();
      defaults = require_defaults().defaults;
      requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      };
      wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      };
      escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      };
      exports2.Builder = function() {
        function Builder(opts) {
          var key, ref, value;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = /* @__PURE__ */ function(_this) {
            return function(element, obj) {
              var attr, child, entry, index, key, value;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index in obj) {
                  if (!hasProp.call(obj, index)) continue;
                  child = obj[index];
                  for (key in child) {
                    entry = child[key];
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key)) continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index)) continue;
                      entry = child[index];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports2);
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports2) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result2 = "";
        if (i < chunk.length) {
          result2 = chunk.charAt(i);
        }
        return result2;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result2 = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result2 += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result2;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports2) {
    (function() {
      "use strict";
      exports2.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports2) {
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports2.normalize = function(str) {
        return str.toLowerCase();
      };
      exports2.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports2.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports2.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports2.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports2) {
    (function() {
      "use strict";
      var bom, defaults, events, isEmpty, processItem, processors2, sax, setImmediate2, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = require("events");
      bom = require_bom();
      processors2 = require_processors();
      setImmediate2 = require("timers").setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      };
      processItem = function(processors3, item, key) {
        var i, len, process2;
        for (i = 0, len = processors3.length; i < len; i++) {
          process2 = processors3[i];
          item = process2(item, key);
        }
        return item;
      };
      exports2.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseStringPromise = bind(this.parseStringPromise, this);
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value;
          if (!(this instanceof exports2.Parser)) {
            return new exports2.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors2.normalize);
          }
          this.reset();
        }
        Parser.prototype.processAsync = function() {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate2(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = /* @__PURE__ */ function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          }(this);
          this.saxParser.onend = /* @__PURE__ */ function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = /* @__PURE__ */ function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key)) continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = /* @__PURE__ */ function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = stack.length; i < len; i++) {
                    node = stack[i];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key)) continue;
                    objClone[key] = obj[key];
                  }
                  s[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = /* @__PURE__ */ function(_this) {
            return function(text) {
              var charChild, s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s[_this.options.childkey].push(charChild);
                }
                return s;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = /* @__PURE__ */ function(_this) {
            return function(text) {
              var s;
              s = ontext(text);
              if (s) {
                return s.cdata = true;
              }
            };
          }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result2) {
              this.reset();
              return cb(null, result2);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate2(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        Parser.prototype.parseStringPromise = function(str) {
          return new Promise(/* @__PURE__ */ function(_this) {
            return function(resolve, reject) {
              return _this.parseString(str, function(err, value) {
                if (err) {
                  return reject(err);
                } else {
                  return resolve(value);
                }
              });
            };
          }(this));
        };
        return Parser;
      }(events);
      exports2.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === "function") {
            cb = b;
          }
          if (typeof a === "object") {
            options = a;
          }
        } else {
          if (typeof a === "function") {
            cb = a;
          }
          options = {};
        }
        parser = new exports2.Parser(options);
        return parser.parseString(str, cb);
      };
      exports2.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === "object") {
          options = a;
        }
        parser = new exports2.Parser(options);
        return parser.parseStringPromise(str);
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports2) {
    (function() {
      "use strict";
      var builder, defaults, parser, processors2, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder();
      parser = require_parser();
      processors2 = require_processors();
      exports2.defaults = defaults.defaults;
      exports2.processors = processors2;
      exports2.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      }(Error);
      exports2.Builder = builder.Builder;
      exports2.Parser = parser.Parser;
      exports2.parseString = parser.parseString;
      exports2.parseStringPromise = parser.parseStringPromise;
    }).call(exports2);
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result2;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result2 = ArrayBuffer.isView(val);
      } else {
        result2 = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result2;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result2 = {};
      function assignValue(val, key) {
        if (isPlainObject(result2[key]) && isPlainObject(val)) {
          result2[key] = merge(result2[key], val);
        } else if (isPlainObject(val)) {
          result2[key] = merge({}, val);
        } else if (isArray(val)) {
          result2[key] = val.slice();
        } else {
          result2[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result2;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults2();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled) return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%") return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match) return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
        // the server is redirecting the user agent to a different resource []
        // A user agent can perform a retrieval request targeting that URI
        // (a GET or HEAD request if using HTTP) []
        statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = url.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl;
        try {
          redirectUrl = url.resolve(currentUrl, location);
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (redirectUrlParts.protocol !== currentUrlParts.protocol || !isSameOrSubdomain(redirectUrlParts.host, currentHost)) {
          removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL2(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get2(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get2, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request) {
      for (var e = 0; e < events.length; e++) {
        request.removeListener(events[e], eventHandlers[events[e]]);
      }
      request.on("error", noop);
      request.abort();
    }
    function isSameOrSubdomain(subdomain, domain) {
      if (subdomain === domain) {
        return true;
      }
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports2, module2) {
    module2.exports = {
      "version": "0.26.0"
    };
  }
});

// node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var VERSION = require_data().version;
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var defaults = require_defaults2();
    var Cancel = require_Cancel();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve = function resolve2(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              config
            ));
          }
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(createError("Request body larger than maxBodyLength limit", config));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        try {
          buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          reject(customErr);
        }
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted) return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              /*eslint default-case:0*/
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(createError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  config,
                  null,
                  lastRequest
                ));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(createError("error request aborted", config, "ERR_REQUEST_ABORTED", lastRequest));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted) return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(enhanceError(err, config, err.code, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS") return;
          reject(enhanceError(err, config, null, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError(
              "error trying to parse `config.timeout` to int",
              config,
              "ERR_PARSE_TIMEOUT",
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var timeoutErrorMessage = "";
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            } else {
              timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
            }
            var transitional = config.transitional || defaults.transitional;
            reject(createError(
              timeoutErrorMessage,
              config,
              transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              req
            ));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted) return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults2();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults2();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result2 = value === void 0 || validator(value, opt, options);
          if (result2 !== true) {
            throw new TypeError("option " + opt + " must be " + result2);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners) return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults2();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all2(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["ecma", "es"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana"
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["keynote"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana"
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana"
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana"
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana"
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana"
      },
      "image/avcs": {
        source: "iana"
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shex": {
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana"
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result2) {
        if (isAsync) {
          callback(err, result2);
        } else {
          defer(function nextTick_callback() {
            callback(err, result2);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result2) {
          if (error) {
            callback(error, result2);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result2) {
        if (error) {
          callback(error, result2);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData;
    util.inherits(FormData, CombinedStream);
    function FormData(options) {
      if (!(this instanceof FormData)) {
        return new FormData(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData.LINE_BREAK = "\r\n";
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop)) continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    };
    FormData.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/internal/debug.js
var require_debug3 = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug3();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug3();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse2 = (version2, options) => {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse2 = require_parse();
    var valid = (version2, options) => {
      const v = parse2(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse2 = require_parse();
    var clean = (version2, options) => {
      const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version2, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse2 = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v12 = parse2(version1);
        const v2 = parse2(version2);
        const hasPre = v12.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse2 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/@lykmapipo/env/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/@lykmapipo/env/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/@lykmapipo/env/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get2(this, key, true);
      }
      peek(key) {
        return get2(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get2(this, key, false));
      }
    };
    var get2 = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = /* @__PURE__ */ new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result2 = [...rangeMap.values()];
        cache.set(memoKey, result2);
        return result2;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug3();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result2 = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result2 && remainingComparators.length) {
        result2 = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result2;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug3();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!min)
            min = version2;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub)
            continue OUTER;
        }
        if (sawNonNull)
          return false;
      }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/@lykmapipo/env/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/@lykmapipo/env/node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    function log(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\r\n|\n|\r/;
    function parse2(src, options) {
      const debug = Boolean(options && options.debug);
      const obj = {};
      src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug) {
          log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    function resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let debug = false;
      if (options) {
        if (options.path != null) {
          dotenvPath = resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
        if (options.debug != null) {
          debug = true;
        }
      }
      try {
        const parsed = parse2(fs.readFileSync(dotenvPath, { encoding }), { debug });
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug) {
            log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return { parsed };
      } catch (e) {
        return { error: e };
      }
    }
    module2.exports.config = config;
    module2.exports.parse = parse2;
  }
});

// node_modules/dotenv-expand/lib/main.js
var require_main2 = __commonJS({
  "node_modules/dotenv-expand/lib/main.js"(exports2, module2) {
    "use strict";
    var dotenvExpand = function(config) {
      var environment = config.ignoreProcessEnv ? {} : process.env;
      var interpolate = function(envValue) {
        var matches = envValue.match(/(.?\${?(?:[a-zA-Z0-9_]+)?}?)/g) || [];
        return matches.reduce(function(newEnv, match) {
          var parts = /(.?)\${?([a-zA-Z0-9_]+)?}?/g.exec(match);
          var prefix = parts[1];
          var value2, replacePart;
          if (prefix === "\\") {
            replacePart = parts[0];
            value2 = replacePart.replace("\\$", "$");
          } else {
            var key = parts[2];
            replacePart = parts[0].substring(prefix.length);
            value2 = environment.hasOwnProperty(key) ? environment[key] : config.parsed[key] || "";
            value2 = interpolate(value2);
          }
          return newEnv.replace(replacePart, value2);
        }, envValue);
      };
      for (var configKey in config.parsed) {
        var value = environment.hasOwnProperty(configKey) ? environment[configKey] : config.parsed[configKey];
        config.parsed[configKey] = interpolate(value);
      }
      for (var processKey in config.parsed) {
        environment[processKey] = config.parsed[processKey];
      }
      return config;
    };
    module2.exports = dotenvExpand;
  }
});

// node_modules/ini/ini.js
var require_ini = __commonJS({
  "node_modules/ini/ini.js"(exports2) {
    exports2.parse = exports2.decode = decode;
    exports2.stringify = exports2.encode = encode;
    exports2.safe = safe;
    exports2.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children2 = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children2.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children2.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match[2]);
        if (key === "__proto__")
          return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _2, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "node_modules/strip-json-comments/index.js"(exports2, module2) {
    "use strict";
    var singleComment = 1;
    var multiComment = 2;
    function stripWithoutWhitespace() {
      return "";
    }
    function stripWithWhitespace(str, start, end) {
      return str.slice(start, end).replace(/\S/g, " ");
    }
    module2.exports = function(str, opts) {
      opts = opts || {};
      var currentChar;
      var nextChar;
      var insideString = false;
      var insideComment = false;
      var offset = 0;
      var ret = "";
      var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      for (var i = 0; i < str.length; i++) {
        currentChar = str[i];
        nextChar = str[i + 1];
        if (!insideComment && currentChar === '"') {
          var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentChar + nextChar === "//") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === "\n") {
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
        } else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
  }
});

// node_modules/rc/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/rc/lib/utils.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var ini = require_ini();
    var path = require("path");
    var stripJsonComments = require_strip_json_comments();
    var parse2 = exports2.parse = function(content) {
      if (/^\s*{/.test(content))
        return JSON.parse(stripJsonComments(content));
      return ini.parse(content);
    };
    var file = exports2.file = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      for (var i in args)
        if ("string" !== typeof args[i])
          return;
      var file2 = path.join.apply(null, args);
      var content;
      try {
        return fs.readFileSync(file2, "utf-8");
      } catch (err) {
        return;
      }
    };
    var json = exports2.json = function() {
      var content = file.apply(null, arguments);
      return content ? parse2(content) : null;
    };
    var env = exports2.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env2) {
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          var keypath = k.substring(l).split("__");
          var _emptyStringIndex;
          while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
            keypath.splice(_emptyStringIndex, 1);
          }
          var cursor = obj;
          keypath.forEach(function _buildSubObj(_subkey, i) {
            if (!_subkey || typeof cursor !== "object")
              return;
            if (i === keypath.length - 1)
              cursor[_subkey] = env2[k];
            if (cursor[_subkey] === void 0)
              cursor[_subkey] = {};
            cursor = cursor[_subkey];
          });
        }
      }
      return obj;
    };
    var find = exports2.find = function() {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path.join(start, rel2);
        try {
          fs.statSync(file2);
          return file2;
        } catch (err) {
          if (path.dirname(start) !== start)
            return find2(path.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    };
  }
});

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  "node_modules/deep-extend/lib/deep-extend.js"(exports2, module2) {
    "use strict";
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone[index] = cloneSpecificValue(item);
          } else {
            clone[index] = deepExtend({}, item);
          }
        } else {
          clone[index] = item;
        }
      });
      return clone;
    }
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    var deepExtend = module2.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] !== "object") {
        return false;
      }
      if (arguments.length < 2) {
        return arguments[0];
      }
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var val, src, clone;
      args.forEach(function(obj) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          return;
        }
        Object.keys(obj).forEach(function(key) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            return;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            return;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return;
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    };
  }
});

// node_modules/minimist/index.js
var require_minimist = __commonJS({
  "node_modules/minimist/index.js"(exports2, module2) {
    module2.exports = function(args, opts) {
      if (!opts) opts = {};
      var flags = { bools: {}, strings: {}, unknownFn: null };
      if (typeof opts["unknown"] === "function") {
        flags.unknownFn = opts["unknown"];
      }
      if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
        flags.allBools = true;
      } else {
        [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
          flags.bools[key2] = true;
        });
      }
      var aliases = {};
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        if (aliases[key2]) {
          flags.strings[aliases[key2]] = true;
        }
      });
      var defaults = opts["default"] || {};
      var argv = { _: [] };
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false) return;
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split("."), value2);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2)) return;
          if (o[key2] === void 0) o[key2] = {};
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype) o[key2] = {};
          if (o[key2] === Array.prototype) o[key2] = [];
          o = o[key2];
        }
        var key2 = keys[keys.length - 1];
        if (isConstructorOrProto(o, key2)) return;
        if (o === Object.prototype || o === Number.prototype || o === String.prototype) o = {};
        if (o === Array.prototype) o = [];
        if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
          o[key2] = value2;
        } else if (Array.isArray(o[key2])) {
          o[key2].push(value2);
        } else {
          o[key2] = [o[key2], value2];
        }
      }
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          var key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== "false";
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          var key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          var key = arg.match(/^--(.+)/)[1];
          var next = args[i + 1];
          if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, next, arg);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            var next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
              setArg(letters[j], next.split("=")[1], arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          var key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
              setArg(key, args[i + 1], arg);
              i++;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === "true", arg);
              i++;
            } else {
              setArg(key, flags.strings[key] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(
              flags.strings["_"] || !isNumber(arg) ? arg : Number(arg)
            );
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function(key2) {
        if (!hasKey(argv, key2.split("."))) {
          setKey(argv, key2.split("."), defaults[key2]);
          (aliases[key2] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults[key2]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = new Array();
        notFlags.forEach(function(key2) {
          argv["--"].push(key2);
        });
      } else {
        notFlags.forEach(function(key2) {
          argv._.push(key2);
        });
      }
      return argv;
    };
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === "number") return true;
      if (/^0x[0-9a-f]+$/i.test(x)) return true;
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return key === "constructor" && typeof obj[key] === "function" || key === "__proto__";
    }
  }
});

// node_modules/rc/index.js
var require_rc = __commonJS({
  "node_modules/rc/index.js"(exports2, module2) {
    var cc = require_utils2();
    var join = require("path").join;
    var deepExtend = require_deep_extend();
    var etc = "/etc";
    var win = process.platform === "win32";
    var home = win ? process.env.USERPROFILE : process.env.HOME;
    module2.exports = function(name, defaults, argv, parse2) {
      if ("string" !== typeof name)
        throw new Error("rc(name): name *must* be string");
      if (!argv)
        argv = require_minimist()(process.argv.slice(2));
      defaults = ("string" === typeof defaults ? cc.json(defaults) : defaults) || {};
      parse2 = parse2 || cc.parse;
      var env = cc.env(name + "_");
      var configs = [defaults];
      var configFiles = [];
      function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0) return;
        var fileConfig = cc.file(file);
        if (fileConfig) {
          configs.push(parse2(fileConfig));
          configFiles.push(file);
        }
      }
      if (!win)
        [
          join(etc, name, "config"),
          join(etc, name + "rc")
        ].forEach(addConfigFile);
      if (home)
        [
          join(home, ".config", name, "config"),
          join(home, ".config", name),
          join(home, "." + name, "config"),
          join(home, "." + name + "rc")
        ].forEach(addConfigFile);
      addConfigFile(cc.find("." + name + "rc"));
      if (env.config) addConfigFile(env.config);
      if (argv.config) addConfigFile(argv.config);
      return deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
      ]));
    };
  }
});

// node_modules/@lykmapipo/env/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@lykmapipo/env/lib/index.js"(exports2) {
    "use strict";
    var path = require("path");
    var semver = require_semver2();
    var dotenv = require_main();
    var expandEnv = require_main2();
    var rc = require_rc();
    var common = require_lib5();
    var lodash = require_lodash();
    var load = lodash.once(() => {
      const BASE_PATH = process.env.BASE_PATH || process.cwd();
      const path$1 = path.resolve(BASE_PATH, ".env");
      return expandEnv(dotenv.config({ path: path$1 }));
    });
    var mapToNumber = (value) => lodash.toNumber(value);
    var mapToString = (value) => lodash.toString(value);
    var set = (key, value) => {
      lodash.set(process.env, key, value);
      return value;
    };
    var get2 = (key, defaultValue) => {
      load();
      const value = lodash.get(process.env, key, defaultValue);
      return value;
    };
    var clear = (...keys) => {
      lodash.forEach([...keys], (key) => {
        delete process.env[key];
      });
    };
    var getArray = (key, defaultValue, optns) => {
      const options = common.mergeObjects({ merge: true, unique: true }, optns);
      let value = [].concat(defaultValue);
      if (!lodash.isEmpty(key)) {
        const found = lodash.compact([...get2(key, "").split(",")]);
        if (options.merge) {
          value = [...value, ...found];
        } else {
          value = lodash.isEmpty(found) ? value : found;
        }
      }
      value = lodash.map(value, lodash.trim);
      value = lodash.compact(value);
      value = options.unique ? lodash.uniq(value) : value;
      return value;
    };
    var getNumbers = (key, defaultValue, optns) => {
      let numbers = getArray(key, defaultValue, optns);
      numbers = lodash.map(numbers, mapToNumber);
      return numbers;
    };
    var getNumber = (key, defaultValue) => {
      let value = get2(key, defaultValue);
      value = value ? mapToNumber(value) : value;
      return value;
    };
    var getString = function getString2(key, defaultValue) {
      let value = get2(key, defaultValue);
      value = value ? mapToString(value) : value;
      return value;
    };
    var getStrings = (key, defaultValue, optns) => {
      let strings = getArray(key, defaultValue, optns);
      strings = lodash.map(strings, mapToString);
      return strings;
    };
    var getStringSet = (key, defaultValue, optns) => {
      let strings = getStrings(key, defaultValue, optns);
      strings = common.sortedUniq(strings);
      return strings;
    };
    var getBoolean = (key, defaultValue) => {
      let value = get2(key, defaultValue);
      if (value === "false") {
        value = false;
      }
      if (value === "true") {
        value = true;
      }
      value = value ? Boolean(value) : value;
      return value;
    };
    var getObject = (key, defaultValue = {}) => {
      let value = get2(key, defaultValue);
      value = value ? common.autoParse(common.parse(value)) : value;
      return value;
    };
    var is = (env) => lodash.toLower(get2("NODE_ENV")) === lodash.toLower(env);
    var isTest = () => is("test");
    var isDevelopment = () => is("development");
    var isProduction = () => is("production");
    var isLocal = () => isTest() || isDevelopment();
    var isHeroku = () => lodash.toLower(get2("RUNTIME_ENV")) === "heroku";
    var apiVersion = (optns) => {
      const options = lodash.merge(
        {},
        {
          version: "1.0.0",
          prefix: "v",
          major: true,
          minor: false,
          patch: false
        },
        optns
      );
      const { version: version2, prefix, minor, patch } = options;
      const parsedVersion = semver.coerce(getString("API_VERSION", version2));
      let parsedApiVersion = parsedVersion.major;
      if (minor) {
        parsedApiVersion = [parsedVersion.major, parsedVersion.minor].join(".");
      }
      if (patch) {
        parsedApiVersion = [
          parsedVersion.major,
          parsedVersion.minor,
          parsedVersion.patch
        ].join(".");
      }
      parsedApiVersion = `${prefix}${parsedApiVersion}`;
      return parsedApiVersion;
    };
    var getLocale = (defaultLocale = "sw") => {
      const locale = getString("DEFAULT_LOCALE", defaultLocale);
      return locale;
    };
    var getCountryCode = (defaultCountryCode = "TZ") => {
      let countryCode = defaultCountryCode;
      if (lodash.size(getLocale().split("_")) > 1) {
        countryCode = lodash.last(getLocale().split("_"));
      }
      if (lodash.size(getLocale().split("-")) > 1) {
        countryCode = lodash.last(getLocale().split("-"));
      }
      countryCode = getString("DEFAULT_COUNTRY_CODE", countryCode);
      return countryCode;
    };
    var rcFor = (moduleName) => {
      if (lodash.isEmpty(moduleName)) {
        return {};
      }
      const conf = rc(moduleName);
      return conf;
    };
    exports2.apiVersion = apiVersion;
    exports2.clear = clear;
    exports2.get = get2;
    exports2.getArray = getArray;
    exports2.getBoolean = getBoolean;
    exports2.getCountryCode = getCountryCode;
    exports2.getLocale = getLocale;
    exports2.getNumber = getNumber;
    exports2.getNumbers = getNumbers;
    exports2.getObject = getObject;
    exports2.getString = getString;
    exports2.getStringSet = getStringSet;
    exports2.getStrings = getStrings;
    exports2.is = is;
    exports2.isDevelopment = isDevelopment;
    exports2.isHeroku = isHeroku;
    exports2.isLocal = isLocal;
    exports2.isProduction = isProduction;
    exports2.isTest = isTest;
    exports2.load = load;
    exports2.mapToNumber = mapToNumber;
    exports2.mapToString = mapToString;
    exports2.rcFor = rcFor;
    exports2.set = set;
  }
});

// node_modules/@lykmapipo/http-client/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@lykmapipo/http-client/lib/index.js"(exports2) {
    "use strict";
    var lodash = require_lodash();
    var axios = require_axios2();
    var common = require_lib5();
    var http = require("http");
    var https = require("https");
    var FormData = require_form_data();
    var env = require_lib7();
    var CONTENT_TYPE = "application/json";
    var RESPONSE_TYPE = "json";
    var withDefaults = (optns) => {
      const options2 = common.safeMergeObjects(
        {
          baseURL: env.getString("BASE_URL") || env.getString("REACT_APP_BASE_URL"),
          headers: { Accept: CONTENT_TYPE, "Content-Type": CONTENT_TYPE }
        },
        optns
      );
      return options2;
    };
    var createAgents = (optns) => {
      let httpAgent;
      let httpsAgent;
      if (common.isNode) {
        let { agentOptions = {} } = withDefaults(optns);
        if (!lodash.isEmpty(agentOptions)) {
          agentOptions = common.mergeObjects({ keepAlive: true }, agentOptions);
          httpAgent = new http.Agent(agentOptions);
          httpsAgent = new https.Agent(agentOptions);
        }
      }
      return { httpAgent, httpsAgent };
    };
    var isFormData = (value) => {
      return typeof FormData !== "undefined" && value instanceof FormData;
    };
    var toFormData = (data = {}) => {
      const form = new FormData();
      lodash.forEach(data, (value, key) => {
        if (key && value) {
          form.append(key, value);
        }
      });
      return form;
    };
    var normalizeRequest = (request2) => {
      let {
        responseType = RESPONSE_TYPE,
        headers = {},
        data = {},
        multipart = false
      } = request2;
      const contentType = headers["content-type"] || headers["Content-Type"];
      multipart = multipart || lodash.startsWith(lodash.toLower(contentType), "multipart") || isFormData(data);
      if (multipart) {
        if (!isFormData(data)) {
          data = toFormData(data);
        }
      }
      if (isFormData(data)) {
        let extraHeaders = {};
        if (lodash.isFunction(data.getHeaders)) {
          delete headers["content-type"];
          delete headers["Content-Type"];
          extraHeaders = data.getHeaders();
        }
        headers = common.mergeObjects(headers, extraHeaders);
      }
      responseType = lodash.isEmpty(responseType) ? RESPONSE_TYPE : responseType;
      request2.headers = headers;
      request2.data = common.isValue(data) ? data : void 0;
      request2.responseType = responseType;
      return request2;
    };
    var mapResponseToData = (rawResponse) => rawResponse.data;
    var mapResponseToError = (rawResponse) => {
      let { code, status, message, description, stack, errors, data } = rawResponse;
      const { request: request2, response } = rawResponse;
      if (response) {
        code = response.code || code;
        status = response.status || status;
        data = response.data || data || {};
        message = data.message || response.statusText || message;
        description = description || message;
        errors = response.errors || errors || {};
        stack = response.stack || data.stack || stack;
      } else if (request2) {
        code = code || 503;
        status = status || 503;
        description = description || "Service Unavailable";
        message = message || description;
      } else {
        code = code || 400;
        status = status || 400;
        description = description || "Bad Request";
        message = message || description;
      }
      const error = new Error(message);
      error.stack = stack;
      common.assign(error, { code, status, message, description, errors, ...data });
      return error;
    };
    var wrapRequest = (request2, skipData = false) => {
      return request2.then((response) => skipData ? response : mapResponseToData(response)).catch((response) => Promise.reject(mapResponseToError(response)));
    };
    var httpClient;
    var createHttpClient = (optns) => {
      if (!httpClient) {
        const clientOptions = lodash.omit(withDefaults(optns), "baseURL");
        httpClient = axios.create(clientOptions);
        httpClient.id = Date.now();
      }
      return httpClient;
    };
    var disposeHttpClient = () => {
      httpClient = null;
      return httpClient;
    };
    var request = (optns) => {
      const options2 = withDefaults(optns);
      const client = createHttpClient(options2);
      const agents = createAgents(options2);
      const requestOptions = common.safeMergeObjects(options2, agents);
      const normalizedRequest = normalizeRequest(requestOptions);
      return client.request(normalizedRequest);
    };
    var spread = axios.spread;
    var all2 = (...requests) => axios.all([...requests]);
    var del = (url, optns = {}) => {
      const requestOptions = { method: "DELETE", url, ...optns };
      return wrapRequest(request(requestOptions));
    };
    var get2 = (url, optns = {}) => {
      const requestOptions = { method: "GET", url, ...optns };
      return wrapRequest(request(requestOptions));
    };
    var head = (url, optns = {}) => {
      const requestOptions = { method: "HEAD", url, ...optns };
      return wrapRequest(request(requestOptions), true);
    };
    var options = (url, optns = {}) => {
      const requestOptions = { method: "OPTIONS", url, ...optns };
      return wrapRequest(request(requestOptions), true);
    };
    var patch = (url, data, optns = {}) => {
      if (lodash.isEmpty(data)) {
        return Promise.reject(new Error("Missing Payload"));
      }
      const requestOptions = { method: "PATCH", url, data, ...optns };
      return wrapRequest(request(requestOptions));
    };
    var post = (url, data, optns = {}) => {
      if (lodash.isEmpty(data)) {
        return Promise.reject(new Error("Missing Payload"));
      }
      const requestOptions = { method: "POST", url, data, ...optns };
      return wrapRequest(request(requestOptions));
    };
    var put = (url, data, optns = {}) => {
      if (lodash.isEmpty(data)) {
        return Promise.reject(new Error("Missing Payload"));
      }
      const requestOptions = { method: "PUT", url, data, ...optns };
      return wrapRequest(request(requestOptions));
    };
    var sendFile = (url, data, optns) => {
      if (!data || lodash.isEmpty(data)) {
        return Promise.reject(new Error("Missing Payload"));
      }
      const opts = common.mergeObjects(optns, { multipart: true });
      const requestOptions = { method: "POST", url, data, ...opts };
      return wrapRequest(request(requestOptions));
    };
    var fetchFile = (url, optns = {}) => {
      const opts = common.mergeObjects(optns, { responseType: "stream" });
      const requestOptions = { method: "GET", url, ...opts };
      return wrapRequest(request(requestOptions));
    };
    exports2.all = all2;
    exports2.createHttpClient = createHttpClient;
    exports2.del = del;
    exports2.disposeHttpClient = disposeHttpClient;
    exports2.fetchFile = fetchFile;
    exports2.get = get2;
    exports2.head = head;
    exports2.isFormData = isFormData;
    exports2.options = options;
    exports2.patch = patch;
    exports2.post = post;
    exports2.put = put;
    exports2.request = request;
    exports2.sendFile = sendFile;
    exports2.spread = spread;
    exports2.toFormData = toFormData;
  }
});

// node_modules/async/dist/async.js
var require_async2 = __commonJS({
  "node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
    })(exports2, function(exports3) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer;
      if (hasQueueMicrotask) {
        _defer = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else if (hasNextTick) {
        _defer = process.nextTick;
      } else {
        _defer = fallback;
      }
      var setImmediate$1 = wrap(_defer);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result2;
          try {
            result2 = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result2 && typeof result2.then === "function") {
            return handlePromise(result2, callback);
          } else {
            callback(null, result2);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && err.message ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function") throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity = asyncFn.length) {
        if (!arity) throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err) return reject2(err);
              resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null) return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
          var item = iterator.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null) throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done) return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result2) {
          running -= 1;
          if (canceled) return;
          if (err) return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result2 === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled) return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj) {
            return callback(null);
          }
          if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true) return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map2(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map2, 3);
      var applyEach$1 = applyEach(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve, reject2;
        function callback(err, ...args) {
          if (err) return reject2(err);
          resolve(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve = res, reject2 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (canceled) return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task) {
          if (hasError) return;
          var taskCallback = onlyOnce((err, ...result2) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result2.length < 2) {
              [result2] = result2;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result2;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              if (canceled) return;
              callback(err, safeResults);
            } else {
              results[key] = result2;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result2 = [];
          Object.keys(tasks).forEach((key) => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
              result2.push(key);
            }
          });
          return result2;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      function stripComments(string) {
        let stripped = "";
        let index2 = 0;
        let endBlockComment = string.indexOf("*/");
        while (index2 < string.length) {
          if (string[index2] === "/" && string[index2 + 1] === "/") {
            let endIndex = string.indexOf("\n", index2);
            index2 = endIndex === -1 ? string.length : endIndex;
          } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
            let endIndex = string.indexOf("*/", index2);
            if (endIndex !== -1) {
              index2 = endIndex + 2;
              endBlockComment = string.indexOf("*/", index2);
            } else {
              stripped += string[index2];
              index2++;
            }
          } else {
            stripped += string[index2];
            index2++;
          }
        }
        return stripped;
      }
      function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
          match = src.match(ARROW_FN_ARGS);
        }
        if (!match) throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync) params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev) node.prev.next = node.next;
          else this.head = node.next;
          if (node.next) node.next.prev = node.prev;
          else this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head) this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next) node.next.prev = newNode;
          else this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev) node.prev.next = newNode;
          else this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head) this.insertBefore(this.head, node);
          else setInitial(this, node);
        }
        push(node) {
          if (this.tail) this.insertAfter(this.tail, node);
          else setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler) return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err) return rejectOnError ? rej(err) : res();
            if (args.length <= 1) return res(args[0]);
            res(args);
          }
          var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback2 : callback || promiseCallback2
          );
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve, reject2) => {
              res = resolve;
              rej = reject2;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task = tasks[i];
              var index2 = workersList.indexOf(task);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler) => {
          if (!handler) {
            return new Promise((resolve, reject2) => {
              once2(name, (err, data) => {
                if (err) return reject2(err);
                resolve(data);
              });
            });
          }
          off(name);
          on(name, handler);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          _createTaskItem(data, callback) {
            return {
              data,
              callback
            };
          },
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload) l = Math.min(l, q.payload);
              for (var i = 0; i < l; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo(worker, payload) {
        return queue(worker, 1, payload);
      }
      function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(
            _functions,
            args,
            (newargs, fn, iterCb) => {
              fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
              }));
            },
            (err, results) => cb(err, ...results)
          );
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err) return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result2 = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result2 = result2.concat(...mapResults[i]);
            }
          }
          return callback(err, result2);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result2) => {
              if (err || err === false) return callback(err);
              if (check(result2) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err) return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x) => console[name](x));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err) return callback(err);
          if (err === false) return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err === false) return;
          if (!truth) return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit, 3);
      function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$2 = awaitify(eachLimit$1, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn)) return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err) return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err) return done(err);
          if (err === false) return;
          task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err) return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result2 = {};
          var { hasOwnProperty } = Object.prototype;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var { key } = mapResults[i];
              var { val } = mapResults[i];
              if (hasOwnProperty.call(result2, key)) {
                result2[key].push(val);
              } else {
                result2[key] = [val];
              }
            }
          }
          return callback(err, result2);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result2) => {
            if (err) return next(err);
            newObj[key] = result2;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer$1;
      if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else {
        _defer$1 = fallback;
      }
      var nextTick = wrap(_defer$1);
      var parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result2) => {
            if (result2.length < 2) {
              [result2] = result2;
            }
            results[key] = result2;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel$1(tasks, callback) {
        return parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return parallel(eachOfLimit(limit), tasks, callback);
      }
      function queue$1(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t;
            index2 = p;
          }
        }
        percDown(index2) {
          let l;
          while ((l = leftChi(index2)) < this.heap.length) {
            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
              l = l + 1;
            }
            if (smaller(this.heap[index2], this.heap[l])) {
              break;
            }
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l];
            this.heap[l] = t;
            index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
              this.heap[j] = this.heap[i];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--) {
            this.percDown(i);
          }
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        if (x.priority !== y.priority) {
          return x.priority < y.priority;
        } else {
          return x.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        var {
          push,
          pushAsync
        } = q;
        q._tasks = new Heap();
        q._createTaskItem = ({ data, priority }, callback) => {
          return {
            data,
            priority,
            callback
          };
        };
        function createDataItems(tasks, priority) {
          if (!Array.isArray(tasks)) {
            return { data: tasks, priority };
          }
          return tasks.map((data) => {
            return { data, priority };
          });
        }
        q.push = function(data, priority = 0, callback) {
          return push(createDataItems(data, priority), callback);
        };
        q.pushAsync = function(data, priority = 0, callback) {
          return pushAsync(createDataItems(data, priority), callback);
        };
        delete q.unshift;
        delete q.unshiftAsync;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
              retVal.error = error;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject$1(coll, iteratee, callback) {
        return reject(eachOf$1, coll, iteratee, callback);
      }
      var reject$2 = awaitify(reject$1, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject(eachOfLimit(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || promiseCallback();
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false) return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
          arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts) retry(opts, taskFn, callback);
          else retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err) return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err) return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result2 = Array(size);
        while (size--) {
          result2[size] = size;
        }
        return result2;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result2;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === false) return taskCb(err);
            if (args.length < 2) {
              [result2] = args;
            } else {
              result2 = args;
            }
            error = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error, result2));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err) return callback(err);
          results = rest;
          if (err === false) return;
          _test(check);
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err === false) return;
          if (!truth) return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length) return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false) return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel: parallel$1,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports3.default = index;
      exports3.apply = apply;
      exports3.applyEach = applyEach$1;
      exports3.applyEachSeries = applyEachSeries;
      exports3.asyncify = asyncify;
      exports3.auto = auto;
      exports3.autoInject = autoInject;
      exports3.cargo = cargo;
      exports3.cargoQueue = cargo$1;
      exports3.compose = compose;
      exports3.concat = concat$1;
      exports3.concatLimit = concatLimit$1;
      exports3.concatSeries = concatSeries$1;
      exports3.constant = constant;
      exports3.detect = detect$1;
      exports3.detectLimit = detectLimit$1;
      exports3.detectSeries = detectSeries$1;
      exports3.dir = dir;
      exports3.doUntil = doUntil;
      exports3.doWhilst = doWhilst$1;
      exports3.each = each;
      exports3.eachLimit = eachLimit$2;
      exports3.eachOf = eachOf$1;
      exports3.eachOfLimit = eachOfLimit$2;
      exports3.eachOfSeries = eachOfSeries$1;
      exports3.eachSeries = eachSeries$1;
      exports3.ensureAsync = ensureAsync;
      exports3.every = every$1;
      exports3.everyLimit = everyLimit$1;
      exports3.everySeries = everySeries$1;
      exports3.filter = filter$1;
      exports3.filterLimit = filterLimit$1;
      exports3.filterSeries = filterSeries$1;
      exports3.forever = forever$1;
      exports3.groupBy = groupBy;
      exports3.groupByLimit = groupByLimit$1;
      exports3.groupBySeries = groupBySeries;
      exports3.log = log;
      exports3.map = map$1;
      exports3.mapLimit = mapLimit$1;
      exports3.mapSeries = mapSeries$1;
      exports3.mapValues = mapValues;
      exports3.mapValuesLimit = mapValuesLimit$1;
      exports3.mapValuesSeries = mapValuesSeries;
      exports3.memoize = memoize;
      exports3.nextTick = nextTick;
      exports3.parallel = parallel$1;
      exports3.parallelLimit = parallelLimit;
      exports3.priorityQueue = priorityQueue;
      exports3.queue = queue$1;
      exports3.race = race$1;
      exports3.reduce = reduce$1;
      exports3.reduceRight = reduceRight;
      exports3.reflect = reflect;
      exports3.reflectAll = reflectAll;
      exports3.reject = reject$2;
      exports3.rejectLimit = rejectLimit$1;
      exports3.rejectSeries = rejectSeries$1;
      exports3.retry = retry;
      exports3.retryable = retryable;
      exports3.seq = seq;
      exports3.series = series;
      exports3.setImmediate = setImmediate$1;
      exports3.some = some$1;
      exports3.someLimit = someLimit$1;
      exports3.someSeries = someSeries$1;
      exports3.sortBy = sortBy$1;
      exports3.timeout = timeout;
      exports3.times = times;
      exports3.timesLimit = timesLimit;
      exports3.timesSeries = timesSeries;
      exports3.transform = transform;
      exports3.tryEach = tryEach$1;
      exports3.unmemoize = unmemoize;
      exports3.until = until;
      exports3.waterfall = waterfall$1;
      exports3.whilst = whilst$1;
      exports3.all = every$1;
      exports3.allLimit = everyLimit$1;
      exports3.allSeries = everySeries$1;
      exports3.any = some$1;
      exports3.anyLimit = someLimit$1;
      exports3.anySeries = someSeries$1;
      exports3.find = detect$1;
      exports3.findLimit = detectLimit$1;
      exports3.findSeries = detectSeries$1;
      exports3.flatMap = concat$1;
      exports3.flatMapLimit = concatLimit$1;
      exports3.flatMapSeries = concatSeries$1;
      exports3.forEach = each;
      exports3.forEachSeries = eachSeries$1;
      exports3.forEachLimit = eachLimit$2;
      exports3.forEachOf = eachOf$1;
      exports3.forEachOfSeries = eachOfSeries$1;
      exports3.forEachOfLimit = eachOfLimit$2;
      exports3.inject = reduce$1;
      exports3.foldl = reduce$1;
      exports3.foldr = reduceRight;
      exports3.select = filter$1;
      exports3.selectLimit = filterLimit$1;
      exports3.selectSeries = filterSeries$1;
      exports3.wrapSync = asyncify;
      exports3.during = whilst$1;
      exports3.doDuring = doWhilst$1;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/geojson-validation/index.js
var require_geojson_validation = __commonJS({
  "node_modules/geojson-validation/index.js"(exports2) {
    var definitions = {};
    function isFunction(object) {
      return typeof object === "function";
    }
    function isObject(object) {
      return object === Object(object);
    }
    function _done(trace, message) {
      let valid = false;
      if (typeof message === "string") {
        message = [message];
      } else if (Object.prototype.toString.call(message) === "[object Array]") {
        if (message.length === 0) {
          valid = true;
        }
      } else {
        valid = true;
      }
      if (trace) {
        return message;
      } else {
        return valid;
      }
    }
    function _customDefinitions(type, object) {
      let errors;
      if (isFunction(definitions[type])) {
        try {
          errors = definitions[type](object);
        } catch (e) {
          errors = ["Problem with custom definition for " + type + ": " + e];
        }
        if (typeof result === "string") {
          errors = [errors];
        }
        if (Object.prototype.toString.call(errors) === "[object Array]") {
          return errors;
        }
      }
      return [];
    }
    exports2.define = (type, definition) => {
      if (type in allTypes && isFunction(definition)) {
        definitions[type] = definition;
        return true;
      } else {
        return false;
      }
    };
    exports2.isPosition = (position, trace = false) => {
      let errors = [];
      if (Array.isArray(position)) {
        if (position.length <= 1) {
          errors.push("Position must be at least two elements");
        }
        position.forEach((pos, index) => {
          if (typeof pos !== "number") {
            errors.push("Position must only contain numbers. Item " + pos + " at index " + index + " is invalid.");
          }
        });
      } else {
        errors.push("Position must be an array");
      }
      errors = errors.concat(_customDefinitions("Position", position));
      return _done(trace, errors);
    };
    exports2.isGeoJSONObject = exports2.valid = (geoJSONObject, trace = false) => {
      if (!isObject(geoJSONObject)) {
        return _done(trace, ["must be a JSON Object"]);
      } else {
        let errors = [];
        if ("type" in geoJSONObject) {
          if (nonGeoTypes[geoJSONObject.type]) {
            return nonGeoTypes[geoJSONObject.type](geoJSONObject, trace);
          } else if (geoTypes[geoJSONObject.type]) {
            return geoTypes[geoJSONObject.type](geoJSONObject, trace);
          } else {
            errors.push('type must be one of: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection", "Feature", or "FeatureCollection"');
          }
        } else {
          errors.push('must have a member with the name "type"');
        }
        errors = errors.concat(_customDefinitions("GeoJSONObject", geoJSONObject));
        return _done(trace, errors);
      }
    };
    exports2.isGeometryObject = (geometryObject, trace = false) => {
      if (!isObject(geometryObject)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("type" in geometryObject) {
        if (geoTypes[geometryObject.type]) {
          return geoTypes[geometryObject.type](geometryObject, trace);
        } else {
          errors.push('type must be one of: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon" or "GeometryCollection"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      errors = errors.concat(_customDefinitions("GeometryObject", geometryObject));
      return _done(trace, errors);
    };
    exports2.isPoint = (point, trace = false) => {
      if (!isObject(point)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in point) {
        const t = exports2.isBbox(point.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in point) {
        if (point.type !== "Point") {
          errors.push('type must be "Point"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("coordinates" in point) {
        const t = exports2.isPosition(point.coordinates, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      } else {
        errors.push('must have a member with the name "coordinates"');
      }
      errors = errors.concat(_customDefinitions("Point", point));
      return _done(trace, errors);
    };
    exports2.isMultiPointCoor = (coordinates, trace = false) => {
      let errors = [];
      if (Array.isArray(coordinates)) {
        coordinates.forEach((val, index) => {
          const t = exports2.isPosition(val, true);
          if (t.length) {
            t[0] = "at " + index + ": ".concat(t[0]);
            errors = errors.concat(t);
          }
        });
      } else {
        errors.push("coordinates must be an array");
      }
      return _done(trace, errors);
    };
    exports2.isMultiPoint = (multiPoint, trace = false) => {
      if (!isObject(multiPoint)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in multiPoint) {
        const t = exports2.isBbox(multiPoint.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in multiPoint) {
        if (multiPoint.type !== "MultiPoint") {
          errors.push('type must be "MultiPoint"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("coordinates" in multiPoint) {
        const t = exports2.isMultiPointCoor(multiPoint.coordinates, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      } else {
        errors.push('must have a member with the name "coordinates"');
      }
      errors = errors.concat(_customDefinitions("MultiPoint", multiPoint));
      return _done(trace, errors);
    };
    exports2.isLineStringCoor = (coordinates, trace = false) => {
      let errors = [];
      if (Array.isArray(coordinates)) {
        if (coordinates.length > 1) {
          coordinates.forEach((val, index) => {
            const t = exports2.isPosition(val, true);
            if (t.length) {
              t[0] = "at " + index + ": ".concat(t[0]);
              errors = errors.concat(t);
            }
          });
        } else {
          errors.push("coordinates must have at least two elements");
        }
      } else {
        errors.push("coordinates must be an array");
      }
      return _done(trace, errors);
    };
    exports2.isLineString = (lineString, trace = false) => {
      if (!isObject(lineString)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in lineString) {
        const t = exports2.isBbox(lineString.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in lineString) {
        if (lineString.type !== "LineString") {
          errors.push('type must be "LineString"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("coordinates" in lineString) {
        const t = exports2.isLineStringCoor(lineString.coordinates, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      } else {
        errors.push('must have a member with the name "coordinates"');
      }
      errors = errors.concat(_customDefinitions("LineString", lineString));
      return _done(trace, errors);
    };
    exports2.isMultiLineStringCoor = (coordinates, trace = false) => {
      let errors = [];
      if (Array.isArray(coordinates)) {
        coordinates.forEach((val, index) => {
          const t = exports2.isLineStringCoor(val, true);
          if (t.length) {
            t[0] = "at " + index + ": ".concat(t[0]);
            errors = errors.concat(t);
          }
        });
      } else {
        errors.push("coordinates must be an array");
      }
      return _done(trace, errors);
    };
    exports2.isMultiLineString = (multilineString, trace = false) => {
      if (!isObject(multilineString)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in multilineString) {
        const t = exports2.isBbox(multilineString.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in multilineString) {
        if (multilineString.type !== "MultiLineString") {
          errors.push('type must be "MultiLineString"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("coordinates" in multilineString) {
        const t = exports2.isMultiLineStringCoor(multilineString.coordinates, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      } else {
        errors.push('must have a member with the name "coordinates"');
      }
      errors = errors.concat(_customDefinitions("MultiPoint", multilineString));
      return _done(trace, errors);
    };
    function _linearRingCoor(coordinates, trace) {
      let errors = [];
      if (Array.isArray(coordinates)) {
        coordinates.forEach((val, index) => {
          const t = exports2.isPosition(val, true);
          if (t.length) {
            t[0] = "at " + index + ": ".concat(t[0]);
            errors = errors.concat(t);
          }
        });
        if (coordinates[0].toString() !== coordinates[coordinates.length - 1].toString()) {
          errors.push("The first and last positions must be equivalent");
        }
        if (coordinates.length < 4) {
          errors.push("coordinates must have at least four positions");
        }
      } else {
        errors.push("coordinates must be an array");
      }
      return _done(trace, errors);
    }
    exports2.isPolygonCoor = (coordinates, trace = false) => {
      let errors = [];
      if (Array.isArray(coordinates)) {
        coordinates.forEach((val, index) => {
          const t = _linearRingCoor(val, true);
          if (t.length) {
            t[0] = "at " + index + ": ".concat(t[0]);
            errors = errors.concat(t);
          }
        });
      } else {
        errors.push("coordinates must be an array");
      }
      return _done(trace, errors);
    };
    exports2.isPolygon = (polygon, trace = false) => {
      if (!isObject(polygon)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in polygon) {
        const t = exports2.isBbox(polygon.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in polygon) {
        if (polygon.type !== "Polygon") {
          errors.push('type must be "Polygon"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("coordinates" in polygon) {
        const t = exports2.isPolygonCoor(polygon.coordinates, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      } else {
        errors.push('must have a member with the name "coordinates"');
      }
      errors = errors.concat(_customDefinitions("Polygon", polygon));
      return _done(trace, errors);
    };
    exports2.isMultiPolygonCoor = (coordinates, trace = false) => {
      let errors = [];
      if (Array.isArray(coordinates)) {
        coordinates.forEach((val, index) => {
          const t = exports2.isPolygonCoor(val, true);
          if (t.length) {
            t[0] = "at " + index + ": ".concat(t[0]);
            errors = errors.concat(t);
          }
        });
      } else {
        errors.push("coordinates must be an array");
      }
      return _done(trace, errors);
    };
    exports2.isMultiPolygon = (multiPolygon, trace = false) => {
      if (!isObject(multiPolygon)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in multiPolygon) {
        const t = exports2.isBbox(multiPolygon.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in multiPolygon) {
        if (multiPolygon.type !== "MultiPolygon") {
          errors.push('type must be "MultiPolygon"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("coordinates" in multiPolygon) {
        const t = exports2.isMultiPolygonCoor(multiPolygon.coordinates, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      } else {
        errors.push('must have a member with the name "coordinates"');
      }
      errors = errors.concat(_customDefinitions("MultiPolygon", multiPolygon));
      return _done(trace, errors);
    };
    exports2.isGeometryCollection = (geometryCollection, trace = false) => {
      if (!isObject(geometryCollection)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in geometryCollection) {
        const t = exports2.isBbox(geometryCollection.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in geometryCollection) {
        if (geometryCollection.type !== "GeometryCollection") {
          errors.push('type must be "GeometryCollection"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("geometries" in geometryCollection) {
        if (Array.isArray(geometryCollection.geometries)) {
          geometryCollection.geometries.forEach((val, index) => {
            const t = exports2.isGeometryObject(val, true);
            if (t.length) {
              t[0] = "at " + index + ": ".concat(t[0]);
              errors = errors.concat(t);
            }
          });
        } else {
          errors.push('"geometries" must be an array');
        }
      } else {
        errors.push('must have a member with the name "geometries"');
      }
      errors = errors.concat(_customDefinitions("GeometryCollection", geometryCollection));
      return _done(trace, errors);
    };
    exports2.isFeature = (feature, trace = false) => {
      if (!isObject(feature)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in feature) {
        const t = exports2.isBbox(feature.bbox, true);
        if (t.length) {
          errors = errors.concat(t);
        }
      }
      if ("type" in feature) {
        if (feature.type !== "Feature") {
          errors.push('type must be "Feature"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if (!("properties" in feature)) {
        errors.push('must have a member with the name "properties"');
      }
      if ("geometry" in feature) {
        if (feature.geometry !== null) {
          const t = exports2.isGeometryObject(feature.geometry, true);
          if (t.length) {
            errors = errors.concat(t);
          }
        }
      } else {
        errors.push('must have a member with the name "geometry"');
      }
      errors = errors.concat(_customDefinitions("Feature", feature));
      return _done(trace, errors);
    };
    exports2.isFeatureCollection = (featureCollection, trace = false) => {
      if (!isObject(featureCollection)) {
        return _done(trace, ["must be a JSON Object"]);
      }
      let errors = [];
      if ("bbox" in featureCollection) {
        const t = exports2.isBbox(featureCollection.bbox, true);
        if (t.length) {
          errors = t;
        }
      }
      if ("type" in featureCollection) {
        if (featureCollection.type !== "FeatureCollection") {
          errors.push('type must be "FeatureCollection"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      if ("features" in featureCollection) {
        if (Array.isArray(featureCollection.features)) {
          featureCollection.features.forEach((val, index) => {
            const t = exports2.isFeature(val, true);
            if (t.length) {
              t[0] = "at " + index + ": ".concat(t[0]);
              errors = errors.concat(t);
            }
          });
        } else {
          errors.push('"Features" must be an array');
        }
      } else {
        errors.push('must have a member with the name "Features"');
      }
      errors = errors.concat(_customDefinitions("FeatureCollection", featureCollection));
      return _done(trace, errors);
    };
    exports2.isBbox = (bbox, trace = false) => {
      let errors = [];
      if (Array.isArray(bbox)) {
        if (bbox.length % 2 !== 0) {
          errors.push("bbox, must be a 2*n array");
        }
      } else {
        errors.push("bbox must be an array");
      }
      errors = errors.concat(_customDefinitions("Bbox", bbox));
      return _done(trace, errors);
    };
    var nonGeoTypes = {
      "Feature": exports2.isFeature,
      "FeatureCollection": exports2.isFeatureCollection
    };
    var geoTypes = {
      "Point": exports2.isPoint,
      "MultiPoint": exports2.isMultiPoint,
      "LineString": exports2.isLineString,
      "MultiLineString": exports2.isMultiLineString,
      "Polygon": exports2.isPolygon,
      "MultiPolygon": exports2.isMultiPolygon,
      "GeometryCollection": exports2.isGeometryCollection
    };
    var allTypes = {
      "Feature": exports2.isFeature,
      "FeatureCollection": exports2.isFeatureCollection,
      "Point": exports2.isPoint,
      "MultiPoint": exports2.isMultiPoint,
      "LineString": exports2.isLineString,
      "MultiLineString": exports2.isMultiLineString,
      "Polygon": exports2.isPolygon,
      "MultiPolygon": exports2.isMultiPolygon,
      "GeometryCollection": exports2.isGeometryCollection,
      "Bbox": exports2.isBbox,
      "Position": exports2.isPosition,
      "GeoJSON": exports2.isGeoJSONObject,
      "GeometryObject": exports2.isGeometryObject
    };
    exports2.allTypes = allTypes;
  }
});

// node_modules/@turf/helpers/dist/js/index.js
var require_js = __commonJS({
  "node_modules/@turf/helpers/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.earthRadius = 63710088e-1;
    exports2.factors = {
      centimeters: exports2.earthRadius * 100,
      centimetres: exports2.earthRadius * 100,
      degrees: exports2.earthRadius / 111325,
      feet: exports2.earthRadius * 3.28084,
      inches: exports2.earthRadius * 39.37,
      kilometers: exports2.earthRadius / 1e3,
      kilometres: exports2.earthRadius / 1e3,
      meters: exports2.earthRadius,
      metres: exports2.earthRadius,
      miles: exports2.earthRadius / 1609.344,
      millimeters: exports2.earthRadius * 1e3,
      millimetres: exports2.earthRadius * 1e3,
      nauticalmiles: exports2.earthRadius / 1852,
      radians: 1,
      yards: exports2.earthRadius * 1.0936
    };
    exports2.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.37,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1e3,
      millimetres: 1e3,
      nauticalmiles: 1 / 1852,
      radians: 1 / exports2.earthRadius,
      yards: 1.0936133
    };
    exports2.areaFactors = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046
    };
    function feature(geom, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var feat = { type: "Feature" };
      if (options.id === 0 || options.id) {
        feat.id = options.id;
      }
      if (options.bbox) {
        feat.bbox = options.bbox;
      }
      feat.properties = properties || {};
      feat.geometry = geom;
      return feat;
    }
    exports2.feature = feature;
    function geometry(type, coordinates, _options) {
      if (_options === void 0) {
        _options = {};
      }
      switch (type) {
        case "Point":
          return point(coordinates).geometry;
        case "LineString":
          return lineString(coordinates).geometry;
        case "Polygon":
          return polygon(coordinates).geometry;
        case "MultiPoint":
          return multiPoint(coordinates).geometry;
        case "MultiLineString":
          return multiLineString(coordinates).geometry;
        case "MultiPolygon":
          return multiPolygon(coordinates).geometry;
        default:
          throw new Error(type + " is invalid");
      }
    }
    exports2.geometry = geometry;
    function point(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (!coordinates) {
        throw new Error("coordinates is required");
      }
      if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
      }
      if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
      }
      var geom = {
        type: "Point",
        coordinates
      };
      return feature(geom, properties, options);
    }
    exports2.point = point;
    function points(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return point(coords, properties);
      }), options);
    }
    exports2.points = points;
    function polygon(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
          if (ring[ring.length - 1][j] !== ring[0][j]) {
            throw new Error("First and last Position are not equivalent.");
          }
        }
      }
      var geom = {
        type: "Polygon",
        coordinates
      };
      return feature(geom, properties, options);
    }
    exports2.polygon = polygon;
    function polygons(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return polygon(coords, properties);
      }), options);
    }
    exports2.polygons = polygons;
    function lineString(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
      }
      var geom = {
        type: "LineString",
        coordinates
      };
      return feature(geom, properties, options);
    }
    exports2.lineString = lineString;
    function lineStrings(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return lineString(coords, properties);
      }), options);
    }
    exports2.lineStrings = lineStrings;
    function featureCollection(features, options) {
      if (options === void 0) {
        options = {};
      }
      var fc = { type: "FeatureCollection" };
      if (options.id) {
        fc.id = options.id;
      }
      if (options.bbox) {
        fc.bbox = options.bbox;
      }
      fc.features = features;
      return fc;
    }
    exports2.featureCollection = featureCollection;
    function multiLineString(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiLineString",
        coordinates
      };
      return feature(geom, properties, options);
    }
    exports2.multiLineString = multiLineString;
    function multiPoint(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPoint",
        coordinates
      };
      return feature(geom, properties, options);
    }
    exports2.multiPoint = multiPoint;
    function multiPolygon(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPolygon",
        coordinates
      };
      return feature(geom, properties, options);
    }
    exports2.multiPolygon = multiPolygon;
    function geometryCollection(geometries, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "GeometryCollection",
        geometries
      };
      return feature(geom, properties, options);
    }
    exports2.geometryCollection = geometryCollection;
    function round(num, precision) {
      if (precision === void 0) {
        precision = 0;
      }
      if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
      }
      var multiplier = Math.pow(10, precision || 0);
      return Math.round(num * multiplier) / multiplier;
    }
    exports2.round = round;
    function radiansToLength(radians, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports2.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return radians * factor;
    }
    exports2.radiansToLength = radiansToLength;
    function lengthToRadians(distance, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports2.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return distance / factor;
    }
    exports2.lengthToRadians = lengthToRadians;
    function lengthToDegrees(distance, units) {
      return radiansToDegrees(lengthToRadians(distance, units));
    }
    exports2.lengthToDegrees = lengthToDegrees;
    function bearingToAzimuth(bearing) {
      var angle = bearing % 360;
      if (angle < 0) {
        angle += 360;
      }
      return angle;
    }
    exports2.bearingToAzimuth = bearingToAzimuth;
    function radiansToDegrees(radians) {
      var degrees = radians % (2 * Math.PI);
      return degrees * 180 / Math.PI;
    }
    exports2.radiansToDegrees = radiansToDegrees;
    function degreesToRadians(degrees) {
      var radians = degrees % 360;
      return radians * Math.PI / 180;
    }
    exports2.degreesToRadians = degreesToRadians;
    function convertLength(length, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "kilometers";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(length >= 0)) {
        throw new Error("length must be a positive number");
      }
      return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
    }
    exports2.convertLength = convertLength;
    function convertArea(area, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "meters";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(area >= 0)) {
        throw new Error("area must be a positive number");
      }
      var startFactor = exports2.areaFactors[originalUnit];
      if (!startFactor) {
        throw new Error("invalid original units");
      }
      var finalFactor = exports2.areaFactors[finalUnit];
      if (!finalFactor) {
        throw new Error("invalid final units");
      }
      return area / startFactor * finalFactor;
    }
    exports2.convertArea = convertArea;
    function isNumber(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num);
    }
    exports2.isNumber = isNumber;
    function isObject(input) {
      return !!input && input.constructor === Object;
    }
    exports2.isObject = isObject;
    function validateBBox(bbox) {
      if (!bbox) {
        throw new Error("bbox is required");
      }
      if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
      }
      if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      }
      bbox.forEach(function(num) {
        if (!isNumber(num)) {
          throw new Error("bbox must only contain numbers");
        }
      });
    }
    exports2.validateBBox = validateBBox;
    function validateId(id) {
      if (!id) {
        throw new Error("id is required");
      }
      if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
      }
    }
    exports2.validateId = validateId;
  }
});

// node_modules/@turf/meta/dist/js/index.js
var require_js2 = __commonJS({
  "node_modules/@turf/meta/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers = require_js();
    function coordEach(geojson, callback, excludeWrapCoord) {
      if (geojson === null) return;
      var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
      for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
          var multiFeatureIndex = 0;
          var geometryIndex = 0;
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
          if (geometry === null) continue;
          coords = geometry.coordinates;
          var geomType = geometry.type;
          wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
          switch (geomType) {
            case null:
              break;
            case "Point":
              if (callback(
                coords,
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              multiFeatureIndex++;
              break;
            case "LineString":
            case "MultiPoint":
              for (j = 0; j < coords.length; j++) {
                if (callback(
                  coords[j],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
                if (geomType === "MultiPoint") multiFeatureIndex++;
              }
              if (geomType === "LineString") multiFeatureIndex++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (j = 0; j < coords.length; j++) {
                for (k = 0; k < coords[j].length - wrapShrink; k++) {
                  if (callback(
                    coords[j][k],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                if (geomType === "MultiLineString") multiFeatureIndex++;
                if (geomType === "Polygon") geometryIndex++;
              }
              if (geomType === "Polygon") multiFeatureIndex++;
              break;
            case "MultiPolygon":
              for (j = 0; j < coords.length; j++) {
                geometryIndex = 0;
                for (k = 0; k < coords[j].length; k++) {
                  for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                    if (callback(
                      coords[j][k][l],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false)
                      return false;
                    coordIndex++;
                  }
                  geometryIndex++;
                }
                multiFeatureIndex++;
              }
              break;
            case "GeometryCollection":
              for (j = 0; j < geometry.geometries.length; j++)
                if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                  return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
    function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach(
        geojson,
        function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
          if (coordIndex === 0 && initialValue === void 0)
            previousValue = currentCoord;
          else
            previousValue = callback(
              previousValue,
              currentCoord,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            );
        },
        excludeWrapCoord
      );
      return previousValue;
    }
    function propEach(geojson, callback) {
      var i;
      switch (geojson.type) {
        case "FeatureCollection":
          for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) break;
          }
          break;
        case "Feature":
          callback(geojson.properties, 0);
          break;
      }
    }
    function propReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      propEach(geojson, function(currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentProperties;
        else
          previousValue = callback(previousValue, currentProperties, featureIndex);
      });
      return previousValue;
    }
    function featureEach(geojson, callback) {
      if (geojson.type === "Feature") {
        callback(geojson, 0);
      } else if (geojson.type === "FeatureCollection") {
        for (var i = 0; i < geojson.features.length; i++) {
          if (callback(geojson.features[i], i) === false) break;
        }
      }
    }
    function featureReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      featureEach(geojson, function(currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
      });
      return previousValue;
    }
    function coordAll(geojson) {
      var coords = [];
      coordEach(geojson, function(coord) {
        coords.push(coord);
      });
      return coords;
    }
    function geomEach(geojson, callback) {
      var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
      for (i = 0; i < stop; i++) {
        geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
        featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
        featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
        featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g = 0; g < stopG; g++) {
          geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
          if (geometry === null) {
            if (callback(
              null,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
            continue;
          }
          switch (geometry.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon": {
              if (callback(
                geometry,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
              break;
            }
            case "GeometryCollection": {
              for (j = 0; j < geometry.geometries.length; j++) {
                if (callback(
                  geometry.geometries[j],
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false)
                  return false;
              }
              break;
            }
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
        featureIndex++;
      }
    }
    function geomReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      geomEach(
        geojson,
        function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentGeometry;
          else
            previousValue = callback(
              previousValue,
              currentGeometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            );
        }
      );
      return previousValue;
    }
    function flattenEach(geojson, callback) {
      geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
        var type = geometry === null ? null : geometry.type;
        switch (type) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            if (callback(
              helpers.feature(geometry, properties, { bbox, id }),
              featureIndex,
              0
            ) === false)
              return false;
            return;
        }
        var geomType;
        switch (type) {
          case "MultiPoint":
            geomType = "Point";
            break;
          case "MultiLineString":
            geomType = "LineString";
            break;
          case "MultiPolygon":
            geomType = "Polygon";
            break;
        }
        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
          var coordinate = geometry.coordinates[multiFeatureIndex];
          var geom = {
            type: geomType,
            coordinates: coordinate
          };
          if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
            return false;
        }
      });
    }
    function flattenReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      flattenEach(
        geojson,
        function(currentFeature, featureIndex, multiFeatureIndex) {
          if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature;
          else
            previousValue = callback(
              previousValue,
              currentFeature,
              featureIndex,
              multiFeatureIndex
            );
        }
      );
      return previousValue;
    }
    function segmentEach(geojson, callback) {
      flattenEach(geojson, function(feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;
        if (!feature.geometry) return;
        var type = feature.geometry.type;
        if (type === "Point" || type === "MultiPoint") return;
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(
          feature,
          function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
              previousCoords = currentCoord;
              previousFeatureIndex = featureIndex;
              previousMultiIndex = multiPartIndexCoord;
              prevGeomIndex = geometryIndex;
              segmentIndex = 0;
              return;
            }
            var currentSegment = helpers.lineString(
              [previousCoords, currentCoord],
              feature.properties
            );
            if (callback(
              currentSegment,
              featureIndex,
              multiFeatureIndex,
              geometryIndex,
              segmentIndex
            ) === false)
              return false;
            segmentIndex++;
            previousCoords = currentCoord;
          }
        ) === false)
          return false;
      });
    }
    function segmentReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      var started = false;
      segmentEach(
        geojson,
        function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
          if (started === false && initialValue === void 0)
            previousValue = currentSegment;
          else
            previousValue = callback(
              previousValue,
              currentSegment,
              featureIndex,
              multiFeatureIndex,
              geometryIndex,
              segmentIndex
            );
          started = true;
        }
      );
      return previousValue;
    }
    function lineEach(geojson, callback) {
      if (!geojson) throw new Error("geojson is required");
      flattenEach(geojson, function(feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
          case "LineString":
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)
              return false;
            break;
          case "Polygon":
            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
              if (callback(
                helpers.lineString(coords[geometryIndex], feature.properties),
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
            }
            break;
        }
      });
    }
    function lineReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      lineEach(
        geojson,
        function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentLine;
          else
            previousValue = callback(
              previousValue,
              currentLine,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            );
        }
      );
      return previousValue;
    }
    function findSegment(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var segmentIndex = options.segmentIndex || 0;
      var properties = options.properties;
      var geometry;
      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }
      if (geometry === null) return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
          if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
          return helpers.lineString(
            [coords[segmentIndex], coords[segmentIndex + 1]],
            properties,
            options
          );
        case "Polygon":
          if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
          return helpers.lineString(
            [
              coords[geometryIndex][segmentIndex],
              coords[geometryIndex][segmentIndex + 1]
            ],
            properties,
            options
          );
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
          return helpers.lineString(
            [
              coords[multiFeatureIndex][segmentIndex],
              coords[multiFeatureIndex][segmentIndex + 1]
            ],
            properties,
            options
          );
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
          return helpers.lineString(
            [
              coords[multiFeatureIndex][geometryIndex][segmentIndex],
              coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
            ],
            properties,
            options
          );
      }
      throw new Error("geojson is invalid");
    }
    function findPoint(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var coordIndex = options.coordIndex || 0;
      var properties = options.properties;
      var geometry;
      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }
      if (geometry === null) return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
          return helpers.point(coords, properties, options);
        case "MultiPoint":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          return helpers.point(coords[multiFeatureIndex], properties, options);
        case "LineString":
          if (coordIndex < 0) coordIndex = coords.length + coordIndex;
          return helpers.point(coords[coordIndex], properties, options);
        case "Polygon":
          if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
          if (coordIndex < 0)
            coordIndex = coords[geometryIndex].length + coordIndex;
          return helpers.point(coords[geometryIndex][coordIndex], properties, options);
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (coordIndex < 0)
            coordIndex = coords[multiFeatureIndex].length + coordIndex;
          return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (coordIndex < 0)
            coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
          return helpers.point(
            coords[multiFeatureIndex][geometryIndex][coordIndex],
            properties,
            options
          );
      }
      throw new Error("geojson is invalid");
    }
    exports2.coordAll = coordAll;
    exports2.coordEach = coordEach;
    exports2.coordReduce = coordReduce;
    exports2.featureEach = featureEach;
    exports2.featureReduce = featureReduce;
    exports2.findPoint = findPoint;
    exports2.findSegment = findSegment;
    exports2.flattenEach = flattenEach;
    exports2.flattenReduce = flattenReduce;
    exports2.geomEach = geomEach;
    exports2.geomReduce = geomReduce;
    exports2.lineEach = lineEach;
    exports2.lineReduce = lineReduce;
    exports2.propEach = propEach;
    exports2.propReduce = propReduce;
    exports2.segmentEach = segmentEach;
    exports2.segmentReduce = segmentReduce;
  }
});

// node_modules/@turf/bbox/dist/js/index.js
var require_js3 = __commonJS({
  "node_modules/@turf/bbox/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    function bbox(geojson) {
      var result2 = [Infinity, Infinity, -Infinity, -Infinity];
      meta_1.coordEach(geojson, function(coord) {
        if (result2[0] > coord[0]) {
          result2[0] = coord[0];
        }
        if (result2[1] > coord[1]) {
          result2[1] = coord[1];
        }
        if (result2[2] < coord[0]) {
          result2[2] = coord[0];
        }
        if (result2[3] < coord[1]) {
          result2[3] = coord[1];
        }
      });
      return result2;
    }
    bbox["default"] = bbox;
    exports2.default = bbox;
  }
});

// node_modules/@turf/invariant/dist/js/index.js
var require_js4 = __commonJS({
  "node_modules/@turf/invariant/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    function getCoord(coord) {
      if (!coord) {
        throw new Error("coord is required");
      }
      if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
          return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
          return coord.coordinates;
        }
      }
      if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
      }
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    exports2.getCoord = getCoord;
    function getCoords(coords) {
      if (Array.isArray(coords)) {
        return coords;
      }
      if (coords.type === "Feature") {
        if (coords.geometry !== null) {
          return coords.geometry.coordinates;
        }
      } else {
        if (coords.coordinates) {
          return coords.coordinates;
        }
      }
      throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
    }
    exports2.getCoords = getCoords;
    function containsNumber(coordinates) {
      if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
      }
      if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
      }
      throw new Error("coordinates must only contain numbers");
    }
    exports2.containsNumber = containsNumber;
    function geojsonType(value, type, name) {
      if (!type || !name) {
        throw new Error("type and name required");
      }
      if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
      }
    }
    exports2.geojsonType = geojsonType;
    function featureOf(feature, type, name) {
      if (!feature) {
        throw new Error("No feature passed");
      }
      if (!name) {
        throw new Error(".featureOf() requires a name");
      }
      if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
      }
      if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
      }
    }
    exports2.featureOf = featureOf;
    function collectionOf(featureCollection, type, name) {
      if (!featureCollection) {
        throw new Error("No featureCollection passed");
      }
      if (!name) {
        throw new Error(".collectionOf() requires a name");
      }
      if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
      }
      for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
          throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
      }
    }
    exports2.collectionOf = collectionOf;
    function getGeom(geojson) {
      if (geojson.type === "Feature") {
        return geojson.geometry;
      }
      return geojson;
    }
    exports2.getGeom = getGeom;
    function getType(geojson, _name) {
      if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
      }
      if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
      }
      if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
      }
      return geojson.type;
    }
    exports2.getType = getType;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/@turf/isolines/dist/js/index.js
var require_js5 = __commonJS({
  "node_modules/@turf/isolines/dist/js/index.js"(exports2, module2) {
    "use strict";
    var bbox = require_js3();
    var meta = require_js2();
    var invariant = require_js4();
    var helpers = require_js();
    var objectAssign = require_object_assign();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bbox__default = /* @__PURE__ */ _interopDefaultLegacy(bbox);
    var objectAssign__default = /* @__PURE__ */ _interopDefaultLegacy(objectAssign);
    var defaultSettings = {
      successCallback: null,
      verbose: false
    };
    var settings = {};
    function isoContours(data, threshold, options) {
      options = options ? options : {};
      var optionKeys = Object.keys(defaultSettings);
      for (var i = 0; i < optionKeys.length; i++) {
        var key = optionKeys[i];
        var val = options[key];
        val = typeof val !== "undefined" && val !== null ? val : defaultSettings[key];
        settings[key] = val;
      }
      if (settings.verbose)
        console.log(
          "MarchingSquaresJS-isoContours: computing isocontour for " + threshold
        );
      var ret = contourGrid2Paths(computeContourGrid(data, threshold));
      if (typeof settings.successCallback === "function")
        settings.successCallback(ret);
      return ret;
    }
    function interpolateX(y, y0, y1) {
      return (y - y0) / (y1 - y0);
    }
    function computeContourGrid(data, threshold) {
      var rows = data.length - 1;
      var cols = data[0].length - 1;
      var ContourGrid = { rows, cols, cells: [] };
      for (var j = 0; j < rows; ++j) {
        ContourGrid.cells[j] = [];
        for (var i = 0; i < cols; ++i) {
          var cval = 0;
          var tl = data[j + 1][i];
          var tr = data[j + 1][i + 1];
          var br = data[j][i + 1];
          var bl = data[j][i];
          if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
            continue;
          }
          cval |= tl >= threshold ? 8 : 0;
          cval |= tr >= threshold ? 4 : 0;
          cval |= br >= threshold ? 2 : 0;
          cval |= bl >= threshold ? 1 : 0;
          var flipped = false;
          if (cval === 5 || cval === 10) {
            var average = (tl + tr + br + bl) / 4;
            if (cval === 5 && average < threshold) {
              cval = 10;
              flipped = true;
            } else if (cval === 10 && average < threshold) {
              cval = 5;
              flipped = true;
            }
          }
          if (cval !== 0 && cval !== 15) {
            var top, bottom, left, right;
            top = bottom = left = right = 0.5;
            if (cval === 1) {
              left = 1 - interpolateX(threshold, tl, bl);
              bottom = 1 - interpolateX(threshold, br, bl);
            } else if (cval === 2) {
              bottom = interpolateX(threshold, bl, br);
              right = 1 - interpolateX(threshold, tr, br);
            } else if (cval === 3) {
              left = 1 - interpolateX(threshold, tl, bl);
              right = 1 - interpolateX(threshold, tr, br);
            } else if (cval === 4) {
              top = interpolateX(threshold, tl, tr);
              right = interpolateX(threshold, br, tr);
            } else if (cval === 5) {
              top = interpolateX(threshold, tl, tr);
              right = interpolateX(threshold, br, tr);
              bottom = 1 - interpolateX(threshold, br, bl);
              left = 1 - interpolateX(threshold, tl, bl);
            } else if (cval === 6) {
              bottom = interpolateX(threshold, bl, br);
              top = interpolateX(threshold, tl, tr);
            } else if (cval === 7) {
              left = 1 - interpolateX(threshold, tl, bl);
              top = interpolateX(threshold, tl, tr);
            } else if (cval === 8) {
              left = interpolateX(threshold, bl, tl);
              top = 1 - interpolateX(threshold, tr, tl);
            } else if (cval === 9) {
              bottom = 1 - interpolateX(threshold, br, bl);
              top = 1 - interpolateX(threshold, tr, tl);
            } else if (cval === 10) {
              top = 1 - interpolateX(threshold, tr, tl);
              right = 1 - interpolateX(threshold, tr, br);
              bottom = interpolateX(threshold, bl, br);
              left = interpolateX(threshold, bl, tl);
            } else if (cval === 11) {
              top = 1 - interpolateX(threshold, tr, tl);
              right = 1 - interpolateX(threshold, tr, br);
            } else if (cval === 12) {
              left = interpolateX(threshold, bl, tl);
              right = interpolateX(threshold, br, tr);
            } else if (cval === 13) {
              bottom = 1 - interpolateX(threshold, br, bl);
              right = interpolateX(threshold, br, tr);
            } else if (cval === 14) {
              left = interpolateX(threshold, bl, tl);
              bottom = interpolateX(threshold, bl, br);
            } else {
              console.log(
                "MarchingSquaresJS-isoContours: Illegal cval detected: " + cval
              );
            }
            ContourGrid.cells[j][i] = {
              cval,
              flipped,
              top,
              right,
              bottom,
              left
            };
          }
        }
      }
      return ContourGrid;
    }
    function isSaddle(cell) {
      return cell.cval === 5 || cell.cval === 10;
    }
    function isTrivial(cell) {
      return cell.cval === 0 || cell.cval === 15;
    }
    function clearCell(cell) {
      if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {
        cell.cval = 15;
      }
    }
    function getXY(cell, edge) {
      if (edge === "top") {
        return [cell.top, 1];
      } else if (edge === "bottom") {
        return [cell.bottom, 0];
      } else if (edge === "right") {
        return [1, cell.right];
      } else if (edge === "left") {
        return [0, cell.left];
      }
    }
    function contourGrid2Paths(grid) {
      var paths = [];
      var path_idx = 0;
      var epsilon = 1e-7;
      grid.cells.forEach(function(g, j) {
        g.forEach(function(gg, i) {
          if (typeof gg !== "undefined" && !isSaddle(gg) && !isTrivial(gg)) {
            var p = tracePath(grid.cells, j, i);
            var merged = false;
            if (p.info === "mergeable") {
              var x = p.path[p.path.length - 1][0], y = p.path[p.path.length - 1][1];
              for (var k = path_idx - 1; k >= 0; k--) {
                if (Math.abs(paths[k][0][0] - x) <= epsilon && Math.abs(paths[k][0][1] - y) <= epsilon) {
                  for (var l = p.path.length - 2; l >= 0; --l) {
                    paths[k].unshift(p.path[l]);
                  }
                  merged = true;
                  break;
                }
              }
            }
            if (!merged) paths[path_idx++] = p.path;
          }
        });
      });
      return paths;
    }
    function tracePath(grid, j, i) {
      var maxj = grid.length;
      var p = [];
      var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];
      var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];
      var dx, dy;
      var startEdge = [
        "none",
        "left",
        "bottom",
        "left",
        "right",
        "none",
        "bottom",
        "left",
        "top",
        "top",
        "none",
        "top",
        "right",
        "right",
        "bottom",
        "none"
      ];
      var nextEdge = [
        "none",
        "bottom",
        "right",
        "right",
        "top",
        "top",
        "top",
        "top",
        "left",
        "bottom",
        "right",
        "right",
        "left",
        "bottom",
        "left",
        "none"
      ];
      var edge;
      var currentCell = grid[j][i];
      var cval = currentCell.cval;
      var edge = startEdge[cval];
      var pt = getXY(currentCell, edge);
      p.push([i + pt[0], j + pt[1]]);
      edge = nextEdge[cval];
      pt = getXY(currentCell, edge);
      p.push([i + pt[0], j + pt[1]]);
      clearCell(currentCell);
      var k = i + dxContour[cval];
      var l = j + dyContour[cval];
      var prev_cval = cval;
      while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {
        currentCell = grid[l][k];
        if (typeof currentCell === "undefined") {
          break;
        }
        cval = currentCell.cval;
        if (cval === 0 || cval === 15) {
          return { path: p, info: "mergeable" };
        }
        edge = nextEdge[cval];
        dx = dxContour[cval];
        dy = dyContour[cval];
        if (cval === 5 || cval === 10) {
          if (cval === 5) {
            if (currentCell.flipped) {
              if (dyContour[prev_cval] === -1) {
                edge = "left";
                dx = -1;
                dy = 0;
              } else {
                edge = "right";
                dx = 1;
                dy = 0;
              }
            } else {
              if (dxContour[prev_cval] === -1) {
                edge = "bottom";
                dx = 0;
                dy = -1;
              }
            }
          } else if (cval === 10) {
            if (currentCell.flipped) {
              if (dxContour[prev_cval] === -1) {
                edge = "top";
                dx = 0;
                dy = 1;
              } else {
                edge = "bottom";
                dx = 0;
                dy = -1;
              }
            } else {
              if (dyContour[prev_cval] === 1) {
                edge = "left";
                dx = -1;
                dy = 0;
              }
            }
          }
        }
        pt = getXY(currentCell, edge);
        p.push([k + pt[0], l + pt[1]]);
        clearCell(currentCell);
        k += dx;
        l += dy;
        prev_cval = cval;
      }
      return { path: p, info: "closed" };
    }
    function gridToMatrix(grid, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var flip = options.flip;
      var flags = options.flags;
      invariant.collectionOf(grid, "Point", "input must contain Points");
      var pointsMatrix = sortPointsByLatLng(grid, flip);
      var matrix = [];
      for (var r = 0; r < pointsMatrix.length; r++) {
        var pointRow = pointsMatrix[r];
        var row = [];
        for (var c = 0; c < pointRow.length; c++) {
          var point = pointRow[c];
          if (point.properties[zProperty]) row.push(point.properties[zProperty]);
          else row.push(0);
          if (flags === true) point.properties.matrixPosition = [r, c];
        }
        matrix.push(row);
      }
      return matrix;
    }
    function sortPointsByLatLng(points, flip) {
      var pointsByLatitude = {};
      meta.featureEach(points, function(point) {
        var lat = invariant.getCoords(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
      });
      var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function(a, b) {
          return invariant.getCoords(a)[0] - invariant.getCoords(b)[0];
        });
        return rowOrderedByLongitude;
      });
      var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
        if (flip) return invariant.getCoords(a[0])[1] - invariant.getCoords(b[0])[1];
        else return invariant.getCoords(b[0])[1] - invariant.getCoords(a[0])[1];
      });
      return pointMatrix;
    }
    function isolines(pointGrid, breaks, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var commonProperties = options.commonProperties || {};
      var breaksProperties = options.breaksProperties || [];
      invariant.collectionOf(pointGrid, "Point", "Input must contain Points");
      if (!breaks) throw new Error("breaks is required");
      if (!Array.isArray(breaks)) throw new Error("breaks must be an Array");
      if (!helpers.isObject(commonProperties))
        throw new Error("commonProperties must be an Object");
      if (!Array.isArray(breaksProperties))
        throw new Error("breaksProperties must be an Array");
      var matrix = gridToMatrix(pointGrid, { zProperty, flip: true });
      var createdIsoLines = createIsoLines(
        matrix,
        breaks,
        zProperty,
        commonProperties,
        breaksProperties
      );
      var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);
      return helpers.featureCollection(scaledIsolines);
    }
    function createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {
      var results = [];
      for (var i = 1; i < breaks.length; i++) {
        var threshold = +breaks[i];
        var properties = objectAssign__default["default"]({}, commonProperties, breaksProperties[i]);
        properties[zProperty] = threshold;
        var isoline = helpers.multiLineString(isoContours(matrix, threshold), properties);
        results.push(isoline);
      }
      return results;
    }
    function rescaleIsolines(createdIsoLines, matrix, points) {
      var gridBbox = bbox__default["default"](points);
      var originalWidth = gridBbox[2] - gridBbox[0];
      var originalHeigth = gridBbox[3] - gridBbox[1];
      var x0 = gridBbox[0];
      var y0 = gridBbox[1];
      var matrixWidth = matrix[0].length - 1;
      var matrixHeight = matrix.length - 1;
      var scaleX = originalWidth / matrixWidth;
      var scaleY = originalHeigth / matrixHeight;
      var resize = function(point) {
        point[0] = point[0] * scaleX + x0;
        point[1] = point[1] * scaleY + y0;
      };
      createdIsoLines.forEach(function(isoline) {
        meta.coordEach(isoline, resize);
      });
      return createdIsoLines;
    }
    module2.exports = isolines;
    module2.exports.default = isolines;
  }
});

// node_modules/concaveman/node_modules/rbush/rbush.js
var require_rbush = __commonJS({
  "node_modules/concaveman/node_modules/rbush/rbush.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.RBush = factory());
    })(exports2, function() {
      "use strict";
      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }
      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) {
            swap(arr, left, right);
          }
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) {
              i++;
            }
            while (compare(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare(arr[left], t) === 0) {
            swap(arr, left, j);
          } else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) {
            left = j + 1;
          }
          if (k <= j) {
            right = j - 1;
          }
        }
      }
      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      var RBush = function RBush2(maxEntries) {
        if (maxEntries === void 0) maxEntries = 9;
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      };
      RBush.prototype.all = function all2() {
        return this._all(this.data, []);
      };
      RBush.prototype.search = function search(bbox) {
        var node = this.data;
        var result2 = [];
        if (!intersects(bbox, node)) {
          return result2;
        }
        var toBBox = this.toBBox;
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf) {
                result2.push(child);
              } else if (contains(bbox, childBBox)) {
                this._all(child, result2);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
          node = nodesToSearch.pop();
        }
        return result2;
      };
      RBush.prototype.collides = function collides(bbox) {
        var node = this.data;
        if (!intersects(bbox, node)) {
          return false;
        }
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) {
                return true;
              }
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      };
      RBush.prototype.load = function load(data) {
        if (!(data && data.length)) {
          return this;
        }
        if (data.length < this._minEntries) {
          for (var i = 0; i < data.length; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        var node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      };
      RBush.prototype.insert = function insert(item) {
        if (item) {
          this._insert(item, this.data.height - 1);
        }
        return this;
      };
      RBush.prototype.clear = function clear() {
        this.data = createNode([]);
        return this;
      };
      RBush.prototype.remove = function remove(item, equalsFn) {
        if (!item) {
          return this;
        }
        var node = this.data;
        var bbox = this.toBBox(item);
        var path = [];
        var indexes = [];
        var i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            var index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
        return this;
      };
      RBush.prototype.toBBox = function toBBox(item) {
        return item;
      };
      RBush.prototype.compareMinX = function compareMinX(a, b) {
        return a.minX - b.minX;
      };
      RBush.prototype.compareMinY = function compareMinY(a, b) {
        return a.minY - b.minY;
      };
      RBush.prototype.toJSON = function toJSON() {
        return this.data;
      };
      RBush.prototype.fromJSON = function fromJSON(data) {
        this.data = data;
        return this;
      };
      RBush.prototype._all = function _all(node, result2) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) {
            result2.push.apply(result2, node.children);
          } else {
            nodesToSearch.push.apply(nodesToSearch, node.children);
          }
          node = nodesToSearch.pop();
        }
        return result2;
      };
      RBush.prototype._build = function _build(items, left, right, height) {
        var N = right - left + 1;
        var M = this._maxEntries;
        var node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M);
        var N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (var i = left; i <= right; i += N1) {
          var right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (var j = i; j <= right2; j += N2) {
            var right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      };
      RBush.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) {
            break;
          }
          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = void 0;
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      };
      RBush.prototype._insert = function _insert(item, level, isNode) {
        var bbox = isNode ? item : this.toBBox(item);
        var insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else {
            break;
          }
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      };
      RBush.prototype._split = function _split(insertPath, level) {
        var node = insertPath[level];
        var M = node.children.length;
        var m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) {
          insertPath[level - 1].children.push(newNode);
        } else {
          this._splitRoot(node, newNode);
        }
      };
      RBush.prototype._splitRoot = function _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      };
      RBush.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {
        var index;
        var minOverlap = Infinity;
        var minArea = Infinity;
        for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);
          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index || M - m;
      };
      RBush.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        var xMargin = this._allDistMargin(node, m, M, compareMinX);
        var yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin) {
          node.children.sort(compareMinX);
        }
      };
      RBush.prototype._allDistMargin = function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox;
        var leftBBox = distBBox(node, 0, m, toBBox);
        var rightBBox = distBBox(node, M - m, M, toBBox);
        var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      };
      RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      };
      RBush.prototype._condense = function _condense(path) {
        for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else {
              this.clear();
            }
          } else {
            calcBBox(path[i], this.toBBox);
          }
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn) {
          return items.indexOf(item);
        }
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) {
            return i;
          }
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) {
          destNode = createNode(null);
        }
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX);
        var minY = Math.max(a.minY, b.minY);
        var maxX = Math.min(a.maxX, b.maxX);
        var maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children2) {
        return {
          children: children2,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right];
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n) {
            continue;
          }
          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
      return RBush;
    });
  }
});

// node_modules/tinyqueue/tinyqueue.js
var require_tinyqueue = __commonJS({
  "node_modules/tinyqueue/tinyqueue.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.TinyQueue = factory());
    })(exports2, function() {
      "use strict";
      var TinyQueue = function TinyQueue2(data, compare) {
        if (data === void 0) data = [];
        if (compare === void 0) compare = defaultCompare;
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;
        if (this.length > 0) {
          for (var i = (this.length >> 1) - 1; i >= 0; i--) {
            this._down(i);
          }
        }
      };
      TinyQueue.prototype.push = function push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
      };
      TinyQueue.prototype.pop = function pop() {
        if (this.length === 0) {
          return void 0;
        }
        var top = this.data[0];
        var bottom = this.data.pop();
        this.length--;
        if (this.length > 0) {
          this.data[0] = bottom;
          this._down(0);
        }
        return top;
      };
      TinyQueue.prototype.peek = function peek() {
        return this.data[0];
      };
      TinyQueue.prototype._up = function _up(pos) {
        var ref = this;
        var data = ref.data;
        var compare = ref.compare;
        var item = data[pos];
        while (pos > 0) {
          var parent = pos - 1 >> 1;
          var current = data[parent];
          if (compare(item, current) >= 0) {
            break;
          }
          data[pos] = current;
          pos = parent;
        }
        data[pos] = item;
      };
      TinyQueue.prototype._down = function _down(pos) {
        var ref = this;
        var data = ref.data;
        var compare = ref.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];
        while (pos < halfLength) {
          var left = (pos << 1) + 1;
          var best = data[left];
          var right = left + 1;
          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }
          if (compare(best, item) >= 0) {
            break;
          }
          data[pos] = best;
          pos = left;
        }
        data[pos] = item;
      };
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      return TinyQueue;
    });
  }
});

// node_modules/point-in-polygon/flat.js
var require_flat2 = __commonJS({
  "node_modules/point-in-polygon/flat.js"(exports2, module2) {
    module2.exports = function pointInPolygonFlat(point, vs, start, end) {
      var x = point[0], y = point[1];
      var inside = false;
      if (start === void 0) start = 0;
      if (end === void 0) end = vs.length;
      var len = (end - start) / 2;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
        var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/nested.js
var require_nested = __commonJS({
  "node_modules/point-in-polygon/nested.js"(exports2, module2) {
    module2.exports = function pointInPolygonNested(point, vs, start, end) {
      var x = point[0], y = point[1];
      var inside = false;
      if (start === void 0) start = 0;
      if (end === void 0) end = vs.length;
      var len = end - start;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i + start][0], yi = vs[i + start][1];
        var xj = vs[j + start][0], yj = vs[j + start][1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/index.js
var require_point_in_polygon = __commonJS({
  "node_modules/point-in-polygon/index.js"(exports2, module2) {
    var pointInPolygonFlat = require_flat2();
    var pointInPolygonNested = require_nested();
    module2.exports = function pointInPolygon(point, vs, start, end) {
      if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point, vs, start, end);
      } else {
        return pointInPolygonFlat(point, vs, start, end);
      }
    };
    module2.exports.nested = pointInPolygonNested;
    module2.exports.flat = pointInPolygonFlat;
  }
});

// node_modules/robust-predicates/umd/orient2d.min.js
var require_orient2d_min = __commonJS({
  "node_modules/robust-predicates/umd/orient2d.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? e(exports2) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
    }(exports2, function(t) {
      "use strict";
      const e = 134217729, n = 33306690738754706e-32;
      function r(t2, e2, n2, r2, o2) {
        let f2, i2, u2, c2, s2 = e2[0], a2 = r2[0], d2 = 0, l2 = 0;
        a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e2[++d2]) : (f2 = a2, a2 = r2[++l2]);
        let p = 0;
        if (d2 < t2 && l2 < n2) for (a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e2[++d2]) : (u2 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2); d2 < t2 && l2 < n2; ) a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e2[++d2]) : (u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2);
        for (; d2 < t2; ) u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e2[++d2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
        for (; l2 < n2; ) u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
        return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
      }
      function o(t2) {
        return new Float64Array(t2);
      }
      const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
      t.orient2d = function(t2, o2, p, b, y, h) {
        const M = (o2 - h) * (p - y), x = (t2 - y) * (b - h), j = M - x;
        if (0 === M || 0 === x || M > 0 != x > 0) return j;
        const m = Math.abs(M + x);
        return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y2, h2) {
          let M2, x2, j2, m2, _, v, w, A, F, O, P, g, k, q, z, B, C, D;
          const E = t3 - b2, G = f2 - b2, H = o3 - y2, I = p2 - y2;
          _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = G - (F = (v = e * G) - (v - G))) - ((B = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B), c[1] = k - (P + _) + (_ - B), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
          let J = function(t4, e2) {
            let n2 = e2[0];
            for (let r2 = 1; r2 < t4; r2++) n2 += e2[r2];
            return n2;
          }(4, c), K = i * h2;
          if (J >= K || -J >= K) return J;
          if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x2 = o3 - (H + (_ = o3 - H)) + (_ - y2), m2 = p2 - (I + (_ = p2 - I)) + (_ - y2), 0 === M2 && 0 === x2 && 0 === j2 && 0 === m2) return J;
          if (K = u * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x2)) >= K || -J >= K) return J;
          _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x2 - (w = (v = e * x2) - (v - x2))) * (O = G - (F = (v = e * G) - (v - G))) - ((B = x2 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B), l[1] = k - (P + _) + (_ - B), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
          const L = r(4, c, 4, l, s);
          _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B), l[1] = k - (P + _) + (_ - B), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
          const N = r(L, s, 4, l, a);
          _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = x2 - (w = (v = e * x2) - (v - x2))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B = x2 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B), l[1] = k - (P + _) + (_ - B), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
          const Q = r(N, a, 4, l, d);
          return d[Q - 1];
        }(t2, o2, p, b, y, h, m);
      }, t.orient2dfast = function(t2, e2, n2, r2, o2, f2) {
        return (e2 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
      }, Object.defineProperty(t, "__esModule", { value: true });
    });
  }
});

// node_modules/concaveman/index.js
var require_concaveman = __commonJS({
  "node_modules/concaveman/index.js"(exports2, module2) {
    "use strict";
    var RBush = require_rbush();
    var Queue = require_tinyqueue();
    var pointInPolygon = require_point_in_polygon();
    var orient = require_orient2d_min().orient2d;
    if (Queue.default) {
      Queue = Queue.default;
    }
    module2.exports = concaveman;
    module2.exports.default = concaveman;
    function concaveman(points, concavity, lengthThreshold) {
      concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
      lengthThreshold = lengthThreshold || 0;
      var hull = fastConvexHull(points);
      var tree = new RBush(16);
      tree.toBBox = function(a2) {
        return {
          minX: a2[0],
          minY: a2[1],
          maxX: a2[0],
          maxY: a2[1]
        };
      };
      tree.compareMinX = function(a2, b2) {
        return a2[0] - b2[0];
      };
      tree.compareMinY = function(a2, b2) {
        return a2[1] - b2[1];
      };
      tree.load(points);
      var queue = [];
      for (var i = 0, last; i < hull.length; i++) {
        var p = hull[i];
        tree.remove(p);
        last = insertNode(p, last);
        queue.push(last);
      }
      var segTree = new RBush(16);
      for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));
      var sqConcavity = concavity * concavity;
      var sqLenThreshold = lengthThreshold * lengthThreshold;
      while (queue.length) {
        var node = queue.shift();
        var a = node.p;
        var b = node.next.p;
        var sqLen = getSqDist(a, b);
        if (sqLen < sqLenThreshold) continue;
        var maxSqLen = sqLen / sqConcavity;
        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
          queue.push(node);
          queue.push(insertNode(p, node));
          tree.remove(p);
          segTree.remove(node);
          segTree.insert(updateBBox(node));
          segTree.insert(updateBBox(node.next));
        }
      }
      node = last;
      var concave = [];
      do {
        concave.push(node.p);
        node = node.next;
      } while (node !== last);
      concave.push(node.p);
      return concave;
    }
    function findCandidate(tree, a, b, c, d, maxDist, segTree) {
      var queue = new Queue([], compareDist);
      var node = tree.data;
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
          if (dist > maxDist) continue;
          queue.push({
            node: child,
            dist
          });
        }
        while (queue.length && !queue.peek().node.children) {
          var item = queue.pop();
          var p = item.node;
          var d0 = sqSegDist(p, a, b);
          var d1 = sqSegDist(p, c, d);
          if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;
        }
        node = queue.pop();
        if (node) node = node.node;
      }
      return null;
    }
    function compareDist(a, b) {
      return a.dist - b.dist;
    }
    function sqSegBoxDist(a, b, bbox) {
      if (inside(a, bbox) || inside(b, bbox)) return 0;
      var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);
      if (d1 === 0) return 0;
      var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);
      if (d2 === 0) return 0;
      var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);
      if (d3 === 0) return 0;
      var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);
      if (d4 === 0) return 0;
      return Math.min(d1, d2, d3, d4);
    }
    function inside(a, bbox) {
      return a[0] >= bbox.minX && a[0] <= bbox.maxX && a[1] >= bbox.minY && a[1] <= bbox.maxY;
    }
    function noIntersections(a, b, segTree) {
      var minX = Math.min(a[0], b[0]);
      var minY = Math.min(a[1], b[1]);
      var maxX = Math.max(a[0], b[0]);
      var maxY = Math.max(a[1], b[1]);
      var edges = segTree.search({ minX, minY, maxX, maxY });
      for (var i = 0; i < edges.length; i++) {
        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;
      }
      return true;
    }
    function cross(p1, p2, p3) {
      return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }
    function intersects(p1, q1, p2, q2) {
      return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
    }
    function updateBBox(node) {
      var p1 = node.p;
      var p2 = node.next.p;
      node.minX = Math.min(p1[0], p2[0]);
      node.minY = Math.min(p1[1], p2[1]);
      node.maxX = Math.max(p1[0], p2[0]);
      node.maxY = Math.max(p1[1], p2[1]);
      return node;
    }
    function fastConvexHull(points) {
      var left = points[0];
      var top = points[0];
      var right = points[0];
      var bottom = points[0];
      for (var i = 0; i < points.length; i++) {
        var p = points[i];
        if (p[0] < left[0]) left = p;
        if (p[0] > right[0]) right = p;
        if (p[1] < top[1]) top = p;
        if (p[1] > bottom[1]) bottom = p;
      }
      var cull = [left, top, right, bottom];
      var filtered = cull.slice();
      for (i = 0; i < points.length; i++) {
        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);
      }
      return convexHull(filtered);
    }
    function insertNode(p, prev) {
      var node = {
        p,
        prev: null,
        next: null,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      };
      if (!prev) {
        node.prev = node;
        node.next = node;
      } else {
        node.next = prev.next;
        node.prev = prev;
        prev.next.prev = node;
        prev.next = node;
      }
      return node;
    }
    function getSqDist(p1, p2) {
      var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
      return dx * dx + dy * dy;
    }
    function sqSegDist(p, p1, p2) {
      var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
      if (dx !== 0 || dy !== 0) {
        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          x = p2[0];
          y = p2[1];
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }
      dx = p[0] - x;
      dy = p[1] - y;
      return dx * dx + dy * dy;
    }
    function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {
      var ux = x1 - x0;
      var uy = y1 - y0;
      var vx = x3 - x2;
      var vy = y3 - y2;
      var wx = x0 - x2;
      var wy = y0 - y2;
      var a = ux * ux + uy * uy;
      var b = ux * vx + uy * vy;
      var c = vx * vx + vy * vy;
      var d = ux * wx + uy * wy;
      var e = vx * wx + vy * wy;
      var D = a * c - b * b;
      var sc, sN, tc, tN;
      var sD = D;
      var tD = D;
      if (D === 0) {
        sN = 0;
        sD = 1;
        tN = e;
        tD = c;
      } else {
        sN = b * e - c * d;
        tN = a * e - b * d;
        if (sN < 0) {
          sN = 0;
          tN = e;
          tD = c;
        } else if (sN > sD) {
          sN = sD;
          tN = e + b;
          tD = c;
        }
      }
      if (tN < 0) {
        tN = 0;
        if (-d < 0) sN = 0;
        else if (-d > a) sN = sD;
        else {
          sN = -d;
          sD = a;
        }
      } else if (tN > tD) {
        tN = tD;
        if (-d + b < 0) sN = 0;
        else if (-d + b > a) sN = sD;
        else {
          sN = -d + b;
          sD = a;
        }
      }
      sc = sN === 0 ? 0 : sN / sD;
      tc = tN === 0 ? 0 : tN / tD;
      var cx = (1 - sc) * x0 + sc * x1;
      var cy = (1 - sc) * y0 + sc * y1;
      var cx2 = (1 - tc) * x2 + tc * x3;
      var cy2 = (1 - tc) * y2 + tc * y3;
      var dx = cx2 - cx;
      var dy = cy2 - cy;
      return dx * dx + dy * dy;
    }
    function compareByX(a, b) {
      return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
    }
    function convexHull(points) {
      points.sort(compareByX);
      var lower = [];
      for (var i = 0; i < points.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
          lower.pop();
        }
        lower.push(points[i]);
      }
      var upper = [];
      for (var ii = points.length - 1; ii >= 0; ii--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
          upper.pop();
        }
        upper.push(points[ii]);
      }
      upper.pop();
      lower.pop();
      return lower.concat(upper);
    }
  }
});

// node_modules/@turf/convex/dist/js/index.js
var require_js6 = __commonJS({
  "node_modules/@turf/convex/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var meta_1 = require_js2();
    var concaveman_1 = __importDefault(require_concaveman());
    function convex(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      options.concavity = options.concavity || Infinity;
      var points = [];
      meta_1.coordEach(geojson, function(coord) {
        points.push([coord[0], coord[1]]);
      });
      if (!points.length) {
        return null;
      }
      var convexHull = concaveman_1.default(points, options.concavity);
      if (convexHull.length > 3) {
        return helpers_1.polygon([convexHull]);
      }
      return null;
    }
    exports2.default = convex;
  }
});

// node_modules/@turf/boolean-point-in-polygon/dist/js/index.js
var require_js7 = __commonJS({
  "node_modules/@turf/boolean-point-in-polygon/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var invariant_1 = require_js4();
    function booleanPointInPolygon(point, polygon, options) {
      if (options === void 0) {
        options = {};
      }
      if (!point) {
        throw new Error("point is required");
      }
      if (!polygon) {
        throw new Error("polygon is required");
      }
      var pt = invariant_1.getCoord(point);
      var geom = invariant_1.getGeom(polygon);
      var type = geom.type;
      var bbox = polygon.bbox;
      var polys = geom.coordinates;
      if (bbox && inBBox(pt, bbox) === false) {
        return false;
      }
      if (type === "Polygon") {
        polys = [polys];
      }
      var insidePoly = false;
      for (var i = 0; i < polys.length && !insidePoly; i++) {
        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
          var inHole = false;
          var k = 1;
          while (k < polys[i].length && !inHole) {
            if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
              inHole = true;
            }
            k++;
          }
          if (!inHole) {
            insidePoly = true;
          }
        }
      }
      return insidePoly;
    }
    exports2.default = booleanPointInPolygon;
    function inRing(pt, ring, ignoreBoundary) {
      var isInside = false;
      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
        ring = ring.slice(0, ring.length - 1);
      }
      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0];
        var yi = ring[i][1];
        var xj = ring[j][0];
        var yj = ring[j][1];
        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
        if (onBoundary) {
          return !ignoreBoundary;
        }
        var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
        if (intersect) {
          isInside = !isInside;
        }
      }
      return isInside;
    }
    function inBBox(pt, bbox) {
      return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
    }
  }
});

// node_modules/@turf/points-within-polygon/dist/js/index.js
var require_js8 = __commonJS({
  "node_modules/@turf/points-within-polygon/dist/js/index.js"(exports2, module2) {
    "use strict";
    var pointInPolygon = require_js7();
    var helpers = require_js();
    var meta = require_js2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var pointInPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(pointInPolygon);
    function pointsWithinPolygon(points, polygons) {
      var results = [];
      meta.featureEach(points, function(point) {
        var contained = false;
        if (point.geometry.type === "Point") {
          meta.geomEach(polygons, function(polygon) {
            if (pointInPolygon__default["default"](point, polygon)) contained = true;
          });
          if (contained) {
            results.push(point);
          }
        } else if (point.geometry.type === "MultiPoint") {
          var pointsWithin = [];
          meta.geomEach(polygons, function(polygon) {
            meta.coordEach(point, function(pointCoord) {
              if (pointInPolygon__default["default"](pointCoord, polygon)) {
                contained = true;
                pointsWithin.push(pointCoord);
              }
            });
          });
          if (contained) {
            results.push(helpers.multiPoint(pointsWithin));
          }
        } else {
          throw new Error("Input geometry must be a Point or MultiPoint");
        }
      });
      return helpers.featureCollection(results);
    }
    module2.exports = pointsWithinPolygon;
    module2.exports.default = pointsWithinPolygon;
  }
});

// node_modules/@turf/distance/dist/js/index.js
var require_js9 = __commonJS({
  "node_modules/@turf/distance/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var invariant_1 = require_js4();
    var helpers_1 = require_js();
    function distance(from, to, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(from);
      var coordinates2 = invariant_1.getCoord(to);
      var dLat = helpers_1.degreesToRadians(coordinates2[1] - coordinates1[1]);
      var dLon = helpers_1.degreesToRadians(coordinates2[0] - coordinates1[0]);
      var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
      var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
      var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
      return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
    }
    exports2.default = distance;
  }
});

// node_modules/@turf/tin/dist/js/index.js
var require_js10 = __commonJS({
  "node_modules/@turf/tin/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    function tin(points, z) {
      var isPointZ = false;
      return helpers_1.featureCollection(triangulate(points.features.map(function(p) {
        var point = {
          x: p.geometry.coordinates[0],
          y: p.geometry.coordinates[1]
        };
        if (z) {
          point.z = p.properties[z];
        } else if (p.geometry.coordinates.length === 3) {
          isPointZ = true;
          point.z = p.geometry.coordinates[2];
        }
        return point;
      })).map(function(triangle) {
        var a = [triangle.a.x, triangle.a.y];
        var b = [triangle.b.x, triangle.b.y];
        var c = [triangle.c.x, triangle.c.y];
        var properties = {};
        if (isPointZ) {
          a.push(triangle.a.z);
          b.push(triangle.b.z);
          c.push(triangle.c.z);
        } else {
          properties = {
            a: triangle.a.z,
            b: triangle.b.z,
            c: triangle.c.z
          };
        }
        return helpers_1.polygon([[a, b, c, a]], properties);
      }));
    }
    exports2.default = tin;
    var Triangle = (
      /** @class */
      /* @__PURE__ */ function() {
        function Triangle2(a, b, c) {
          this.a = a;
          this.b = b;
          this.c = c;
          var A = b.x - a.x;
          var B = b.y - a.y;
          var C = c.x - a.x;
          var D = c.y - a.y;
          var E = A * (a.x + b.x) + B * (a.y + b.y);
          var F = C * (a.x + c.x) + D * (a.y + c.y);
          var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
          var dx;
          var dy;
          this.x = (D * E - B * F) / G;
          this.y = (A * F - C * E) / G;
          dx = this.x - a.x;
          dy = this.y - a.y;
          this.r = dx * dx + dy * dy;
        }
        return Triangle2;
      }()
    );
    function byX(a, b) {
      return b.x - a.x;
    }
    function dedup(edges) {
      var j = edges.length;
      var a;
      var b;
      var i;
      var m;
      var n;
      outer: while (j) {
        b = edges[--j];
        a = edges[--j];
        i = j;
        while (i) {
          n = edges[--i];
          m = edges[--i];
          if (a === m && b === n || a === n && b === m) {
            edges.splice(j, 2);
            edges.splice(i, 2);
            j -= 2;
            continue outer;
          }
        }
      }
    }
    function triangulate(vertices) {
      if (vertices.length < 3) {
        return [];
      }
      vertices.sort(byX);
      var i = vertices.length - 1;
      var xmin = vertices[i].x;
      var xmax = vertices[0].x;
      var ymin = vertices[i].y;
      var ymax = ymin;
      var epsilon = 1e-12;
      var a;
      var b;
      var c;
      var A;
      var B;
      var G;
      while (i--) {
        if (vertices[i].y < ymin) {
          ymin = vertices[i].y;
        }
        if (vertices[i].y > ymax) {
          ymax = vertices[i].y;
        }
      }
      var dx = xmax - xmin;
      var dy = ymax - ymin;
      var dmax = dx > dy ? dx : dy;
      var xmid = (xmax + xmin) * 0.5;
      var ymid = (ymax + ymin) * 0.5;
      var open = [
        new Triangle({
          __sentinel: true,
          x: xmid - 20 * dmax,
          y: ymid - dmax
        }, {
          __sentinel: true,
          x: xmid,
          y: ymid + 20 * dmax
        }, {
          __sentinel: true,
          x: xmid + 20 * dmax,
          y: ymid - dmax
        })
      ];
      var closed = [];
      var edges = [];
      var j;
      i = vertices.length;
      while (i--) {
        edges.length = 0;
        j = open.length;
        while (j--) {
          dx = vertices[i].x - open[j].x;
          if (dx > 0 && dx * dx > open[j].r) {
            closed.push(open[j]);
            open.splice(j, 1);
            continue;
          }
          dy = vertices[i].y - open[j].y;
          if (dx * dx + dy * dy > open[j].r) {
            continue;
          }
          edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
          open.splice(j, 1);
        }
        dedup(edges);
        j = edges.length;
        while (j) {
          b = edges[--j];
          a = edges[--j];
          c = vertices[i];
          A = b.x - a.x;
          B = b.y - a.y;
          G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
          if (Math.abs(G) > epsilon) {
            open.push(new Triangle(a, b, c));
          }
        }
      }
      Array.prototype.push.apply(closed, open);
      i = closed.length;
      while (i--) {
        if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
          closed.splice(i, 1);
        }
      }
      return closed;
    }
  }
});

// node_modules/@turf/clone/dist/js/index.js
var require_js11 = __commonJS({
  "node_modules/@turf/clone/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function clone(geojson) {
      if (!geojson) {
        throw new Error("geojson is required");
      }
      switch (geojson.type) {
        case "Feature":
          return cloneFeature(geojson);
        case "FeatureCollection":
          return cloneFeatureCollection(geojson);
        case "Point":
        case "LineString":
        case "Polygon":
        case "MultiPoint":
        case "MultiLineString":
        case "MultiPolygon":
        case "GeometryCollection":
          return cloneGeometry(geojson);
        default:
          throw new Error("unknown GeoJSON type");
      }
    }
    function cloneFeature(geojson) {
      var cloned = { type: "Feature" };
      Object.keys(geojson).forEach(function(key) {
        switch (key) {
          case "type":
          case "properties":
          case "geometry":
            return;
          default:
            cloned[key] = geojson[key];
        }
      });
      cloned.properties = cloneProperties(geojson.properties);
      cloned.geometry = cloneGeometry(geojson.geometry);
      return cloned;
    }
    function cloneProperties(properties) {
      var cloned = {};
      if (!properties) {
        return cloned;
      }
      Object.keys(properties).forEach(function(key) {
        var value = properties[key];
        if (typeof value === "object") {
          if (value === null) {
            cloned[key] = null;
          } else if (Array.isArray(value)) {
            cloned[key] = value.map(function(item) {
              return item;
            });
          } else {
            cloned[key] = cloneProperties(value);
          }
        } else {
          cloned[key] = value;
        }
      });
      return cloned;
    }
    function cloneFeatureCollection(geojson) {
      var cloned = { type: "FeatureCollection" };
      Object.keys(geojson).forEach(function(key) {
        switch (key) {
          case "type":
          case "features":
            return;
          default:
            cloned[key] = geojson[key];
        }
      });
      cloned.features = geojson.features.map(function(feature) {
        return cloneFeature(feature);
      });
      return cloned;
    }
    function cloneGeometry(geometry) {
      var geom = { type: geometry.type };
      if (geometry.bbox) {
        geom.bbox = geometry.bbox;
      }
      if (geometry.type === "GeometryCollection") {
        geom.geometries = geometry.geometries.map(function(g) {
          return cloneGeometry(g);
        });
        return geom;
      }
      geom.coordinates = deepSlice(geometry.coordinates);
      return geom;
    }
    function deepSlice(coords) {
      var cloned = coords;
      if (typeof cloned[0] !== "object") {
        return cloned.slice();
      }
      return cloned.map(function(coord) {
        return deepSlice(coord);
      });
    }
    exports2.default = clone;
  }
});

// node_modules/@turf/concave/dist/js/lib/turf-line-dissolve.js
var require_turf_line_dissolve = __commonJS({
  "node_modules/@turf/concave/dist/js/lib/turf-line-dissolve.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var clone_1 = __importDefault(require_js11());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    function lineDissolve(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      options = options || {};
      if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
      }
      var mutate = options.mutate;
      if (invariant_1.getType(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
      }
      if (!geojson.features.length) {
        throw new Error("geojson is empty");
      }
      if (mutate === false || mutate === void 0) {
        geojson = clone_1.default(geojson);
      }
      var result2 = [];
      var lastLine = meta_1.lineReduce(geojson, function(previousLine, currentLine) {
        var merged = mergeLineStrings(previousLine, currentLine);
        if (merged) {
          return merged;
        } else {
          result2.push(previousLine);
          return currentLine;
        }
      });
      if (lastLine) {
        result2.push(lastLine);
      }
      if (!result2.length) {
        return null;
      } else if (result2.length === 1) {
        return result2[0];
      } else {
        return helpers_1.multiLineString(result2.map(function(line) {
          return line.coordinates;
        }));
      }
    }
    function coordId(coord) {
      return coord[0].toString() + "," + coord[1].toString();
    }
    function mergeLineStrings(a, b) {
      var coords1 = a.geometry.coordinates;
      var coords2 = b.geometry.coordinates;
      var s1 = coordId(coords1[0]);
      var e1 = coordId(coords1[coords1.length - 1]);
      var s2 = coordId(coords2[0]);
      var e2 = coordId(coords2[coords2.length - 1]);
      var coords;
      if (s1 === e2) {
        coords = coords2.concat(coords1.slice(1));
      } else if (s2 === e1) {
        coords = coords1.concat(coords2.slice(1));
      } else if (s1 === s2) {
        coords = coords1.slice(1).reverse().concat(coords2);
      } else if (e1 === e2) {
        coords = coords1.concat(coords2.reverse().slice(1));
      } else {
        return null;
      }
      return helpers_1.lineString(coords);
    }
    exports2.default = lineDissolve;
  }
});

// node_modules/topojson-client/dist/topojson-client.js
var require_topojson_client = __commonJS({
  "node_modules/topojson-client/dist/topojson-client.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.topojson = global2.topojson || {}));
    })(exports2, function(exports3) {
      "use strict";
      function identity(x) {
        return x;
      }
      function transform(transform2) {
        if (transform2 == null) return identity;
        var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
        return function(input, i) {
          if (!i) x0 = y0 = 0;
          var j = 2, n = input.length, output = new Array(n);
          output[0] = (x0 += input[0]) * kx + dx;
          output[1] = (y0 += input[1]) * ky + dy;
          while (j < n) output[j] = input[j], ++j;
          return output;
        };
      }
      function bbox(topology) {
        var t = transform(topology.transform), key, x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;
        function bboxPoint(p) {
          p = t(p);
          if (p[0] < x0) x0 = p[0];
          if (p[0] > x1) x1 = p[0];
          if (p[1] < y0) y0 = p[1];
          if (p[1] > y1) y1 = p[1];
        }
        function bboxGeometry(o) {
          switch (o.type) {
            case "GeometryCollection":
              o.geometries.forEach(bboxGeometry);
              break;
            case "Point":
              bboxPoint(o.coordinates);
              break;
            case "MultiPoint":
              o.coordinates.forEach(bboxPoint);
              break;
          }
        }
        topology.arcs.forEach(function(arc) {
          var i = -1, n = arc.length, p;
          while (++i < n) {
            p = t(arc[i], i);
            if (p[0] < x0) x0 = p[0];
            if (p[0] > x1) x1 = p[0];
            if (p[1] < y0) y0 = p[1];
            if (p[1] > y1) y1 = p[1];
          }
        });
        for (key in topology.objects) {
          bboxGeometry(topology.objects[key]);
        }
        return [x0, y0, x1, y1];
      }
      function reverse(array, n) {
        var t, j = array.length, i = j - n;
        while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
      }
      function feature(topology, o) {
        if (typeof o === "string") o = topology.objects[o];
        return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
          return feature$1(topology, o2);
        }) } : feature$1(topology, o);
      }
      function feature$1(topology, o) {
        var id = o.id, bbox2 = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
        return id == null && bbox2 == null ? { type: "Feature", properties, geometry } : bbox2 == null ? { type: "Feature", id, properties, geometry } : { type: "Feature", id, bbox: bbox2, properties, geometry };
      }
      function object(topology, o) {
        var transformPoint = transform(topology.transform), arcs = topology.arcs;
        function arc(i, points) {
          if (points.length) points.pop();
          for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
            points.push(transformPoint(a[k], k));
          }
          if (i < 0) reverse(points, n);
        }
        function point(p) {
          return transformPoint(p);
        }
        function line(arcs2) {
          var points = [];
          for (var i = 0, n = arcs2.length; i < n; ++i) arc(arcs2[i], points);
          if (points.length < 2) points.push(points[0]);
          return points;
        }
        function ring(arcs2) {
          var points = line(arcs2);
          while (points.length < 4) points.push(points[0]);
          return points;
        }
        function polygon(arcs2) {
          return arcs2.map(ring);
        }
        function geometry(o2) {
          var type = o2.type, coordinates;
          switch (type) {
            case "GeometryCollection":
              return { type, geometries: o2.geometries.map(geometry) };
            case "Point":
              coordinates = point(o2.coordinates);
              break;
            case "MultiPoint":
              coordinates = o2.coordinates.map(point);
              break;
            case "LineString":
              coordinates = line(o2.arcs);
              break;
            case "MultiLineString":
              coordinates = o2.arcs.map(line);
              break;
            case "Polygon":
              coordinates = polygon(o2.arcs);
              break;
            case "MultiPolygon":
              coordinates = o2.arcs.map(polygon);
              break;
            default:
              return null;
          }
          return { type, coordinates };
        }
        return geometry(o);
      }
      function stitch(topology, arcs) {
        var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
        arcs.forEach(function(i, j) {
          var arc = topology.arcs[i < 0 ? ~i : i], t;
          if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
            t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
          }
        });
        arcs.forEach(function(i) {
          var e = ends(i), start = e[0], end = e[1], f, g;
          if (f = fragmentByEnd[start]) {
            delete fragmentByEnd[f.end];
            f.push(i);
            f.end = end;
            if (g = fragmentByStart[end]) {
              delete fragmentByStart[g.start];
              var fg = g === f ? f : f.concat(g);
              fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
          } else if (f = fragmentByStart[end]) {
            delete fragmentByStart[f.start];
            f.unshift(i);
            f.start = start;
            if (g = fragmentByEnd[start]) {
              delete fragmentByEnd[g.end];
              var gf = g === f ? f : g.concat(f);
              fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
          } else {
            f = [i];
            fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
          }
        });
        function ends(i) {
          var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
          if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
            p1[0] += dp[0], p1[1] += dp[1];
          });
          else p1 = arc[arc.length - 1];
          return i < 0 ? [p1, p0] : [p0, p1];
        }
        function flush(fragmentByEnd2, fragmentByStart2) {
          for (var k in fragmentByEnd2) {
            var f = fragmentByEnd2[k];
            delete fragmentByStart2[f.start];
            delete f.start;
            delete f.end;
            f.forEach(function(i) {
              stitchedArcs[i < 0 ? ~i : i] = 1;
            });
            fragments.push(f);
          }
        }
        flush(fragmentByEnd, fragmentByStart);
        flush(fragmentByStart, fragmentByEnd);
        arcs.forEach(function(i) {
          if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
        });
        return fragments;
      }
      function mesh(topology) {
        return object(topology, meshArcs.apply(this, arguments));
      }
      function meshArcs(topology, object2, filter) {
        var arcs, i, n;
        if (arguments.length > 1) arcs = extractArcs(topology, object2, filter);
        else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
        return { type: "MultiLineString", arcs: stitch(topology, arcs) };
      }
      function extractArcs(topology, object2, filter) {
        var arcs = [], geomsByArc = [], geom;
        function extract0(i) {
          var j = i < 0 ? ~i : i;
          (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
        }
        function extract1(arcs2) {
          arcs2.forEach(extract0);
        }
        function extract2(arcs2) {
          arcs2.forEach(extract1);
        }
        function extract3(arcs2) {
          arcs2.forEach(extract2);
        }
        function geometry(o) {
          switch (geom = o, o.type) {
            case "GeometryCollection":
              o.geometries.forEach(geometry);
              break;
            case "LineString":
              extract1(o.arcs);
              break;
            case "MultiLineString":
            case "Polygon":
              extract2(o.arcs);
              break;
            case "MultiPolygon":
              extract3(o.arcs);
              break;
          }
        }
        geometry(object2);
        geomsByArc.forEach(filter == null ? function(geoms) {
          arcs.push(geoms[0].i);
        } : function(geoms) {
          if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
        });
        return arcs;
      }
      function planarRingArea(ring) {
        var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
        while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
        return Math.abs(area);
      }
      function merge(topology) {
        return object(topology, mergeArcs.apply(this, arguments));
      }
      function mergeArcs(topology, objects) {
        var polygonsByArc = {}, polygons = [], groups = [];
        objects.forEach(geometry);
        function geometry(o) {
          switch (o.type) {
            case "GeometryCollection":
              o.geometries.forEach(geometry);
              break;
            case "Polygon":
              extract(o.arcs);
              break;
            case "MultiPolygon":
              o.arcs.forEach(extract);
              break;
          }
        }
        function extract(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
            });
          });
          polygons.push(polygon);
        }
        function area(ring) {
          return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
        }
        polygons.forEach(function(polygon) {
          if (!polygon._) {
            var group = [], neighbors2 = [polygon];
            polygon._ = 1;
            groups.push(group);
            while (polygon = neighbors2.pop()) {
              group.push(polygon);
              polygon.forEach(function(ring) {
                ring.forEach(function(arc) {
                  polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
                    if (!polygon2._) {
                      polygon2._ = 1;
                      neighbors2.push(polygon2);
                    }
                  });
                });
              });
            }
          }
        });
        polygons.forEach(function(polygon) {
          delete polygon._;
        });
        return {
          type: "MultiPolygon",
          arcs: groups.map(function(polygons2) {
            var arcs = [], n;
            polygons2.forEach(function(polygon) {
              polygon.forEach(function(ring) {
                ring.forEach(function(arc) {
                  if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                    arcs.push(arc);
                  }
                });
              });
            });
            arcs = stitch(topology, arcs);
            if ((n = arcs.length) > 1) {
              for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
                if ((ki = area(arcs[i])) > k) {
                  t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
                }
              }
            }
            return arcs;
          }).filter(function(arcs) {
            return arcs.length > 0;
          })
        };
      }
      function bisect(a, x) {
        var lo = 0, hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (a[mid] < x) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      }
      function neighbors(objects) {
        var indexesByArc = {}, neighbors2 = objects.map(function() {
          return [];
        });
        function line(arcs, i2) {
          arcs.forEach(function(a) {
            if (a < 0) a = ~a;
            var o = indexesByArc[a];
            if (o) o.push(i2);
            else indexesByArc[a] = [i2];
          });
        }
        function polygon(arcs, i2) {
          arcs.forEach(function(arc) {
            line(arc, i2);
          });
        }
        function geometry(o, i2) {
          if (o.type === "GeometryCollection") o.geometries.forEach(function(o2) {
            geometry(o2, i2);
          });
          else if (o.type in geometryType) geometryType[o.type](o.arcs, i2);
        }
        var geometryType = {
          LineString: line,
          MultiLineString: polygon,
          Polygon: polygon,
          MultiPolygon: function(arcs, i2) {
            arcs.forEach(function(arc) {
              polygon(arc, i2);
            });
          }
        };
        objects.forEach(geometry);
        for (var i in indexesByArc) {
          for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
            for (var k = j + 1; k < m; ++k) {
              var ij = indexes[j], ik = indexes[k], n;
              if ((n = neighbors2[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
              if ((n = neighbors2[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
            }
          }
        }
        return neighbors2;
      }
      function untransform(transform2) {
        if (transform2 == null) return identity;
        var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
        return function(input, i) {
          if (!i) x0 = y0 = 0;
          var j = 2, n = input.length, output = new Array(n), x1 = Math.round((input[0] - dx) / kx), y1 = Math.round((input[1] - dy) / ky);
          output[0] = x1 - x0, x0 = x1;
          output[1] = y1 - y0, y0 = y1;
          while (j < n) output[j] = input[j], ++j;
          return output;
        };
      }
      function quantize(topology, transform2) {
        if (topology.transform) throw new Error("already quantized");
        if (!transform2 || !transform2.scale) {
          if (!((n = Math.floor(transform2)) >= 2)) throw new Error("n must be \u22652");
          box = topology.bbox || bbox(topology);
          var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
          transform2 = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };
        } else {
          box = topology.bbox;
        }
        var t = untransform(transform2), box, key, inputs = topology.objects, outputs = {};
        function quantizePoint(point) {
          return t(point);
        }
        function quantizeGeometry(input) {
          var output;
          switch (input.type) {
            case "GeometryCollection":
              output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
              break;
            case "Point":
              output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
              break;
            case "MultiPoint":
              output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
              break;
            default:
              return input;
          }
          if (input.id != null) output.id = input.id;
          if (input.bbox != null) output.bbox = input.bbox;
          if (input.properties != null) output.properties = input.properties;
          return output;
        }
        function quantizeArc(input) {
          var i = 0, j = 1, n2 = input.length, p, output = new Array(n2);
          output[0] = t(input[0], 0);
          while (++i < n2) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p;
          if (j === 1) output[j++] = [0, 0];
          output.length = j;
          return output;
        }
        for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);
        return {
          type: "Topology",
          bbox: box,
          transform: transform2,
          objects: outputs,
          arcs: topology.arcs.map(quantizeArc)
        };
      }
      exports3.bbox = bbox;
      exports3.feature = feature;
      exports3.merge = merge;
      exports3.mergeArcs = mergeArcs;
      exports3.mesh = mesh;
      exports3.meshArcs = meshArcs;
      exports3.neighbors = neighbors;
      exports3.quantize = quantize;
      exports3.transform = transform;
      exports3.untransform = untransform;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/topojson-server/dist/topojson-server.js
var require_topojson_server = __commonJS({
  "node_modules/topojson-server/dist/topojson-server.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.topojson = global2.topojson || {}));
    })(exports2, function(exports3) {
      "use strict";
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function bounds(objects) {
        var x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
        function boundGeometry(geometry2) {
          if (geometry2 != null && hasOwnProperty.call(boundGeometryType, geometry2.type)) boundGeometryType[geometry2.type](geometry2);
        }
        var boundGeometryType = {
          GeometryCollection: function(o) {
            o.geometries.forEach(boundGeometry);
          },
          Point: function(o) {
            boundPoint(o.coordinates);
          },
          MultiPoint: function(o) {
            o.coordinates.forEach(boundPoint);
          },
          LineString: function(o) {
            boundLine(o.arcs);
          },
          MultiLineString: function(o) {
            o.arcs.forEach(boundLine);
          },
          Polygon: function(o) {
            o.arcs.forEach(boundLine);
          },
          MultiPolygon: function(o) {
            o.arcs.forEach(boundMultiLine);
          }
        };
        function boundPoint(coordinates) {
          var x = coordinates[0], y = coordinates[1];
          if (x < x0) x0 = x;
          if (x > x1) x1 = x;
          if (y < y0) y0 = y;
          if (y > y1) y1 = y;
        }
        function boundLine(coordinates) {
          coordinates.forEach(boundPoint);
        }
        function boundMultiLine(coordinates) {
          coordinates.forEach(boundLine);
        }
        for (var key in objects) {
          boundGeometry(objects[key]);
        }
        return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : void 0;
      }
      function hashset(size, hash, equal, type, empty) {
        if (arguments.length === 3) {
          type = Array;
          empty = null;
        }
        var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), mask = size - 1;
        for (var i = 0; i < size; ++i) {
          store[i] = empty;
        }
        function add(value) {
          var index = hash(value) & mask, match = store[index], collisions = 0;
          while (match != empty) {
            if (equal(match, value)) return true;
            if (++collisions >= size) throw new Error("full hashset");
            match = store[index = index + 1 & mask];
          }
          store[index] = value;
          return true;
        }
        function has(value) {
          var index = hash(value) & mask, match = store[index], collisions = 0;
          while (match != empty) {
            if (equal(match, value)) return true;
            if (++collisions >= size) break;
            match = store[index = index + 1 & mask];
          }
          return false;
        }
        function values() {
          var values2 = [];
          for (var i2 = 0, n = store.length; i2 < n; ++i2) {
            var match = store[i2];
            if (match != empty) values2.push(match);
          }
          return values2;
        }
        return {
          add,
          has,
          values
        };
      }
      function hashmap(size, hash, equal, keyType, keyEmpty, valueType) {
        if (arguments.length === 3) {
          keyType = valueType = Array;
          keyEmpty = null;
        }
        var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), valstore = new valueType(size), mask = size - 1;
        for (var i = 0; i < size; ++i) {
          keystore[i] = keyEmpty;
        }
        function set(key, value) {
          var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
          while (matchKey != keyEmpty) {
            if (equal(matchKey, key)) return valstore[index] = value;
            if (++collisions >= size) throw new Error("full hashmap");
            matchKey = keystore[index = index + 1 & mask];
          }
          keystore[index] = key;
          valstore[index] = value;
          return value;
        }
        function maybeSet(key, value) {
          var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
          while (matchKey != keyEmpty) {
            if (equal(matchKey, key)) return valstore[index];
            if (++collisions >= size) throw new Error("full hashmap");
            matchKey = keystore[index = index + 1 & mask];
          }
          keystore[index] = key;
          valstore[index] = value;
          return value;
        }
        function get2(key, missingValue) {
          var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
          while (matchKey != keyEmpty) {
            if (equal(matchKey, key)) return valstore[index];
            if (++collisions >= size) break;
            matchKey = keystore[index = index + 1 & mask];
          }
          return missingValue;
        }
        function keys() {
          var keys2 = [];
          for (var i2 = 0, n = keystore.length; i2 < n; ++i2) {
            var matchKey = keystore[i2];
            if (matchKey != keyEmpty) keys2.push(matchKey);
          }
          return keys2;
        }
        return {
          set,
          maybeSet,
          // set if unset
          get: get2,
          keys
        };
      }
      function equalPoint(pointA, pointB) {
        return pointA[0] === pointB[0] && pointA[1] === pointB[1];
      }
      var buffer = new ArrayBuffer(16), floats = new Float64Array(buffer), uints = new Uint32Array(buffer);
      function hashPoint(point) {
        floats[0] = point[0];
        floats[1] = point[1];
        var hash = uints[0] ^ uints[1];
        hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
        return hash & 2147483647;
      }
      function join(topology2) {
        var coordinates = topology2.coordinates, lines = topology2.lines, rings = topology2.rings, indexes = index(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i, n, previousIndex, currentIndex, nextIndex;
        for (i = 0, n = coordinates.length; i < n; ++i) {
          visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
        }
        for (i = 0, n = lines.length; i < n; ++i) {
          var line = lines[i], lineStart = line[0], lineEnd = line[1];
          currentIndex = indexes[lineStart];
          nextIndex = indexes[++lineStart];
          ++junctionCount, junctionByIndex[currentIndex] = 1;
          while (++lineStart <= lineEnd) {
            sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
          }
          ++junctionCount, junctionByIndex[nextIndex] = 1;
        }
        for (i = 0, n = coordinates.length; i < n; ++i) {
          visitedByIndex[i] = -1;
        }
        for (i = 0, n = rings.length; i < n; ++i) {
          var ring = rings[i], ringStart = ring[0] + 1, ringEnd = ring[1];
          previousIndex = indexes[ringEnd - 1];
          currentIndex = indexes[ringStart - 1];
          nextIndex = indexes[ringStart];
          sequence(i, previousIndex, currentIndex, nextIndex);
          while (++ringStart <= ringEnd) {
            sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
          }
        }
        function sequence(i2, previousIndex2, currentIndex2, nextIndex2) {
          if (visitedByIndex[currentIndex2] === i2) return;
          visitedByIndex[currentIndex2] = i2;
          var leftIndex = leftByIndex[currentIndex2];
          if (leftIndex >= 0) {
            var rightIndex = rightByIndex[currentIndex2];
            if ((leftIndex !== previousIndex2 || rightIndex !== nextIndex2) && (leftIndex !== nextIndex2 || rightIndex !== previousIndex2)) {
              ++junctionCount, junctionByIndex[currentIndex2] = 1;
            }
          } else {
            leftByIndex[currentIndex2] = previousIndex2;
            rightByIndex[currentIndex2] = nextIndex2;
          }
        }
        function index() {
          var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes2 = new Int32Array(coordinates.length);
          for (var i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
            indexes2[i2] = indexByPoint.maybeSet(i2, i2);
          }
          return indexes2;
        }
        function hashIndex(i2) {
          return hashPoint(coordinates[i2]);
        }
        function equalIndex(i2, j2) {
          return equalPoint(coordinates[i2], coordinates[j2]);
        }
        visitedByIndex = leftByIndex = rightByIndex = null;
        var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;
        for (i = 0, n = coordinates.length; i < n; ++i) {
          if (junctionByIndex[j = indexes[i]]) {
            junctionByPoint.add(coordinates[j]);
          }
        }
        return junctionByPoint;
      }
      function cut(topology2) {
        var junctions = join(topology2), coordinates = topology2.coordinates, lines = topology2.lines, rings = topology2.rings, next, i, n;
        for (i = 0, n = lines.length; i < n; ++i) {
          var line = lines[i], lineMid = line[0], lineEnd = line[1];
          while (++lineMid < lineEnd) {
            if (junctions.has(coordinates[lineMid])) {
              next = { 0: lineMid, 1: line[1] };
              line[1] = lineMid;
              line = line.next = next;
            }
          }
        }
        for (i = 0, n = rings.length; i < n; ++i) {
          var ring = rings[i], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
          while (++ringMid < ringEnd) {
            if (junctions.has(coordinates[ringMid])) {
              if (ringFixed) {
                next = { 0: ringMid, 1: ring[1] };
                ring[1] = ringMid;
                ring = ring.next = next;
              } else {
                rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
                coordinates[ringEnd] = coordinates[ringStart];
                ringFixed = true;
                ringMid = ringStart;
              }
            }
          }
        }
        return topology2;
      }
      function rotateArray(array, start, end, offset) {
        reverse(array, start, end);
        reverse(array, start, start + offset);
        reverse(array, start + offset, end);
      }
      function reverse(array, start, end) {
        for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {
          t = array[start], array[start] = array[end], array[end] = t;
        }
      }
      function dedup(topology2) {
        var coordinates = topology2.coordinates, lines = topology2.lines, line, rings = topology2.rings, ring, arcCount = lines.length + rings.length, i, n;
        delete topology2.lines;
        delete topology2.rings;
        for (i = 0, n = lines.length; i < n; ++i) {
          line = lines[i];
          while (line = line.next) ++arcCount;
        }
        for (i = 0, n = rings.length; i < n; ++i) {
          ring = rings[i];
          while (ring = ring.next) ++arcCount;
        }
        var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint), arcs = topology2.arcs = [];
        for (i = 0, n = lines.length; i < n; ++i) {
          line = lines[i];
          do {
            dedupLine(line);
          } while (line = line.next);
        }
        for (i = 0, n = rings.length; i < n; ++i) {
          ring = rings[i];
          if (ring.next) {
            do {
              dedupLine(ring);
            } while (ring = ring.next);
          } else {
            dedupRing(ring);
          }
        }
        function dedupLine(arc) {
          var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i2, n2;
          if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
            for (i2 = 0, n2 = startArcs.length; i2 < n2; ++i2) {
              startArc = startArcs[i2];
              if (equalLine(startArc, arc)) {
                arc[0] = startArc[0];
                arc[1] = startArc[1];
                return;
              }
            }
          }
          if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
            for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
              endArc = endArcs[i2];
              if (reverseEqualLine(endArc, arc)) {
                arc[1] = endArc[0];
                arc[0] = endArc[1];
                return;
              }
            }
          }
          if (startArcs) startArcs.push(arc);
          else arcsByEnd.set(startPoint, [arc]);
          if (endArcs) endArcs.push(arc);
          else arcsByEnd.set(endPoint, [arc]);
          arcs.push(arc);
        }
        function dedupRing(arc) {
          var endPoint, endArcs, endArc, i2, n2;
          if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
            for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
              endArc = endArcs[i2];
              if (equalRing(endArc, arc)) {
                arc[0] = endArc[0];
                arc[1] = endArc[1];
                return;
              }
              if (reverseEqualRing(endArc, arc)) {
                arc[0] = endArc[1];
                arc[1] = endArc[0];
                return;
              }
            }
          }
          if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
            for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
              endArc = endArcs[i2];
              if (equalRing(endArc, arc)) {
                arc[0] = endArc[0];
                arc[1] = endArc[1];
                return;
              }
              if (reverseEqualRing(endArc, arc)) {
                arc[0] = endArc[1];
                arc[1] = endArc[0];
                return;
              }
            }
          }
          if (endArcs) endArcs.push(arc);
          else arcsByEnd.set(endPoint, [arc]);
          arcs.push(arc);
        }
        function equalLine(arcA, arcB) {
          var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
          if (ia - ja !== ib - jb) return false;
          for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;
          return true;
        }
        function reverseEqualLine(arcA, arcB) {
          var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
          if (ia - ja !== ib - jb) return false;
          for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;
          return true;
        }
        function equalRing(arcA, arcB) {
          var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
          if (n2 !== jb - ib) return false;
          var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
          for (var i2 = 0; i2 < n2; ++i2) {
            if (!equalPoint(coordinates[ia + (i2 + ka) % n2], coordinates[ib + (i2 + kb) % n2])) return false;
          }
          return true;
        }
        function reverseEqualRing(arcA, arcB) {
          var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
          if (n2 !== jb - ib) return false;
          var ka = findMinimumOffset(arcA), kb = n2 - findMinimumOffset(arcB);
          for (var i2 = 0; i2 < n2; ++i2) {
            if (!equalPoint(coordinates[ia + (i2 + ka) % n2], coordinates[jb - (i2 + kb) % n2])) return false;
          }
          return true;
        }
        function findMinimumOffset(arc) {
          var start = arc[0], end = arc[1], mid = start, minimum = mid, minimumPoint = coordinates[mid];
          while (++mid < end) {
            var point = coordinates[mid];
            if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
              minimum = mid;
              minimumPoint = point;
            }
          }
          return minimum - start;
        }
        return topology2;
      }
      function delta(arcs) {
        var i = -1, n = arcs.length;
        while (++i < n) {
          var arc = arcs[i], j = 0, k = 1, m = arc.length, point = arc[0], x0 = point[0], y0 = point[1], x1, y1;
          while (++j < m) {
            point = arc[j], x1 = point[0], y1 = point[1];
            if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
          }
          if (k === 1) arc[k++] = [0, 0];
          arc.length = k;
        }
        return arcs;
      }
      function extract(objects) {
        var index = -1, lines = [], rings = [], coordinates = [];
        function extractGeometry(geometry2) {
          if (geometry2 && hasOwnProperty.call(extractGeometryType, geometry2.type)) extractGeometryType[geometry2.type](geometry2);
        }
        var extractGeometryType = {
          GeometryCollection: function(o) {
            o.geometries.forEach(extractGeometry);
          },
          LineString: function(o) {
            o.arcs = extractLine(o.arcs);
          },
          MultiLineString: function(o) {
            o.arcs = o.arcs.map(extractLine);
          },
          Polygon: function(o) {
            o.arcs = o.arcs.map(extractRing);
          },
          MultiPolygon: function(o) {
            o.arcs = o.arcs.map(extractMultiRing);
          }
        };
        function extractLine(line) {
          for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];
          var arc = { 0: index - n + 1, 1: index };
          lines.push(arc);
          return arc;
        }
        function extractRing(ring) {
          for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];
          var arc = { 0: index - n + 1, 1: index };
          rings.push(arc);
          return arc;
        }
        function extractMultiRing(rings2) {
          return rings2.map(extractRing);
        }
        for (var key in objects) {
          extractGeometry(objects[key]);
        }
        return {
          type: "Topology",
          coordinates,
          lines,
          rings,
          objects
        };
      }
      function geometry(inputs) {
        var outputs = {}, key;
        for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
        return outputs;
      }
      function geomifyObject(input) {
        return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
      }
      function geomifyFeatureCollection(input) {
        var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
        if (input.bbox != null) output.bbox = input.bbox;
        return output;
      }
      function geomifyFeature(input) {
        var output = geomifyGeometry(input.geometry), key;
        if (input.id != null) output.id = input.id;
        if (input.bbox != null) output.bbox = input.bbox;
        for (key in input.properties) {
          output.properties = input.properties;
          break;
        }
        return output;
      }
      function geomifyGeometry(input) {
        if (input == null) return { type: null };
        var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };
        if (input.bbox != null) output.bbox = input.bbox;
        return output;
      }
      function prequantize(objects, bbox, n) {
        var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3], kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1, ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;
        function quantizePoint(input) {
          return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
        }
        function quantizePoints(input, m) {
          var i = -1, j = 0, n2 = input.length, output = new Array(n2), pi, px, py, x, y;
          while (++i < n2) {
            pi = input[i];
            x = Math.round((pi[0] - x0) * kx);
            y = Math.round((pi[1] - y0) * ky);
            if (x !== px || y !== py) output[j++] = [px = x, py = y];
          }
          output.length = j;
          while (j < m) j = output.push([output[0][0], output[0][1]]);
          return output;
        }
        function quantizeLine(input) {
          return quantizePoints(input, 2);
        }
        function quantizeRing(input) {
          return quantizePoints(input, 4);
        }
        function quantizePolygon(input) {
          return input.map(quantizeRing);
        }
        function quantizeGeometry(o) {
          if (o != null && hasOwnProperty.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);
        }
        var quantizeGeometryType = {
          GeometryCollection: function(o) {
            o.geometries.forEach(quantizeGeometry);
          },
          Point: function(o) {
            o.coordinates = quantizePoint(o.coordinates);
          },
          MultiPoint: function(o) {
            o.coordinates = o.coordinates.map(quantizePoint);
          },
          LineString: function(o) {
            o.arcs = quantizeLine(o.arcs);
          },
          MultiLineString: function(o) {
            o.arcs = o.arcs.map(quantizeLine);
          },
          Polygon: function(o) {
            o.arcs = quantizePolygon(o.arcs);
          },
          MultiPolygon: function(o) {
            o.arcs = o.arcs.map(quantizePolygon);
          }
        };
        for (var key in objects) {
          quantizeGeometry(objects[key]);
        }
        return {
          scale: [1 / kx, 1 / ky],
          translate: [x0, y0]
        };
      }
      function topology(objects, quantization) {
        var bbox = bounds(objects = geometry(objects)), transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization), topology2 = dedup(cut(extract(objects))), coordinates = topology2.coordinates, indexByArc = hashmap(topology2.arcs.length * 1.4, hashArc, equalArc);
        objects = topology2.objects;
        topology2.bbox = bbox;
        topology2.arcs = topology2.arcs.map(function(arc, i) {
          indexByArc.set(arc, i);
          return coordinates.slice(arc[0], arc[1] + 1);
        });
        delete topology2.coordinates;
        coordinates = null;
        function indexGeometry(geometry2) {
          if (geometry2 && hasOwnProperty.call(indexGeometryType, geometry2.type)) indexGeometryType[geometry2.type](geometry2);
        }
        var indexGeometryType = {
          GeometryCollection: function(o) {
            o.geometries.forEach(indexGeometry);
          },
          LineString: function(o) {
            o.arcs = indexArcs(o.arcs);
          },
          MultiLineString: function(o) {
            o.arcs = o.arcs.map(indexArcs);
          },
          Polygon: function(o) {
            o.arcs = o.arcs.map(indexArcs);
          },
          MultiPolygon: function(o) {
            o.arcs = o.arcs.map(indexMultiArcs);
          }
        };
        function indexArcs(arc) {
          var indexes = [];
          do {
            var index = indexByArc.get(arc);
            indexes.push(arc[0] < arc[1] ? index : ~index);
          } while (arc = arc.next);
          return indexes;
        }
        function indexMultiArcs(arcs) {
          return arcs.map(indexArcs);
        }
        for (var key in objects) {
          indexGeometry(objects[key]);
        }
        if (transform) {
          topology2.transform = transform;
          topology2.arcs = delta(topology2.arcs);
        }
        return topology2;
      }
      function hashArc(arc) {
        var i = arc[0], j = arc[1], t;
        if (j < i) t = i, i = j, j = t;
        return i + 31 * j;
      }
      function equalArc(arcA, arcB) {
        var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t;
        if (ja < ia) t = ia, ia = ja, ja = t;
        if (jb < ib) t = ib, ib = jb, jb = t;
        return ia === ib && ja === jb;
      }
      exports3.topology = topology;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@turf/concave/dist/js/lib/turf-polygon-dissolve.js
var require_turf_polygon_dissolve = __commonJS({
  "node_modules/@turf/concave/dist/js/lib/turf-polygon-dissolve.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var clone_1 = __importDefault(require_js11());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    var topojson_client_1 = require_topojson_client();
    var topojson_server_1 = require_topojson_server();
    function polygonDissolve(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      if (invariant_1.getType(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
      }
      if (!geojson.features.length) {
        throw new Error("geojson is empty");
      }
      if (options.mutate === false || options.mutate === void 0) {
        geojson = clone_1.default(geojson);
      }
      var geoms = [];
      meta_1.flattenEach(geojson, function(feature) {
        geoms.push(feature.geometry);
      });
      var topo = topojson_server_1.topology({ geoms: helpers_1.geometryCollection(geoms).geometry });
      var merged = topojson_client_1.merge(topo, topo.objects.geoms.geometries);
      return merged;
    }
    exports2.default = polygonDissolve;
  }
});

// node_modules/@turf/concave/dist/js/lib/turf-dissolve.js
var require_turf_dissolve = __commonJS({
  "node_modules/@turf/concave/dist/js/lib/turf-dissolve.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var clone_1 = __importDefault(require_js11());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    var turf_line_dissolve_1 = __importDefault(require_turf_line_dissolve());
    var turf_polygon_dissolve_1 = __importDefault(require_turf_polygon_dissolve());
    function dissolve(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      options = options || {};
      if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
      }
      var mutate = options.mutate;
      if (invariant_1.getType(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
      }
      if (!geojson.features.length) {
        throw new Error("geojson is empty");
      }
      if (mutate === false || mutate === void 0) {
        geojson = clone_1.default(geojson);
      }
      var type = getHomogenousType(geojson);
      if (!type) {
        throw new Error("geojson must be homogenous");
      }
      var data = geojson;
      switch (type) {
        case "LineString":
          return turf_line_dissolve_1.default(data, options);
        case "Polygon":
          return turf_polygon_dissolve_1.default(data, options);
        default:
          throw new Error(type + " is not supported");
      }
    }
    function getHomogenousType(geojson) {
      var types = {};
      meta_1.flattenEach(geojson, function(feature) {
        types[feature.geometry.type] = true;
      });
      var keys = Object.keys(types);
      if (keys.length === 1) {
        return keys[0];
      }
      return null;
    }
    exports2.default = dissolve;
  }
});

// node_modules/@turf/concave/dist/js/index.js
var require_js12 = __commonJS({
  "node_modules/@turf/concave/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var distance_1 = __importDefault(require_js9());
    var helpers_1 = require_js();
    var meta_1 = require_js2();
    var tin_1 = __importDefault(require_js10());
    var turf_dissolve_1 = __importDefault(require_turf_dissolve());
    function concave(points, options) {
      if (options === void 0) {
        options = {};
      }
      var maxEdge = options.maxEdge || Infinity;
      var cleaned = removeDuplicates(points);
      var tinPolys = tin_1.default(cleaned);
      tinPolys.features = tinPolys.features.filter(function(triangle) {
        var pt1 = triangle.geometry.coordinates[0][0];
        var pt2 = triangle.geometry.coordinates[0][1];
        var pt3 = triangle.geometry.coordinates[0][2];
        var dist1 = distance_1.default(pt1, pt2, options);
        var dist2 = distance_1.default(pt2, pt3, options);
        var dist3 = distance_1.default(pt1, pt3, options);
        return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
      });
      if (tinPolys.features.length < 1) {
        return null;
      }
      var dissolved = turf_dissolve_1.default(tinPolys);
      if (dissolved.coordinates.length === 1) {
        dissolved.coordinates = dissolved.coordinates[0];
        dissolved.type = "Polygon";
      }
      return helpers_1.feature(dissolved);
    }
    function removeDuplicates(points) {
      var cleaned = [];
      var existing = {};
      meta_1.featureEach(points, function(pt) {
        if (!pt.geometry) {
          return;
        }
        var key = pt.geometry.coordinates.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
          cleaned.push(pt);
          existing[key] = true;
        }
      });
      return helpers_1.featureCollection(cleaned);
    }
    exports2.default = concave;
  }
});

// node_modules/quickselect/quickselect.js
var require_quickselect = __commonJS({
  "node_modules/quickselect/quickselect.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.quickselect = factory();
    })(exports2, function() {
      "use strict";
      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }
      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
          }
          if (compare(arr[left], t) === 0) swap(arr, left, j);
          else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
        }
      }
      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      return quickselect;
    });
  }
});

// node_modules/rbush/index.js
var require_rbush2 = __commonJS({
  "node_modules/rbush/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rbush;
    module2.exports.default = rbush;
    var quickselect = require_quickselect();
    function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format);
      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      if (format) {
        this._initFormat(format);
      }
      this.clear();
    }
    rbush.prototype = {
      all: function() {
        return this._all(this.data, []);
      },
      search: function(bbox) {
        var node = this.data, result2 = [], toBBox = this.toBBox;
        if (!intersects(bbox, node)) return result2;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf) result2.push(child);
              else if (contains(bbox, childBBox)) this._all(child, result2);
              else nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return result2;
      },
      collides: function(bbox) {
        var node = this.data, toBBox = this.toBBox;
        if (!intersects(bbox, node)) return false;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      },
      load: function(data) {
        if (!(data && data.length)) return this;
        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        var node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      },
      insert: function(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function() {
        this.data = createNode([]);
        return this;
      },
      remove: function(item, equalsFn) {
        if (!item) return this;
        var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else node = null;
        }
        return this;
      },
      toBBox: function(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function() {
        return this.data;
      },
      fromJSON: function(data) {
        this.data = data;
        return this;
      },
      _all: function(node, result2) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) result2.push.apply(result2, node.children);
          else nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }
        return result2;
      },
      _build: function(items, left, right, height) {
        var N = right - left + 1, M = this._maxEntries, node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
        multiSelect(items, left, right, N1, this.compareMinX);
        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function(bbox, node, level, path) {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) break;
          minArea = minEnlargement = Infinity;
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area = bboxArea(child);
            enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      },
      _insert: function(item, level, isNode) {
        var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else break;
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      },
      // split overflowed node into two
      _split: function(insertPath, level) {
        var node = insertPath[level], M = node.children.length, m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
      },
      _splitRoot: function(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function(node, m, M) {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
        minOverlap = minArea = Infinity;
        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox2 = distBBox(node, i, M, this.toBBox);
          overlap = intersectionArea(bbox1, bbox2);
          area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin) node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      },
      _adjustParentBBoxes: function(bbox, path, level) {
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      },
      _condense: function(path) {
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else this.clear();
          } else calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function(format) {
        var compareArr = ["return a", " - b", ";"];
        this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
        this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
        this.toBBox = new Function(
          "a",
          "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
        );
      }
    };
    function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);
      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
      }
      return -1;
    }
    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }
    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }
    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }
    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }
    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }
    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }
    function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }
    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }
    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }
    function createNode(children2) {
      return {
        children: children2,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    }
    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right], mid;
      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
  }
});

// node_modules/@turf/collect/dist/js/index.js
var require_js13 = __commonJS({
  "node_modules/@turf/collect/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bbox_1 = __importDefault(require_js3());
    var boolean_point_in_polygon_1 = __importDefault(require_js7());
    var rbush_1 = __importDefault(require_rbush2());
    function collect(polygons, points, inProperty, outProperty) {
      var rtree = rbush_1.default(6);
      var treeItems = points.features.map(function(item) {
        var _a;
        return {
          minX: item.geometry.coordinates[0],
          minY: item.geometry.coordinates[1],
          maxX: item.geometry.coordinates[0],
          maxY: item.geometry.coordinates[1],
          property: (_a = item.properties) === null || _a === void 0 ? void 0 : _a[inProperty]
        };
      });
      rtree.load(treeItems);
      polygons.features.forEach(function(poly) {
        if (!poly.properties) {
          poly.properties = {};
        }
        var bbox = bbox_1.default(poly);
        var potentialPoints = rtree.search({
          minX: bbox[0],
          minY: bbox[1],
          maxX: bbox[2],
          maxY: bbox[3]
        });
        var values = [];
        potentialPoints.forEach(function(pt) {
          if (boolean_point_in_polygon_1.default([pt.minX, pt.minY], poly)) {
            values.push(pt.property);
          }
        });
        poly.properties[outProperty] = values;
      });
      return polygons;
    }
    exports2.default = collect;
  }
});

// node_modules/@turf/flip/dist/js/index.js
var require_js14 = __commonJS({
  "node_modules/@turf/flip/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var helpers = require_js();
    var clone = require_js11();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    function flip(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var mutate = options.mutate;
      if (!geojson) throw new Error("geojson is required");
      if (mutate === false || mutate === void 0) geojson = clone__default["default"](geojson);
      meta.coordEach(geojson, function(coord) {
        var x = coord[0];
        var y = coord[1];
        coord[0] = y;
        coord[1] = x;
      });
      return geojson;
    }
    module2.exports = flip;
    module2.exports.default = flip;
  }
});

// node_modules/@turf/clean-coords/dist/js/index.js
var require_js15 = __commonJS({
  "node_modules/@turf/clean-coords/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function cleanCoords(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      var mutate = typeof options === "object" ? options.mutate : options;
      if (!geojson)
        throw new Error("geojson is required");
      var type = invariant_1.getType(geojson);
      var newCoords = [];
      switch (type) {
        case "LineString":
          newCoords = cleanLine(geojson);
          break;
        case "MultiLineString":
        case "Polygon":
          invariant_1.getCoords(geojson).forEach(function(line) {
            newCoords.push(cleanLine(line));
          });
          break;
        case "MultiPolygon":
          invariant_1.getCoords(geojson).forEach(function(polygons) {
            var polyPoints = [];
            polygons.forEach(function(ring) {
              polyPoints.push(cleanLine(ring));
            });
            newCoords.push(polyPoints);
          });
          break;
        case "Point":
          return geojson;
        case "MultiPoint":
          var existing = {};
          invariant_1.getCoords(geojson).forEach(function(coord) {
            var key = coord.join("-");
            if (!Object.prototype.hasOwnProperty.call(existing, key)) {
              newCoords.push(coord);
              existing[key] = true;
            }
          });
          break;
        default:
          throw new Error(type + " geometry not supported");
      }
      if (geojson.coordinates) {
        if (mutate === true) {
          geojson.coordinates = newCoords;
          return geojson;
        }
        return { type, coordinates: newCoords };
      } else {
        if (mutate === true) {
          geojson.geometry.coordinates = newCoords;
          return geojson;
        }
        return helpers_1.feature({ type, coordinates: newCoords }, geojson.properties, {
          bbox: geojson.bbox,
          id: geojson.id
        });
      }
    }
    function cleanLine(line) {
      var points = invariant_1.getCoords(line);
      if (points.length === 2 && !equals(points[0], points[1]))
        return points;
      var newPoints = [];
      var secondToLast = points.length - 1;
      var newPointsLength = newPoints.length;
      newPoints.push(points[0]);
      for (var i = 1; i < secondToLast; i++) {
        var prevAddedPoint = newPoints[newPoints.length - 1];
        if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1])
          continue;
        else {
          newPoints.push(points[i]);
          newPointsLength = newPoints.length;
          if (newPointsLength > 2) {
            if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
              newPoints.splice(newPoints.length - 2, 1);
          }
        }
      }
      newPoints.push(points[points.length - 1]);
      newPointsLength = newPoints.length;
      if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)
        throw new Error("invalid polygon");
      if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
        newPoints.splice(newPoints.length - 2, 1);
      return newPoints;
    }
    function equals(pt1, pt2) {
      return pt1[0] === pt2[0] && pt1[1] === pt2[1];
    }
    function isPointOnLineSegment(start, end, point) {
      var x = point[0], y = point[1];
      var startX = start[0], startY = start[1];
      var endX = end[0], endY = end[1];
      var dxc = x - startX;
      var dyc = y - startY;
      var dxl = endX - startX;
      var dyl = endY - startY;
      var cross = dxc * dyl - dyc * dxl;
      if (cross !== 0)
        return false;
      else if (Math.abs(dxl) >= Math.abs(dyl))
        return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
      else
        return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
    }
    exports2.default = cleanCoords;
  }
});

// node_modules/@turf/simplify/dist/js/index.js
var require_js16 = __commonJS({
  "node_modules/@turf/simplify/dist/js/index.js"(exports2, module2) {
    "use strict";
    var cleanCoords = require_js15();
    var clone = require_js11();
    var meta = require_js2();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var cleanCoords__default = /* @__PURE__ */ _interopDefaultLegacy(cleanCoords);
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    function getSqDist(p1, p2) {
      var dx = p1.x - p2.x, dy = p1.y - p2.y;
      return dx * dx + dy * dy;
    }
    function getSqSegDist(p, p1, p2) {
      var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
      if (dx !== 0 || dy !== 0) {
        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          x = p2.x;
          y = p2.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }
      dx = p.x - x;
      dy = p.y - y;
      return dx * dx + dy * dy;
    }
    function simplifyRadialDist(points, sqTolerance) {
      var prevPoint = points[0], newPoints = [prevPoint], point;
      for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];
        if (getSqDist(point, prevPoint) > sqTolerance) {
          newPoints.push(point);
          prevPoint = point;
        }
      }
      if (prevPoint !== point) newPoints.push(point);
      return newPoints;
    }
    function simplifyDPStep(points, first, last, sqTolerance, simplified) {
      var maxSqDist = sqTolerance, index;
      for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);
        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }
      if (maxSqDist > sqTolerance) {
        if (index - first > 1)
          simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1)
          simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
    }
    function simplifyDouglasPeucker(points, sqTolerance) {
      var last = points.length - 1;
      var simplified = [points[0]];
      simplifyDPStep(points, 0, last, sqTolerance, simplified);
      simplified.push(points[last]);
      return simplified;
    }
    function simplify(points, tolerance, highestQuality) {
      if (points.length <= 2) return points;
      var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
      points = simplifyDouglasPeucker(points, sqTolerance);
      return points;
    }
    function simplify$1(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var tolerance = options.tolerance !== void 0 ? options.tolerance : 1;
      var highQuality = options.highQuality || false;
      var mutate = options.mutate || false;
      if (!geojson) throw new Error("geojson is required");
      if (tolerance && tolerance < 0) throw new Error("invalid tolerance");
      if (mutate !== true) geojson = clone__default["default"](geojson);
      meta.geomEach(geojson, function(geom) {
        simplifyGeom(geom, tolerance, highQuality);
      });
      return geojson;
    }
    function simplifyGeom(geometry, tolerance, highQuality) {
      var type = geometry.type;
      if (type === "Point" || type === "MultiPoint") return geometry;
      cleanCoords__default["default"](geometry, true);
      var coordinates = geometry.coordinates;
      switch (type) {
        case "LineString":
          geometry["coordinates"] = simplifyLine(
            coordinates,
            tolerance,
            highQuality
          );
          break;
        case "MultiLineString":
          geometry["coordinates"] = coordinates.map(function(lines) {
            return simplifyLine(lines, tolerance, highQuality);
          });
          break;
        case "Polygon":
          geometry["coordinates"] = simplifyPolygon(
            coordinates,
            tolerance,
            highQuality
          );
          break;
        case "MultiPolygon":
          geometry["coordinates"] = coordinates.map(function(rings) {
            return simplifyPolygon(rings, tolerance, highQuality);
          });
      }
      return geometry;
    }
    function simplifyLine(coordinates, tolerance, highQuality) {
      return simplify(
        coordinates.map(function(coord) {
          return { x: coord[0], y: coord[1], z: coord[2] };
        }),
        tolerance,
        highQuality
      ).map(function(coords) {
        return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];
      });
    }
    function simplifyPolygon(coordinates, tolerance, highQuality) {
      return coordinates.map(function(ring) {
        var pts = ring.map(function(coord) {
          return { x: coord[0], y: coord[1] };
        });
        if (pts.length < 4) {
          throw new Error("invalid polygon");
        }
        var simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
          return [coords.x, coords.y];
        });
        while (!checkValidity(simpleRing)) {
          tolerance -= tolerance * 0.01;
          simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
            return [coords.x, coords.y];
          });
        }
        if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
          simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
      });
    }
    function checkValidity(ring) {
      if (ring.length < 3) return false;
      return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
    }
    module2.exports = simplify$1;
    module2.exports.default = simplify$1;
  }
});

// node_modules/@turf/bezier-spline/dist/js/lib/spline.js
var require_spline = __commonJS({
  "node_modules/@turf/bezier-spline/dist/js/lib/spline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Spline = (
      /** @class */
      function() {
        function Spline2(options) {
          this.points = options.points || [];
          this.duration = options.duration || 1e4;
          this.sharpness = options.sharpness || 0.85;
          this.centers = [];
          this.controls = [];
          this.stepLength = options.stepLength || 60;
          this.length = this.points.length;
          this.delay = 0;
          for (var i = 0; i < this.length; i++) {
            this.points[i].z = this.points[i].z || 0;
          }
          for (var i = 0; i < this.length - 1; i++) {
            var p1 = this.points[i];
            var p2 = this.points[i + 1];
            this.centers.push({
              x: (p1.x + p2.x) / 2,
              y: (p1.y + p2.y) / 2,
              z: (p1.z + p2.z) / 2
            });
          }
          this.controls.push([this.points[0], this.points[0]]);
          for (var i = 0; i < this.centers.length - 1; i++) {
            var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
            var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
            var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
            this.controls.push([
              {
                x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
                y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
                z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
              },
              {
                x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
                y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
                z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
              }
            ]);
          }
          this.controls.push([
            this.points[this.length - 1],
            this.points[this.length - 1]
          ]);
          this.steps = this.cacheSteps(this.stepLength);
          return this;
        }
        Spline2.prototype.cacheSteps = function(mindist) {
          var steps = [];
          var laststep = this.pos(0);
          steps.push(0);
          for (var t = 0; t < this.duration; t += 10) {
            var step = this.pos(t);
            var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
            if (dist > mindist) {
              steps.push(t);
              laststep = step;
            }
          }
          return steps;
        };
        Spline2.prototype.vector = function(t) {
          var p1 = this.pos(t + 10);
          var p2 = this.pos(t - 10);
          return {
            angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
            speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
          };
        };
        Spline2.prototype.pos = function(time) {
          var t = time - this.delay;
          if (t < 0) {
            t = 0;
          }
          if (t > this.duration) {
            t = this.duration - 1;
          }
          var t2 = t / this.duration;
          if (t2 >= 1) {
            return this.points[this.length - 1];
          }
          var n = Math.floor((this.points.length - 1) * t2);
          var t1 = (this.length - 1) * t2 - n;
          return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
        };
        return Spline2;
      }()
    );
    exports2.default = Spline;
    function bezier(t, p1, c1, c2, p2) {
      var b = B(t);
      var pos = {
        x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
        y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
        z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
      };
      return pos;
    }
    function B(t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return [
        t3,
        3 * t2 * (1 - t),
        3 * t * (1 - t) * (1 - t),
        (1 - t) * (1 - t) * (1 - t)
      ];
    }
  }
});

// node_modules/@turf/bezier-spline/dist/js/index.js
var require_js17 = __commonJS({
  "node_modules/@turf/bezier-spline/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var spline_1 = __importDefault(require_spline());
    function bezier(line, options) {
      if (options === void 0) {
        options = {};
      }
      var resolution = options.resolution || 1e4;
      var sharpness = options.sharpness || 0.85;
      var coords = [];
      var points = invariant_1.getGeom(line).coordinates.map(function(pt) {
        return { x: pt[0], y: pt[1] };
      });
      var spline = new spline_1.default({
        duration: resolution,
        points,
        sharpness
      });
      var pushCoord = function(time) {
        var pos = spline.pos(time);
        if (Math.floor(time / 100) % 2 === 0) {
          coords.push([pos.x, pos.y]);
        }
      };
      for (var i = 0; i < spline.duration; i += 10) {
        pushCoord(i);
      }
      pushCoord(spline.duration);
      return helpers_1.lineString(coords, options.properties);
    }
    exports2.default = bezier;
  }
});

// node_modules/@turf/tag/dist/js/index.js
var require_js18 = __commonJS({
  "node_modules/@turf/tag/dist/js/index.js"(exports2, module2) {
    "use strict";
    var booleanPointInPolygon = require_js7();
    var clone = require_js11();
    var meta = require_js2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var booleanPointInPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(booleanPointInPolygon);
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    function tag(points, polygons, field, outField) {
      points = clone__default["default"](points);
      polygons = clone__default["default"](polygons);
      meta.featureEach(points, function(pt) {
        if (!pt.properties) pt.properties = {};
        meta.featureEach(polygons, function(poly) {
          if (pt.properties[outField] === void 0) {
            if (booleanPointInPolygon__default["default"](pt, poly))
              pt.properties[outField] = poly.properties[field];
          }
        });
      });
      return points;
    }
    module2.exports = tag;
    module2.exports.default = tag;
  }
});

// node_modules/@turf/sample/dist/js/index.js
var require_js19 = __commonJS({
  "node_modules/@turf/sample/dist/js/index.js"(exports2, module2) {
    "use strict";
    var helpers = require_js();
    function sample(featurecollection, num) {
      if (!featurecollection) throw new Error("featurecollection is required");
      if (num === null || num === void 0) throw new Error("num is required");
      if (typeof num !== "number") throw new Error("num must be a number");
      var outFC = helpers.featureCollection(
        getRandomSubarray(featurecollection.features, num)
      );
      return outFC;
    }
    function getRandomSubarray(arr, size) {
      var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;
      while (i-- > min) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
      }
      return shuffled.slice(min);
    }
    module2.exports = sample;
    module2.exports.default = sample;
  }
});

// node_modules/@turf/bbox-polygon/dist/js/index.js
var require_js20 = __commonJS({
  "node_modules/@turf/bbox-polygon/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    function bboxPolygon(bbox, options) {
      if (options === void 0) {
        options = {};
      }
      var west = Number(bbox[0]);
      var south = Number(bbox[1]);
      var east = Number(bbox[2]);
      var north = Number(bbox[3]);
      if (bbox.length === 6) {
        throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
      }
      var lowLeft = [west, south];
      var topLeft = [west, north];
      var topRight = [east, north];
      var lowRight = [east, south];
      return helpers_1.polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox, id: options.id });
    }
    exports2.default = bboxPolygon;
  }
});

// node_modules/@turf/envelope/dist/js/index.js
var require_js21 = __commonJS({
  "node_modules/@turf/envelope/dist/js/index.js"(exports2, module2) {
    "use strict";
    var bbox = require_js3();
    var bboxPolygon = require_js20();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bbox__default = /* @__PURE__ */ _interopDefaultLegacy(bbox);
    var bboxPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(bboxPolygon);
    function envelope(geojson) {
      return bboxPolygon__default["default"](bbox__default["default"](geojson));
    }
    module2.exports = envelope;
    module2.exports.default = envelope;
  }
});

// node_modules/@turf/square/dist/js/index.js
var require_js22 = __commonJS({
  "node_modules/@turf/square/dist/js/index.js"(exports2, module2) {
    "use strict";
    var distance = require_js9();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var distance__default = /* @__PURE__ */ _interopDefaultLegacy(distance);
    function square(bbox) {
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];
      var horizontalDistance = distance__default["default"](bbox.slice(0, 2), [east, south]);
      var verticalDistance = distance__default["default"](bbox.slice(0, 2), [west, north]);
      if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (south + north) / 2;
        return [
          west,
          verticalMidpoint - (east - west) / 2,
          east,
          verticalMidpoint + (east - west) / 2
        ];
      } else {
        var horizontalMidpoint = (west + east) / 2;
        return [
          horizontalMidpoint - (north - south) / 2,
          south,
          horizontalMidpoint + (north - south) / 2,
          north
        ];
      }
    }
    module2.exports = square;
    module2.exports.default = square;
  }
});

// node_modules/@turf/destination/dist/js/index.js
var require_js23 = __commonJS({
  "node_modules/@turf/destination/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function destination(origin, distance, bearing, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(origin);
      var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);
      var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);
      var bearingRad = helpers_1.degreesToRadians(bearing);
      var radians = helpers_1.lengthToRadians(distance, options.units);
      var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
      var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
      var lng = helpers_1.radiansToDegrees(longitude2);
      var lat = helpers_1.radiansToDegrees(latitude2);
      return helpers_1.point([lng, lat], options.properties);
    }
    exports2.default = destination;
  }
});

// node_modules/@turf/circle/dist/js/index.js
var require_js24 = __commonJS({
  "node_modules/@turf/circle/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var destination_1 = __importDefault(require_js23());
    var helpers_1 = require_js();
    function circle(center, radius, options) {
      if (options === void 0) {
        options = {};
      }
      var steps = options.steps || 64;
      var properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
      var coordinates = [];
      for (var i = 0; i < steps; i++) {
        coordinates.push(destination_1.default(center, radius, i * -360 / steps, options).geometry.coordinates);
      }
      coordinates.push(coordinates[0]);
      return helpers_1.polygon([coordinates], properties);
    }
    exports2.default = circle;
  }
});

// node_modules/@turf/bearing/dist/js/index.js
var require_js25 = __commonJS({
  "node_modules/@turf/bearing/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function bearing(start, end, options) {
      if (options === void 0) {
        options = {};
      }
      if (options.final === true) {
        return calculateFinalBearing(start, end);
      }
      var coordinates1 = invariant_1.getCoord(start);
      var coordinates2 = invariant_1.getCoord(end);
      var lon1 = helpers_1.degreesToRadians(coordinates1[0]);
      var lon2 = helpers_1.degreesToRadians(coordinates2[0]);
      var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
      var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
      var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
      var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
      return helpers_1.radiansToDegrees(Math.atan2(a, b));
    }
    exports2.default = bearing;
    function calculateFinalBearing(start, end) {
      var bear = bearing(end, start);
      bear = (bear + 180) % 360;
      return bear;
    }
  }
});

// node_modules/@turf/midpoint/dist/js/index.js
var require_js26 = __commonJS({
  "node_modules/@turf/midpoint/dist/js/index.js"(exports2, module2) {
    "use strict";
    var bearing = require_js25();
    var destination = require_js23();
    var distance = require_js9();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bearing__default = /* @__PURE__ */ _interopDefaultLegacy(bearing);
    var destination__default = /* @__PURE__ */ _interopDefaultLegacy(destination);
    var distance__default = /* @__PURE__ */ _interopDefaultLegacy(distance);
    function midpoint(point1, point2) {
      var dist = distance__default["default"](point1, point2);
      var heading = bearing__default["default"](point1, point2);
      var midpoint2 = destination__default["default"](point1, dist / 2, heading);
      return midpoint2;
    }
    module2.exports = midpoint;
    module2.exports.default = midpoint;
  }
});

// node_modules/@turf/center/dist/js/index.js
var require_js27 = __commonJS({
  "node_modules/@turf/center/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bbox_1 = __importDefault(require_js3());
    var helpers_1 = require_js();
    function center(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      var ext = bbox_1.default(geojson);
      var x = (ext[0] + ext[2]) / 2;
      var y = (ext[1] + ext[3]) / 2;
      return helpers_1.point([x, y], options.properties, options);
    }
    exports2.default = center;
  }
});

// node_modules/@turf/centroid/dist/js/index.js
var require_js28 = __commonJS({
  "node_modules/@turf/centroid/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    function centroid(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      var xSum = 0;
      var ySum = 0;
      var len = 0;
      meta_1.coordEach(geojson, function(coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
      }, true);
      return helpers_1.point([xSum / len, ySum / len], options.properties);
    }
    exports2.default = centroid;
  }
});

// node_modules/@turf/center-of-mass/dist/js/index.js
var require_js29 = __commonJS({
  "node_modules/@turf/center-of-mass/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var convex_1 = __importDefault(require_js6());
    var centroid_1 = __importDefault(require_js28());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    function centerOfMass(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      switch (invariant_1.getType(geojson)) {
        case "Point":
          return helpers_1.point(invariant_1.getCoord(geojson), options.properties);
        case "Polygon":
          var coords = [];
          meta_1.coordEach(geojson, function(coord) {
            coords.push(coord);
          });
          var centre = centroid_1.default(geojson, { properties: options.properties });
          var translation = centre.geometry.coordinates;
          var sx = 0;
          var sy = 0;
          var sArea = 0;
          var i, pi, pj, xi, xj, yi, yj, a;
          var neutralizedPoints = coords.map(function(point) {
            return [point[0] - translation[0], point[1] - translation[1]];
          });
          for (i = 0; i < coords.length - 1; i++) {
            pi = neutralizedPoints[i];
            xi = pi[0];
            yi = pi[1];
            pj = neutralizedPoints[i + 1];
            xj = pj[0];
            yj = pj[1];
            a = xi * yj - xj * yi;
            sArea += a;
            sx += (xi + xj) * a;
            sy += (yi + yj) * a;
          }
          if (sArea === 0) {
            return centre;
          } else {
            var area = sArea * 0.5;
            var areaFactor = 1 / (6 * area);
            return helpers_1.point([translation[0] + areaFactor * sx, translation[1] + areaFactor * sy], options.properties);
          }
        default:
          var hull = convex_1.default(geojson);
          if (hull)
            return centerOfMass(hull, { properties: options.properties });
          else
            return centroid_1.default(geojson, { properties: options.properties });
      }
    }
    exports2.default = centerOfMass;
  }
});

// node_modules/@turf/combine/dist/js/index.js
var require_js30 = __commonJS({
  "node_modules/@turf/combine/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var meta_1 = require_js2();
    function combine(fc) {
      var groups = {
        MultiPoint: {
          coordinates: [],
          properties: []
        },
        MultiLineString: {
          coordinates: [],
          properties: []
        },
        MultiPolygon: {
          coordinates: [],
          properties: []
        }
      };
      meta_1.featureEach(fc, function(feature) {
        var _a, _b, _c;
        var _d;
        switch ((_d = feature.geometry) === null || _d === void 0 ? void 0 : _d.type) {
          case "Point":
            groups.MultiPoint.coordinates.push(feature.geometry.coordinates);
            groups.MultiPoint.properties.push(feature.properties);
            break;
          case "MultiPoint":
            (_a = groups.MultiPoint.coordinates).push.apply(_a, feature.geometry.coordinates);
            groups.MultiPoint.properties.push(feature.properties);
            break;
          case "LineString":
            groups.MultiLineString.coordinates.push(feature.geometry.coordinates);
            groups.MultiLineString.properties.push(feature.properties);
            break;
          case "MultiLineString":
            (_b = groups.MultiLineString.coordinates).push.apply(_b, feature.geometry.coordinates);
            groups.MultiLineString.properties.push(feature.properties);
            break;
          case "Polygon":
            groups.MultiPolygon.coordinates.push(feature.geometry.coordinates);
            groups.MultiPolygon.properties.push(feature.properties);
            break;
          case "MultiPolygon":
            (_c = groups.MultiPolygon.coordinates).push.apply(_c, feature.geometry.coordinates);
            groups.MultiPolygon.properties.push(feature.properties);
            break;
          default:
            break;
        }
      });
      return helpers_1.featureCollection(Object.keys(groups).filter(function(key) {
        return groups[key].coordinates.length;
      }).sort().map(function(key) {
        var geometry = { type: key, coordinates: groups[key].coordinates };
        var properties = { collectedProperties: groups[key].properties };
        return helpers_1.feature(geometry, properties);
      }));
    }
    exports2.default = combine;
  }
});

// node_modules/@turf/explode/dist/js/index.js
var require_js31 = __commonJS({
  "node_modules/@turf/explode/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var helpers = require_js();
    function explode(geojson) {
      var points = [];
      if (geojson.type === "FeatureCollection") {
        meta.featureEach(geojson, function(feature) {
          meta.coordEach(feature, function(coord) {
            points.push(helpers.point(coord, feature.properties));
          });
        });
      } else {
        meta.coordEach(geojson, function(coord) {
          points.push(helpers.point(coord, geojson.properties));
        });
      }
      return helpers.featureCollection(points);
    }
    module2.exports = explode;
    module2.exports.default = explode;
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports2, module2) {
    "use strict";
    module2.exports = earcut;
    module2.exports.default = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize);
            earcutLinked(c, triangles, dim, minX, minY, invSize);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      var filteredBridge = filterPoints(bridge, bridge.next);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return outerNode === bridge ? filteredBridge : outerNode;
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y) return p;
              if (hy === p.next.y) return p.next;
            }
            m = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      if (hx === qx) return m;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e;
            else list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = 32767 * (x - minX) * invSize;
      y = 32767 * (y - minY) * invSize;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result2 = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++) result2.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result2.holes.push(holeIndex);
        }
      }
      return result2;
    };
  }
});

// node_modules/@turf/tesselate/dist/js/index.js
var require_js32 = __commonJS({
  "node_modules/@turf/tesselate/dist/js/index.js"(exports2, module2) {
    "use strict";
    var earcut = require_earcut();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var earcut__default = /* @__PURE__ */ _interopDefaultLegacy(earcut);
    function tesselate(poly) {
      if (!poly.geometry || poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon") {
        throw new Error("input must be a Polygon or MultiPolygon");
      }
      var fc = { type: "FeatureCollection", features: [] };
      if (poly.geometry.type === "Polygon") {
        fc.features = processPolygon(poly.geometry.coordinates);
      } else {
        poly.geometry.coordinates.forEach(function(coordinates) {
          fc.features = fc.features.concat(processPolygon(coordinates));
        });
      }
      return fc;
    }
    function processPolygon(coordinates) {
      var data = flattenCoords(coordinates);
      var dim = 2;
      var result2 = earcut__default["default"](data.vertices, data.holes, dim);
      var features = [];
      var vertices = [];
      result2.forEach(function(vert, i2) {
        var index = result2[i2];
        vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);
      });
      for (var i = 0; i < vertices.length; i += 3) {
        var coords = vertices.slice(i, i + 3);
        coords.push(vertices[i]);
        features.push(helpers.polygon([coords]));
      }
      return features;
    }
    function flattenCoords(data) {
      var dim = data[0][0].length, result2 = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++) result2.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result2.holes.push(holeIndex);
        }
      }
      return result2;
    }
    module2.exports = tesselate;
    module2.exports.default = tesselate;
  }
});

// node_modules/@turf/nearest-point/dist/js/index.js
var require_js33 = __commonJS({
  "node_modules/@turf/nearest-point/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var clone_1 = __importDefault(require_js11());
    var distance_1 = __importDefault(require_js9());
    var meta_1 = require_js2();
    function nearestPoint(targetPoint, points) {
      if (!targetPoint)
        throw new Error("targetPoint is required");
      if (!points)
        throw new Error("points is required");
      var nearest;
      var minDist = Infinity;
      var bestFeatureIndex = 0;
      meta_1.featureEach(points, function(pt, featureIndex) {
        var distanceToPoint = distance_1.default(targetPoint, pt);
        if (distanceToPoint < minDist) {
          bestFeatureIndex = featureIndex;
          minDist = distanceToPoint;
        }
      });
      nearest = clone_1.default(points.features[bestFeatureIndex]);
      nearest.properties.featureIndex = bestFeatureIndex;
      nearest.properties.distanceToPoint = minDist;
      return nearest;
    }
    exports2.default = nearestPoint;
  }
});

// node_modules/@turf/line-segment/dist/js/index.js
var require_js34 = __commonJS({
  "node_modules/@turf/line-segment/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    function lineSegment(geojson) {
      if (!geojson) {
        throw new Error("geojson is required");
      }
      var results = [];
      meta_1.flattenEach(geojson, function(feature) {
        lineSegmentFeature(feature, results);
      });
      return helpers_1.featureCollection(results);
    }
    function lineSegmentFeature(geojson, results) {
      var coords = [];
      var geometry = geojson.geometry;
      if (geometry !== null) {
        switch (geometry.type) {
          case "Polygon":
            coords = invariant_1.getCoords(geometry);
            break;
          case "LineString":
            coords = [invariant_1.getCoords(geometry)];
        }
        coords.forEach(function(coord) {
          var segments = createSegments(coord, geojson.properties);
          segments.forEach(function(segment) {
            segment.id = results.length;
            results.push(segment);
          });
        });
      }
    }
    function createSegments(coords, properties) {
      var segments = [];
      coords.reduce(function(previousCoords, currentCoords) {
        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
      });
      return segments;
    }
    function bbox(coords1, coords2) {
      var x1 = coords1[0];
      var y1 = coords1[1];
      var x2 = coords2[0];
      var y2 = coords2[1];
      var west = x1 < x2 ? x1 : x2;
      var south = y1 < y2 ? y1 : y2;
      var east = x1 > x2 ? x1 : x2;
      var north = y1 > y2 ? y1 : y2;
      return [west, south, east, north];
    }
    exports2.default = lineSegment;
  }
});

// node_modules/geojson-rbush/node_modules/rbush/rbush.js
var require_rbush3 = __commonJS({
  "node_modules/geojson-rbush/node_modules/rbush/rbush.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.RBush = factory());
    })(exports2, function() {
      "use strict";
      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }
      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) {
            swap(arr, left, right);
          }
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) {
              i++;
            }
            while (compare(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare(arr[left], t) === 0) {
            swap(arr, left, j);
          } else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) {
            left = j + 1;
          }
          if (k <= j) {
            right = j - 1;
          }
        }
      }
      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      var RBush = function RBush2(maxEntries) {
        if (maxEntries === void 0) maxEntries = 9;
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      };
      RBush.prototype.all = function all2() {
        return this._all(this.data, []);
      };
      RBush.prototype.search = function search(bbox) {
        var node = this.data;
        var result2 = [];
        if (!intersects(bbox, node)) {
          return result2;
        }
        var toBBox = this.toBBox;
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf) {
                result2.push(child);
              } else if (contains(bbox, childBBox)) {
                this._all(child, result2);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
          node = nodesToSearch.pop();
        }
        return result2;
      };
      RBush.prototype.collides = function collides(bbox) {
        var node = this.data;
        if (!intersects(bbox, node)) {
          return false;
        }
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) {
                return true;
              }
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      };
      RBush.prototype.load = function load(data) {
        if (!(data && data.length)) {
          return this;
        }
        if (data.length < this._minEntries) {
          for (var i = 0; i < data.length; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        var node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      };
      RBush.prototype.insert = function insert(item) {
        if (item) {
          this._insert(item, this.data.height - 1);
        }
        return this;
      };
      RBush.prototype.clear = function clear() {
        this.data = createNode([]);
        return this;
      };
      RBush.prototype.remove = function remove(item, equalsFn) {
        if (!item) {
          return this;
        }
        var node = this.data;
        var bbox = this.toBBox(item);
        var path = [];
        var indexes = [];
        var i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            var index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
        return this;
      };
      RBush.prototype.toBBox = function toBBox(item) {
        return item;
      };
      RBush.prototype.compareMinX = function compareMinX(a, b) {
        return a.minX - b.minX;
      };
      RBush.prototype.compareMinY = function compareMinY(a, b) {
        return a.minY - b.minY;
      };
      RBush.prototype.toJSON = function toJSON() {
        return this.data;
      };
      RBush.prototype.fromJSON = function fromJSON(data) {
        this.data = data;
        return this;
      };
      RBush.prototype._all = function _all(node, result2) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) {
            result2.push.apply(result2, node.children);
          } else {
            nodesToSearch.push.apply(nodesToSearch, node.children);
          }
          node = nodesToSearch.pop();
        }
        return result2;
      };
      RBush.prototype._build = function _build(items, left, right, height) {
        var N = right - left + 1;
        var M = this._maxEntries;
        var node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M);
        var N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (var i = left; i <= right; i += N1) {
          var right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (var j = i; j <= right2; j += N2) {
            var right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      };
      RBush.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) {
            break;
          }
          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = void 0;
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      };
      RBush.prototype._insert = function _insert(item, level, isNode) {
        var bbox = isNode ? item : this.toBBox(item);
        var insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else {
            break;
          }
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      };
      RBush.prototype._split = function _split(insertPath, level) {
        var node = insertPath[level];
        var M = node.children.length;
        var m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) {
          insertPath[level - 1].children.push(newNode);
        } else {
          this._splitRoot(node, newNode);
        }
      };
      RBush.prototype._splitRoot = function _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      };
      RBush.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {
        var index;
        var minOverlap = Infinity;
        var minArea = Infinity;
        for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);
          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index || M - m;
      };
      RBush.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        var xMargin = this._allDistMargin(node, m, M, compareMinX);
        var yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin) {
          node.children.sort(compareMinX);
        }
      };
      RBush.prototype._allDistMargin = function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox;
        var leftBBox = distBBox(node, 0, m, toBBox);
        var rightBBox = distBBox(node, M - m, M, toBBox);
        var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      };
      RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      };
      RBush.prototype._condense = function _condense(path) {
        for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else {
              this.clear();
            }
          } else {
            calcBBox(path[i], this.toBBox);
          }
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn) {
          return items.indexOf(item);
        }
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) {
            return i;
          }
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) {
          destNode = createNode(null);
        }
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX);
        var minY = Math.max(a.minY, b.minY);
        var maxX = Math.min(a.maxX, b.maxX);
        var maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children2) {
        return {
          children: children2,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right];
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n) {
            continue;
          }
          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
      return RBush;
    });
  }
});

// node_modules/geojson-rbush/index.js
var require_geojson_rbush = __commonJS({
  "node_modules/geojson-rbush/index.js"(exports2, module2) {
    var rbush = require_rbush3();
    var helpers = require_js();
    var meta = require_js2();
    var turfBBox = require_js3().default;
    var featureEach = meta.featureEach;
    var coordEach = meta.coordEach;
    var polygon = helpers.polygon;
    var featureCollection = helpers.featureCollection;
    function geojsonRbush(maxEntries) {
      var tree = new rbush(maxEntries);
      tree.insert = function(feature) {
        if (feature.type !== "Feature") throw new Error("invalid feature");
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.insert.call(this, feature);
      };
      tree.load = function(features) {
        var load = [];
        if (Array.isArray(features)) {
          features.forEach(function(feature) {
            if (feature.type !== "Feature") throw new Error("invalid features");
            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
            load.push(feature);
          });
        } else {
          featureEach(features, function(feature) {
            if (feature.type !== "Feature") throw new Error("invalid features");
            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
            load.push(feature);
          });
        }
        return rbush.prototype.load.call(this, load);
      };
      tree.remove = function(feature, equals) {
        if (feature.type !== "Feature") throw new Error("invalid feature");
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.remove.call(this, feature, equals);
      };
      tree.clear = function() {
        return rbush.prototype.clear.call(this);
      };
      tree.search = function(geojson) {
        var features = rbush.prototype.search.call(this, this.toBBox(geojson));
        return featureCollection(features);
      };
      tree.collides = function(geojson) {
        return rbush.prototype.collides.call(this, this.toBBox(geojson));
      };
      tree.all = function() {
        var features = rbush.prototype.all.call(this);
        return featureCollection(features);
      };
      tree.toJSON = function() {
        return rbush.prototype.toJSON.call(this);
      };
      tree.fromJSON = function(json) {
        return rbush.prototype.fromJSON.call(this, json);
      };
      tree.toBBox = function(geojson) {
        var bbox;
        if (geojson.bbox) bbox = geojson.bbox;
        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];
        else if (geojson.type === "Feature") bbox = turfBBox(geojson);
        else if (geojson.type === "FeatureCollection") bbox = turfBBox(geojson);
        else throw new Error("invalid geojson");
        return {
          minX: bbox[0],
          minY: bbox[1],
          maxX: bbox[2],
          maxY: bbox[3]
        };
      };
      return tree;
    }
    module2.exports = geojsonRbush;
    module2.exports.default = geojsonRbush;
  }
});

// node_modules/@turf/line-intersect/dist/js/index.js
var require_js35 = __commonJS({
  "node_modules/@turf/line-intersect/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var line_segment_1 = __importDefault(require_js34());
    var meta_1 = require_js2();
    var geojson_rbush_1 = __importDefault(require_geojson_rbush());
    function lineIntersect(line1, line2) {
      var unique = {};
      var results = [];
      if (line1.type === "LineString") {
        line1 = helpers_1.feature(line1);
      }
      if (line2.type === "LineString") {
        line2 = helpers_1.feature(line2);
      }
      if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
        var intersect = intersects(line1, line2);
        if (intersect) {
          results.push(intersect);
        }
        return helpers_1.featureCollection(results);
      }
      var tree = geojson_rbush_1.default();
      tree.load(line_segment_1.default(line2));
      meta_1.featureEach(line_segment_1.default(line1), function(segment) {
        meta_1.featureEach(tree.search(segment), function(match) {
          var intersect2 = intersects(segment, match);
          if (intersect2) {
            var key = invariant_1.getCoords(intersect2).join(",");
            if (!unique[key]) {
              unique[key] = true;
              results.push(intersect2);
            }
          }
        });
      });
      return helpers_1.featureCollection(results);
    }
    function intersects(line1, line2) {
      var coords1 = invariant_1.getCoords(line1);
      var coords2 = invariant_1.getCoords(line2);
      if (coords1.length !== 2) {
        throw new Error("<intersects> line1 must only contain 2 coordinates");
      }
      if (coords2.length !== 2) {
        throw new Error("<intersects> line2 must only contain 2 coordinates");
      }
      var x1 = coords1[0][0];
      var y1 = coords1[0][1];
      var x2 = coords1[1][0];
      var y2 = coords1[1][1];
      var x3 = coords2[0][0];
      var y3 = coords2[0][1];
      var x4 = coords2[1][0];
      var y4 = coords2[1][1];
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      if (denom === 0) {
        if (numeA === 0 && numeB === 0) {
          return null;
        }
        return null;
      }
      var uA = numeA / denom;
      var uB = numeB / denom;
      if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        var x = x1 + uA * (x2 - x1);
        var y = y1 + uA * (y2 - y1);
        return helpers_1.point([x, y]);
      }
      return null;
    }
    exports2.default = lineIntersect;
  }
});

// node_modules/@turf/nearest-point-on-line/dist/js/index.js
var require_js36 = __commonJS({
  "node_modules/@turf/nearest-point-on-line/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bearing_1 = __importDefault(require_js25());
    var distance_1 = __importDefault(require_js9());
    var destination_1 = __importDefault(require_js23());
    var line_intersect_1 = __importDefault(require_js35());
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function nearestPointOnLine(lines, pt, options) {
      if (options === void 0) {
        options = {};
      }
      var closestPt = helpers_1.point([Infinity, Infinity], {
        dist: Infinity
      });
      var length = 0;
      meta_1.flattenEach(lines, function(line) {
        var coords = invariant_1.getCoords(line);
        for (var i = 0; i < coords.length - 1; i++) {
          var start = helpers_1.point(coords[i]);
          start.properties.dist = distance_1.default(pt, start, options);
          var stop_1 = helpers_1.point(coords[i + 1]);
          stop_1.properties.dist = distance_1.default(pt, stop_1, options);
          var sectionLength = distance_1.default(start, stop_1, options);
          var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
          var direction = bearing_1.default(start, stop_1);
          var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);
          var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);
          var intersect = line_intersect_1.default(helpers_1.lineString([
            perpendicularPt1.geometry.coordinates,
            perpendicularPt2.geometry.coordinates
          ]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
          var intersectPt = null;
          if (intersect.features.length > 0) {
            intersectPt = intersect.features[0];
            intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);
            intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);
          }
          if (start.properties.dist < closestPt.properties.dist) {
            closestPt = start;
            closestPt.properties.index = i;
            closestPt.properties.location = length;
          }
          if (stop_1.properties.dist < closestPt.properties.dist) {
            closestPt = stop_1;
            closestPt.properties.index = i + 1;
            closestPt.properties.location = length + sectionLength;
          }
          if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
            closestPt = intersectPt;
            closestPt.properties.index = i;
          }
          length += sectionLength;
        }
      });
      return closestPt;
    }
    exports2.default = nearestPointOnLine;
  }
});

// node_modules/@turf/rhumb-distance/dist/js/index.js
var require_js37 = __commonJS({
  "node_modules/@turf/rhumb-distance/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function rhumbDistance(from, to, options) {
      if (options === void 0) {
        options = {};
      }
      var origin = invariant_1.getCoord(from);
      var destination = invariant_1.getCoord(to);
      destination[0] += destination[0] - origin[0] > 180 ? -360 : origin[0] - destination[0] > 180 ? 360 : 0;
      var distanceInMeters = calculateRhumbDistance(origin, destination);
      var distance = helpers_1.convertLength(distanceInMeters, "meters", options.units);
      return distance;
    }
    function calculateRhumbDistance(origin, destination, radius) {
      radius = radius === void 0 ? helpers_1.earthRadius : Number(radius);
      var R = radius;
      var phi1 = origin[1] * Math.PI / 180;
      var phi2 = destination[1] * Math.PI / 180;
      var DeltaPhi = phi2 - phi1;
      var DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;
      if (DeltaLambda > Math.PI) {
        DeltaLambda -= 2 * Math.PI;
      }
      var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
      var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda);
      var dist = delta * R;
      return dist;
    }
    exports2.default = rhumbDistance;
  }
});

// node_modules/@turf/point-to-line-distance/dist/js/index.js
var require_js38 = __commonJS({
  "node_modules/@turf/point-to-line-distance/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var distance_1 = __importDefault(require_js9());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    var rhumb_distance_1 = __importDefault(require_js37());
    function pointToLineDistance(pt, line, options) {
      if (options === void 0) {
        options = {};
      }
      if (!options.method) {
        options.method = "geodesic";
      }
      if (!options.units) {
        options.units = "kilometers";
      }
      if (!pt) {
        throw new Error("pt is required");
      }
      if (Array.isArray(pt)) {
        pt = helpers_1.point(pt);
      } else if (pt.type === "Point") {
        pt = helpers_1.feature(pt);
      } else {
        invariant_1.featureOf(pt, "Point", "point");
      }
      if (!line) {
        throw new Error("line is required");
      }
      if (Array.isArray(line)) {
        line = helpers_1.lineString(line);
      } else if (line.type === "LineString") {
        line = helpers_1.feature(line);
      } else {
        invariant_1.featureOf(line, "LineString", "line");
      }
      var distance = Infinity;
      var p = pt.geometry.coordinates;
      meta_1.segmentEach(line, function(segment) {
        var a = segment.geometry.coordinates[0];
        var b = segment.geometry.coordinates[1];
        var d = distanceToSegment(p, a, b, options);
        if (d < distance) {
          distance = d;
        }
      });
      return helpers_1.convertLength(distance, "degrees", options.units);
    }
    function distanceToSegment(p, a, b, options) {
      var v = [b[0] - a[0], b[1] - a[1]];
      var w = [p[0] - a[0], p[1] - a[1]];
      var c1 = dot(w, v);
      if (c1 <= 0) {
        return calcDistance(p, a, { method: options.method, units: "degrees" });
      }
      var c2 = dot(v, v);
      if (c2 <= c1) {
        return calcDistance(p, b, { method: options.method, units: "degrees" });
      }
      var b2 = c1 / c2;
      var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
      return calcDistance(p, Pb, { method: options.method, units: "degrees" });
    }
    function dot(u, v) {
      return u[0] * v[0] + u[1] * v[1];
    }
    function calcDistance(a, b, options) {
      return options.method === "planar" ? rhumb_distance_1.default(a, b, options) : distance_1.default(a, b, options);
    }
    exports2.default = pointToLineDistance;
  }
});

// node_modules/@turf/nearest-point-to-line/dist/js/index.js
var require_js39 = __commonJS({
  "node_modules/@turf/nearest-point-to-line/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    var point_to_line_distance_1 = __importDefault(require_js38());
    var object_assign_1 = __importDefault(require_object_assign());
    function nearestPointToLine(points, line, options) {
      if (options === void 0) {
        options = {};
      }
      var units = options.units;
      var properties = options.properties || {};
      var pts = normalize2(points);
      if (!pts.features.length) {
        throw new Error("points must contain features");
      }
      if (!line) {
        throw new Error("line is required");
      }
      if (invariant_1.getType(line) !== "LineString") {
        throw new Error("line must be a LineString");
      }
      var dist = Infinity;
      var pt = null;
      meta_1.featureEach(pts, function(point) {
        var d = point_to_line_distance_1.default(point, line, { units });
        if (d < dist) {
          dist = d;
          pt = point;
        }
      });
      if (pt) {
        pt.properties = object_assign_1.default({ dist }, pt.properties, properties);
      }
      return pt;
    }
    function normalize2(points) {
      var features = [];
      var type = points.geometry ? points.geometry.type : points.type;
      switch (type) {
        case "GeometryCollection":
          meta_1.geomEach(points, function(geom) {
            if (geom.type === "Point") {
              features.push({ type: "Feature", properties: {}, geometry: geom });
            }
          });
          return { type: "FeatureCollection", features };
        case "FeatureCollection":
          points.features = points.features.filter(function(feature) {
            return feature.geometry.type === "Point";
          });
          return points;
        default:
          throw new Error("points must be a Point Collection");
      }
    }
    exports2.default = nearestPointToLine;
  }
});

// node_modules/@turf/planepoint/dist/js/index.js
var require_js40 = __commonJS({
  "node_modules/@turf/planepoint/dist/js/index.js"(exports2, module2) {
    "use strict";
    var invariant = require_js4();
    function planepoint(point, triangle) {
      var coord = invariant.getCoord(point);
      var geom = invariant.getGeom(triangle);
      var coords = geom.coordinates;
      var outer = coords[0];
      if (outer.length < 4)
        throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
      var properties = triangle.properties || {};
      var a = properties.a;
      var b = properties.b;
      var c = properties.c;
      var x = coord[0];
      var y = coord[1];
      var x1 = outer[0][0];
      var y1 = outer[0][1];
      var z1 = a !== void 0 ? a : outer[0][2];
      var x2 = outer[1][0];
      var y2 = outer[1][1];
      var z2 = b !== void 0 ? b : outer[1][2];
      var x3 = outer[2][0];
      var y3 = outer[2][1];
      var z3 = c !== void 0 ? c : outer[2][2];
      var z = (z3 * (x - x1) * (y - y2) + z1 * (x - x2) * (y - y3) + z2 * (x - x3) * (y - y1) - z2 * (x - x1) * (y - y3) - z3 * (x - x2) * (y - y1) - z1 * (x - x3) * (y - y2)) / ((x - x1) * (y - y2) + (x - x2) * (y - y3) + (x - x3) * (y - y1) - (x - x1) * (y - y3) - (x - x2) * (y - y1) - (x - x3) * (y - y2));
      return z;
    }
    module2.exports = planepoint;
    module2.exports.default = planepoint;
  }
});

// node_modules/@turf/kinks/dist/js/index.js
var require_js41 = __commonJS({
  "node_modules/@turf/kinks/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    function kinks(featureIn) {
      var coordinates;
      var feature;
      var results = {
        type: "FeatureCollection",
        features: []
      };
      if (featureIn.type === "Feature") {
        feature = featureIn.geometry;
      } else {
        feature = featureIn;
      }
      if (feature.type === "LineString") {
        coordinates = [feature.coordinates];
      } else if (feature.type === "MultiLineString") {
        coordinates = feature.coordinates;
      } else if (feature.type === "MultiPolygon") {
        coordinates = [].concat.apply([], feature.coordinates);
      } else if (feature.type === "Polygon") {
        coordinates = feature.coordinates;
      } else {
        throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
      }
      coordinates.forEach(function(line1) {
        coordinates.forEach(function(line2) {
          for (var i = 0; i < line1.length - 1; i++) {
            for (var k = i; k < line2.length - 1; k++) {
              if (line1 === line2) {
                if (Math.abs(i - k) === 1) {
                  continue;
                }
                if (
                  // segments are first and last segment of lineString
                  i === 0 && k === line1.length - 2 && // lineString is closed
                  line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]
                ) {
                  continue;
                }
              }
              var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
              if (intersection) {
                results.features.push(helpers_1.point([intersection[0], intersection[1]]));
              }
            }
          }
        });
      });
      return results;
    }
    exports2.default = kinks;
    function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
      var denominator;
      var a;
      var b;
      var numerator1;
      var numerator2;
      var result2 = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
      };
      denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
      if (denominator === 0) {
        if (result2.x !== null && result2.y !== null) {
          return result2;
        } else {
          return false;
        }
      }
      a = line1StartY - line2StartY;
      b = line1StartX - line2StartX;
      numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
      numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
      a = numerator1 / denominator;
      b = numerator2 / denominator;
      result2.x = line1StartX + a * (line1EndX - line1StartX);
      result2.y = line1StartY + a * (line1EndY - line1StartY);
      if (a >= 0 && a <= 1) {
        result2.onLine1 = true;
      }
      if (b >= 0 && b <= 1) {
        result2.onLine2 = true;
      }
      if (result2.onLine1 && result2.onLine2) {
        return [result2.x, result2.y];
      } else {
        return false;
      }
    }
  }
});

// node_modules/@turf/point-on-feature/dist/js/index.js
var require_js42 = __commonJS({
  "node_modules/@turf/point-on-feature/dist/js/index.js"(exports2, module2) {
    "use strict";
    var explode = require_js31();
    var centroid = require_js27();
    var nearestPoint = require_js33();
    var booleanPointInPolygon = require_js7();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var explode__default = /* @__PURE__ */ _interopDefaultLegacy(explode);
    var centroid__default = /* @__PURE__ */ _interopDefaultLegacy(centroid);
    var nearestPoint__default = /* @__PURE__ */ _interopDefaultLegacy(nearestPoint);
    var booleanPointInPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(booleanPointInPolygon);
    function pointOnFeature(geojson) {
      var fc = normalize2(geojson);
      var cent = centroid__default["default"](fc);
      var onSurface = false;
      var i = 0;
      while (!onSurface && i < fc.features.length) {
        var geom = fc.features[i].geometry;
        var x, y, x1, y1, x2, y2, k;
        var onLine = false;
        if (geom.type === "Point") {
          if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
            onSurface = true;
          }
        } else if (geom.type === "MultiPoint") {
          var onMultiPoint = false;
          k = 0;
          while (!onMultiPoint && k < geom.coordinates.length) {
            if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
              onSurface = true;
              onMultiPoint = true;
            }
            k++;
          }
        } else if (geom.type === "LineString") {
          k = 0;
          while (!onLine && k < geom.coordinates.length - 1) {
            x = cent.geometry.coordinates[0];
            y = cent.geometry.coordinates[1];
            x1 = geom.coordinates[k][0];
            y1 = geom.coordinates[k][1];
            x2 = geom.coordinates[k + 1][0];
            y2 = geom.coordinates[k + 1][1];
            if (pointOnSegment(x, y, x1, y1, x2, y2)) {
              onLine = true;
              onSurface = true;
            }
            k++;
          }
        } else if (geom.type === "MultiLineString") {
          var j = 0;
          while (j < geom.coordinates.length) {
            onLine = false;
            k = 0;
            var line = geom.coordinates[j];
            while (!onLine && k < line.length - 1) {
              x = cent.geometry.coordinates[0];
              y = cent.geometry.coordinates[1];
              x1 = line[k][0];
              y1 = line[k][1];
              x2 = line[k + 1][0];
              y2 = line[k + 1][1];
              if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                onLine = true;
                onSurface = true;
              }
              k++;
            }
            j++;
          }
        } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
          if (booleanPointInPolygon__default["default"](cent, geom)) {
            onSurface = true;
          }
        }
        i++;
      }
      if (onSurface) {
        return cent;
      } else {
        var vertices = helpers.featureCollection([]);
        for (i = 0; i < fc.features.length; i++) {
          vertices.features = vertices.features.concat(
            explode__default["default"](fc.features[i]).features
          );
        }
        return helpers.point(nearestPoint__default["default"](cent, vertices).geometry.coordinates);
      }
    }
    function normalize2(geojson) {
      if (geojson.type !== "FeatureCollection") {
        if (geojson.type !== "Feature") {
          return helpers.featureCollection([helpers.feature(geojson)]);
        }
        return helpers.featureCollection([geojson]);
      }
      return geojson;
    }
    function pointOnSegment(x, y, x1, y1, x2, y2) {
      var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
      return ab === ap + pb;
    }
    module2.exports = pointOnFeature;
    module2.exports.default = pointOnFeature;
  }
});

// node_modules/@turf/area/dist/js/index.js
var require_js43 = __commonJS({
  "node_modules/@turf/area/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    var RADIUS = 6378137;
    function area(geojson) {
      return meta_1.geomReduce(geojson, function(value, geom) {
        return value + calculateArea(geom);
      }, 0);
    }
    exports2.default = area;
    function calculateArea(geom) {
      var total = 0;
      var i;
      switch (geom.type) {
        case "Polygon":
          return polygonArea(geom.coordinates);
        case "MultiPolygon":
          for (i = 0; i < geom.coordinates.length; i++) {
            total += polygonArea(geom.coordinates[i]);
          }
          return total;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
          return 0;
      }
      return 0;
    }
    function polygonArea(coords) {
      var total = 0;
      if (coords && coords.length > 0) {
        total += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
          total -= Math.abs(ringArea(coords[i]));
        }
      }
      return total;
    }
    function ringArea(coords) {
      var p1;
      var p2;
      var p3;
      var lowerIndex;
      var middleIndex;
      var upperIndex;
      var i;
      var total = 0;
      var coordsLength = coords.length;
      if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
          if (i === coordsLength - 2) {
            lowerIndex = coordsLength - 2;
            middleIndex = coordsLength - 1;
            upperIndex = 0;
          } else if (i === coordsLength - 1) {
            lowerIndex = coordsLength - 1;
            middleIndex = 0;
            upperIndex = 1;
          } else {
            lowerIndex = i;
            middleIndex = i + 1;
            upperIndex = i + 2;
          }
          p1 = coords[lowerIndex];
          p2 = coords[middleIndex];
          p3 = coords[upperIndex];
          total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
        }
        total = total * RADIUS * RADIUS / 2;
      }
      return total;
    }
    function rad(num) {
      return num * Math.PI / 180;
    }
  }
});

// node_modules/@turf/along/dist/js/index.js
var require_js44 = __commonJS({
  "node_modules/@turf/along/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bearing_1 = __importDefault(require_js25());
    var destination_1 = __importDefault(require_js23());
    var distance_1 = __importDefault(require_js9());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function along(line, distance, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(line);
      var coords = geom.coordinates;
      var travelled = 0;
      for (var i = 0; i < coords.length; i++) {
        if (distance >= travelled && i === coords.length - 1) {
          break;
        } else if (travelled >= distance) {
          var overshot = distance - travelled;
          if (!overshot) {
            return helpers_1.point(coords[i]);
          } else {
            var direction = bearing_1.default(coords[i], coords[i - 1]) - 180;
            var interpolated = destination_1.default(coords[i], overshot, direction, options);
            return interpolated;
          }
        } else {
          travelled += distance_1.default(coords[i], coords[i + 1], options);
        }
      }
      return helpers_1.point(coords[coords.length - 1]);
    }
    exports2.default = along;
  }
});

// node_modules/@turf/length/dist/js/index.js
var require_js45 = __commonJS({
  "node_modules/@turf/length/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var distance_1 = __importDefault(require_js9());
    var meta_1 = require_js2();
    function length(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      return meta_1.segmentReduce(geojson, function(previousValue, segment) {
        var coords = segment.geometry.coordinates;
        return previousValue + distance_1.default(coords[0], coords[1], options);
      }, 0);
    }
    exports2.default = length;
  }
});

// node_modules/@turf/line-slice/dist/js/index.js
var require_js46 = __commonJS({
  "node_modules/@turf/line-slice/dist/js/index.js"(exports2, module2) {
    "use strict";
    var invariant = require_js4();
    var helpers = require_js();
    var nearestPointOnLine = require_js36();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var nearestPointOnLine__default = /* @__PURE__ */ _interopDefaultLegacy(nearestPointOnLine);
    function lineSlice(startPt, stopPt, line) {
      var coords = invariant.getCoords(line);
      if (invariant.getType(line) !== "LineString")
        throw new Error("line must be a LineString");
      var startVertex = nearestPointOnLine__default["default"](line, startPt);
      var stopVertex = nearestPointOnLine__default["default"](line, stopPt);
      var ends;
      if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [startVertex, stopVertex];
      } else {
        ends = [stopVertex, startVertex];
      }
      var clipCoords = [ends[0].geometry.coordinates];
      for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
        clipCoords.push(coords[i]);
      }
      clipCoords.push(ends[1].geometry.coordinates);
      return helpers.lineString(clipCoords, line.properties);
    }
    module2.exports = lineSlice;
    module2.exports.default = lineSlice;
  }
});

// node_modules/@turf/line-slice-along/dist/js/index.js
var require_js47 = __commonJS({
  "node_modules/@turf/line-slice-along/dist/js/index.js"(exports2, module2) {
    "use strict";
    var bearing = require_js25();
    var distance = require_js9();
    var destination = require_js23();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bearing__default = /* @__PURE__ */ _interopDefaultLegacy(bearing);
    var distance__default = /* @__PURE__ */ _interopDefaultLegacy(distance);
    var destination__default = /* @__PURE__ */ _interopDefaultLegacy(destination);
    function lineSliceAlong(line, startDist, stopDist, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var coords;
      var slice = [];
      if (line.type === "Feature") coords = line.geometry.coordinates;
      else if (line.type === "LineString") coords = line.coordinates;
      else throw new Error("input must be a LineString Feature or Geometry");
      var origCoordsLength = coords.length;
      var travelled = 0;
      var overshot, direction, interpolated;
      for (var i = 0; i < coords.length; i++) {
        if (startDist >= travelled && i === coords.length - 1) break;
        else if (travelled > startDist && slice.length === 0) {
          overshot = startDist - travelled;
          if (!overshot) {
            slice.push(coords[i]);
            return helpers.lineString(slice);
          }
          direction = bearing__default["default"](coords[i], coords[i - 1]) - 180;
          interpolated = destination__default["default"](coords[i], overshot, direction, options);
          slice.push(interpolated.geometry.coordinates);
        }
        if (travelled >= stopDist) {
          overshot = stopDist - travelled;
          if (!overshot) {
            slice.push(coords[i]);
            return helpers.lineString(slice);
          }
          direction = bearing__default["default"](coords[i], coords[i - 1]) - 180;
          interpolated = destination__default["default"](coords[i], overshot, direction, options);
          slice.push(interpolated.geometry.coordinates);
          return helpers.lineString(slice);
        }
        if (travelled >= startDist) {
          slice.push(coords[i]);
        }
        if (i === coords.length - 1) {
          return helpers.lineString(slice);
        }
        travelled += distance__default["default"](coords[i], coords[i + 1], options);
      }
      if (travelled < startDist && coords.length === origCoordsLength)
        throw new Error("Start position is beyond line");
      var last = coords[coords.length - 1];
      return helpers.lineString([last, last]);
    }
    module2.exports = lineSliceAlong;
    module2.exports.default = lineSliceAlong;
  }
});

// node_modules/@turf/boolean-point-on-line/dist/js/index.js
var require_js48 = __commonJS({
  "node_modules/@turf/boolean-point-on-line/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var invariant_1 = require_js4();
    function booleanPointOnLine(pt, line, options) {
      if (options === void 0) {
        options = {};
      }
      var ptCoords = invariant_1.getCoord(pt);
      var lineCoords = invariant_1.getCoords(line);
      for (var i = 0; i < lineCoords.length - 1; i++) {
        var ignoreBoundary = false;
        if (options.ignoreEndVertices) {
          if (i === 0) {
            ignoreBoundary = "start";
          }
          if (i === lineCoords.length - 2) {
            ignoreBoundary = "end";
          }
          if (i === 0 && i + 1 === lineCoords.length - 1) {
            ignoreBoundary = "both";
          }
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
          return true;
        }
      }
      return false;
    }
    function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {
      var x = pt[0];
      var y = pt[1];
      var x1 = lineSegmentStart[0];
      var y1 = lineSegmentStart[1];
      var x2 = lineSegmentEnd[0];
      var y2 = lineSegmentEnd[1];
      var dxc = pt[0] - x1;
      var dyc = pt[1] - y1;
      var dxl = x2 - x1;
      var dyl = y2 - y1;
      var cross = dxc * dyl - dyc * dxl;
      if (epsilon !== null) {
        if (Math.abs(cross) > epsilon) {
          return false;
        }
      } else if (cross !== 0) {
        return false;
      }
      if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
          return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
      } else if (excludeBoundary === "start") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
          return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
      } else if (excludeBoundary === "end") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
          return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
      } else if (excludeBoundary === "both") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
          return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
      }
      return false;
    }
    exports2.default = booleanPointOnLine;
  }
});

// node_modules/@turf/boolean-within/dist/js/index.js
var require_js49 = __commonJS({
  "node_modules/@turf/boolean-within/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bbox_1 = __importDefault(require_js3());
    var boolean_point_on_line_1 = __importDefault(require_js48());
    var boolean_point_in_polygon_1 = __importDefault(require_js7());
    var invariant_1 = require_js4();
    function booleanWithin(feature1, feature2) {
      var geom1 = invariant_1.getGeom(feature1);
      var geom2 = invariant_1.getGeom(feature2);
      var type1 = geom1.type;
      var type2 = geom2.type;
      switch (type1) {
        case "Point":
          switch (type2) {
            case "MultiPoint":
              return isPointInMultiPoint(geom1, geom2);
            case "LineString":
              return boolean_point_on_line_1.default(geom1, geom2, { ignoreEndVertices: true });
            case "Polygon":
            case "MultiPolygon":
              return boolean_point_in_polygon_1.default(geom1, geom2, { ignoreBoundary: true });
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "MultiPoint":
          switch (type2) {
            case "MultiPoint":
              return isMultiPointInMultiPoint(geom1, geom2);
            case "LineString":
              return isMultiPointOnLine(geom1, geom2);
            case "Polygon":
            case "MultiPolygon":
              return isMultiPointInPoly(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "LineString":
          switch (type2) {
            case "LineString":
              return isLineOnLine(geom1, geom2);
            case "Polygon":
            case "MultiPolygon":
              return isLineInPoly(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "Polygon":
          switch (type2) {
            case "Polygon":
            case "MultiPolygon":
              return isPolyInPoly(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        default:
          throw new Error("feature1 " + type1 + " geometry not supported");
      }
    }
    function isPointInMultiPoint(point, multiPoint) {
      var i;
      var output = false;
      for (i = 0; i < multiPoint.coordinates.length; i++) {
        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {
          output = true;
          break;
        }
      }
      return output;
    }
    function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
      for (var i = 0; i < multiPoint1.coordinates.length; i++) {
        var anyMatch = false;
        for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
          if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
            anyMatch = true;
          }
        }
        if (!anyMatch) {
          return false;
        }
      }
      return true;
    }
    function isMultiPointOnLine(multiPoint, lineString) {
      var foundInsidePoint = false;
      for (var i = 0; i < multiPoint.coordinates.length; i++) {
        if (!boolean_point_on_line_1.default(multiPoint.coordinates[i], lineString)) {
          return false;
        }
        if (!foundInsidePoint) {
          foundInsidePoint = boolean_point_on_line_1.default(multiPoint.coordinates[i], lineString, { ignoreEndVertices: true });
        }
      }
      return foundInsidePoint;
    }
    function isMultiPointInPoly(multiPoint, polygon) {
      var output = true;
      var oneInside = false;
      var isInside = false;
      for (var i = 0; i < multiPoint.coordinates.length; i++) {
        isInside = boolean_point_in_polygon_1.default(multiPoint.coordinates[1], polygon);
        if (!isInside) {
          output = false;
          break;
        }
        if (!oneInside) {
          isInside = boolean_point_in_polygon_1.default(multiPoint.coordinates[1], polygon, {
            ignoreBoundary: true
          });
        }
      }
      return output && isInside;
    }
    function isLineOnLine(lineString1, lineString2) {
      for (var i = 0; i < lineString1.coordinates.length; i++) {
        if (!boolean_point_on_line_1.default(lineString1.coordinates[i], lineString2)) {
          return false;
        }
      }
      return true;
    }
    function isLineInPoly(linestring, polygon) {
      var polyBbox = bbox_1.default(polygon);
      var lineBbox = bbox_1.default(linestring);
      if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
      }
      var foundInsidePoint = false;
      for (var i = 0; i < linestring.coordinates.length - 1; i++) {
        if (!boolean_point_in_polygon_1.default(linestring.coordinates[i], polygon)) {
          return false;
        }
        if (!foundInsidePoint) {
          foundInsidePoint = boolean_point_in_polygon_1.default(linestring.coordinates[i], polygon, { ignoreBoundary: true });
        }
        if (!foundInsidePoint) {
          var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
          foundInsidePoint = boolean_point_in_polygon_1.default(midpoint, polygon, {
            ignoreBoundary: true
          });
        }
      }
      return foundInsidePoint;
    }
    function isPolyInPoly(geometry1, geometry2) {
      var poly1Bbox = bbox_1.default(geometry1);
      var poly2Bbox = bbox_1.default(geometry2);
      if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
        return false;
      }
      for (var i = 0; i < geometry1.coordinates[0].length; i++) {
        if (!boolean_point_in_polygon_1.default(geometry1.coordinates[0][i], geometry2)) {
          return false;
        }
      }
      return true;
    }
    function doBBoxOverlap(bbox1, bbox2) {
      if (bbox1[0] > bbox2[0])
        return false;
      if (bbox1[2] < bbox2[2])
        return false;
      if (bbox1[1] > bbox2[1])
        return false;
      if (bbox1[3] < bbox2[3])
        return false;
      return true;
    }
    function compareCoords(pair1, pair2) {
      return pair1[0] === pair2[0] && pair1[1] === pair2[1];
    }
    function getMidpoint(pair1, pair2) {
      return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
    }
    exports2.default = booleanWithin;
  }
});

// node_modules/@turf/point-grid/dist/js/index.js
var require_js50 = __commonJS({
  "node_modules/@turf/point-grid/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var boolean_within_1 = __importDefault(require_js49());
    var distance_1 = __importDefault(require_js9());
    var helpers_1 = require_js();
    function pointGrid(bbox, cellSide, options) {
      if (options === void 0) {
        options = {};
      }
      if (options.mask && !options.units)
        options.units = "kilometers";
      var results = [];
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];
      var xFraction = cellSide / distance_1.default([west, south], [east, south], options);
      var cellWidth = xFraction * (east - west);
      var yFraction = cellSide / distance_1.default([west, south], [west, north], options);
      var cellHeight = yFraction * (north - south);
      var bboxWidth = east - west;
      var bboxHeight = north - south;
      var columns = Math.floor(bboxWidth / cellWidth);
      var rows = Math.floor(bboxHeight / cellHeight);
      var deltaX = (bboxWidth - columns * cellWidth) / 2;
      var deltaY = (bboxHeight - rows * cellHeight) / 2;
      var currentX = west + deltaX;
      while (currentX <= east) {
        var currentY = south + deltaY;
        while (currentY <= north) {
          var cellPt = helpers_1.point([currentX, currentY], options.properties);
          if (options.mask) {
            if (boolean_within_1.default(cellPt, options.mask))
              results.push(cellPt);
          } else {
            results.push(cellPt);
          }
          currentY += cellHeight;
        }
        currentX += cellWidth;
      }
      return helpers_1.featureCollection(results);
    }
    exports2.default = pointGrid;
  }
});

// node_modules/@turf/truncate/dist/js/index.js
var require_js51 = __commonJS({
  "node_modules/@turf/truncate/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    function truncate(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      var precision = options.precision;
      var coordinates = options.coordinates;
      var mutate = options.mutate;
      precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
      coordinates = coordinates === void 0 || coordinates === null || isNaN(coordinates) ? 3 : coordinates;
      if (!geojson)
        throw new Error("<geojson> is required");
      if (typeof precision !== "number")
        throw new Error("<precision> must be a number");
      if (typeof coordinates !== "number")
        throw new Error("<coordinates> must be a number");
      if (mutate === false || mutate === void 0)
        geojson = JSON.parse(JSON.stringify(geojson));
      var factor = Math.pow(10, precision);
      meta_1.coordEach(geojson, function(coords) {
        truncateCoords(coords, factor, coordinates);
      });
      return geojson;
    }
    function truncateCoords(coords, factor, coordinates) {
      if (coords.length > coordinates)
        coords.splice(coordinates, coords.length);
      for (var i = 0; i < coords.length; i++) {
        coords[i] = Math.round(coords[i] * factor) / factor;
      }
      return coords;
    }
    exports2.default = truncate;
  }
});

// node_modules/@turf/flatten/dist/js/index.js
var require_js52 = __commonJS({
  "node_modules/@turf/flatten/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var helpers = require_js();
    function flatten(geojson) {
      if (!geojson) throw new Error("geojson is required");
      var results = [];
      meta.flattenEach(geojson, function(feature) {
        results.push(feature);
      });
      return helpers.featureCollection(results);
    }
    module2.exports = flatten;
    module2.exports.default = flatten;
  }
});

// node_modules/@turf/line-chunk/dist/js/index.js
var require_js53 = __commonJS({
  "node_modules/@turf/line-chunk/dist/js/index.js"(exports2, module2) {
    "use strict";
    var length = require_js45();
    var lineSliceAlong = require_js47();
    var meta = require_js2();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var length__default = /* @__PURE__ */ _interopDefaultLegacy(length);
    var lineSliceAlong__default = /* @__PURE__ */ _interopDefaultLegacy(lineSliceAlong);
    function lineChunk(geojson, segmentLength, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var units = options.units;
      var reverse = options.reverse;
      if (!geojson) throw new Error("geojson is required");
      if (segmentLength <= 0)
        throw new Error("segmentLength must be greater than 0");
      var results = [];
      meta.flattenEach(geojson, function(feature) {
        if (reverse)
          feature.geometry.coordinates = feature.geometry.coordinates.reverse();
        sliceLineSegments(feature, segmentLength, units, function(segment) {
          results.push(segment);
        });
      });
      return helpers.featureCollection(results);
    }
    function sliceLineSegments(line, segmentLength, units, callback) {
      var lineLength = length__default["default"](line, { units });
      if (lineLength <= segmentLength) return callback(line);
      var numberOfSegments = lineLength / segmentLength;
      if (!Number.isInteger(numberOfSegments)) {
        numberOfSegments = Math.floor(numberOfSegments) + 1;
      }
      for (var i = 0; i < numberOfSegments; i++) {
        var outline = lineSliceAlong__default["default"](
          line,
          segmentLength * i,
          segmentLength * (i + 1),
          { units }
        );
        callback(outline, i);
      }
    }
    module2.exports = lineChunk;
    module2.exports.default = lineChunk;
  }
});

// node_modules/@turf/unkink-polygon/dist/js/index.js
var require_js54 = __commonJS({
  "node_modules/@turf/unkink-polygon/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var helpers = require_js();
    var rbush = require_rbush2();
    var area = require_js43();
    var booleanPointInPolygon = require_js7();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var rbush__default = /* @__PURE__ */ _interopDefaultLegacy(rbush);
    var area__default = /* @__PURE__ */ _interopDefaultLegacy(area);
    var booleanPointInPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(booleanPointInPolygon);
    function isects(feature, filterFn, useSpatialIndex) {
      if (feature.geometry.type !== "Polygon")
        throw new Error("The input feature must be a Polygon");
      if (useSpatialIndex === void 0) useSpatialIndex = 1;
      var coord = feature.geometry.coordinates;
      var output = [];
      var seen = {};
      if (useSpatialIndex) {
        var allEdgesAsRbushTreeItems = [];
        for (var ring0 = 0; ring0 < coord.length; ring0++) {
          for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
            allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
          }
        }
        var tree = rbush__default["default"]();
        tree.load(allEdgesAsRbushTreeItems);
      }
      for (var ringA = 0; ringA < coord.length; ringA++) {
        for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {
          if (useSpatialIndex) {
            var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
            bboxOverlaps.forEach(function(bboxIsect) {
              var ring12 = bboxIsect.ring;
              var edge12 = bboxIsect.edge;
              ifIsectAddToOutput(ringA, edgeA, ring12, edge12);
            });
          } else {
            for (var ring1 = 0; ring1 < coord.length; ring1++) {
              for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
                ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
              }
            }
          }
        }
      }
      if (!filterFn)
        output = {
          type: "Feature",
          geometry: { type: "MultiPoint", coordinates: output }
        };
      return output;
      function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {
        var start0 = coord[ring02][edge02];
        var end0 = coord[ring02][edge02 + 1];
        var start1 = coord[ring12][edge12];
        var end1 = coord[ring12][edge12 + 1];
        var isect = intersect(start0, end0, start1, end1);
        if (isect === null) return;
        var frac0;
        var frac1;
        if (end0[0] !== start0[0]) {
          frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
        } else {
          frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
        }
        if (end1[0] !== start1[0]) {
          frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
        } else {
          frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
        }
        if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return;
        var key = isect;
        var unique = !seen[key];
        if (unique) {
          seen[key] = true;
        }
        if (filterFn) {
          output.push(
            filterFn(
              isect,
              ring02,
              edge02,
              start0,
              end0,
              frac0,
              ring12,
              edge12,
              start1,
              end1,
              frac1,
              unique
            )
          );
        } else {
          output.push(isect);
        }
      }
      function rbushTreeItem(ring, edge) {
        var start = coord[ring][edge];
        var end = coord[ring][edge + 1];
        var minX;
        var maxX;
        var minY;
        var maxY;
        if (start[0] < end[0]) {
          minX = start[0];
          maxX = end[0];
        } else {
          minX = end[0];
          maxX = start[0];
        }
        if (start[1] < end[1]) {
          minY = start[1];
          maxY = end[1];
        } else {
          minY = end[1];
          maxY = start[1];
        }
        return {
          minX,
          minY,
          maxX,
          maxY,
          ring,
          edge
        };
      }
    }
    function intersect(start0, end0, start1, end1) {
      if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1))
        return null;
      var x0 = start0[0], y0 = start0[1], x1 = end0[0], y1 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
      var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
      if (denom === 0) return null;
      var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
      var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
      return [x4, y4];
    }
    function equalArrays(array1, array2) {
      if (!array1 || !array2) return false;
      if (array1.length !== array2.length) return false;
      for (var i = 0, l = array1.length; i < l; i++) {
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
          if (!equalArrays(array1[i], array2[i])) return false;
        } else if (array1[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    function simplepolygon(feature) {
      if (feature.type != "Feature")
        throw new Error("The input must a geojson object of type Feature");
      if (feature.geometry === void 0 || feature.geometry == null)
        throw new Error(
          "The input must a geojson object with a non-empty geometry"
        );
      if (feature.geometry.type != "Polygon")
        throw new Error("The input must be a geojson Polygon");
      var numRings = feature.geometry.coordinates.length;
      var vertices = [];
      for (var i = 0; i < numRings; i++) {
        var ring = feature.geometry.coordinates[i];
        if (!equalArrays$1(ring[0], ring[ring.length - 1])) {
          ring.push(ring[0]);
        }
        vertices.push.apply(vertices, ring.slice(0, ring.length - 1));
      }
      if (!isUnique(vertices))
        throw new Error(
          "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
        );
      var numvertices = vertices.length;
      var selfIsectsData = isects(
        feature,
        function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
          return [
            isect,
            ring0,
            edge0,
            start0,
            end0,
            frac0,
            ring1,
            edge1,
            start1,
            end1,
            frac1,
            unique
          ];
        }
      );
      var numSelfIsect = selfIsectsData.length;
      if (numSelfIsect == 0) {
        var outputFeatureArray = [];
        for (var i = 0; i < numRings; i++) {
          outputFeatureArray.push(
            helpers.polygon([feature.geometry.coordinates[i]], {
              parent: -1,
              winding: windingOfRing(feature.geometry.coordinates[i])
            })
          );
        }
        var output = helpers.featureCollection(outputFeatureArray);
        determineParents();
        setNetWinding();
        return output;
      }
      var pseudoVtxListByRingAndEdge = [];
      var isectList = [];
      for (var i = 0; i < numRings; i++) {
        pseudoVtxListByRingAndEdge.push([]);
        for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {
          pseudoVtxListByRingAndEdge[i].push([
            new PseudoVtx(
              feature.geometry.coordinates[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)],
              1,
              [i, j],
              [i, modulo(j + 1, feature.geometry.coordinates[i].length - 1)],
              void 0
            )
          ]);
          isectList.push(
            new Isect(
              feature.geometry.coordinates[i][j],
              [i, modulo(j - 1, feature.geometry.coordinates[i].length - 1)],
              [i, j],
              void 0,
              void 0,
              false,
              true
            )
          );
        }
      }
      for (var i = 0; i < numSelfIsect; i++) {
        pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(
          new PseudoVtx(
            selfIsectsData[i][0],
            selfIsectsData[i][5],
            [selfIsectsData[i][1], selfIsectsData[i][2]],
            [selfIsectsData[i][6], selfIsectsData[i][7]],
            void 0
          )
        );
        if (selfIsectsData[i][11])
          isectList.push(
            new Isect(
              selfIsectsData[i][0],
              [selfIsectsData[i][1], selfIsectsData[i][2]],
              [selfIsectsData[i][6], selfIsectsData[i][7]],
              void 0,
              void 0,
              true,
              true
            )
          );
      }
      var numIsect = isectList.length;
      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
          pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {
            return a.param < b.param ? -1 : 1;
          });
        }
      }
      var allIsectsAsIsectRbushTreeItem = [];
      for (var i = 0; i < numIsect; i++) {
        allIsectsAsIsectRbushTreeItem.push({
          minX: isectList[i].coord[0],
          minY: isectList[i].coord[1],
          maxX: isectList[i].coord[0],
          maxY: isectList[i].coord[1],
          index: i
        });
      }
      var isectRbushTree = rbush__default["default"]();
      isectRbushTree.load(allIsectsAsIsectRbushTreeItem);
      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
          for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
            var coordToFind;
            if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
              coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)][0].coord;
            } else {
              coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
            }
            var IsectRbushTreeItemFound = isectRbushTree.search({
              minX: coordToFind[0],
              minY: coordToFind[1],
              maxX: coordToFind[0],
              maxY: coordToFind[1]
            })[0];
            pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
          }
        }
      }
      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
          for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
            var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
            var IsectRbushTreeItemFound = isectRbushTree.search({
              minX: coordToFind[0],
              minY: coordToFind[1],
              maxX: coordToFind[0],
              maxY: coordToFind[1]
            })[0];
            var l = IsectRbushTreeItemFound.index;
            if (l < numvertices) {
              isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
            } else {
              if (equalArrays$1(
                isectList[l].ringAndEdge1,
                pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn
              )) {
                isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
              } else {
                isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
              }
            }
          }
        }
      }
      var queue = [];
      var i = 0;
      for (var j = 0; j < numRings; j++) {
        var leftIsect = i;
        for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {
          if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
            leftIsect = i;
          }
          i++;
        }
        var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
        for (var k = 0; k < isectList.length; k++) {
          if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
            var isectBeforeLeftIsect = k;
            break;
          }
        }
        var windingAtIsect = isConvex(
          [
            isectList[isectBeforeLeftIsect].coord,
            isectList[leftIsect].coord,
            isectList[isectAfterLeftIsect].coord
          ],
          true
        ) ? 1 : -1;
        queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
      }
      queue.sort(function(a, b) {
        return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
      });
      var outputFeatureArray = [];
      while (queue.length > 0) {
        var popped = queue.pop();
        var startIsect = popped.isect;
        var currentOutputRingParent = popped.parent;
        var currentOutputRingWinding = popped.winding;
        var currentOutputRing = outputFeatureArray.length;
        var currentOutputRingCoords = [isectList[startIsect].coord];
        var currentIsect = startIsect;
        if (isectList[startIsect].ringAndEdge1Walkable) {
          var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
          var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
        } else {
          var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
          var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
        }
        while (!equalArrays$1(isectList[startIsect].coord, isectList[nxtIsect].coord)) {
          currentOutputRingCoords.push(isectList[nxtIsect].coord);
          var nxtIsectInQueue = void 0;
          for (var i = 0; i < queue.length; i++) {
            if (queue[i].isect == nxtIsect) {
              nxtIsectInQueue = i;
              break;
            }
          }
          if (nxtIsectInQueue != void 0) {
            queue.splice(nxtIsectInQueue, 1);
          }
          if (equalArrays$1(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
            walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
            isectList[nxtIsect].ringAndEdge2Walkable = false;
            if (isectList[nxtIsect].ringAndEdge1Walkable) {
              var pushing = { isect: nxtIsect };
              if (isConvex(
                [
                  isectList[currentIsect].coord,
                  isectList[nxtIsect].coord,
                  isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord
                ],
                currentOutputRingWinding == 1
              )) {
                pushing.parent = currentOutputRingParent;
                pushing.winding = -currentOutputRingWinding;
              } else {
                pushing.parent = currentOutputRing;
                pushing.winding = currentOutputRingWinding;
              }
              queue.push(pushing);
            }
            currentIsect = nxtIsect;
            nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
          } else {
            walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
            isectList[nxtIsect].ringAndEdge1Walkable = false;
            if (isectList[nxtIsect].ringAndEdge2Walkable) {
              var pushing = { isect: nxtIsect };
              if (isConvex(
                [
                  isectList[currentIsect].coord,
                  isectList[nxtIsect].coord,
                  isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord
                ],
                currentOutputRingWinding == 1
              )) {
                pushing.parent = currentOutputRingParent;
                pushing.winding = -currentOutputRingWinding;
              } else {
                pushing.parent = currentOutputRing;
                pushing.winding = currentOutputRingWinding;
              }
              queue.push(pushing);
            }
            currentIsect = nxtIsect;
            nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
          }
        }
        currentOutputRingCoords.push(isectList[nxtIsect].coord);
        outputFeatureArray.push(
          helpers.polygon([currentOutputRingCoords], {
            index: currentOutputRing,
            parent: currentOutputRingParent,
            winding: currentOutputRingWinding,
            netWinding: void 0
          })
        );
      }
      var output = helpers.featureCollection(outputFeatureArray);
      determineParents();
      setNetWinding();
      function determineParents() {
        var featuresWithoutParent = [];
        for (var i2 = 0; i2 < output.features.length; i2++) {
          if (output.features[i2].properties.parent == -1)
            featuresWithoutParent.push(i2);
        }
        if (featuresWithoutParent.length > 1) {
          for (var i2 = 0; i2 < featuresWithoutParent.length; i2++) {
            var parent = -1;
            var parentArea = Infinity;
            for (var j2 = 0; j2 < output.features.length; j2++) {
              if (featuresWithoutParent[i2] == j2) continue;
              if (booleanPointInPolygon__default["default"](
                output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0],
                output.features[j2],
                { ignoreBoundary: true }
              )) {
                if (area__default["default"](output.features[j2]) < parentArea) {
                  parent = j2;
                }
              }
            }
            output.features[featuresWithoutParent[i2]].properties.parent = parent;
          }
        }
      }
      function setNetWinding() {
        for (var i2 = 0; i2 < output.features.length; i2++) {
          if (output.features[i2].properties.parent == -1) {
            var netWinding = output.features[i2].properties.winding;
            output.features[i2].properties.netWinding = netWinding;
            setNetWindingOfChildren(i2, netWinding);
          }
        }
      }
      function setNetWindingOfChildren(parent, ParentNetWinding) {
        for (var i2 = 0; i2 < output.features.length; i2++) {
          if (output.features[i2].properties.parent == parent) {
            var netWinding = ParentNetWinding + output.features[i2].properties.winding;
            output.features[i2].properties.netWinding = netWinding;
            setNetWindingOfChildren(i2, netWinding);
          }
        }
      }
      return output;
    }
    var PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
      this.coord = coord;
      this.param = param;
      this.ringAndEdgeIn = ringAndEdgeIn;
      this.ringAndEdgeOut = ringAndEdgeOut;
      this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;
    };
    var Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
      this.coord = coord;
      this.ringAndEdge1 = ringAndEdge1;
      this.ringAndEdge2 = ringAndEdge2;
      this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;
      this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;
      this.ringAndEdge1Walkable = ringAndEdge1Walkable;
      this.ringAndEdge2Walkable = ringAndEdge2Walkable;
    };
    function isConvex(pts, righthanded) {
      if (typeof righthanded === "undefined") righthanded = true;
      if (pts.length != 3)
        throw new Error("This function requires an array of three points [x,y]");
      var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
      return d >= 0 == righthanded;
    }
    function windingOfRing(ring) {
      var leftVtx = 0;
      for (var i = 0; i < ring.length - 1; i++) {
        if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;
      }
      if (isConvex(
        [
          ring[modulo(leftVtx - 1, ring.length - 1)],
          ring[leftVtx],
          ring[modulo(leftVtx + 1, ring.length - 1)]
        ],
        true
      )) {
        var winding = 1;
      } else {
        var winding = -1;
      }
      return winding;
    }
    function equalArrays$1(array1, array2) {
      if (!array1 || !array2) return false;
      if (array1.length != array2.length) return false;
      for (var i = 0, l = array1.length; i < l; i++) {
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
          if (!equalArrays$1(array1[i], array2[i])) return false;
        } else if (array1[i] != array2[i]) {
          return false;
        }
      }
      return true;
    }
    function modulo(n, m) {
      return (n % m + m) % m;
    }
    function isUnique(array) {
      var u = {};
      var isUnique2 = 1;
      for (var i = 0, l = array.length; i < l; ++i) {
        if (Object.prototype.hasOwnProperty.call(u, array[i])) {
          isUnique2 = 0;
          break;
        }
        u[array[i]] = 1;
      }
      return isUnique2;
    }
    function unkinkPolygon(geojson) {
      var features = [];
      meta.flattenEach(geojson, function(feature) {
        if (feature.geometry.type !== "Polygon") return;
        meta.featureEach(simplepolygon(feature), function(poly) {
          features.push(helpers.polygon(poly.geometry.coordinates, feature.properties));
        });
      });
      return helpers.featureCollection(features);
    }
    module2.exports = unkinkPolygon;
    module2.exports.default = unkinkPolygon;
  }
});

// node_modules/@turf/great-circle/dist/js/index.js
var require_js55 = __commonJS({
  "node_modules/@turf/great-circle/dist/js/index.js"(exports2, module2) {
    "use strict";
    var invariant = require_js4();
    var D2R = Math.PI / 180;
    var R2D = 180 / Math.PI;
    var Coord = function(lon, lat) {
      this.lon = lon;
      this.lat = lat;
      this.x = D2R * lon;
      this.y = D2R * lat;
    };
    Coord.prototype.view = function() {
      return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
    };
    Coord.prototype.antipode = function() {
      var anti_lat = -1 * this.lat;
      var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
      return new Coord(anti_lon, anti_lat);
    };
    var LineString = function() {
      this.coords = [];
      this.length = 0;
    };
    LineString.prototype.move_to = function(coord) {
      this.length++;
      this.coords.push(coord);
    };
    var Arc = function(properties) {
      this.properties = properties || {};
      this.geometries = [];
    };
    Arc.prototype.json = function() {
      if (this.geometries.length <= 0) {
        return {
          geometry: { type: "LineString", coordinates: null },
          type: "Feature",
          properties: this.properties
        };
      } else if (this.geometries.length === 1) {
        return {
          geometry: { type: "LineString", coordinates: this.geometries[0].coords },
          type: "Feature",
          properties: this.properties
        };
      } else {
        var multiline = [];
        for (var i = 0; i < this.geometries.length; i++) {
          multiline.push(this.geometries[i].coords);
        }
        return {
          geometry: { type: "MultiLineString", coordinates: multiline },
          type: "Feature",
          properties: this.properties
        };
      }
    };
    Arc.prototype.wkt = function() {
      var wkt_string = "";
      var wkt = "LINESTRING(";
      var collect = function(c) {
        wkt += c[0] + " " + c[1] + ",";
      };
      for (var i = 0; i < this.geometries.length; i++) {
        if (this.geometries[i].coords.length === 0) {
          return "LINESTRING(empty)";
        } else {
          var coords = this.geometries[i].coords;
          coords.forEach(collect);
          wkt_string += wkt.substring(0, wkt.length - 1) + ")";
        }
      }
      return wkt_string;
    };
    var GreatCircle = function(start, end, properties) {
      if (!start || start.x === void 0 || start.y === void 0) {
        throw new Error(
          "GreatCircle constructor expects two args: start and end objects with x and y properties"
        );
      }
      if (!end || end.x === void 0 || end.y === void 0) {
        throw new Error(
          "GreatCircle constructor expects two args: start and end objects with x and y properties"
        );
      }
      this.start = new Coord(start.x, start.y);
      this.end = new Coord(end.x, end.y);
      this.properties = properties || {};
      var w = this.start.x - this.end.x;
      var h = this.start.y - this.end.y;
      var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
      this.g = 2 * Math.asin(Math.sqrt(z));
      if (this.g === Math.PI) {
        throw new Error(
          "it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
        );
      } else if (isNaN(this.g)) {
        throw new Error(
          "could not calculate great circle between " + start + " and " + end
        );
      }
    };
    GreatCircle.prototype.interpolate = function(f) {
      var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
      var B = Math.sin(f * this.g) / Math.sin(this.g);
      var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);
      var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);
      var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);
      var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
      var lon = R2D * Math.atan2(y, x);
      return [lon, lat];
    };
    GreatCircle.prototype.Arc = function(npoints, options) {
      var first_pass = [];
      if (!npoints || npoints <= 2) {
        first_pass.push([this.start.lon, this.start.lat]);
        first_pass.push([this.end.lon, this.end.lat]);
      } else {
        var delta = 1 / (npoints - 1);
        for (var i = 0; i < npoints; ++i) {
          var step = delta * i;
          var pair = this.interpolate(step);
          first_pass.push(pair);
        }
      }
      var bHasBigDiff = false;
      var dfMaxSmallDiffLong = 0;
      var dfDateLineOffset = options && options.offset ? options.offset : 10;
      var dfLeftBorderX = 180 - dfDateLineOffset;
      var dfRightBorderX = -180 + dfDateLineOffset;
      var dfDiffSpace = 360 - dfDateLineOffset;
      for (var j = 1; j < first_pass.length; ++j) {
        var dfPrevX = first_pass[j - 1][0];
        var dfX = first_pass[j][0];
        var dfDiffLong = Math.abs(dfX - dfPrevX);
        if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
          bHasBigDiff = true;
        } else if (dfDiffLong > dfMaxSmallDiffLong) {
          dfMaxSmallDiffLong = dfDiffLong;
        }
      }
      var poMulti = [];
      if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
        var poNewLS = [];
        poMulti.push(poNewLS);
        for (var k = 0; k < first_pass.length; ++k) {
          var dfX0 = parseFloat(first_pass[k][0]);
          if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
            var dfX1 = parseFloat(first_pass[k - 1][0]);
            var dfY1 = parseFloat(first_pass[k - 1][1]);
            var dfX2 = parseFloat(first_pass[k][0]);
            var dfY2 = parseFloat(first_pass[k][1]);
            if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
              poNewLS.push([-180, first_pass[k][1]]);
              k++;
              poNewLS.push([first_pass[k][0], first_pass[k][1]]);
              continue;
            } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
              poNewLS.push([180, first_pass[k][1]]);
              k++;
              poNewLS.push([first_pass[k][0], first_pass[k][1]]);
              continue;
            }
            if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
              var tmpX = dfX1;
              dfX1 = dfX2;
              dfX2 = tmpX;
              var tmpY = dfY1;
              dfY1 = dfY2;
              dfY2 = tmpY;
            }
            if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
              dfX2 += 360;
            }
            if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
              var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
              var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
              poNewLS.push([
                first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
                dfY
              ]);
              poNewLS = [];
              poNewLS.push([
                first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
                dfY
              ]);
              poMulti.push(poNewLS);
            } else {
              poNewLS = [];
              poMulti.push(poNewLS);
            }
            poNewLS.push([dfX0, first_pass[k][1]]);
          } else {
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          }
        }
      } else {
        var poNewLS0 = [];
        poMulti.push(poNewLS0);
        for (var l = 0; l < first_pass.length; ++l) {
          poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
        }
      }
      var arc = new Arc(this.properties);
      for (var m = 0; m < poMulti.length; ++m) {
        var line = new LineString();
        arc.geometries.push(line);
        var points = poMulti[m];
        for (var j0 = 0; j0 < points.length; ++j0) {
          line.move_to(points[j0]);
        }
      }
      return arc;
    };
    function greatCircle(start, end, options) {
      options = options || {};
      if (typeof options !== "object") throw new Error("options is invalid");
      var properties = options.properties;
      var npoints = options.npoints;
      var offset = options.offset;
      start = invariant.getCoord(start);
      end = invariant.getCoord(end);
      properties = properties || {};
      npoints = npoints || 100;
      offset = offset || 10;
      var generator = new GreatCircle(
        { x: start[0], y: start[1] },
        { x: end[0], y: end[1] },
        properties
      );
      var line = generator.Arc(npoints, { offset });
      return line.json();
    }
    module2.exports = greatCircle;
    module2.exports.default = greatCircle;
  }
});

// node_modules/@turf/line-split/dist/js/index.js
var require_js56 = __commonJS({
  "node_modules/@turf/line-split/dist/js/index.js"(exports2, module2) {
    "use strict";
    var rbush = require_geojson_rbush();
    var square = require_js22();
    var bbox = require_js3();
    var truncate = require_js51();
    var lineSegment = require_js34();
    var lineIntersect = require_js35();
    var nearestPointOnLine = require_js36();
    var invariant = require_js4();
    var meta = require_js2();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var rbush__default = /* @__PURE__ */ _interopDefaultLegacy(rbush);
    var square__default = /* @__PURE__ */ _interopDefaultLegacy(square);
    var bbox__default = /* @__PURE__ */ _interopDefaultLegacy(bbox);
    var truncate__default = /* @__PURE__ */ _interopDefaultLegacy(truncate);
    var lineSegment__default = /* @__PURE__ */ _interopDefaultLegacy(lineSegment);
    var lineIntersect__default = /* @__PURE__ */ _interopDefaultLegacy(lineIntersect);
    var nearestPointOnLine__default = /* @__PURE__ */ _interopDefaultLegacy(nearestPointOnLine);
    function lineSplit(line, splitter) {
      if (!line) throw new Error("line is required");
      if (!splitter) throw new Error("splitter is required");
      var lineType = invariant.getType(line);
      var splitterType = invariant.getType(splitter);
      if (lineType !== "LineString") throw new Error("line must be LineString");
      if (splitterType === "FeatureCollection")
        throw new Error("splitter cannot be a FeatureCollection");
      if (splitterType === "GeometryCollection")
        throw new Error("splitter cannot be a GeometryCollection");
      var truncatedSplitter = truncate__default["default"](splitter, { precision: 7 });
      switch (splitterType) {
        case "Point":
          return splitLineWithPoint(line, truncatedSplitter);
        case "MultiPoint":
          return splitLineWithPoints(line, truncatedSplitter);
        case "LineString":
        case "MultiLineString":
        case "Polygon":
        case "MultiPolygon":
          return splitLineWithPoints(line, lineIntersect__default["default"](line, truncatedSplitter));
      }
    }
    function splitLineWithPoints(line, splitter) {
      var results = [];
      var tree = rbush__default["default"]();
      meta.flattenEach(splitter, function(point) {
        results.forEach(function(feature, index) {
          feature.id = index;
        });
        if (!results.length) {
          results = splitLineWithPoint(line, point).features;
          results.forEach(function(feature) {
            if (!feature.bbox) feature.bbox = square__default["default"](bbox__default["default"](feature));
          });
          tree.load(helpers.featureCollection(results));
        } else {
          var search = tree.search(point);
          if (search.features.length) {
            var closestLine = findClosestFeature(point, search);
            results = results.filter(function(feature) {
              return feature.id !== closestLine.id;
            });
            tree.remove(closestLine);
            meta.featureEach(splitLineWithPoint(closestLine, point), function(line2) {
              results.push(line2);
              tree.insert(line2);
            });
          }
        }
      });
      return helpers.featureCollection(results);
    }
    function splitLineWithPoint(line, splitter) {
      var results = [];
      var startPoint = invariant.getCoords(line)[0];
      var endPoint = invariant.getCoords(line)[line.geometry.coordinates.length - 1];
      if (pointsEquals(startPoint, invariant.getCoord(splitter)) || pointsEquals(endPoint, invariant.getCoord(splitter)))
        return helpers.featureCollection([line]);
      var tree = rbush__default["default"]();
      var segments = lineSegment__default["default"](line);
      tree.load(segments);
      var search = tree.search(splitter);
      if (!search.features.length) return helpers.featureCollection([line]);
      var closestSegment = findClosestFeature(splitter, search);
      var initialValue = [startPoint];
      var lastCoords = meta.featureReduce(
        segments,
        function(previous, current, index) {
          var currentCoords = invariant.getCoords(current)[1];
          var splitterCoords = invariant.getCoord(splitter);
          if (index === closestSegment.id) {
            previous.push(splitterCoords);
            results.push(helpers.lineString(previous));
            if (pointsEquals(splitterCoords, currentCoords))
              return [splitterCoords];
            return [splitterCoords, currentCoords];
          } else {
            previous.push(currentCoords);
            return previous;
          }
        },
        initialValue
      );
      if (lastCoords.length > 1) {
        results.push(helpers.lineString(lastCoords));
      }
      return helpers.featureCollection(results);
    }
    function findClosestFeature(point, lines) {
      if (!lines.features.length) throw new Error("lines must contain features");
      if (lines.features.length === 1) return lines.features[0];
      var closestFeature;
      var closestDistance = Infinity;
      meta.featureEach(lines, function(segment) {
        var pt = nearestPointOnLine__default["default"](segment, point);
        var dist = pt.properties.dist;
        if (dist < closestDistance) {
          closestFeature = segment;
          closestDistance = dist;
        }
      });
      return closestFeature;
    }
    function pointsEquals(pt1, pt2) {
      return pt1[0] === pt2[0] && pt1[1] === pt2[1];
    }
    module2.exports = lineSplit;
    module2.exports.default = lineSplit;
  }
});

// node_modules/@turf/line-arc/dist/js/index.js
var require_js57 = __commonJS({
  "node_modules/@turf/line-arc/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var circle_1 = __importDefault(require_js24());
    var destination_1 = __importDefault(require_js23());
    var helpers_1 = require_js();
    function lineArc(center, radius, bearing1, bearing2, options) {
      if (options === void 0) {
        options = {};
      }
      var steps = options.steps || 64;
      var angle1 = convertAngleTo360(bearing1);
      var angle2 = convertAngleTo360(bearing2);
      var properties = !Array.isArray(center) && center.type === "Feature" ? center.properties : {};
      if (angle1 === angle2) {
        return helpers_1.lineString(circle_1.default(center, radius, options).geometry.coordinates[0], properties);
      }
      var arcStartDegree = angle1;
      var arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;
      var alfa = arcStartDegree;
      var coordinates = [];
      var i = 0;
      while (alfa < arcEndDegree) {
        coordinates.push(destination_1.default(center, radius, alfa, options).geometry.coordinates);
        i++;
        alfa = arcStartDegree + i * 360 / steps;
      }
      if (alfa > arcEndDegree) {
        coordinates.push(destination_1.default(center, radius, arcEndDegree, options).geometry.coordinates);
      }
      return helpers_1.lineString(coordinates, properties);
    }
    exports2.default = lineArc;
    function convertAngleTo360(alfa) {
      var beta = alfa % 360;
      if (beta < 0) {
        beta += 360;
      }
      return beta;
    }
  }
});

// node_modules/@turf/polygon-to-line/dist/js/index.js
var require_js58 = __commonJS({
  "node_modules/@turf/polygon-to-line/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function default_1(poly, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(poly);
      if (!options.properties && poly.type === "Feature") {
        options.properties = poly.properties;
      }
      switch (geom.type) {
        case "Polygon":
          return polygonToLine(geom, options);
        case "MultiPolygon":
          return multiPolygonToLine(geom, options);
        default:
          throw new Error("invalid poly");
      }
    }
    exports2.default = default_1;
    function polygonToLine(poly, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(poly);
      var coords = geom.coordinates;
      var properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
      return coordsToLine(coords, properties);
    }
    exports2.polygonToLine = polygonToLine;
    function multiPolygonToLine(multiPoly, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(multiPoly);
      var coords = geom.coordinates;
      var properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
      var lines = [];
      coords.forEach(function(coord) {
        lines.push(coordsToLine(coord, properties));
      });
      return helpers_1.featureCollection(lines);
    }
    exports2.multiPolygonToLine = multiPolygonToLine;
    function coordsToLine(coords, properties) {
      if (coords.length > 1) {
        return helpers_1.multiLineString(coords, properties);
      }
      return helpers_1.lineString(coords[0], properties);
    }
    exports2.coordsToLine = coordsToLine;
  }
});

// node_modules/@turf/line-to-polygon/dist/js/index.js
var require_js59 = __commonJS({
  "node_modules/@turf/line-to-polygon/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bbox_1 = __importDefault(require_js3());
    var invariant_1 = require_js4();
    var helpers_1 = require_js();
    var clone_1 = __importDefault(require_js11());
    function lineToPolygon(lines, options) {
      if (options === void 0) {
        options = {};
      }
      var _a, _b, _c;
      var properties = options.properties;
      var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;
      var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;
      var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;
      if (!mutate) {
        lines = clone_1.default(lines);
      }
      switch (lines.type) {
        case "FeatureCollection":
          var coords = [];
          lines.features.forEach(function(line) {
            coords.push(invariant_1.getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));
          });
          return helpers_1.multiPolygon(coords, properties);
        default:
          return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
      }
    }
    function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
      properties = properties ? properties : line.type === "Feature" ? line.properties : {};
      var geom = invariant_1.getGeom(line);
      var coords = geom.coordinates;
      var type = geom.type;
      if (!coords.length)
        throw new Error("line must contain coordinates");
      switch (type) {
        case "LineString":
          if (autoComplete)
            coords = autoCompleteCoords(coords);
          return helpers_1.polygon([coords], properties);
        case "MultiLineString":
          var multiCoords = [];
          var largestArea = 0;
          coords.forEach(function(coord) {
            if (autoComplete)
              coord = autoCompleteCoords(coord);
            if (orderCoords) {
              var area = calculateArea(bbox_1.default(helpers_1.lineString(coord)));
              if (area > largestArea) {
                multiCoords.unshift(coord);
                largestArea = area;
              } else
                multiCoords.push(coord);
            } else {
              multiCoords.push(coord);
            }
          });
          return helpers_1.polygon(multiCoords, properties);
        default:
          throw new Error("geometry type " + type + " is not supported");
      }
    }
    function autoCompleteCoords(coords) {
      var first = coords[0];
      var x1 = first[0];
      var y1 = first[1];
      var last = coords[coords.length - 1];
      var x2 = last[0];
      var y2 = last[1];
      if (x1 !== x2 || y1 !== y2) {
        coords.push(first);
      }
      return coords;
    }
    function calculateArea(bbox) {
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];
      return Math.abs(west - east) * Math.abs(south - north);
    }
    exports2.default = lineToPolygon;
  }
});

// node_modules/@turf/bbox-clip/dist/js/lib/lineclip.js
var require_lineclip = __commonJS({
  "node_modules/@turf/bbox-clip/dist/js/lib/lineclip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function lineclip(points, bbox, result2) {
      var len = points.length, codeA = bitCode(points[0], bbox), part = [], i, codeB, lastCode;
      var a;
      var b;
      if (!result2)
        result2 = [];
      for (i = 1; i < len; i++) {
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);
        while (true) {
          if (!(codeA | codeB)) {
            part.push(a);
            if (codeB !== lastCode) {
              part.push(b);
              if (i < len - 1) {
                result2.push(part);
                part = [];
              }
            } else if (i === len - 1) {
              part.push(b);
            }
            break;
          } else if (codeA & codeB) {
            break;
          } else if (codeA) {
            a = intersect(a, b, codeA, bbox);
            codeA = bitCode(a, bbox);
          } else {
            b = intersect(a, b, codeB, bbox);
            codeB = bitCode(b, bbox);
          }
        }
        codeA = lastCode;
      }
      if (part.length)
        result2.push(part);
      return result2;
    }
    exports2.lineclip = lineclip;
    function polygonclip(points, bbox) {
      var result2, edge, prev, prevInside, i, p, inside;
      for (edge = 1; edge <= 8; edge *= 2) {
        result2 = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);
        for (i = 0; i < points.length; i++) {
          p = points[i];
          inside = !(bitCode(p, bbox) & edge);
          if (inside !== prevInside)
            result2.push(intersect(prev, p, edge, bbox));
          if (inside)
            result2.push(p);
          prev = p;
          prevInside = inside;
        }
        points = result2;
        if (!points.length)
          break;
      }
      return result2;
    }
    exports2.polygonclip = polygonclip;
    function intersect(a, b, edge, bbox) {
      return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : null;
    }
    function bitCode(p, bbox) {
      var code = 0;
      if (p[0] < bbox[0])
        code |= 1;
      else if (p[0] > bbox[2])
        code |= 2;
      if (p[1] < bbox[1])
        code |= 4;
      else if (p[1] > bbox[3])
        code |= 8;
      return code;
    }
  }
});

// node_modules/@turf/bbox-clip/dist/js/index.js
var require_js60 = __commonJS({
  "node_modules/@turf/bbox-clip/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var lineclip_1 = require_lineclip();
    function bboxClip(feature, bbox) {
      var geom = invariant_1.getGeom(feature);
      var type = geom.type;
      var properties = feature.type === "Feature" ? feature.properties : {};
      var coords = geom.coordinates;
      switch (type) {
        case "LineString":
        case "MultiLineString": {
          var lines_1 = [];
          if (type === "LineString") {
            coords = [coords];
          }
          coords.forEach(function(line) {
            lineclip_1.lineclip(line, bbox, lines_1);
          });
          if (lines_1.length === 1) {
            return helpers_1.lineString(lines_1[0], properties);
          }
          return helpers_1.multiLineString(lines_1, properties);
        }
        case "Polygon":
          return helpers_1.polygon(clipPolygon(coords, bbox), properties);
        case "MultiPolygon":
          return helpers_1.multiPolygon(coords.map(function(poly) {
            return clipPolygon(poly, bbox);
          }), properties);
        default:
          throw new Error("geometry " + type + " not supported");
      }
    }
    exports2.default = bboxClip;
    function clipPolygon(rings, bbox) {
      var outRings = [];
      for (var _i = 0, rings_1 = rings; _i < rings_1.length; _i++) {
        var ring = rings_1[_i];
        var clipped = lineclip_1.polygonclip(ring, bbox);
        if (clipped.length > 0) {
          if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
            clipped.push(clipped[0]);
          }
          if (clipped.length >= 4) {
            outRings.push(clipped);
          }
        }
      }
      return outRings;
    }
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src2 = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src2();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result2 = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result2;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports2, module2) {
    "use strict";
    var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var arePropertyDescriptorsSupported = function() {
      var obj = {};
      try {
        origDefineProperty(obj, "x", { enumerable: false, value: obj });
        for (var _ in obj) {
          return false;
        }
        return obj.x === obj;
      } catch (e) {
        return false;
      }
    };
    var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object && (!isFunction(predicate) || !predicate())) {
        return;
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map2) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map2);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map2));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map2[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object-is/implementation.js"(exports2, module2) {
    "use strict";
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module2.exports = function is(a, b) {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      if (a === b) {
        return true;
      }
      if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object-is/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/object-is/shim.js
var require_shim = __commonJS({
  "node_modules/object-is/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module2.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module2.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// node_modules/es-abstract/helpers/callBind.js
var require_callBind = __commonJS({
  "node_modules/es-abstract/helpers/callBind.js"(exports2, module2) {
    "use strict";
    module2.exports = require_call_bind();
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports2, module2) {
    "use strict";
    var $Object = Object;
    var $TypeError = TypeError;
    module2.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result2 = "";
      if (this.global) {
        result2 += "g";
      }
      if (this.ignoreCase) {
        result2 += "i";
      }
      if (this.multiline) {
        result2 += "m";
      }
      if (this.dotAll) {
        result2 += "s";
      }
      if (this.unicode) {
        result2 += "u";
      }
      if (this.sticky) {
        result2 += "y";
      }
      return result2;
    };
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    var $TypeError = TypeError;
    module2.exports = function getPolyfill() {
      if (!supportsDescriptors) {
        throw new $TypeError("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      if (/a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
          return descriptor.get;
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports2, module2) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module2.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_callBind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(implementation);
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = flagsBound;
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports2, module2) {
    "use strict";
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateObject2(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    module2.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/deep-equal/index.js
var require_deep_equal = __commonJS({
  "node_modules/deep-equal/index.js"(exports2, module2) {
    var objectKeys = require_object_keys();
    var isArguments = require_is_arguments();
    var is = require_object_is();
    var isRegex = require_is_regex();
    var flags = require_regexp_prototype();
    var isDate = require_is_date_object();
    var getTime = Date.prototype.getTime;
    function deepEqual(actual, expected, options) {
      var opts = options || {};
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is(actual, expected) : actual == expected;
      }
      return objEquiv(actual, expected, opts);
    }
    function isUndefinedOrNull(value) {
      return value === null || value === void 0;
    }
    function isBuffer(x) {
      if (!x || typeof x !== "object" || typeof x.length !== "number") {
        return false;
      }
      if (typeof x.copy !== "function" || typeof x.slice !== "function") {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== "number") {
        return false;
      }
      return true;
    }
    function objEquiv(a, b, opts) {
      var i, key;
      if (typeof a !== typeof b) {
        return false;
      }
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
        return false;
      }
      if (a.prototype !== b.prototype) {
        return false;
      }
      if (isArguments(a) !== isArguments(b)) {
        return false;
      }
      var aIsRegex = isRegex(a);
      var bIsRegex = isRegex(b);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if (aIsRegex || bIsRegex) {
        return a.source === b.source && flags(a) === flags(b);
      }
      if (isDate(a) && isDate(b)) {
        return getTime.call(a) === getTime.call(b);
      }
      var aIsBuffer = isBuffer(a);
      var bIsBuffer = isBuffer(b);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a.length !== b.length) {
          return false;
        }
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      try {
        var ka = objectKeys(a);
        var kb = objectKeys(b);
      } catch (e) {
        return false;
      }
      if (ka.length !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i]) {
          return false;
        }
      }
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = deepEqual;
  }
});

// node_modules/@turf/line-overlap/dist/js/index.js
var require_js61 = __commonJS({
  "node_modules/@turf/line-overlap/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var geojson_rbush_1 = __importDefault(require_geojson_rbush());
    var line_segment_1 = __importDefault(require_js34());
    var nearest_point_on_line_1 = __importDefault(require_js36());
    var boolean_point_on_line_1 = __importDefault(require_js48());
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    var deep_equal_1 = __importDefault(require_deep_equal());
    function lineOverlap(line1, line2, options) {
      if (options === void 0) {
        options = {};
      }
      options = options || {};
      if (!helpers_1.isObject(options))
        throw new Error("options is invalid");
      var tolerance = options.tolerance || 0;
      var features = [];
      var tree = geojson_rbush_1.default();
      var line = line_segment_1.default(line1);
      tree.load(line);
      var overlapSegment;
      meta_1.segmentEach(line2, function(segment) {
        var doesOverlaps = false;
        if (!segment) {
          return;
        }
        meta_1.featureEach(tree.search(segment), function(match) {
          if (doesOverlaps === false) {
            var coordsSegment = invariant_1.getCoords(segment).sort();
            var coordsMatch = invariant_1.getCoords(match).sort();
            if (deep_equal_1.default(coordsSegment, coordsMatch)) {
              doesOverlaps = true;
              if (overlapSegment)
                overlapSegment = concatSegment(overlapSegment, segment);
              else
                overlapSegment = segment;
            } else if (tolerance === 0 ? boolean_point_on_line_1.default(coordsSegment[0], match) && boolean_point_on_line_1.default(coordsSegment[1], match) : nearest_point_on_line_1.default(match, coordsSegment[0]).properties.dist <= tolerance && nearest_point_on_line_1.default(match, coordsSegment[1]).properties.dist <= tolerance) {
              doesOverlaps = true;
              if (overlapSegment)
                overlapSegment = concatSegment(overlapSegment, segment);
              else
                overlapSegment = segment;
            } else if (tolerance === 0 ? boolean_point_on_line_1.default(coordsMatch[0], segment) && boolean_point_on_line_1.default(coordsMatch[1], segment) : nearest_point_on_line_1.default(segment, coordsMatch[0]).properties.dist <= tolerance && nearest_point_on_line_1.default(segment, coordsMatch[1]).properties.dist <= tolerance) {
              if (overlapSegment)
                overlapSegment = concatSegment(overlapSegment, match);
              else
                overlapSegment = match;
            }
          }
        });
        if (doesOverlaps === false && overlapSegment) {
          features.push(overlapSegment);
          overlapSegment = void 0;
        }
      });
      if (overlapSegment)
        features.push(overlapSegment);
      return helpers_1.featureCollection(features);
    }
    function concatSegment(line, segment) {
      var coords = invariant_1.getCoords(segment);
      var lineCoords = invariant_1.getCoords(line);
      var start = lineCoords[0];
      var end = lineCoords[lineCoords.length - 1];
      var geom = line.geometry.coordinates;
      if (deep_equal_1.default(coords[0], start))
        geom.unshift(coords[1]);
      else if (deep_equal_1.default(coords[0], end))
        geom.push(coords[1]);
      else if (deep_equal_1.default(coords[1], start))
        geom.unshift(coords[0]);
      else if (deep_equal_1.default(coords[1], end))
        geom.push(coords[0]);
      return line;
    }
    exports2.default = lineOverlap;
  }
});

// node_modules/@turf/sector/dist/js/index.js
var require_js62 = __commonJS({
  "node_modules/@turf/sector/dist/js/index.js"(exports2, module2) {
    "use strict";
    var circle = require_js24();
    var lineArc = require_js57();
    var meta = require_js2();
    var helpers = require_js();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var circle__default = /* @__PURE__ */ _interopDefaultLegacy(circle);
    var lineArc__default = /* @__PURE__ */ _interopDefaultLegacy(lineArc);
    function sector(center, radius, bearing1, bearing2, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var properties = options.properties;
      if (!center) throw new Error("center is required");
      if (bearing1 === void 0 || bearing1 === null)
        throw new Error("bearing1 is required");
      if (bearing2 === void 0 || bearing2 === null)
        throw new Error("bearing2 is required");
      if (!radius) throw new Error("radius is required");
      if (typeof options !== "object") throw new Error("options must be an object");
      if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {
        return circle__default["default"](center, radius, options);
      }
      var coords = invariant.getCoords(center);
      var arc = lineArc__default["default"](center, radius, bearing1, bearing2, options);
      var sliceCoords = [[coords]];
      meta.coordEach(arc, function(currentCoords) {
        sliceCoords[0].push(currentCoords);
      });
      sliceCoords[0].push(coords);
      return helpers.polygon(sliceCoords, properties);
    }
    function convertAngleTo360(alfa) {
      var beta = alfa % 360;
      if (beta < 0) beta += 360;
      return beta;
    }
    module2.exports = sector;
    module2.exports.default = sector;
  }
});

// node_modules/@turf/rhumb-bearing/dist/js/index.js
var require_js63 = __commonJS({
  "node_modules/@turf/rhumb-bearing/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function rhumbBearing(start, end, options) {
      if (options === void 0) {
        options = {};
      }
      var bear360;
      if (options.final) {
        bear360 = calculateRhumbBearing(invariant_1.getCoord(end), invariant_1.getCoord(start));
      } else {
        bear360 = calculateRhumbBearing(invariant_1.getCoord(start), invariant_1.getCoord(end));
      }
      var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
      return bear180;
    }
    function calculateRhumbBearing(from, to) {
      var phi1 = helpers_1.degreesToRadians(from[1]);
      var phi2 = helpers_1.degreesToRadians(to[1]);
      var deltaLambda = helpers_1.degreesToRadians(to[0] - from[0]);
      if (deltaLambda > Math.PI) {
        deltaLambda -= 2 * Math.PI;
      }
      if (deltaLambda < -Math.PI) {
        deltaLambda += 2 * Math.PI;
      }
      var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var theta = Math.atan2(deltaLambda, deltaPsi);
      return (helpers_1.radiansToDegrees(theta) + 360) % 360;
    }
    exports2.default = rhumbBearing;
  }
});

// node_modules/@turf/rhumb-destination/dist/js/index.js
var require_js64 = __commonJS({
  "node_modules/@turf/rhumb-destination/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function rhumbDestination(origin, distance, bearing, options) {
      if (options === void 0) {
        options = {};
      }
      var wasNegativeDistance = distance < 0;
      var distanceInMeters = helpers_1.convertLength(Math.abs(distance), options.units, "meters");
      if (wasNegativeDistance)
        distanceInMeters = -Math.abs(distanceInMeters);
      var coords = invariant_1.getCoord(origin);
      var destination = calculateRhumbDestination(coords, distanceInMeters, bearing);
      destination[0] += destination[0] - coords[0] > 180 ? -360 : coords[0] - destination[0] > 180 ? 360 : 0;
      return helpers_1.point(destination, options.properties);
    }
    function calculateRhumbDestination(origin, distance, bearing, radius) {
      radius = radius === void 0 ? helpers_1.earthRadius : Number(radius);
      var delta = distance / radius;
      var lambda1 = origin[0] * Math.PI / 180;
      var phi1 = helpers_1.degreesToRadians(origin[1]);
      var theta = helpers_1.degreesToRadians(bearing);
      var DeltaPhi = delta * Math.cos(theta);
      var phi2 = phi1 + DeltaPhi;
      if (Math.abs(phi2) > Math.PI / 2) {
        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
      }
      var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
      var DeltaLambda = delta * Math.sin(theta) / q;
      var lambda2 = lambda1 + DeltaLambda;
      return [
        (lambda2 * 180 / Math.PI + 540) % 360 - 180,
        phi2 * 180 / Math.PI
      ];
    }
    exports2.default = rhumbDestination;
  }
});

// node_modules/@turf/polygon-tangents/dist/js/index.js
var require_js65 = __commonJS({
  "node_modules/@turf/polygon-tangents/dist/js/index.js"(exports2, module2) {
    "use strict";
    var invariant = require_js4();
    var helpers = require_js();
    var calcBbox = require_js3();
    var explode = require_js31();
    var nearestPoint = require_js33();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var calcBbox__default = /* @__PURE__ */ _interopDefaultLegacy(calcBbox);
    var explode__default = /* @__PURE__ */ _interopDefaultLegacy(explode);
    var nearestPoint__default = /* @__PURE__ */ _interopDefaultLegacy(nearestPoint);
    function polygonTangents(pt, polygon) {
      var pointCoords = invariant.getCoords(pt);
      var polyCoords = invariant.getCoords(polygon);
      var rtan;
      var ltan;
      var enext;
      var eprev;
      var bbox = calcBbox__default["default"](polygon);
      var nearestPtIndex = 0;
      var nearest = null;
      if (pointCoords[0] > bbox[0] && pointCoords[0] < bbox[2] && pointCoords[1] > bbox[1] && pointCoords[1] < bbox[3]) {
        nearest = nearestPoint__default["default"](pt, explode__default["default"](polygon));
        nearestPtIndex = nearest.properties.featureIndex;
      }
      var type = invariant.getType(polygon);
      switch (type) {
        case "Polygon":
          rtan = polyCoords[0][nearestPtIndex];
          ltan = polyCoords[0][0];
          if (nearest !== null) {
            if (nearest.geometry.coordinates[1] < pointCoords[1])
              ltan = polyCoords[0][nearestPtIndex];
          }
          eprev = isLeft(
            polyCoords[0][0],
            polyCoords[0][polyCoords[0].length - 1],
            pointCoords
          );
          var out = processPolygon(
            polyCoords[0],
            pointCoords,
            eprev,
            enext,
            rtan,
            ltan
          );
          rtan = out[0];
          ltan = out[1];
          break;
        case "MultiPolygon":
          var closestFeature = 0;
          var closestVertex = 0;
          var verticesCounted = 0;
          for (var i = 0; i < polyCoords[0].length; i++) {
            closestFeature = i;
            var verticeFound = false;
            for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {
              closestVertex = i2;
              if (verticesCounted === nearestPtIndex) {
                verticeFound = true;
                break;
              }
              verticesCounted++;
            }
            if (verticeFound) break;
          }
          rtan = polyCoords[0][closestFeature][closestVertex];
          ltan = polyCoords[0][closestFeature][closestVertex];
          eprev = isLeft(
            polyCoords[0][0][0],
            polyCoords[0][0][polyCoords[0][0].length - 1],
            pointCoords
          );
          polyCoords.forEach(function(ring) {
            var out2 = processPolygon(
              ring[0],
              pointCoords,
              eprev,
              enext,
              rtan,
              ltan
            );
            rtan = out2[0];
            ltan = out2[1];
          });
          break;
      }
      return helpers.featureCollection([helpers.point(rtan), helpers.point(ltan)]);
    }
    function processPolygon(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {
      for (var i = 0; i < polygonCoords.length; i++) {
        var currentCoords = polygonCoords[i];
        var nextCoordPair = polygonCoords[i + 1];
        if (i === polygonCoords.length - 1) {
          nextCoordPair = polygonCoords[0];
        }
        enext = isLeft(currentCoords, nextCoordPair, ptCoords);
        if (eprev <= 0 && enext > 0) {
          if (!isBelow(ptCoords, currentCoords, rtan)) {
            rtan = currentCoords;
          }
        } else if (eprev > 0 && enext <= 0) {
          if (!isAbove(ptCoords, currentCoords, ltan)) {
            ltan = currentCoords;
          }
        }
        eprev = enext;
      }
      return [rtan, ltan];
    }
    function isAbove(point1, point2, point3) {
      return isLeft(point1, point2, point3) > 0;
    }
    function isBelow(point1, point2, point3) {
      return isLeft(point1, point2, point3) < 0;
    }
    function isLeft(point1, point2, point3) {
      return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);
    }
    module2.exports = polygonTangents;
    module2.exports.default = polygonTangents;
  }
});

// node_modules/@turf/boolean-clockwise/dist/js/index.js
var require_js66 = __commonJS({
  "node_modules/@turf/boolean-clockwise/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var invariant_1 = require_js4();
    function booleanClockwise(line) {
      var ring = invariant_1.getCoords(line);
      var sum = 0;
      var i = 1;
      var prev;
      var cur;
      while (i < ring.length) {
        prev = cur || ring[0];
        cur = ring[i];
        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
        i++;
      }
      return sum > 0;
    }
    exports2.default = booleanClockwise;
  }
});

// node_modules/@turf/rewind/dist/js/index.js
var require_js67 = __commonJS({
  "node_modules/@turf/rewind/dist/js/index.js"(exports2, module2) {
    "use strict";
    var clone = require_js11();
    var booleanClockwise = require_js66();
    var meta = require_js2();
    var invariant = require_js4();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    var booleanClockwise__default = /* @__PURE__ */ _interopDefaultLegacy(booleanClockwise);
    function rewind(geojson, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var reverse = options.reverse || false;
      var mutate = options.mutate || false;
      if (!geojson) throw new Error("<geojson> is required");
      if (typeof reverse !== "boolean")
        throw new Error("<reverse> must be a boolean");
      if (typeof mutate !== "boolean")
        throw new Error("<mutate> must be a boolean");
      if (mutate === false) geojson = clone__default["default"](geojson);
      var results = [];
      switch (geojson.type) {
        case "GeometryCollection":
          meta.geomEach(geojson, function(geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "FeatureCollection":
          meta.featureEach(geojson, function(feature) {
            meta.featureEach(rewindFeature(feature, reverse), function(result2) {
              results.push(result2);
            });
          });
          return helpers.featureCollection(results);
      }
      return rewindFeature(geojson, reverse);
    }
    function rewindFeature(geojson, reverse) {
      var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
      switch (type) {
        case "GeometryCollection":
          meta.geomEach(geojson, function(geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "LineString":
          rewindLineString(invariant.getCoords(geojson), reverse);
          return geojson;
        case "Polygon":
          rewindPolygon(invariant.getCoords(geojson), reverse);
          return geojson;
        case "MultiLineString":
          invariant.getCoords(geojson).forEach(function(lineCoords) {
            rewindLineString(lineCoords, reverse);
          });
          return geojson;
        case "MultiPolygon":
          invariant.getCoords(geojson).forEach(function(lineCoords) {
            rewindPolygon(lineCoords, reverse);
          });
          return geojson;
        case "Point":
        case "MultiPoint":
          return geojson;
      }
    }
    function rewindLineString(coords, reverse) {
      if (booleanClockwise__default["default"](coords) === reverse) coords.reverse();
    }
    function rewindPolygon(coords, reverse) {
      if (booleanClockwise__default["default"](coords[0]) !== reverse) {
        coords[0].reverse();
      }
      for (var i = 1; i < coords.length; i++) {
        if (booleanClockwise__default["default"](coords[i]) === reverse) {
          coords[i].reverse();
        }
      }
    }
    module2.exports = rewind;
    module2.exports.default = rewind;
  }
});

// node_modules/@turf/isobands/dist/js/index.js
var require_js68 = __commonJS({
  "node_modules/@turf/isobands/dist/js/index.js"(exports2, module2) {
    "use strict";
    var bbox = require_js3();
    var area = require_js43();
    var booleanPointInPolygon = require_js7();
    var explode = require_js31();
    var invariant = require_js4();
    var helpers = require_js();
    var objectAssign = require_object_assign();
    var meta = require_js2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bbox__default = /* @__PURE__ */ _interopDefaultLegacy(bbox);
    var area__default = /* @__PURE__ */ _interopDefaultLegacy(area);
    var booleanPointInPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(booleanPointInPolygon);
    var explode__default = /* @__PURE__ */ _interopDefaultLegacy(explode);
    var objectAssign__default = /* @__PURE__ */ _interopDefaultLegacy(objectAssign);
    function gridToMatrix(grid, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var flip = options.flip;
      var flags = options.flags;
      invariant.collectionOf(grid, "Point", "input must contain Points");
      var pointsMatrix = sortPointsByLatLng(grid, flip);
      var matrix = [];
      for (var r = 0; r < pointsMatrix.length; r++) {
        var pointRow = pointsMatrix[r];
        var row = [];
        for (var c = 0; c < pointRow.length; c++) {
          var point = pointRow[c];
          if (point.properties[zProperty]) row.push(point.properties[zProperty]);
          else row.push(0);
          if (flags === true) point.properties.matrixPosition = [r, c];
        }
        matrix.push(row);
      }
      return matrix;
    }
    function sortPointsByLatLng(points, flip) {
      var pointsByLatitude = {};
      meta.featureEach(points, function(point) {
        var lat = invariant.getCoords(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
      });
      var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function(a, b) {
          return invariant.getCoords(a)[0] - invariant.getCoords(b)[0];
        });
        return rowOrderedByLongitude;
      });
      var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
        if (flip) return invariant.getCoords(a[0])[1] - invariant.getCoords(b[0])[1];
        else return invariant.getCoords(b[0])[1] - invariant.getCoords(a[0])[1];
      });
      return pointMatrix;
    }
    var defaultSettings = {
      successCallback: null,
      verbose: false,
      polygons: false
    };
    var settings = {};
    function isoBands(data, minV, bandwidth, options) {
      options = options ? options : {};
      var optionKeys = Object.keys(defaultSettings);
      for (var i = 0; i < optionKeys.length; i++) {
        var key = optionKeys[i];
        var val = options[key];
        val = typeof val !== "undefined" && val !== null ? val : defaultSettings[key];
        settings[key] = val;
      }
      if (settings.verbose)
        console.log(
          "MarchingSquaresJS-isoBands: computing isobands for [" + minV + ":" + (minV + bandwidth) + "]"
        );
      var grid = computeBandGrid(data, minV, bandwidth);
      var ret;
      if (settings.polygons) {
        if (settings.verbose)
          console.log(
            "MarchingSquaresJS-isoBands: returning single polygons for each grid cell"
          );
        ret = BandGrid2Areas(grid);
      } else {
        if (settings.verbose)
          console.log(
            "MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"
          );
        ret = BandGrid2AreaPaths(grid);
      }
      if (typeof settings.successCallback === "function")
        settings.successCallback(ret);
      return ret;
    }
    var Node0 = 64;
    var Node1 = 16;
    var Node2 = 4;
    var Node3 = 1;
    var isoBandNextXTL = [];
    var isoBandNextYTL = [];
    var isoBandNextOTL = [];
    var isoBandNextXTR = [];
    var isoBandNextYTR = [];
    var isoBandNextOTR = [];
    var isoBandNextXRT = [];
    var isoBandNextYRT = [];
    var isoBandNextORT = [];
    var isoBandNextXRB = [];
    var isoBandNextYRB = [];
    var isoBandNextORB = [];
    var isoBandNextXBL = [];
    var isoBandNextYBL = [];
    var isoBandNextOBL = [];
    var isoBandNextXBR = [];
    var isoBandNextYBR = [];
    var isoBandNextOBR = [];
    var isoBandNextXLT = [];
    var isoBandNextYLT = [];
    var isoBandNextOLT = [];
    var isoBandNextXLB = [];
    var isoBandNextYLB = [];
    var isoBandNextOLB = [];
    isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
    isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
    isoBandNextORT[85] = isoBandNextORB[85] = 1;
    isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
    isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
    isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
    isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
    isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
    isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
    isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
    isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
    isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
    isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
    isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
    isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
    isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
    isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
    isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
    isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
    isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
    isoBandNextORB[4] = isoBandNextORB[166] = 1;
    isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
    isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
    isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
    isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
    isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
    isoBandNextORT[16] = isoBandNextORT[154] = 1;
    isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
    isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
    isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
    isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
    isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
    isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
    isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
    isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
    isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
    isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
    isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
    isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
    isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
    isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
    isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
    isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
    isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
    isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
    isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
    isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
    isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
    isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
    isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
    isoBandNextORT[8] = isoBandNextORT[162] = 0;
    isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
    isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
    isoBandNextORB[8] = isoBandNextORB[162] = 1;
    isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
    isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
    isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
    isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
    isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
    isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
    isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
    isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
    isoBandNextORT[32] = isoBandNextORT[138] = 1;
    isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
    isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
    isoBandNextORB[32] = isoBandNextORB[138] = 0;
    isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
    isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
    isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
    isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
    isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
    isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
    isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
    isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
    isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
    isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
    isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
    isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
    isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
    isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
    isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
    isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
    isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
    isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
    isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
    isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
    isoBandNextORB[5] = isoBandNextORB[165] = 0;
    isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
    isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
    isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
    isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
    isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
    isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
    isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
    isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
    isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
    isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
    isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
    isoBandNextORT[80] = isoBandNextORT[90] = 1;
    isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
    isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
    isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
    isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
    isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
    isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
    isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
    isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
    isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
    isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
    isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
    isoBandNextORT[160] = isoBandNextORT[10] = 1;
    isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
    isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
    isoBandNextORB[160] = isoBandNextORB[10] = 0;
    isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
    isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
    isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
    isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
    isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
    isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
    isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
    isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
    isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
    isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
    isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
    isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
    isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
    isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
    isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
    isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
    isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
    isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
    isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
    isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
    isoBandNextORB[37] = isoBandNextORB[133] = 1;
    isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
    isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
    isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
    isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
    isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
    isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
    isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
    isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
    isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
    isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
    isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
    isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
    isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
    isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
    isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
    isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
    isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
    isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
    isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
    isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
    isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
    isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
    isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
    isoBandNextORT[82] = isoBandNextORT[88] = 1;
    isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
    isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
    isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
    isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
    isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
    isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
    isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
    isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
    isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
    isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
    isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
    isoBandNextORT[73] = isoBandNextORT[97] = 0;
    isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
    isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
    isoBandNextORB[73] = isoBandNextORB[97] = 0;
    isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
    isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
    isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
    isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
    isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
    isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
    isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
    isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
    isoBandNextORT[145] = isoBandNextORT[25] = 0;
    isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
    isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
    isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
    isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
    isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
    isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
    isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
    isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
    isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
    isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
    isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
    isoBandNextORB[70] = isoBandNextORB[100] = 0;
    isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
    isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
    isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
    isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
    isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
    isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
    isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
    isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
    isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
    isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
    isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
    isoBandNextORB[101] = isoBandNextORB[69] = 0;
    isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
    isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
    isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
    isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
    isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
    isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
    isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
    isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
    isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
    isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
    isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
    isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
    isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
    isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
    isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
    isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
    isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
    isoBandNextORT[89] = isoBandNextORT[81] = 0;
    isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
    isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
    isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
    isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
    isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
    isoBandNextORT[96] = isoBandNextORT[74] = 0;
    isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
    isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
    isoBandNextORB[96] = isoBandNextORB[74] = 1;
    isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
    isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
    isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
    isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
    isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
    isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
    isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
    isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
    isoBandNextORT[24] = isoBandNextORT[146] = 1;
    isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
    isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
    isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
    isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
    isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
    isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
    isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
    isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
    isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
    isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
    isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
    isoBandNextORB[6] = isoBandNextORB[164] = 1;
    isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
    isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
    isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
    isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
    isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
    isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
    isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
    isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
    isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
    isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
    isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
    isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
    isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
    isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
    isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
    isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
    isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
    isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
    isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
    isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
    isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
    isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
    isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
    isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
    isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
    isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
    isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
    isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
    isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
    isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
    isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
    isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
    isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
    isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
    isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
    isoBandNextORT[144] = isoBandNextORT[26] = 0;
    isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
    isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
    isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
    isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
    isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
    isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
    isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
    isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
    isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
    isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
    isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
    isoBandNextORB[36] = isoBandNextORB[134] = 1;
    isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
    isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
    isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
    isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
    isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
    isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
    isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
    isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
    isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
    isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
    isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
    isoBandNextORT[9] = isoBandNextORT[161] = 0;
    isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
    isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
    isoBandNextORB[9] = isoBandNextORB[161] = 0;
    isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
    isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
    isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
    isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
    isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
    isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
    isoBandNextXRT[136] = 0;
    isoBandNextYRT[136] = 1;
    isoBandNextORT[136] = 1;
    isoBandNextXRB[136] = 0;
    isoBandNextYRB[136] = 1;
    isoBandNextORB[136] = 0;
    isoBandNextXBR[136] = -1;
    isoBandNextYBR[136] = 0;
    isoBandNextOBR[136] = 1;
    isoBandNextXBL[136] = -1;
    isoBandNextYBL[136] = 0;
    isoBandNextOBL[136] = 0;
    isoBandNextXLB[136] = 0;
    isoBandNextYLB[136] = -1;
    isoBandNextOLB[136] = 0;
    isoBandNextXLT[136] = 0;
    isoBandNextYLT[136] = -1;
    isoBandNextOLT[136] = 1;
    isoBandNextXTL[136] = 1;
    isoBandNextYTL[136] = 0;
    isoBandNextOTL[136] = 0;
    isoBandNextXTR[136] = 1;
    isoBandNextYTR[136] = 0;
    isoBandNextOTR[136] = 1;
    isoBandNextXRT[34] = 0;
    isoBandNextYRT[34] = -1;
    isoBandNextORT[34] = 0;
    isoBandNextXRB[34] = 0;
    isoBandNextYRB[34] = -1;
    isoBandNextORB[34] = 1;
    isoBandNextXBR[34] = 1;
    isoBandNextYBR[34] = 0;
    isoBandNextOBR[34] = 0;
    isoBandNextXBL[34] = 1;
    isoBandNextYBL[34] = 0;
    isoBandNextOBL[34] = 1;
    isoBandNextXLB[34] = 0;
    isoBandNextYLB[34] = 1;
    isoBandNextOLB[34] = 1;
    isoBandNextXLT[34] = 0;
    isoBandNextYLT[34] = 1;
    isoBandNextOLT[34] = 0;
    isoBandNextXTL[34] = -1;
    isoBandNextYTL[34] = 0;
    isoBandNextOTL[34] = 1;
    isoBandNextXTR[34] = -1;
    isoBandNextYTR[34] = 0;
    isoBandNextOTR[34] = 0;
    isoBandNextXRT[35] = 0;
    isoBandNextYRT[35] = 1;
    isoBandNextORT[35] = 1;
    isoBandNextXRB[35] = 0;
    isoBandNextYRB[35] = -1;
    isoBandNextORB[35] = 1;
    isoBandNextXBR[35] = 1;
    isoBandNextYBR[35] = 0;
    isoBandNextOBR[35] = 0;
    isoBandNextXBL[35] = -1;
    isoBandNextYBL[35] = 0;
    isoBandNextOBL[35] = 0;
    isoBandNextXLB[35] = 0;
    isoBandNextYLB[35] = -1;
    isoBandNextOLB[35] = 0;
    isoBandNextXLT[35] = 0;
    isoBandNextYLT[35] = 1;
    isoBandNextOLT[35] = 0;
    isoBandNextXTL[35] = -1;
    isoBandNextYTL[35] = 0;
    isoBandNextOTL[35] = 1;
    isoBandNextXTR[35] = 1;
    isoBandNextYTR[35] = 0;
    isoBandNextOTR[35] = 1;
    isoBandNextXRT[153] = 0;
    isoBandNextYRT[153] = 1;
    isoBandNextORT[153] = 1;
    isoBandNextXBL[153] = -1;
    isoBandNextYBL[153] = 0;
    isoBandNextOBL[153] = 0;
    isoBandNextXLB[153] = 0;
    isoBandNextYLB[153] = -1;
    isoBandNextOLB[153] = 0;
    isoBandNextXTR[153] = 1;
    isoBandNextYTR[153] = 0;
    isoBandNextOTR[153] = 1;
    isoBandNextXRB[102] = 0;
    isoBandNextYRB[102] = -1;
    isoBandNextORB[102] = 1;
    isoBandNextXBR[102] = 1;
    isoBandNextYBR[102] = 0;
    isoBandNextOBR[102] = 0;
    isoBandNextXLT[102] = 0;
    isoBandNextYLT[102] = 1;
    isoBandNextOLT[102] = 0;
    isoBandNextXTL[102] = -1;
    isoBandNextYTL[102] = 0;
    isoBandNextOTL[102] = 1;
    isoBandNextXRT[155] = 0;
    isoBandNextYRT[155] = -1;
    isoBandNextORT[155] = 0;
    isoBandNextXBL[155] = 1;
    isoBandNextYBL[155] = 0;
    isoBandNextOBL[155] = 1;
    isoBandNextXLB[155] = 0;
    isoBandNextYLB[155] = 1;
    isoBandNextOLB[155] = 1;
    isoBandNextXTR[155] = -1;
    isoBandNextYTR[155] = 0;
    isoBandNextOTR[155] = 0;
    isoBandNextXRB[103] = 0;
    isoBandNextYRB[103] = 1;
    isoBandNextORB[103] = 0;
    isoBandNextXBR[103] = -1;
    isoBandNextYBR[103] = 0;
    isoBandNextOBR[103] = 1;
    isoBandNextXLT[103] = 0;
    isoBandNextYLT[103] = -1;
    isoBandNextOLT[103] = 1;
    isoBandNextXTL[103] = 1;
    isoBandNextYTL[103] = 0;
    isoBandNextOTL[103] = 0;
    isoBandNextXRT[152] = 0;
    isoBandNextYRT[152] = 1;
    isoBandNextORT[152] = 1;
    isoBandNextXBR[152] = -1;
    isoBandNextYBR[152] = 0;
    isoBandNextOBR[152] = 1;
    isoBandNextXBL[152] = -1;
    isoBandNextYBL[152] = 0;
    isoBandNextOBL[152] = 0;
    isoBandNextXLB[152] = 0;
    isoBandNextYLB[152] = -1;
    isoBandNextOLB[152] = 0;
    isoBandNextXLT[152] = 0;
    isoBandNextYLT[152] = -1;
    isoBandNextOLT[152] = 1;
    isoBandNextXTR[152] = 1;
    isoBandNextYTR[152] = 0;
    isoBandNextOTR[152] = 1;
    isoBandNextXRT[156] = 0;
    isoBandNextYRT[156] = -1;
    isoBandNextORT[156] = 1;
    isoBandNextXBR[156] = 1;
    isoBandNextYBR[156] = 0;
    isoBandNextOBR[156] = 1;
    isoBandNextXBL[156] = -1;
    isoBandNextYBL[156] = 0;
    isoBandNextOBL[156] = 0;
    isoBandNextXLB[156] = 0;
    isoBandNextYLB[156] = -1;
    isoBandNextOLB[156] = 0;
    isoBandNextXLT[156] = 0;
    isoBandNextYLT[156] = 1;
    isoBandNextOLT[156] = 1;
    isoBandNextXTR[156] = -1;
    isoBandNextYTR[156] = 0;
    isoBandNextOTR[156] = 1;
    isoBandNextXRT[137] = 0;
    isoBandNextYRT[137] = 1;
    isoBandNextORT[137] = 1;
    isoBandNextXRB[137] = 0;
    isoBandNextYRB[137] = 1;
    isoBandNextORB[137] = 0;
    isoBandNextXBL[137] = -1;
    isoBandNextYBL[137] = 0;
    isoBandNextOBL[137] = 0;
    isoBandNextXLB[137] = 0;
    isoBandNextYLB[137] = -1;
    isoBandNextOLB[137] = 0;
    isoBandNextXTL[137] = 1;
    isoBandNextYTL[137] = 0;
    isoBandNextOTL[137] = 0;
    isoBandNextXTR[137] = 1;
    isoBandNextYTR[137] = 0;
    isoBandNextOTR[137] = 1;
    isoBandNextXRT[139] = 0;
    isoBandNextYRT[139] = 1;
    isoBandNextORT[139] = 1;
    isoBandNextXRB[139] = 0;
    isoBandNextYRB[139] = -1;
    isoBandNextORB[139] = 0;
    isoBandNextXBL[139] = 1;
    isoBandNextYBL[139] = 0;
    isoBandNextOBL[139] = 0;
    isoBandNextXLB[139] = 0;
    isoBandNextYLB[139] = 1;
    isoBandNextOLB[139] = 0;
    isoBandNextXTL[139] = -1;
    isoBandNextYTL[139] = 0;
    isoBandNextOTL[139] = 0;
    isoBandNextXTR[139] = 1;
    isoBandNextYTR[139] = 0;
    isoBandNextOTR[139] = 1;
    isoBandNextXRT[98] = 0;
    isoBandNextYRT[98] = -1;
    isoBandNextORT[98] = 0;
    isoBandNextXRB[98] = 0;
    isoBandNextYRB[98] = -1;
    isoBandNextORB[98] = 1;
    isoBandNextXBR[98] = 1;
    isoBandNextYBR[98] = 0;
    isoBandNextOBR[98] = 0;
    isoBandNextXBL[98] = 1;
    isoBandNextYBL[98] = 0;
    isoBandNextOBL[98] = 1;
    isoBandNextXLT[98] = 0;
    isoBandNextYLT[98] = 1;
    isoBandNextOLT[98] = 0;
    isoBandNextXTL[98] = -1;
    isoBandNextYTL[98] = 0;
    isoBandNextOTL[98] = 1;
    isoBandNextXRT[99] = 0;
    isoBandNextYRT[99] = 1;
    isoBandNextORT[99] = 0;
    isoBandNextXRB[99] = 0;
    isoBandNextYRB[99] = -1;
    isoBandNextORB[99] = 1;
    isoBandNextXBR[99] = 1;
    isoBandNextYBR[99] = 0;
    isoBandNextOBR[99] = 0;
    isoBandNextXBL[99] = -1;
    isoBandNextYBL[99] = 0;
    isoBandNextOBL[99] = 1;
    isoBandNextXLT[99] = 0;
    isoBandNextYLT[99] = -1;
    isoBandNextOLT[99] = 0;
    isoBandNextXTL[99] = 1;
    isoBandNextYTL[99] = 0;
    isoBandNextOTL[99] = 1;
    isoBandNextXRB[38] = 0;
    isoBandNextYRB[38] = -1;
    isoBandNextORB[38] = 1;
    isoBandNextXBR[38] = 1;
    isoBandNextYBR[38] = 0;
    isoBandNextOBR[38] = 0;
    isoBandNextXLB[38] = 0;
    isoBandNextYLB[38] = 1;
    isoBandNextOLB[38] = 1;
    isoBandNextXLT[38] = 0;
    isoBandNextYLT[38] = 1;
    isoBandNextOLT[38] = 0;
    isoBandNextXTL[38] = -1;
    isoBandNextYTL[38] = 0;
    isoBandNextOTL[38] = 1;
    isoBandNextXTR[38] = -1;
    isoBandNextYTR[38] = 0;
    isoBandNextOTR[38] = 0;
    isoBandNextXRB[39] = 0;
    isoBandNextYRB[39] = 1;
    isoBandNextORB[39] = 1;
    isoBandNextXBR[39] = -1;
    isoBandNextYBR[39] = 0;
    isoBandNextOBR[39] = 0;
    isoBandNextXLB[39] = 0;
    isoBandNextYLB[39] = -1;
    isoBandNextOLB[39] = 1;
    isoBandNextXLT[39] = 0;
    isoBandNextYLT[39] = 1;
    isoBandNextOLT[39] = 0;
    isoBandNextXTL[39] = -1;
    isoBandNextYTL[39] = 0;
    isoBandNextOTL[39] = 1;
    isoBandNextXTR[39] = 1;
    isoBandNextYTR[39] = 0;
    isoBandNextOTR[39] = 0;
    var p00 = function(cell) {
      return [
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom]
      ];
    };
    var p01 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0]
      ];
    };
    var p02 = function(cell) {
      return [
        [cell.topright, 1],
        [1, 1],
        [1, cell.righttop]
      ];
    };
    var p03 = function(cell) {
      return [
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p04 = function(cell) {
      return [
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop]
      ];
    };
    var p05 = function(cell) {
      return [
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [1, cell.righttop],
        [1, cell.rightbottom]
      ];
    };
    var p06 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.topleft, 1],
        [cell.topright, 1]
      ];
    };
    var p07 = function(cell) {
      return [
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topleft, 1],
        [cell.topright, 1]
      ];
    };
    var p08 = function(cell) {
      return [
        [0, 0],
        [0, cell.leftbottom],
        [1, cell.rightbottom],
        [1, 0]
      ];
    };
    var p09 = function(cell) {
      return [
        [1, 0],
        [cell.bottomright, 0],
        [cell.topright, 1],
        [1, 1]
      ];
    };
    var p10 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [0, cell.lefttop],
        [0, 1]
      ];
    };
    var p11 = function(cell) {
      return [
        [cell.bottomleft, 0],
        [0, 0],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p12 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [0, cell.leftbottom],
        [0, cell.lefttop]
      ];
    };
    var p13 = function(cell) {
      return [
        [cell.topleft, 1],
        [cell.topright, 1],
        [cell.bottomright, 0],
        [cell.bottomleft, 0]
      ];
    };
    var p14 = function() {
      return [
        [0, 0],
        [0, 1],
        [1, 1],
        [1, 0]
      ];
    };
    var p15 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [0, 0],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p16 = function(cell) {
      return [
        [cell.topright, 1],
        [1, 1],
        [1, 0],
        [0, 0],
        [0, cell.leftbottom]
      ];
    };
    var p17 = function(cell) {
      return [
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.lefttop],
        [0, 1],
        [1, 1]
      ];
    };
    var p18 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomleft, 0],
        [0, 0],
        [0, 1]
      ];
    };
    var p19 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p20 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [cell.topright, 1]
      ];
    };
    var p21 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop]
      ];
    };
    var p22 = function(cell) {
      return [
        [cell.topright, 1],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topleft, 1]
      ];
    };
    var p23 = function(cell) {
      return [
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p24 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topright, 1]
      ];
    };
    var p25 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [cell.topleft, 1],
        [cell.topright, 1]
      ];
    };
    var p26 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom]
      ];
    };
    var p27 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topleft, 1],
        [cell.topright, 1]
      ];
    };
    var p28 = function(cell) {
      return [
        [1, 1],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topright, 1]
      ];
    };
    var p29 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.lefttop],
        [0, 1]
      ];
    };
    var p30 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomleft, 0],
        [0, 0],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p31 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topright, 1]
      ];
    };
    var p32 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p33 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topleft, 1],
        [cell.topright, 1]
      ];
    };
    var p34 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topright, 1]
      ];
    };
    var p35 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p36 = function(cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topright, 1]
      ];
    };
    var p37 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topleft, 1],
        [cell.topright, 1]
      ];
    };
    var p38 = function(cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1]
      ];
    };
    var p39 = function(cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topleft, 1],
        [cell.topright, 1]
      ];
    };
    var isoBandEdgeRT = [];
    var isoBandEdgeRB = [];
    var isoBandEdgeBR = [];
    var isoBandEdgeBL = [];
    var isoBandEdgeLB = [];
    var isoBandEdgeLT = [];
    var isoBandEdgeTL = [];
    var isoBandEdgeTR = [];
    isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
    isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
    isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
    isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
    isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
    isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
    isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
    isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
    isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
    isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
    isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
    isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
    isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
    isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
    isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
    isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
    isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
    isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
    isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
    isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
    isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
    isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
    isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
    isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
    isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
    isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
    isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
    isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
    isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
    isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
    isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
    isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
    isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
    isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
    isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
    isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
    isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
    isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
    isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
    isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
    isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
    isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
    isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
    isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
    isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
    isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
    isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
    isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
    isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
    isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
    isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
    isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
    isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
    isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
    isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
    isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
    isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
    isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
    isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
    isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
    isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
    isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
    isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
    isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
    isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
    isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
    isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
    isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
    isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
    isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
    isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
    isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
    isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
    isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
    isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
    isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
    isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
    isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
    isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
    isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
    isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
    isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
    isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
    isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
    isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
    isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
    isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
    isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
    isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
    isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
    isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
    isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
    isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
    isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
    isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
    isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
    isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
    isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
    isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
    isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
    isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
    isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
    isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
    isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
    isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
    isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
    isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
    isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
    isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
    isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
    isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
    isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
    isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
    isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
    isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
    isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
    isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
    isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
    isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
    isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
    isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
    isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
    isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
    isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
    isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
    isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
    isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
    isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
    isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
    isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
    isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
    isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
    isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
    isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
    isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
    isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
    isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
    isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
    isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
    isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
    isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
    isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
    isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
    isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
    isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
    isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
    isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
    isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
    var polygon_table = [];
    polygon_table[1] = polygon_table[169] = p00;
    polygon_table[4] = polygon_table[166] = p01;
    polygon_table[16] = polygon_table[154] = p02;
    polygon_table[64] = polygon_table[106] = p03;
    polygon_table[168] = polygon_table[2] = p04;
    polygon_table[162] = polygon_table[8] = p05;
    polygon_table[138] = polygon_table[32] = p06;
    polygon_table[42] = polygon_table[128] = p07;
    polygon_table[5] = polygon_table[165] = p08;
    polygon_table[20] = polygon_table[150] = p09;
    polygon_table[80] = polygon_table[90] = p10;
    polygon_table[65] = polygon_table[105] = p11;
    polygon_table[160] = polygon_table[10] = p12;
    polygon_table[130] = polygon_table[40] = p13;
    polygon_table[85] = p14;
    polygon_table[101] = polygon_table[69] = p15;
    polygon_table[149] = polygon_table[21] = p16;
    polygon_table[86] = polygon_table[84] = p17;
    polygon_table[89] = polygon_table[81] = p18;
    polygon_table[96] = polygon_table[74] = p19;
    polygon_table[24] = polygon_table[146] = p20;
    polygon_table[6] = polygon_table[164] = p21;
    polygon_table[129] = polygon_table[41] = p22;
    polygon_table[66] = polygon_table[104] = p23;
    polygon_table[144] = polygon_table[26] = p24;
    polygon_table[36] = polygon_table[134] = p25;
    polygon_table[9] = polygon_table[161] = p26;
    polygon_table[37] = polygon_table[133] = p27;
    polygon_table[148] = polygon_table[22] = p28;
    polygon_table[82] = polygon_table[88] = p29;
    polygon_table[73] = polygon_table[97] = p30;
    polygon_table[145] = polygon_table[25] = p31;
    polygon_table[70] = polygon_table[100] = p32;
    polygon_table[34] = function(c) {
      return [p07(c), p05(c)];
    };
    polygon_table[35] = p33;
    polygon_table[136] = function(c) {
      return [p06(c), p04(c)];
    };
    polygon_table[153] = function(c) {
      return [p02(c), p00(c)];
    };
    polygon_table[102] = function(c) {
      return [p01(c), p03(c)];
    };
    polygon_table[155] = p34;
    polygon_table[103] = p35;
    polygon_table[152] = function(c) {
      return [p02(c), p04(c)];
    };
    polygon_table[156] = p36;
    polygon_table[137] = function(c) {
      return [p06(c), p00(c)];
    };
    polygon_table[139] = p37;
    polygon_table[98] = function(c) {
      return [p05(c), p03(c)];
    };
    polygon_table[99] = p38;
    polygon_table[38] = function(c) {
      return [p01(c), p07(c)];
    };
    polygon_table[39] = p39;
    function interpolateX(y, y0, y1) {
      return (y - y0) / (y1 - y0);
    }
    function isArray(myArray) {
      return myArray.constructor.toString().indexOf("Array") > -1;
    }
    function computeBandGrid(data, minV, bandwidth) {
      var rows = data.length - 1;
      var cols = data[0].length - 1;
      var BandGrid = { rows, cols, cells: [] };
      var maxV = minV + Math.abs(bandwidth);
      for (var j = 0; j < rows; ++j) {
        BandGrid.cells[j] = [];
        for (var i = 0; i < cols; ++i) {
          var cval = 0;
          var tl = data[j + 1][i];
          var tr = data[j + 1][i + 1];
          var br = data[j][i + 1];
          var bl = data[j][i];
          if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
            continue;
          }
          cval |= tl < minV ? 0 : tl > maxV ? 128 : 64;
          cval |= tr < minV ? 0 : tr > maxV ? 32 : 16;
          cval |= br < minV ? 0 : br > maxV ? 8 : 4;
          cval |= bl < minV ? 0 : bl > maxV ? 2 : 1;
          var cval_real = +cval;
          var flipped = 0;
          if (cval === 17 || cval === 18 || cval === 33 || cval === 34 || cval === 38 || cval === 68 || cval === 72 || cval === 98 || cval === 102 || cval === 132 || cval === 136 || cval === 137 || cval === 152 || cval === 153) {
            var average = (tl + tr + br + bl) / 4;
            flipped = average > maxV ? 2 : average < minV ? 0 : 1;
            if (cval === 34) {
              if (flipped === 1) {
                cval = 35;
              } else if (flipped === 0) {
                cval = 136;
              }
            } else if (cval === 136) {
              if (flipped === 1) {
                cval = 35;
                flipped = 4;
              } else if (flipped === 0) {
                cval = 34;
              }
            } else if (cval === 17) {
              if (flipped === 1) {
                cval = 155;
                flipped = 4;
              } else if (flipped === 0) {
                cval = 153;
              }
            } else if (cval === 68) {
              if (flipped === 1) {
                cval = 103;
                flipped = 4;
              } else if (flipped === 0) {
                cval = 102;
              }
            } else if (cval === 153) {
              if (flipped === 1) cval = 155;
            } else if (cval === 102) {
              if (flipped === 1) cval = 103;
            } else if (cval === 152) {
              if (flipped < 2) {
                cval = 156;
                flipped = 1;
              }
            } else if (cval === 137) {
              if (flipped < 2) {
                cval = 139;
                flipped = 1;
              }
            } else if (cval === 98) {
              if (flipped < 2) {
                cval = 99;
                flipped = 1;
              }
            } else if (cval === 38) {
              if (flipped < 2) {
                cval = 39;
                flipped = 1;
              }
            } else if (cval === 18) {
              if (flipped > 0) {
                cval = 156;
                flipped = 4;
              } else {
                cval = 152;
              }
            } else if (cval === 33) {
              if (flipped > 0) {
                cval = 139;
                flipped = 4;
              } else {
                cval = 137;
              }
            } else if (cval === 72) {
              if (flipped > 0) {
                cval = 99;
                flipped = 4;
              } else {
                cval = 98;
              }
            } else if (cval === 132) {
              if (flipped > 0) {
                cval = 39;
                flipped = 4;
              } else {
                cval = 38;
              }
            }
          }
          if (cval != 0 && cval != 170) {
            var topleft, topright, bottomleft, bottomright, righttop, rightbottom, lefttop, leftbottom;
            topleft = topright = bottomleft = bottomright = righttop = rightbottom = lefttop = leftbottom = 0.5;
            var edges = [];
            if (cval === 1) {
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 169) {
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 4) {
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = interpolateX(minV, bl, br);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 166) {
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = 1 - interpolateX(maxV, br, bl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 16) {
              righttop = interpolateX(minV, br, tr);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 154) {
              righttop = 1 - interpolateX(maxV, tr, br);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 64) {
              lefttop = interpolateX(minV, bl, tl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 106) {
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 168) {
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 2) {
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 162) {
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 8) {
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 138) {
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 32) {
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 42) {
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 128) {
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            }
            if (cval === 5) {
              rightbottom = 1 - interpolateX(minV, tr, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 165) {
              rightbottom = interpolateX(maxV, br, tr);
              leftbottom = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 20) {
              bottomright = interpolateX(minV, bl, br);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 150) {
              bottomright = 1 - interpolateX(maxV, br, bl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 80) {
              righttop = interpolateX(minV, br, tr);
              lefttop = interpolateX(minV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 90) {
              righttop = 1 - interpolateX(maxV, tr, br);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 65) {
              bottomleft = 1 - interpolateX(minV, br, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 105) {
              bottomleft = interpolateX(maxV, bl, br);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 160) {
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 10) {
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 130) {
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 40) {
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 101) {
              rightbottom = interpolateX(maxV, br, tr);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 69) {
              rightbottom = 1 - interpolateX(minV, tr, br);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 149) {
              leftbottom = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 21) {
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 86) {
              bottomright = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 84) {
              bottomright = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 89) {
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 81) {
              righttop = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 96) {
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              lefttop = interpolateX(minV, bl, tl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 74) {
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 24) {
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 146) {
              righttop = interpolateX(minV, br, tr);
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 6) {
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = 1 - interpolateX(maxV, br, bl);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 164) {
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = interpolateX(minV, bl, br);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 129) {
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = interpolateX(maxV, bl, tl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 41) {
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 66) {
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 104) {
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeTL[cval]);
            } else if (cval === 144) {
              righttop = interpolateX(minV, br, tr);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 26) {
              righttop = 1 - interpolateX(maxV, tr, br);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 36) {
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = interpolateX(minV, bl, br);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 134) {
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = 1 - interpolateX(maxV, br, bl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 9) {
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 161) {
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 37) {
              rightbottom = interpolateX(maxV, br, tr);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 133) {
              rightbottom = 1 - interpolateX(minV, tr, br);
              leftbottom = interpolateX(maxV, bl, tl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 148) {
              bottomright = interpolateX(minV, bl, br);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 22) {
              bottomright = 1 - interpolateX(maxV, br, bl);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 82) {
              righttop = interpolateX(minV, br, tr);
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 88) {
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 73) {
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 97) {
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 145) {
              righttop = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 25) {
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 70) {
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 100) {
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 34) {
              if (flipped === 0) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 35) {
              if (flipped === 4) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 136) {
              if (flipped === 0) {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              } else {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 153) {
              if (flipped === 0) {
                righttop = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 102) {
              if (flipped === 0) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 155) {
              if (flipped === 4) {
                righttop = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 103) {
              if (flipped === 4) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 152) {
              if (flipped === 0) {
                righttop = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 156) {
              if (flipped === 4) {
                righttop = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 137) {
              if (flipped === 0) {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              } else {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 139) {
              if (flipped === 4) {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              } else {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 98) {
              if (flipped === 0) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 99) {
              if (flipped === 4) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 38) {
              if (flipped === 0) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 39) {
              if (flipped === 4) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 85) {
              righttop = 1;
              rightbottom = 0;
              bottomright = 1;
              bottomleft = 0;
              leftbottom = 0;
              lefttop = 1;
              topleft = 0;
              topright = 1;
            }
            if (topleft < 0 || topleft > 1 || topright < 0 || topright > 1 || righttop < 0 || righttop > 1 || bottomright < 0 || bottomright > 1 || leftbottom < 0 || leftbottom > 1 || lefttop < 0 || lefttop > 1) {
              console.log(
                "MarchingSquaresJS-isoBands: " + cval + " " + cval_real + " " + tl + "," + tr + "," + br + "," + bl + " " + flipped + " " + topleft + " " + topright + " " + righttop + " " + rightbottom + " " + bottomright + " " + bottomleft + " " + leftbottom + " " + lefttop
              );
            }
            BandGrid.cells[j][i] = {
              cval,
              cval_real,
              flipped,
              topleft,
              topright,
              righttop,
              rightbottom,
              bottomright,
              bottomleft,
              leftbottom,
              lefttop,
              edges
            };
          }
        }
      }
      return BandGrid;
    }
    function BandGrid2AreaPaths(grid) {
      var areas = [];
      var rows = grid.rows;
      var cols = grid.cols;
      var currentPolygon = [];
      for (var j = 0; j < rows; j++) {
        for (var i = 0; i < cols; i++) {
          if (typeof grid.cells[j][i] !== "undefined" && grid.cells[j][i].edges.length > 0) {
            var cell = grid.cells[j][i];
            var prev = getStartXY(cell), next = null, p = i, q = j;
            if (prev !== null) {
              currentPolygon.push([prev.p[0] + p, prev.p[1] + q]);
            }
            do {
              next = getExitXY(grid.cells[q][p], prev.x, prev.y, prev.o);
              if (next !== null) {
                currentPolygon.push([next.p[0] + p, next.p[1] + q]);
                p += next.x;
                q += next.y;
                prev = next;
              } else {
                break;
              }
              if (q < 0 || q >= rows || p < 0 || p >= cols || typeof grid.cells[q][p] === "undefined") {
                p -= next.x;
                q -= next.y;
                var missing = traceOutOfGridPath(
                  grid,
                  p,
                  q,
                  next.x,
                  next.y,
                  next.o
                );
                if (missing !== null) {
                  missing.path.forEach(function(pp) {
                    currentPolygon.push(pp);
                  });
                  p = missing.i;
                  q = missing.j;
                  prev = missing;
                } else {
                  break;
                }
              }
            } while (typeof grid.cells[q][p] !== "undefined" && grid.cells[q][p].edges.length > 0);
            areas.push(currentPolygon);
            currentPolygon = [];
            if (grid.cells[j][i].edges.length > 0) i--;
          }
        }
      }
      return areas;
    }
    function traceOutOfGridPath(grid, i, j, d_x, d_y, d_o) {
      var cell = grid.cells[j][i];
      var cval = cell.cval_real;
      var p = i + d_x, q = j + d_y;
      var path = [];
      var closed = false;
      while (!closed) {
        if (typeof grid.cells[q] === "undefined" || typeof grid.cells[q][p] === "undefined") {
          q -= d_y;
          p -= d_x;
          cell = grid.cells[q][p];
          cval = cell.cval_real;
          if (d_y === -1) {
            if (d_o === 0) {
              if (cval & Node3) {
                path.push([p, q]);
                d_x = -1;
                d_y = 0;
                d_o = 0;
              } else if (cval & Node2) {
                path.push([p + 1, q]);
                d_x = 1;
                d_y = 0;
                d_o = 0;
              } else {
                path.push([p + cell.bottomright, q]);
                d_x = 0;
                d_y = 1;
                d_o = 1;
                closed = true;
                break;
              }
            } else if (cval & Node3) {
              path.push([p, q]);
              d_x = -1;
              d_y = 0;
              d_o = 0;
            } else if (cval & Node2) {
              path.push([p + cell.bottomright, q]);
              d_x = 0;
              d_y = 1;
              d_o = 1;
              closed = true;
              break;
            } else {
              path.push([p + cell.bottomleft, q]);
              d_x = 0;
              d_y = 1;
              d_o = 0;
              closed = true;
              break;
            }
          } else if (d_y === 1) {
            if (d_o === 0) {
              if (cval & Node1) {
                path.push([p + 1, q + 1]);
                d_x = 1;
                d_y = 0;
                d_o = 1;
              } else if (!(cval & Node0)) {
                path.push([p + cell.topright, q + 1]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
                closed = true;
                break;
              } else {
                path.push([p + cell.topleft, q + 1]);
                d_x = 0;
                d_y = -1;
                d_o = 0;
                closed = true;
                break;
              }
            } else if (cval & Node1) {
              path.push([p + 1, q + 1]);
              d_x = 1;
              d_y = 0;
              d_o = 1;
            } else {
              path.push([p + 1, q + 1]);
              d_x = 1;
              d_y = 0;
              d_o = 1;
            }
          } else if (d_x === -1) {
            if (d_o === 0) {
              if (cval & Node0) {
                path.push([p, q + 1]);
                d_x = 0;
                d_y = 1;
                d_o = 0;
              } else if (!(cval & Node3)) {
                path.push([p, q + cell.lefttop]);
                d_x = 1;
                d_y = 0;
                d_o = 1;
                closed = true;
                break;
              } else {
                path.push([p, q + cell.leftbottom]);
                d_x = 1;
                d_y = 0;
                d_o = 0;
                closed = true;
                break;
              }
            } else {
              if (cval & Node0) {
                path.push([p, q + 1]);
                d_x = 0;
                d_y = 1;
                d_o = 0;
              } else {
                console.log("MarchingSquaresJS-isoBands: wtf");
                break;
              }
            }
          } else if (d_x === 1) {
            if (d_o === 0) {
              if (cval & Node2) {
                path.push([p + 1, q]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else {
                path.push([p + 1, q + cell.rightbottom]);
                d_x = -1;
                d_y = 0;
                d_o = 0;
                closed = true;
                break;
              }
            } else {
              if (cval & Node2) {
                path.push([p + 1, q]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else if (!(cval & Node1)) {
                path.push([p + 1, q + cell.rightbottom]);
                d_x = -1;
                d_y = 0;
                d_o = 0;
                closed = true;
                break;
              } else {
                path.push([p + 1, q + cell.righttop]);
                d_x = -1;
                d_y = 0;
                d_o = 1;
                break;
              }
            }
          } else {
            console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
            break;
          }
        } else {
          cell = grid.cells[q][p];
          cval = cell.cval_real;
          if (d_x === -1) {
            if (d_o === 0) {
              if (typeof grid.cells[q - 1] !== "undefined" && typeof grid.cells[q - 1][p] !== "undefined") {
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else if (cval & Node3) {
                path.push([p, q]);
              } else {
                path.push([p + cell.bottomright, q]);
                d_x = 0;
                d_y = 1;
                d_o = 1;
                closed = true;
                break;
              }
            } else if (cval & Node0) {
              console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!");
            } else {
              console.log(
                "MarchingSquaresJS-isoBands: found entry from top at " + p + "," + q
              );
              break;
            }
          } else if (d_x === 1) {
            if (d_o === 0) {
              console.log("MarchingSquaresJS-isoBands: wtf");
              break;
            } else {
              if (typeof grid.cells[q + 1] !== "undefined" && typeof grid.cells[q + 1][p] !== "undefined") {
                d_x = 0;
                d_y = 1;
                d_o = 0;
              } else if (cval & Node1) {
                path.push([p + 1, q + 1]);
                d_x = 1;
                d_y = 0;
                d_o = 1;
              } else {
                path.push([p + cell.topleft, q + 1]);
                d_x = 0;
                d_y = -1;
                d_o = 0;
                closed = true;
                break;
              }
            }
          } else if (d_y === -1) {
            if (d_o === 1) {
              if (typeof grid.cells[q][p + 1] !== "undefined") {
                d_x = 1;
                d_y = 0;
                d_o = 1;
              } else if (cval & Node2) {
                path.push([p + 1, q]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else {
                path.push([p + 1, q + cell.righttop]);
                d_x = -1;
                d_y = 0;
                d_o = 1;
                closed = true;
                break;
              }
            } else {
              console.log("MarchingSquaresJS-isoBands: wtf");
              break;
            }
          } else if (d_y === 1) {
            if (d_o === 0) {
              if (typeof grid.cells[q][p - 1] !== "undefined") {
                d_x = -1;
                d_y = 0;
                d_o = 0;
              } else if (cval & Node0) {
                path.push([p, q + 1]);
                d_x = 0;
                d_y = 1;
                d_o = 0;
              } else {
                path.push([p, q + cell.leftbottom]);
                d_x = 1;
                d_y = 0;
                d_o = 0;
                closed = true;
                break;
              }
            } else {
              console.log("MarchingSquaresJS-isoBands: wtf");
              break;
            }
          } else {
            console.log("MarchingSquaresJS-isoBands: where did we came from???");
            break;
          }
        }
        p += d_x;
        q += d_y;
        if (p === i && q === j) {
          break;
        }
      }
      return { path, i: p, j: q, x: d_x, y: d_y, o: d_o };
    }
    function deleteEdge(cell, edgeIdx) {
      delete cell.edges[edgeIdx];
      for (var k = edgeIdx + 1; k < cell.edges.length; k++) {
        cell.edges[k - 1] = cell.edges[k];
      }
      cell.edges.pop();
    }
    function getStartXY(cell) {
      if (cell.edges.length > 0) {
        var e = cell.edges[cell.edges.length - 1];
        var cval = cell.cval_real;
        switch (e) {
          case 0:
            if (cval & Node1) {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            }
          case 1:
            if (cval & Node2) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 2:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            }
          case 3:
            if (cval & Node3) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 4:
            if (cval & Node1) {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          case 5:
            if (cval & Node2) {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 6:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          case 7:
            if (cval & Node3) {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 8:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            }
          case 9:
            if (cval & Node3) {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 10:
            if (cval & Node3) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            }
          case 11:
            if (cval & Node0) {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 12:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 13:
            if (cval & Node3) {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 14:
            if (cval & Node3) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 15:
            if (cval & Node0) {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 16:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            }
          case 17:
            if (cval & Node0) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 18:
            if (cval & Node3) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 19:
            if (cval & Node0) {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 20:
            if (cval & Node0) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            }
          case 21:
            if (cval & Node1) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          case 22:
            if (cval & Node0) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 23:
            if (cval & Node1) {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          default:
            console.log("MarchingSquaresJS-isoBands: edge index out of range!");
            console.log(cell);
            break;
        }
      }
      return null;
    }
    function getExitXY(cell, x, y, o) {
      var e, id_x, d_x, d_y, cval = cell.cval;
      var d_o;
      switch (x) {
        case -1:
          switch (o) {
            case 0:
              e = isoBandEdgeRB[cval];
              d_x = isoBandNextXRB[cval];
              d_y = isoBandNextYRB[cval];
              d_o = isoBandNextORB[cval];
              break;
            default:
              e = isoBandEdgeRT[cval];
              d_x = isoBandNextXRT[cval];
              d_y = isoBandNextYRT[cval];
              d_o = isoBandNextORT[cval];
              break;
          }
          break;
        case 1:
          switch (o) {
            case 0:
              e = isoBandEdgeLB[cval];
              d_x = isoBandNextXLB[cval];
              d_y = isoBandNextYLB[cval];
              d_o = isoBandNextOLB[cval];
              break;
            default:
              e = isoBandEdgeLT[cval];
              d_x = isoBandNextXLT[cval];
              d_y = isoBandNextYLT[cval];
              d_o = isoBandNextOLT[cval];
              break;
          }
          break;
        default:
          switch (y) {
            case -1:
              switch (o) {
                case 0:
                  e = isoBandEdgeTL[cval];
                  d_x = isoBandNextXTL[cval];
                  d_y = isoBandNextYTL[cval];
                  d_o = isoBandNextOTL[cval];
                  break;
                default:
                  e = isoBandEdgeTR[cval];
                  d_x = isoBandNextXTR[cval];
                  d_y = isoBandNextYTR[cval];
                  d_o = isoBandNextOTR[cval];
                  break;
              }
              break;
            case 1:
              switch (o) {
                case 0:
                  e = isoBandEdgeBL[cval];
                  d_x = isoBandNextXBL[cval];
                  d_y = isoBandNextYBL[cval];
                  d_o = isoBandNextOBL[cval];
                  break;
                default:
                  e = isoBandEdgeBR[cval];
                  d_x = isoBandNextXBR[cval];
                  d_y = isoBandNextYBR[cval];
                  d_o = isoBandNextOBR[cval];
                  break;
              }
              break;
          }
          break;
      }
      id_x = cell.edges.indexOf(e);
      if (typeof cell.edges[id_x] !== "undefined") {
        deleteEdge(cell, id_x);
      } else {
        return null;
      }
      cval = cell.cval_real;
      switch (e) {
        case 0:
          if (cval & Node1) {
            x = cell.topleft;
            y = 1;
          } else {
            x = 1;
            y = cell.righttop;
          }
          break;
        case 1:
          if (cval & Node2) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 2:
          if (cval & Node2) {
            x = cell.topleft;
            y = 1;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 3:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 4:
          if (cval & Node1) {
            x = cell.topright;
            y = 1;
          } else {
            x = 1;
            y = cell.righttop;
          }
          break;
        case 5:
          if (cval & Node2) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = cell.topright;
            y = 1;
          }
          break;
        case 6:
          if (cval & Node2) {
            x = cell.topright;
            y = 1;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 7:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = cell.topright;
            y = 1;
          }
          break;
        case 8:
          if (cval & Node2) {
            x = 1;
            y = cell.righttop;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 9:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = 1;
            y = cell.righttop;
          }
          break;
        case 10:
          if (cval & Node3) {
            x = 1;
            y = cell.righttop;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 11:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = 1;
            y = cell.righttop;
          }
          break;
        case 12:
          if (cval & Node2) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 13:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = 1;
            y = cell.rightbottom;
          }
          break;
        case 14:
          if (cval & Node3) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 15:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = 1;
            y = cell.rightbottom;
          }
          break;
        case 16:
          if (cval & Node2) {
            x = 0;
            y = cell.leftbottom;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 17:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 18:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 19:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = cell.bottomleft;
            y = 0;
          }
          break;
        case 20:
          if (cval & Node0) {
            x = 0;
            y = cell.leftbottom;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 21:
          if (cval & Node1) {
            x = cell.topright;
            y = 1;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 22:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 23:
          if (cval & Node1) {
            x = cell.topright;
            y = 1;
          } else {
            x = 0;
            y = cell.lefttop;
          }
          break;
        default:
          console.log("MarchingSquaresJS-isoBands: edge index out of range!");
          console.log(cell);
          return null;
      }
      if (typeof x === "undefined" || typeof y === "undefined" || typeof d_x === "undefined" || typeof d_y === "undefined" || typeof d_o === "undefined") {
        console.log("MarchingSquaresJS-isoBands: undefined value!");
        console.log(cell);
        console.log(x + " " + y + " " + d_x + " " + d_y + " " + d_o);
      }
      return { p: [x, y], x: d_x, y: d_y, o: d_o };
    }
    function BandGrid2Areas(grid) {
      var areas = [];
      var area_idx = 0;
      grid.cells.forEach(function(g, j) {
        g.forEach(function(gg, i) {
          if (typeof gg !== "undefined") {
            var a = polygon_table[gg.cval](gg);
            if (typeof a === "object" && isArray(a)) {
              if (typeof a[0] === "object" && isArray(a[0])) {
                if (typeof a[0][0] === "object" && isArray(a[0][0])) {
                  a.forEach(function(aa) {
                    aa.forEach(function(aaa) {
                      aaa[0] += i;
                      aaa[1] += j;
                    });
                    areas[area_idx++] = aa;
                  });
                } else {
                  a.forEach(function(aa) {
                    aa[0] += i;
                    aa[1] += j;
                  });
                  areas[area_idx++] = a;
                }
              } else {
                console.log(
                  "MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates"
                );
              }
            } else {
              console.log(
                "MarchingSquaresJS-isoBands: bandcell polygon with null coordinates"
              );
            }
          }
        });
      });
      return areas;
    }
    function isobands(pointGrid, breaks, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var commonProperties = options.commonProperties || {};
      var breaksProperties = options.breaksProperties || [];
      invariant.collectionOf(pointGrid, "Point", "Input must contain Points");
      if (!breaks) throw new Error("breaks is required");
      if (!Array.isArray(breaks)) throw new Error("breaks is not an Array");
      if (!helpers.isObject(commonProperties))
        throw new Error("commonProperties is not an Object");
      if (!Array.isArray(breaksProperties))
        throw new Error("breaksProperties is not an Array");
      var matrix = gridToMatrix(pointGrid, { zProperty, flip: true });
      var contours = createContourLines(matrix, breaks, zProperty);
      contours = rescaleContours(contours, matrix, pointGrid);
      var multipolygons = contours.map(function(contour, index) {
        if (breaksProperties[index] && !helpers.isObject(breaksProperties[index])) {
          throw new Error("Each mappedProperty is required to be an Object");
        }
        var contourProperties = objectAssign__default["default"](
          {},
          commonProperties,
          breaksProperties[index]
        );
        contourProperties[zProperty] = contour[zProperty];
        var multiP = helpers.multiPolygon(contour.groupedRings, contourProperties);
        return multiP;
      });
      return helpers.featureCollection(multipolygons);
    }
    function createContourLines(matrix, breaks, property) {
      var contours = [];
      for (var i = 1; i < breaks.length; i++) {
        var lowerBand = +breaks[i - 1];
        var upperBand = +breaks[i];
        var isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);
        var nestedRings = orderByArea(isobandsCoords);
        var groupedRings = groupNestedRings(nestedRings);
        var obj = {};
        obj["groupedRings"] = groupedRings;
        obj[property] = lowerBand + "-" + upperBand;
        contours.push(obj);
      }
      return contours;
    }
    function rescaleContours(contours, matrix, points) {
      var gridBbox = bbox__default["default"](points);
      var originalWidth = gridBbox[2] - gridBbox[0];
      var originalHeigth = gridBbox[3] - gridBbox[1];
      var x0 = gridBbox[0];
      var y0 = gridBbox[1];
      var matrixWidth = matrix[0].length - 1;
      var matrixHeight = matrix.length - 1;
      var scaleX = originalWidth / matrixWidth;
      var scaleY = originalHeigth / matrixHeight;
      var resize = function(point) {
        point[0] = point[0] * scaleX + x0;
        point[1] = point[1] * scaleY + y0;
      };
      contours.forEach(function(contour) {
        contour.groupedRings.forEach(function(lineRingSet) {
          lineRingSet.forEach(function(lineRing) {
            lineRing.forEach(resize);
          });
        });
      });
      return contours;
    }
    function orderByArea(ringsCoords) {
      var ringsWithArea = [];
      var areas = [];
      ringsCoords.forEach(function(coords) {
        var ringArea = area__default["default"](helpers.polygon([coords]));
        areas.push(ringArea);
        ringsWithArea.push({ ring: coords, area: ringArea });
      });
      areas.sort(function(a, b) {
        return b - a;
      });
      var orderedByArea = [];
      areas.forEach(function(area2) {
        for (var lr = 0; lr < ringsWithArea.length; lr++) {
          if (ringsWithArea[lr].area === area2) {
            orderedByArea.push(ringsWithArea[lr].ring);
            ringsWithArea.splice(lr, 1);
            break;
          }
        }
      });
      return orderedByArea;
    }
    function groupNestedRings(orderedLinearRings) {
      var lrList = orderedLinearRings.map(function(lr) {
        return { lrCoordinates: lr, grouped: false };
      });
      var groupedLinearRingsCoords = [];
      while (!allGrouped(lrList)) {
        for (var i = 0; i < lrList.length; i++) {
          if (!lrList[i].grouped) {
            var group = [];
            group.push(lrList[i].lrCoordinates);
            lrList[i].grouped = true;
            var outerMostPoly = helpers.polygon([lrList[i].lrCoordinates]);
            for (var j = i + 1; j < lrList.length; j++) {
              if (!lrList[j].grouped) {
                var lrPoly = helpers.polygon([lrList[j].lrCoordinates]);
                if (isInside(lrPoly, outerMostPoly)) {
                  group.push(lrList[j].lrCoordinates);
                  lrList[j].grouped = true;
                }
              }
            }
            groupedLinearRingsCoords.push(group);
          }
        }
      }
      return groupedLinearRingsCoords;
    }
    function isInside(testPolygon, targetPolygon) {
      var points = explode__default["default"](testPolygon);
      for (var i = 0; i < points.features.length; i++) {
        if (!booleanPointInPolygon__default["default"](points.features[i], targetPolygon)) {
          return false;
        }
      }
      return true;
    }
    function allGrouped(list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].grouped === false) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isobands;
    module2.exports.default = isobands;
  }
});

// node_modules/@turf/transform-rotate/dist/js/index.js
var require_js69 = __commonJS({
  "node_modules/@turf/transform-rotate/dist/js/index.js"(exports2, module2) {
    "use strict";
    var centroid = require_js28();
    var rhumbBearing = require_js63();
    var rhumbDistance = require_js37();
    var rhumbDestination = require_js64();
    var clone = require_js11();
    var meta = require_js2();
    var invariant = require_js4();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var centroid__default = /* @__PURE__ */ _interopDefaultLegacy(centroid);
    var rhumbBearing__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbBearing);
    var rhumbDistance__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDistance);
    var rhumbDestination__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDestination);
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    function transformRotate(geojson, angle, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var pivot = options.pivot;
      var mutate = options.mutate;
      if (!geojson) throw new Error("geojson is required");
      if (angle === void 0 || angle === null || isNaN(angle))
        throw new Error("angle is required");
      if (angle === 0) return geojson;
      if (!pivot) pivot = centroid__default["default"](geojson);
      if (mutate === false || mutate === void 0) geojson = clone__default["default"](geojson);
      meta.coordEach(geojson, function(pointCoords) {
        var initialAngle = rhumbBearing__default["default"](pivot, pointCoords);
        var finalAngle = initialAngle + angle;
        var distance = rhumbDistance__default["default"](pivot, pointCoords);
        var newCoords = invariant.getCoords(rhumbDestination__default["default"](pivot, distance, finalAngle));
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
      });
      return geojson;
    }
    module2.exports = transformRotate;
    module2.exports.default = transformRotate;
  }
});

// node_modules/@turf/transform-scale/dist/js/index.js
var require_js70 = __commonJS({
  "node_modules/@turf/transform-scale/dist/js/index.js"(exports2, module2) {
    "use strict";
    var clone = require_js11();
    var center = require_js27();
    var centroid = require_js28();
    var turfBBox = require_js3();
    var rhumbBearing = require_js63();
    var rhumbDistance = require_js37();
    var rhumbDestination = require_js64();
    var meta = require_js2();
    var helpers = require_js();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    var center__default = /* @__PURE__ */ _interopDefaultLegacy(center);
    var centroid__default = /* @__PURE__ */ _interopDefaultLegacy(centroid);
    var turfBBox__default = /* @__PURE__ */ _interopDefaultLegacy(turfBBox);
    var rhumbBearing__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbBearing);
    var rhumbDistance__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDistance);
    var rhumbDestination__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDestination);
    function transformScale(geojson, factor, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var origin = options.origin;
      var mutate = options.mutate;
      if (!geojson) throw new Error("geojson required");
      if (typeof factor !== "number" || factor === 0)
        throw new Error("invalid factor");
      var originIsPoint = Array.isArray(origin) || typeof origin === "object";
      if (mutate !== true) geojson = clone__default["default"](geojson);
      if (geojson.type === "FeatureCollection" && !originIsPoint) {
        meta.featureEach(geojson, function(feature, index) {
          geojson.features[index] = scale(feature, factor, origin);
        });
        return geojson;
      }
      return scale(geojson, factor, origin);
    }
    function scale(feature, factor, origin) {
      var isPoint = invariant.getType(feature) === "Point";
      origin = defineOrigin(feature, origin);
      if (factor === 1 || isPoint) return feature;
      meta.coordEach(feature, function(coord) {
        var originalDistance = rhumbDistance__default["default"](origin, coord);
        var bearing = rhumbBearing__default["default"](origin, coord);
        var newDistance = originalDistance * factor;
        var newCoord = invariant.getCoords(rhumbDestination__default["default"](origin, newDistance, bearing));
        coord[0] = newCoord[0];
        coord[1] = newCoord[1];
        if (coord.length === 3) coord[2] *= factor;
      });
      return feature;
    }
    function defineOrigin(geojson, origin) {
      if (origin === void 0 || origin === null) origin = "centroid";
      if (Array.isArray(origin) || typeof origin === "object")
        return invariant.getCoord(origin);
      var bbox = geojson.bbox ? geojson.bbox : turfBBox__default["default"](geojson);
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];
      switch (origin) {
        case "sw":
        case "southwest":
        case "westsouth":
        case "bottomleft":
          return helpers.point([west, south]);
        case "se":
        case "southeast":
        case "eastsouth":
        case "bottomright":
          return helpers.point([east, south]);
        case "nw":
        case "northwest":
        case "westnorth":
        case "topleft":
          return helpers.point([west, north]);
        case "ne":
        case "northeast":
        case "eastnorth":
        case "topright":
          return helpers.point([east, north]);
        case "center":
          return center__default["default"](geojson);
        case void 0:
        case null:
        case "centroid":
          return centroid__default["default"](geojson);
        default:
          throw new Error("invalid origin");
      }
    }
    module2.exports = transformScale;
    module2.exports.default = transformScale;
  }
});

// node_modules/@turf/transform-translate/dist/js/index.js
var require_js71 = __commonJS({
  "node_modules/@turf/transform-translate/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var helpers = require_js();
    var invariant = require_js4();
    var clone = require_js11();
    var rhumbDestination = require_js64();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    var rhumbDestination__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDestination);
    function transformTranslate(geojson, distance, direction, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var units = options.units;
      var zTranslation = options.zTranslation;
      var mutate = options.mutate;
      if (!geojson) throw new Error("geojson is required");
      if (distance === void 0 || distance === null || isNaN(distance))
        throw new Error("distance is required");
      if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
        throw new Error("zTranslation is not a number");
      zTranslation = zTranslation !== void 0 ? zTranslation : 0;
      if (distance === 0 && zTranslation === 0) return geojson;
      if (direction === void 0 || direction === null || isNaN(direction))
        throw new Error("direction is required");
      if (distance < 0) {
        distance = -distance;
        direction = direction + 180;
      }
      if (mutate === false || mutate === void 0) geojson = clone__default["default"](geojson);
      meta.coordEach(geojson, function(pointCoords) {
        var newCoords = invariant.getCoords(
          rhumbDestination__default["default"](pointCoords, distance, direction, { units })
        );
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
        if (zTranslation && pointCoords.length === 3)
          pointCoords[2] += zTranslation;
      });
      return geojson;
    }
    module2.exports = transformTranslate;
    module2.exports.default = transformTranslate;
  }
});

// node_modules/@turf/line-offset/dist/js/index.js
var require_js72 = __commonJS({
  "node_modules/@turf/line-offset/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var invariant = require_js4();
    var helpers = require_js();
    function ab(segment) {
      var start = segment[0];
      var end = segment[1];
      return [end[0] - start[0], end[1] - start[1]];
    }
    function crossProduct(v12, v2) {
      return v12[0] * v2[1] - v2[0] * v12[1];
    }
    function add(v12, v2) {
      return [v12[0] + v2[0], v12[1] + v2[1]];
    }
    function sub(v12, v2) {
      return [v12[0] - v2[0], v12[1] - v2[1]];
    }
    function scalarMult(s, v) {
      return [s * v[0], s * v[1]];
    }
    function intersectSegments(a, b) {
      var p = a[0];
      var r = ab(a);
      var q = b[0];
      var s = ab(b);
      var cross = crossProduct(r, s);
      var qmp = sub(q, p);
      var numerator = crossProduct(qmp, s);
      var t = numerator / cross;
      var intersection2 = add(p, scalarMult(t, r));
      return intersection2;
    }
    function isParallel(a, b) {
      var r = ab(a);
      var s = ab(b);
      return crossProduct(r, s) === 0;
    }
    function intersection(a, b) {
      if (isParallel(a, b)) return false;
      return intersectSegments(a, b);
    }
    function lineOffset(geojson, distance, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var units = options.units;
      if (!geojson) throw new Error("geojson is required");
      if (distance === void 0 || distance === null || isNaN(distance))
        throw new Error("distance is required");
      var type = invariant.getType(geojson);
      var properties = geojson.properties;
      switch (type) {
        case "LineString":
          return lineOffsetFeature(geojson, distance, units);
        case "MultiLineString":
          var coords = [];
          meta.flattenEach(geojson, function(feature) {
            coords.push(
              lineOffsetFeature(feature, distance, units).geometry.coordinates
            );
          });
          return helpers.multiLineString(coords, properties);
        default:
          throw new Error("geometry " + type + " is not supported");
      }
    }
    function lineOffsetFeature(line, distance, units) {
      var segments = [];
      var offsetDegrees = helpers.lengthToDegrees(distance, units);
      var coords = invariant.getCoords(line);
      var finalCoords = [];
      coords.forEach(function(currentCoords, index) {
        if (index !== coords.length - 1) {
          var segment = processSegment(
            currentCoords,
            coords[index + 1],
            offsetDegrees
          );
          segments.push(segment);
          if (index > 0) {
            var seg2Coords = segments[index - 1];
            var intersects = intersection(segment, seg2Coords);
            if (intersects !== false) {
              seg2Coords[1] = intersects;
              segment[0] = intersects;
            }
            finalCoords.push(seg2Coords[0]);
            if (index === coords.length - 2) {
              finalCoords.push(segment[0]);
              finalCoords.push(segment[1]);
            }
          }
          if (coords.length === 2) {
            finalCoords.push(segment[0]);
            finalCoords.push(segment[1]);
          }
        }
      });
      return helpers.lineString(finalCoords, line.properties);
    }
    function processSegment(point1, point2, offset) {
      var L = Math.sqrt(
        (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1])
      );
      var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;
      var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;
      var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;
      var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;
      return [
        [out1x, out1y],
        [out2x, out2y]
      ];
    }
    module2.exports = lineOffset;
    module2.exports.default = lineOffset;
  }
});

// node_modules/@turf/polygonize/dist/js/lib/util.js
var require_util = __commonJS({
  "node_modules/@turf/polygonize/dist/js/lib/util.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var boolean_point_in_polygon_1 = __importDefault(require_js7());
    var helpers_1 = require_js();
    function mathSign(x) {
      return (x > 0) - (x < 0) || +x;
    }
    function orientationIndex(p1, p2, q) {
      var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
      return mathSign(dx1 * dy2 - dx2 * dy1);
    }
    exports2.orientationIndex = orientationIndex;
    function envelopeIsEqual(env1, env2) {
      var envX1 = env1.geometry.coordinates[0].map(function(c) {
        return c[0];
      }), envY1 = env1.geometry.coordinates[0].map(function(c) {
        return c[1];
      }), envX2 = env2.geometry.coordinates[0].map(function(c) {
        return c[0];
      }), envY2 = env2.geometry.coordinates[0].map(function(c) {
        return c[1];
      });
      return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
    }
    exports2.envelopeIsEqual = envelopeIsEqual;
    function envelopeContains(self2, env) {
      return env.geometry.coordinates[0].every(function(c) {
        return boolean_point_in_polygon_1.default(helpers_1.point(c), self2);
      });
    }
    exports2.envelopeContains = envelopeContains;
    function coordinatesEqual(coord1, coord2) {
      return coord1[0] === coord2[0] && coord1[1] === coord2[1];
    }
    exports2.coordinatesEqual = coordinatesEqual;
  }
});

// node_modules/@turf/polygonize/dist/js/lib/Node.js
var require_Node = __commonJS({
  "node_modules/@turf/polygonize/dist/js/lib/Node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var Node = (
      /** @class */
      function() {
        function Node2(coordinates) {
          this.id = Node2.buildId(coordinates);
          this.coordinates = coordinates;
          this.innerEdges = [];
          this.outerEdges = [];
          this.outerEdgesSorted = false;
        }
        Node2.buildId = function(coordinates) {
          return coordinates.join(",");
        };
        Node2.prototype.removeInnerEdge = function(edge) {
          this.innerEdges = this.innerEdges.filter(function(e) {
            return e.from.id !== edge.from.id;
          });
        };
        Node2.prototype.removeOuterEdge = function(edge) {
          this.outerEdges = this.outerEdges.filter(function(e) {
            return e.to.id !== edge.to.id;
          });
        };
        Node2.prototype.addOuterEdge = function(edge) {
          this.outerEdges.push(edge);
          this.outerEdgesSorted = false;
        };
        Node2.prototype.sortOuterEdges = function() {
          var _this = this;
          if (!this.outerEdgesSorted) {
            this.outerEdges.sort(function(a, b) {
              var aNode = a.to, bNode = b.to;
              if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
                return 1;
              if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
                return -1;
              if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
                if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
                  return aNode.coordinates[1] - bNode.coordinates[1];
                return bNode.coordinates[1] - aNode.coordinates[1];
              }
              var det = util_1.orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
              if (det < 0)
                return 1;
              if (det > 0)
                return -1;
              var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
              return d1 - d2;
            });
            this.outerEdgesSorted = true;
          }
        };
        Node2.prototype.getOuterEdges = function() {
          this.sortOuterEdges();
          return this.outerEdges;
        };
        Node2.prototype.getOuterEdge = function(i) {
          this.sortOuterEdges();
          return this.outerEdges[i];
        };
        Node2.prototype.addInnerEdge = function(edge) {
          this.innerEdges.push(edge);
        };
        return Node2;
      }()
    );
    exports2.default = Node;
  }
});

// node_modules/@turf/polygonize/dist/js/lib/Edge.js
var require_Edge = __commonJS({
  "node_modules/@turf/polygonize/dist/js/lib/Edge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var util_1 = require_util();
    var Edge = (
      /** @class */
      function() {
        function Edge2(from, to) {
          this.from = from;
          this.to = to;
          this.next = void 0;
          this.label = void 0;
          this.symetric = void 0;
          this.ring = void 0;
          this.from.addOuterEdge(this);
          this.to.addInnerEdge(this);
        }
        Edge2.prototype.getSymetric = function() {
          if (!this.symetric) {
            this.symetric = new Edge2(this.to, this.from);
            this.symetric.symetric = this;
          }
          return this.symetric;
        };
        Edge2.prototype.deleteEdge = function() {
          this.from.removeOuterEdge(this);
          this.to.removeInnerEdge(this);
        };
        Edge2.prototype.isEqual = function(edge) {
          return this.from.id === edge.from.id && this.to.id === edge.to.id;
        };
        Edge2.prototype.toString = function() {
          return "Edge { " + this.from.id + " -> " + this.to.id + " }";
        };
        Edge2.prototype.toLineString = function() {
          return helpers_1.lineString([this.from.coordinates, this.to.coordinates]);
        };
        Edge2.prototype.compareTo = function(edge) {
          return util_1.orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
        };
        return Edge2;
      }()
    );
    exports2.default = Edge;
  }
});

// node_modules/@turf/polygonize/dist/js/lib/EdgeRing.js
var require_EdgeRing = __commonJS({
  "node_modules/@turf/polygonize/dist/js/lib/EdgeRing.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var helpers_1 = require_js();
    var envelope_1 = __importDefault(require_js21());
    var boolean_point_in_polygon_1 = __importDefault(require_js7());
    var EdgeRing = (
      /** @class */
      function() {
        function EdgeRing2() {
          this.edges = [];
          this.polygon = void 0;
          this.envelope = void 0;
        }
        EdgeRing2.prototype.push = function(edge) {
          this.edges.push(edge);
          this.polygon = this.envelope = void 0;
        };
        EdgeRing2.prototype.get = function(i) {
          return this.edges[i];
        };
        Object.defineProperty(EdgeRing2.prototype, "length", {
          /**
           * Getter of length property.
           *
           * @memberof EdgeRing
           * @returns {number} - Length of the edge ring.
           */
          get: function() {
            return this.edges.length;
          },
          enumerable: true,
          configurable: true
        });
        EdgeRing2.prototype.forEach = function(f) {
          this.edges.forEach(f);
        };
        EdgeRing2.prototype.map = function(f) {
          return this.edges.map(f);
        };
        EdgeRing2.prototype.some = function(f) {
          return this.edges.some(f);
        };
        EdgeRing2.prototype.isValid = function() {
          return true;
        };
        EdgeRing2.prototype.isHole = function() {
          var _this = this;
          var hiIndex = this.edges.reduce(function(high, edge, i) {
            if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
              high = i;
            return high;
          }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = util_1.orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
          if (disc === 0)
            return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
          return disc > 0;
        };
        EdgeRing2.prototype.toMultiPoint = function() {
          return helpers_1.multiPoint(this.edges.map(function(edge) {
            return edge.from.coordinates;
          }));
        };
        EdgeRing2.prototype.toPolygon = function() {
          if (this.polygon)
            return this.polygon;
          var coordinates = this.edges.map(function(edge) {
            return edge.from.coordinates;
          });
          coordinates.push(this.edges[0].from.coordinates);
          return this.polygon = helpers_1.polygon([coordinates]);
        };
        EdgeRing2.prototype.getEnvelope = function() {
          if (this.envelope)
            return this.envelope;
          return this.envelope = envelope_1.default(this.toPolygon());
        };
        EdgeRing2.findEdgeRingContaining = function(testEdgeRing, shellList) {
          var testEnvelope = testEdgeRing.getEnvelope();
          var minEnvelope, minShell;
          shellList.forEach(function(shell) {
            var tryEnvelope = shell.getEnvelope();
            if (minShell)
              minEnvelope = minShell.getEnvelope();
            if (util_1.envelopeIsEqual(tryEnvelope, testEnvelope))
              return;
            if (util_1.envelopeContains(tryEnvelope, testEnvelope)) {
              var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
                return edge.from.coordinates;
              });
              var testPoint = void 0;
              var _loop_1 = function(pt2) {
                if (!shell.some(function(edge) {
                  return util_1.coordinatesEqual(pt2, edge.from.coordinates);
                })) {
                  testPoint = pt2;
                }
              };
              for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
                var pt = testEdgeRingCoordinates_1[_i];
                _loop_1(pt);
              }
              if (testPoint && shell.inside(helpers_1.point(testPoint))) {
                if (!minShell || util_1.envelopeContains(minEnvelope, tryEnvelope))
                  minShell = shell;
              }
            }
          });
          return minShell;
        };
        EdgeRing2.prototype.inside = function(pt) {
          return boolean_point_in_polygon_1.default(pt, this.toPolygon());
        };
        return EdgeRing2;
      }()
    );
    exports2.default = EdgeRing;
  }
});

// node_modules/@turf/polygonize/dist/js/lib/Graph.js
var require_Graph = __commonJS({
  "node_modules/@turf/polygonize/dist/js/lib/Graph.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Node_1 = __importDefault(require_Node());
    var Edge_1 = __importDefault(require_Edge());
    var EdgeRing_1 = __importDefault(require_EdgeRing());
    var meta_1 = require_js2();
    var invariant_1 = require_js4();
    function validateGeoJson(geoJson) {
      if (!geoJson)
        throw new Error("No geojson passed");
      if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
        throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
    }
    var Graph = (
      /** @class */
      function() {
        function Graph2() {
          this.edges = [];
          this.nodes = {};
        }
        Graph2.fromGeoJson = function(geoJson) {
          validateGeoJson(geoJson);
          var graph = new Graph2();
          meta_1.flattenEach(geoJson, function(feature) {
            invariant_1.featureOf(feature, "LineString", "Graph::fromGeoJson");
            meta_1.coordReduce(feature, function(prev, cur) {
              if (prev) {
                var start = graph.getNode(prev), end = graph.getNode(cur);
                graph.addEdge(start, end);
              }
              return cur;
            });
          });
          return graph;
        };
        Graph2.prototype.getNode = function(coordinates) {
          var id = Node_1.default.buildId(coordinates);
          var node = this.nodes[id];
          if (!node)
            node = this.nodes[id] = new Node_1.default(coordinates);
          return node;
        };
        Graph2.prototype.addEdge = function(from, to) {
          var edge = new Edge_1.default(from, to), symetricEdge = edge.getSymetric();
          this.edges.push(edge);
          this.edges.push(symetricEdge);
        };
        Graph2.prototype.deleteDangles = function() {
          var _this = this;
          Object.keys(this.nodes).map(function(id) {
            return _this.nodes[id];
          }).forEach(function(node) {
            return _this._removeIfDangle(node);
          });
        };
        Graph2.prototype._removeIfDangle = function(node) {
          var _this = this;
          if (node.innerEdges.length <= 1) {
            var outerNodes = node.getOuterEdges().map(function(e) {
              return e.to;
            });
            this.removeNode(node);
            outerNodes.forEach(function(n) {
              return _this._removeIfDangle(n);
            });
          }
        };
        Graph2.prototype.deleteCutEdges = function() {
          var _this = this;
          this._computeNextCWEdges();
          this._findLabeledEdgeRings();
          this.edges.forEach(function(edge) {
            if (edge.label === edge.symetric.label) {
              _this.removeEdge(edge.symetric);
              _this.removeEdge(edge);
            }
          });
        };
        Graph2.prototype._computeNextCWEdges = function(node) {
          var _this = this;
          if (typeof node === "undefined") {
            Object.keys(this.nodes).forEach(function(id) {
              return _this._computeNextCWEdges(_this.nodes[id]);
            });
          } else {
            node.getOuterEdges().forEach(function(edge, i) {
              node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
            });
          }
        };
        Graph2.prototype._computeNextCCWEdges = function(node, label) {
          var edges = node.getOuterEdges();
          var firstOutDE, prevInDE;
          for (var i = edges.length - 1; i >= 0; --i) {
            var de = edges[i], sym = de.symetric, outDE = void 0, inDE = void 0;
            if (de.label === label)
              outDE = de;
            if (sym.label === label)
              inDE = sym;
            if (!outDE || !inDE)
              continue;
            if (inDE)
              prevInDE = inDE;
            if (outDE) {
              if (prevInDE) {
                prevInDE.next = outDE;
                prevInDE = void 0;
              }
              if (!firstOutDE)
                firstOutDE = outDE;
            }
          }
          if (prevInDE)
            prevInDE.next = firstOutDE;
        };
        Graph2.prototype._findLabeledEdgeRings = function() {
          var edgeRingStarts = [];
          var label = 0;
          this.edges.forEach(function(edge) {
            if (edge.label >= 0)
              return;
            edgeRingStarts.push(edge);
            var e = edge;
            do {
              e.label = label;
              e = e.next;
            } while (!edge.isEqual(e));
            label++;
          });
          return edgeRingStarts;
        };
        Graph2.prototype.getEdgeRings = function() {
          var _this = this;
          this._computeNextCWEdges();
          this.edges.forEach(function(edge) {
            edge.label = void 0;
          });
          this._findLabeledEdgeRings().forEach(function(edge) {
            _this._findIntersectionNodes(edge).forEach(function(node) {
              _this._computeNextCCWEdges(node, edge.label);
            });
          });
          var edgeRingList = [];
          this.edges.forEach(function(edge) {
            if (edge.ring)
              return;
            edgeRingList.push(_this._findEdgeRing(edge));
          });
          return edgeRingList;
        };
        Graph2.prototype._findIntersectionNodes = function(startEdge) {
          var intersectionNodes = [];
          var edge = startEdge;
          var _loop_1 = function() {
            var degree = 0;
            edge.from.getOuterEdges().forEach(function(e) {
              if (e.label === startEdge.label)
                ++degree;
            });
            if (degree > 1)
              intersectionNodes.push(edge.from);
            edge = edge.next;
          };
          do {
            _loop_1();
          } while (!startEdge.isEqual(edge));
          return intersectionNodes;
        };
        Graph2.prototype._findEdgeRing = function(startEdge) {
          var edge = startEdge;
          var edgeRing = new EdgeRing_1.default();
          do {
            edgeRing.push(edge);
            edge.ring = edgeRing;
            edge = edge.next;
          } while (!startEdge.isEqual(edge));
          return edgeRing;
        };
        Graph2.prototype.removeNode = function(node) {
          var _this = this;
          node.getOuterEdges().forEach(function(edge) {
            return _this.removeEdge(edge);
          });
          node.innerEdges.forEach(function(edge) {
            return _this.removeEdge(edge);
          });
          delete this.nodes[node.id];
        };
        Graph2.prototype.removeEdge = function(edge) {
          this.edges = this.edges.filter(function(e) {
            return !e.isEqual(edge);
          });
          edge.deleteEdge();
        };
        return Graph2;
      }()
    );
    exports2.default = Graph;
  }
});

// node_modules/@turf/polygonize/dist/js/index.js
var require_js73 = __commonJS({
  "node_modules/@turf/polygonize/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var Graph_1 = __importDefault(require_Graph());
    var EdgeRing_1 = __importDefault(require_EdgeRing());
    function polygonize(geoJson) {
      var graph = Graph_1.default.fromGeoJson(geoJson);
      graph.deleteDangles();
      graph.deleteCutEdges();
      var holes = [], shells = [];
      graph.getEdgeRings().filter(function(edgeRing) {
        return edgeRing.isValid();
      }).forEach(function(edgeRing) {
        if (edgeRing.isHole())
          holes.push(edgeRing);
        else
          shells.push(edgeRing);
      });
      holes.forEach(function(hole) {
        if (EdgeRing_1.default.findEdgeRingContaining(hole, shells))
          shells.push(hole);
      });
      return helpers_1.featureCollection(shells.map(function(shell) {
        return shell.toPolygon();
      }));
    }
    exports2.default = polygonize;
  }
});

// node_modules/@turf/boolean-disjoint/dist/js/index.js
var require_js74 = __commonJS({
  "node_modules/@turf/boolean-disjoint/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var boolean_point_in_polygon_1 = __importDefault(require_js7());
    var line_intersect_1 = __importDefault(require_js35());
    var meta_1 = require_js2();
    var polygon_to_line_1 = __importDefault(require_js58());
    function booleanDisjoint(feature1, feature2) {
      var bool = true;
      meta_1.flattenEach(feature1, function(flatten1) {
        meta_1.flattenEach(feature2, function(flatten2) {
          if (bool === false) {
            return false;
          }
          bool = disjoint(flatten1.geometry, flatten2.geometry);
        });
      });
      return bool;
    }
    function disjoint(geom1, geom2) {
      switch (geom1.type) {
        case "Point":
          switch (geom2.type) {
            case "Point":
              return !compareCoords(geom1.coordinates, geom2.coordinates);
            case "LineString":
              return !isPointOnLine(geom2, geom1);
            case "Polygon":
              return !boolean_point_in_polygon_1.default(geom1, geom2);
          }
          break;
        case "LineString":
          switch (geom2.type) {
            case "Point":
              return !isPointOnLine(geom1, geom2);
            case "LineString":
              return !isLineOnLine(geom1, geom2);
            case "Polygon":
              return !isLineInPoly(geom2, geom1);
          }
          break;
        case "Polygon":
          switch (geom2.type) {
            case "Point":
              return !boolean_point_in_polygon_1.default(geom2, geom1);
            case "LineString":
              return !isLineInPoly(geom1, geom2);
            case "Polygon":
              return !isPolyInPoly(geom2, geom1);
          }
      }
      return false;
    }
    function isPointOnLine(lineString, pt) {
      for (var i = 0; i < lineString.coordinates.length - 1; i++) {
        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {
          return true;
        }
      }
      return false;
    }
    function isLineOnLine(lineString1, lineString2) {
      var doLinesIntersect = line_intersect_1.default(lineString1, lineString2);
      if (doLinesIntersect.features.length > 0) {
        return true;
      }
      return false;
    }
    function isLineInPoly(polygon, lineString) {
      for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (boolean_point_in_polygon_1.default(coord, polygon)) {
          return true;
        }
      }
      var doLinesIntersect = line_intersect_1.default(lineString, polygon_to_line_1.default(polygon));
      if (doLinesIntersect.features.length > 0) {
        return true;
      }
      return false;
    }
    function isPolyInPoly(feature1, feature2) {
      for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {
        var coord1 = _a[_i];
        if (boolean_point_in_polygon_1.default(coord1, feature2)) {
          return true;
        }
      }
      for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {
        var coord2 = _c[_b];
        if (boolean_point_in_polygon_1.default(coord2, feature1)) {
          return true;
        }
      }
      var doLinesIntersect = line_intersect_1.default(polygon_to_line_1.default(feature1), polygon_to_line_1.default(feature2));
      if (doLinesIntersect.features.length > 0) {
        return true;
      }
      return false;
    }
    function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {
      var dxc = pt[0] - lineSegmentStart[0];
      var dyc = pt[1] - lineSegmentStart[1];
      var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
      var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
      var cross = dxc * dyl - dyc * dxl;
      if (cross !== 0) {
        return false;
      }
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        if (dxl > 0) {
          return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
        } else {
          return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
      } else if (dyl > 0) {
        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
      } else {
        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
      }
    }
    function compareCoords(pair1, pair2) {
      return pair1[0] === pair2[0] && pair1[1] === pair2[1];
    }
    exports2.default = booleanDisjoint;
  }
});

// node_modules/@turf/boolean-contains/dist/js/index.js
var require_js75 = __commonJS({
  "node_modules/@turf/boolean-contains/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bbox_1 = __importDefault(require_js3());
    var boolean_point_in_polygon_1 = __importDefault(require_js7());
    var boolean_point_on_line_1 = __importDefault(require_js48());
    var invariant_1 = require_js4();
    function booleanContains(feature1, feature2) {
      var geom1 = invariant_1.getGeom(feature1);
      var geom2 = invariant_1.getGeom(feature2);
      var type1 = geom1.type;
      var type2 = geom2.type;
      var coords1 = geom1.coordinates;
      var coords2 = geom2.coordinates;
      switch (type1) {
        case "Point":
          switch (type2) {
            case "Point":
              return compareCoords(coords1, coords2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "MultiPoint":
          switch (type2) {
            case "Point":
              return isPointInMultiPoint(geom1, geom2);
            case "MultiPoint":
              return isMultiPointInMultiPoint(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "LineString":
          switch (type2) {
            case "Point":
              return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });
            case "LineString":
              return isLineOnLine(geom1, geom2);
            case "MultiPoint":
              return isMultiPointOnLine(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "Polygon":
          switch (type2) {
            case "Point":
              return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });
            case "LineString":
              return isLineInPoly(geom1, geom2);
            case "Polygon":
              return isPolyInPoly(geom1, geom2);
            case "MultiPoint":
              return isMultiPointInPoly(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        default:
          throw new Error("feature1 " + type1 + " geometry not supported");
      }
    }
    exports2.default = booleanContains;
    function isPointInMultiPoint(multiPoint, pt) {
      var i;
      var output = false;
      for (i = 0; i < multiPoint.coordinates.length; i++) {
        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {
          output = true;
          break;
        }
      }
      return output;
    }
    exports2.isPointInMultiPoint = isPointInMultiPoint;
    function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
      for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
        var coord2 = _a[_i];
        var matchFound = false;
        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {
          var coord1 = _c[_b];
          if (compareCoords(coord2, coord1)) {
            matchFound = true;
            break;
          }
        }
        if (!matchFound) {
          return false;
        }
      }
      return true;
    }
    exports2.isMultiPointInMultiPoint = isMultiPointInMultiPoint;
    function isMultiPointOnLine(lineString, multiPoint) {
      var haveFoundInteriorPoint = false;
      for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {
          haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default(coord, lineString)) {
          return false;
        }
      }
      if (haveFoundInteriorPoint) {
        return true;
      }
      return false;
    }
    exports2.isMultiPointOnLine = isMultiPointOnLine;
    function isMultiPointInPoly(polygon, multiPoint) {
      for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {
          return false;
        }
      }
      return true;
    }
    exports2.isMultiPointInPoly = isMultiPointInPoly;
    function isLineOnLine(lineString1, lineString2) {
      var haveFoundInteriorPoint = false;
      for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
        var coords = _a[_i];
        if (boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, {
          ignoreEndVertices: true
        })) {
          haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, {
          ignoreEndVertices: false
        })) {
          return false;
        }
      }
      return haveFoundInteriorPoint;
    }
    exports2.isLineOnLine = isLineOnLine;
    function isLineInPoly(polygon, linestring) {
      var output = false;
      var i = 0;
      var polyBbox = bbox_1.default(polygon);
      var lineBbox = bbox_1.default(linestring);
      if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
      }
      for (i; i < linestring.coordinates.length - 1; i++) {
        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
        if (boolean_point_in_polygon_1.default({ type: "Point", coordinates: midPoint }, polygon, {
          ignoreBoundary: true
        })) {
          output = true;
          break;
        }
      }
      return output;
    }
    exports2.isLineInPoly = isLineInPoly;
    function isPolyInPoly(feature1, feature2) {
      if (feature1.type === "Feature" && feature1.geometry === null) {
        return false;
      }
      if (feature2.type === "Feature" && feature2.geometry === null) {
        return false;
      }
      var poly1Bbox = bbox_1.default(feature1);
      var poly2Bbox = bbox_1.default(feature2);
      if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
        return false;
      }
      var coords = invariant_1.getGeom(feature2).coordinates;
      for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
        var ring = coords_1[_i];
        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {
          var coord = ring_1[_a];
          if (!boolean_point_in_polygon_1.default(coord, feature1)) {
            return false;
          }
        }
      }
      return true;
    }
    exports2.isPolyInPoly = isPolyInPoly;
    function doBBoxOverlap(bbox1, bbox2) {
      if (bbox1[0] > bbox2[0]) {
        return false;
      }
      if (bbox1[2] < bbox2[2]) {
        return false;
      }
      if (bbox1[1] > bbox2[1]) {
        return false;
      }
      if (bbox1[3] < bbox2[3]) {
        return false;
      }
      return true;
    }
    exports2.doBBoxOverlap = doBBoxOverlap;
    function compareCoords(pair1, pair2) {
      return pair1[0] === pair2[0] && pair1[1] === pair2[1];
    }
    exports2.compareCoords = compareCoords;
    function getMidpoint(pair1, pair2) {
      return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
    }
    exports2.getMidpoint = getMidpoint;
  }
});

// node_modules/@turf/boolean-crosses/dist/js/index.js
var require_js76 = __commonJS({
  "node_modules/@turf/boolean-crosses/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var line_intersect_1 = __importDefault(require_js35());
    var polygon_to_line_1 = require_js58();
    var boolean_point_in_polygon_1 = __importDefault(require_js7());
    var invariant_1 = require_js4();
    var helpers_1 = require_js();
    function booleanCrosses(feature1, feature2) {
      var geom1 = invariant_1.getGeom(feature1);
      var geom2 = invariant_1.getGeom(feature2);
      var type1 = geom1.type;
      var type2 = geom2.type;
      switch (type1) {
        case "MultiPoint":
          switch (type2) {
            case "LineString":
              return doMultiPointAndLineStringCross(geom1, geom2);
            case "Polygon":
              return doesMultiPointCrossPoly(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "LineString":
          switch (type2) {
            case "MultiPoint":
              return doMultiPointAndLineStringCross(geom2, geom1);
            case "LineString":
              return doLineStringsCross(geom1, geom2);
            case "Polygon":
              return doLineStringAndPolygonCross(geom1, geom2);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        case "Polygon":
          switch (type2) {
            case "MultiPoint":
              return doesMultiPointCrossPoly(geom2, geom1);
            case "LineString":
              return doLineStringAndPolygonCross(geom2, geom1);
            default:
              throw new Error("feature2 " + type2 + " geometry not supported");
          }
        default:
          throw new Error("feature1 " + type1 + " geometry not supported");
      }
    }
    function doMultiPointAndLineStringCross(multiPoint, lineString) {
      var foundIntPoint = false;
      var foundExtPoint = false;
      var pointLength = multiPoint.coordinates.length;
      var i = 0;
      while (i < pointLength && !foundIntPoint && !foundExtPoint) {
        for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {
          var incEndVertices = true;
          if (i2 === 0 || i2 === lineString.coordinates.length - 2) {
            incEndVertices = false;
          }
          if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {
            foundIntPoint = true;
          } else {
            foundExtPoint = true;
          }
        }
        i++;
      }
      return foundIntPoint && foundExtPoint;
    }
    function doLineStringsCross(lineString1, lineString2) {
      var doLinesIntersect = line_intersect_1.default(lineString1, lineString2);
      if (doLinesIntersect.features.length > 0) {
        for (var i = 0; i < lineString1.coordinates.length - 1; i++) {
          for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
            var incEndVertices = true;
            if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
              incEndVertices = false;
            }
            if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {
              return true;
            }
          }
        }
      }
      return false;
    }
    function doLineStringAndPolygonCross(lineString, polygon) {
      var line = polygon_to_line_1.polygonToLine(polygon);
      var doLinesIntersect = line_intersect_1.default(lineString, line);
      if (doLinesIntersect.features.length > 0) {
        return true;
      }
      return false;
    }
    function doesMultiPointCrossPoly(multiPoint, polygon) {
      var foundIntPoint = false;
      var foundExtPoint = false;
      var pointLength = multiPoint.coordinates.length;
      for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {
        if (boolean_point_in_polygon_1.default(helpers_1.point(multiPoint.coordinates[i]), polygon)) {
          foundIntPoint = true;
        } else {
          foundExtPoint = true;
        }
      }
      return foundExtPoint && foundIntPoint;
    }
    function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
      var dxc = pt[0] - lineSegmentStart[0];
      var dyc = pt[1] - lineSegmentStart[1];
      var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
      var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
      var cross = dxc * dyl - dyc * dxl;
      if (cross !== 0) {
        return false;
      }
      if (incEnd) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
          return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
      } else {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
          return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
      }
    }
    exports2.default = booleanCrosses;
  }
});

// node_modules/geojson-equality/index.js
var require_geojson_equality = __commonJS({
  "node_modules/geojson-equality/index.js"(exports2, module2) {
    var deepEqual = require_deep_equal();
    var Equality = function(opt) {
      this.precision = opt && opt.precision ? opt.precision : 17;
      this.direction = opt && opt.direction ? opt.direction : false;
      this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
      this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
    };
    Equality.prototype.compare = function(g1, g2) {
      if (g1.type !== g2.type || !sameLength(g1, g2)) return false;
      switch (g1.type) {
        case "Point":
          return this.compareCoord(g1.coordinates, g2.coordinates);
          break;
        case "LineString":
          return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
          break;
        case "Polygon":
          return this.comparePolygon(g1, g2);
          break;
        case "Feature":
          return this.compareFeature(g1, g2);
        default:
          if (g1.type.indexOf("Multi") === 0) {
            var context = this;
            var g1s = explode(g1);
            var g2s = explode(g2);
            return g1s.every(function(g1part) {
              return this.some(function(g2part) {
                return context.compare(g1part, g2part);
              });
            }, g2s);
          }
      }
      return false;
    };
    function explode(g) {
      return g.coordinates.map(function(part) {
        return {
          type: g.type.replace("Multi", ""),
          coordinates: part
        };
      });
    }
    function sameLength(g1, g2) {
      return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
    }
    Equality.prototype.compareCoord = function(c1, c2) {
      if (c1.length !== c2.length) {
        return false;
      }
      for (var i = 0; i < c1.length; i++) {
        if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
          return false;
        }
      }
      return true;
    };
    Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
      if (!sameLength(path1, path2)) return false;
      var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
      var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
      if (isPoly && !this.compareCoord(p1[0], p2[0])) {
        p2 = this.fixStartIndex(p2, p1);
        if (!p2) return;
      }
      var sameDirection = this.compareCoord(p1[ind], p2[ind]);
      if (this.direction || sameDirection) {
        return this.comparePath(p1, p2);
      } else {
        if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
          return this.comparePath(p1.slice().reverse(), p2);
        }
        return false;
      }
    };
    Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
      var correctPath, ind = -1;
      for (var i = 0; i < sourcePath.length; i++) {
        if (this.compareCoord(sourcePath[i], targetPath[0])) {
          ind = i;
          break;
        }
      }
      if (ind >= 0) {
        correctPath = [].concat(
          sourcePath.slice(ind, sourcePath.length),
          sourcePath.slice(1, ind + 1)
        );
      }
      return correctPath;
    };
    Equality.prototype.comparePath = function(p1, p2) {
      var cont = this;
      return p1.every(function(c, i) {
        return cont.compareCoord(c, this[i]);
      }, p2);
    };
    Equality.prototype.comparePolygon = function(g1, g2) {
      if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
        var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
        var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
        var cont = this;
        return holes1.every(function(h1) {
          return this.some(function(h2) {
            return cont.compareLine(h1, h2, 1, true);
          });
        }, holes2);
      } else {
        return false;
      }
    };
    Equality.prototype.compareFeature = function(g1, g2) {
      if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
        return false;
      }
      return this.compare(g1.geometry, g2.geometry);
    };
    Equality.prototype.compareBBox = function(g1, g2) {
      if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
        return true;
      }
      return false;
    };
    Equality.prototype.removePseudo = function(path) {
      return path;
    };
    function objectComparator(obj1, obj2) {
      return deepEqual(obj1, obj2, { strict: true });
    }
    module2.exports = Equality;
  }
});

// node_modules/@turf/boolean-overlap/dist/js/index.js
var require_js77 = __commonJS({
  "node_modules/@turf/boolean-overlap/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    var invariant_1 = require_js4();
    var line_overlap_1 = __importDefault(require_js61());
    var line_intersect_1 = __importDefault(require_js35());
    var geojson_equality_1 = __importDefault(require_geojson_equality());
    function booleanOverlap(feature1, feature2) {
      var geom1 = invariant_1.getGeom(feature1);
      var geom2 = invariant_1.getGeom(feature2);
      var type1 = geom1.type;
      var type2 = geom2.type;
      if (type1 === "MultiPoint" && type2 !== "MultiPoint" || (type1 === "LineString" || type1 === "MultiLineString") && type2 !== "LineString" && type2 !== "MultiLineString" || (type1 === "Polygon" || type1 === "MultiPolygon") && type2 !== "Polygon" && type2 !== "MultiPolygon") {
        throw new Error("features must be of the same type");
      }
      if (type1 === "Point")
        throw new Error("Point geometry not supported");
      var equality = new geojson_equality_1.default({ precision: 6 });
      if (equality.compare(feature1, feature2))
        return false;
      var overlap = 0;
      switch (type1) {
        case "MultiPoint":
          for (var i = 0; i < geom1.coordinates.length; i++) {
            for (var j = 0; j < geom2.coordinates.length; j++) {
              var coord1 = geom1.coordinates[i];
              var coord2 = geom2.coordinates[j];
              if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
                return true;
              }
            }
          }
          return false;
        case "LineString":
        case "MultiLineString":
          meta_1.segmentEach(feature1, function(segment1) {
            meta_1.segmentEach(feature2, function(segment2) {
              if (line_overlap_1.default(segment1, segment2).features.length)
                overlap++;
            });
          });
          break;
        case "Polygon":
        case "MultiPolygon":
          meta_1.segmentEach(feature1, function(segment1) {
            meta_1.segmentEach(feature2, function(segment2) {
              if (line_intersect_1.default(segment1, segment2).features.length)
                overlap++;
            });
          });
          break;
      }
      return overlap > 0;
    }
    exports2.default = booleanOverlap;
  }
});

// node_modules/@turf/boolean-equal/dist/js/index.js
var require_js78 = __commonJS({
  "node_modules/@turf/boolean-equal/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var geojson_equality_1 = __importDefault(require_geojson_equality());
    var clean_coords_1 = __importDefault(require_js15());
    var invariant_1 = require_js4();
    function booleanEqual(feature1, feature2) {
      var type1 = invariant_1.getGeom(feature1).type;
      var type2 = invariant_1.getGeom(feature2).type;
      if (type1 !== type2)
        return false;
      var equality = new geojson_equality_1.default({ precision: 6 });
      return equality.compare(clean_coords_1.default(feature1), clean_coords_1.default(feature2));
    }
    exports2.default = booleanEqual;
  }
});

// node_modules/@turf/boolean-intersects/dist/js/index.js
var require_js79 = __commonJS({
  "node_modules/@turf/boolean-intersects/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var boolean_disjoint_1 = __importDefault(require_js74());
    var meta_1 = require_js2();
    function booleanIntersects(feature1, feature2) {
      var bool = false;
      meta_1.flattenEach(feature1, function(flatten1) {
        meta_1.flattenEach(feature2, function(flatten2) {
          if (bool === true) {
            return true;
          }
          bool = !boolean_disjoint_1.default(flatten1.geometry, flatten2.geometry);
        });
      });
      return bool;
    }
    exports2.default = booleanIntersects;
  }
});

// node_modules/density-clustering/lib/DBSCAN.js
var require_DBSCAN = __commonJS({
  "node_modules/density-clustering/lib/DBSCAN.js"(exports2, module2) {
    function DBSCAN(dataset, epsilon, minPts, distanceFunction) {
      this.dataset = [];
      this.epsilon = 1;
      this.minPts = 2;
      this.distance = this._euclideanDistance;
      this.clusters = [];
      this.noise = [];
      this._visited = [];
      this._assigned = [];
      this._datasetLength = 0;
      this._init(dataset, epsilon, minPts, distanceFunction);
    }
    DBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
      this._init(dataset, epsilon, minPts, distanceFunction);
      for (var pointId = 0; pointId < this._datasetLength; pointId++) {
        if (this._visited[pointId] !== 1) {
          this._visited[pointId] = 1;
          var neighbors = this._regionQuery(pointId);
          if (neighbors.length < this.minPts) {
            this.noise.push(pointId);
          } else {
            var clusterId = this.clusters.length;
            this.clusters.push([]);
            this._addToCluster(pointId, clusterId);
            this._expandCluster(clusterId, neighbors);
          }
        }
      }
      return this.clusters;
    };
    DBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {
      if (dataset) {
        if (!(dataset instanceof Array)) {
          throw Error("Dataset must be of type array, " + typeof dataset + " given");
        }
        this.dataset = dataset;
        this.clusters = [];
        this.noise = [];
        this._datasetLength = dataset.length;
        this._visited = new Array(this._datasetLength);
        this._assigned = new Array(this._datasetLength);
      }
      if (epsilon) {
        this.epsilon = epsilon;
      }
      if (minPts) {
        this.minPts = minPts;
      }
      if (distance) {
        this.distance = distance;
      }
    };
    DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {
      for (var i = 0; i < neighbors.length; i++) {
        var pointId2 = neighbors[i];
        if (this._visited[pointId2] !== 1) {
          this._visited[pointId2] = 1;
          var neighbors2 = this._regionQuery(pointId2);
          if (neighbors2.length >= this.minPts) {
            neighbors = this._mergeArrays(neighbors, neighbors2);
          }
        }
        if (this._assigned[pointId2] !== 1) {
          this._addToCluster(pointId2, clusterId);
        }
      }
    };
    DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
      this.clusters[clusterId].push(pointId);
      this._assigned[pointId] = 1;
    };
    DBSCAN.prototype._regionQuery = function(pointId) {
      var neighbors = [];
      for (var id = 0; id < this._datasetLength; id++) {
        var dist = this.distance(this.dataset[pointId], this.dataset[id]);
        if (dist < this.epsilon) {
          neighbors.push(id);
        }
      }
      return neighbors;
    };
    DBSCAN.prototype._mergeArrays = function(a, b) {
      var len = b.length;
      for (var i = 0; i < len; i++) {
        var P = b[i];
        if (a.indexOf(P) < 0) {
          a.push(P);
        }
      }
      return a;
    };
    DBSCAN.prototype._euclideanDistance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);
      while (i--) {
        sum += (p[i] - q[i]) * (p[i] - q[i]);
      }
      return Math.sqrt(sum);
    };
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = DBSCAN;
    }
  }
});

// node_modules/density-clustering/lib/KMEANS.js
var require_KMEANS = __commonJS({
  "node_modules/density-clustering/lib/KMEANS.js"(exports2, module2) {
    function KMEANS(dataset, k, distance) {
      this.k = 3;
      this.dataset = [];
      this.assignments = [];
      this.centroids = [];
      this.init(dataset, k, distance);
    }
    KMEANS.prototype.init = function(dataset, k, distance) {
      this.assignments = [];
      this.centroids = [];
      if (typeof dataset !== "undefined") {
        this.dataset = dataset;
      }
      if (typeof k !== "undefined") {
        this.k = k;
      }
      if (typeof distance !== "undefined") {
        this.distance = distance;
      }
    };
    KMEANS.prototype.run = function(dataset, k) {
      this.init(dataset, k);
      var len = this.dataset.length;
      for (var i = 0; i < this.k; i++) {
        this.centroids[i] = this.randomCentroid();
      }
      var change = true;
      while (change) {
        change = this.assign();
        for (var centroidId = 0; centroidId < this.k; centroidId++) {
          var mean = new Array(maxDim);
          var count = 0;
          for (var dim = 0; dim < maxDim; dim++) {
            mean[dim] = 0;
          }
          for (var j = 0; j < len; j++) {
            var maxDim = this.dataset[j].length;
            if (centroidId === this.assignments[j]) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean[dim] += this.dataset[j][dim];
              }
              count++;
            }
          }
          if (count > 0) {
            for (var dim = 0; dim < maxDim; dim++) {
              mean[dim] /= count;
            }
            this.centroids[centroidId] = mean;
          } else {
            this.centroids[centroidId] = this.randomCentroid();
            change = true;
          }
        }
      }
      return this.getClusters();
    };
    KMEANS.prototype.randomCentroid = function() {
      var maxId = this.dataset.length - 1;
      var centroid;
      var id;
      do {
        id = Math.round(Math.random() * maxId);
        centroid = this.dataset[id];
      } while (this.centroids.indexOf(centroid) >= 0);
      return centroid;
    };
    KMEANS.prototype.assign = function() {
      var change = false;
      var len = this.dataset.length;
      var closestCentroid;
      for (var i = 0; i < len; i++) {
        closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
        if (closestCentroid != this.assignments[i]) {
          this.assignments[i] = closestCentroid;
          change = true;
        }
      }
      return change;
    };
    KMEANS.prototype.getClusters = function() {
      var clusters = new Array(this.k);
      var centroidId;
      for (var pointId = 0; pointId < this.assignments.length; pointId++) {
        centroidId = this.assignments[pointId];
        if (typeof clusters[centroidId] === "undefined") {
          clusters[centroidId] = [];
        }
        clusters[centroidId].push(pointId);
      }
      return clusters;
    };
    KMEANS.prototype.argmin = function(point, set, f) {
      var min = Number.MAX_VALUE;
      var arg = 0;
      var len = set.length;
      var d;
      for (var i = 0; i < len; i++) {
        d = f(point, set[i]);
        if (d < min) {
          min = d;
          arg = i;
        }
      }
      return arg;
    };
    KMEANS.prototype.distance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);
      while (i--) {
        var diff = p[i] - q[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    };
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = KMEANS;
    }
  }
});

// node_modules/density-clustering/lib/PriorityQueue.js
var require_PriorityQueue = __commonJS({
  "node_modules/density-clustering/lib/PriorityQueue.js"(exports2, module2) {
    function PriorityQueue(elements, priorities, sorting) {
      this._queue = [];
      this._priorities = [];
      this._sorting = "desc";
      this._init(elements, priorities, sorting);
    }
    PriorityQueue.prototype.insert = function(ele, priority) {
      var indexToInsert = this._queue.length;
      var index = indexToInsert;
      while (index--) {
        var priority2 = this._priorities[index];
        if (this._sorting === "desc") {
          if (priority > priority2) {
            indexToInsert = index;
          }
        } else {
          if (priority < priority2) {
            indexToInsert = index;
          }
        }
      }
      this._insertAt(ele, priority, indexToInsert);
    };
    PriorityQueue.prototype.remove = function(ele) {
      var index = this._queue.length;
      while (index--) {
        var ele2 = this._queue[index];
        if (ele === ele2) {
          this._queue.splice(index, 1);
          this._priorities.splice(index, 1);
          break;
        }
      }
    };
    PriorityQueue.prototype.forEach = function(func) {
      this._queue.forEach(func);
    };
    PriorityQueue.prototype.getElements = function() {
      return this._queue;
    };
    PriorityQueue.prototype.getElementPriority = function(index) {
      return this._priorities[index];
    };
    PriorityQueue.prototype.getPriorities = function() {
      return this._priorities;
    };
    PriorityQueue.prototype.getElementsWithPriorities = function() {
      var result2 = [];
      for (var i = 0, l = this._queue.length; i < l; i++) {
        result2.push([this._queue[i], this._priorities[i]]);
      }
      return result2;
    };
    PriorityQueue.prototype._init = function(elements, priorities, sorting) {
      if (elements && priorities) {
        this._queue = [];
        this._priorities = [];
        if (elements.length !== priorities.length) {
          throw new Error("Arrays must have the same length");
        }
        for (var i = 0; i < elements.length; i++) {
          this.insert(elements[i], priorities[i]);
        }
      }
      if (sorting) {
        this._sorting = sorting;
      }
    };
    PriorityQueue.prototype._insertAt = function(ele, priority, index) {
      if (this._queue.length === index) {
        this._queue.push(ele);
        this._priorities.push(priority);
      } else {
        this._queue.splice(index, 0, ele);
        this._priorities.splice(index, 0, priority);
      }
    };
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = PriorityQueue;
    }
  }
});

// node_modules/density-clustering/lib/OPTICS.js
var require_OPTICS = __commonJS({
  "node_modules/density-clustering/lib/OPTICS.js"(exports2, module2) {
    if (typeof module2 !== "undefined" && module2.exports) {
      PriorityQueue = require_PriorityQueue();
    }
    var PriorityQueue;
    function OPTICS(dataset, epsilon, minPts, distanceFunction) {
      this.epsilon = 1;
      this.minPts = 1;
      this.distance = this._euclideanDistance;
      this._reachability = [];
      this._processed = [];
      this._coreDistance = 0;
      this._orderedList = [];
      this._init(dataset, epsilon, minPts, distanceFunction);
    }
    OPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
      this._init(dataset, epsilon, minPts, distanceFunction);
      for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
        if (this._processed[pointId] !== 1) {
          this._processed[pointId] = 1;
          this.clusters.push([pointId]);
          var clusterId = this.clusters.length - 1;
          this._orderedList.push(pointId);
          var priorityQueue = new PriorityQueue(null, null, "asc");
          var neighbors = this._regionQuery(pointId);
          if (this._distanceToCore(pointId) !== void 0) {
            this._updateQueue(pointId, neighbors, priorityQueue);
            this._expandCluster(clusterId, priorityQueue);
          }
        }
      }
      return this.clusters;
    };
    OPTICS.prototype.getReachabilityPlot = function() {
      var reachabilityPlot = [];
      for (var i = 0, l = this._orderedList.length; i < l; i++) {
        var pointId = this._orderedList[i];
        var distance = this._reachability[pointId];
        reachabilityPlot.push([pointId, distance]);
      }
      return reachabilityPlot;
    };
    OPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {
      if (dataset) {
        if (!(dataset instanceof Array)) {
          throw Error("Dataset must be of type array, " + typeof dataset + " given");
        }
        this.dataset = dataset;
        this.clusters = [];
        this._reachability = new Array(this.dataset.length);
        this._processed = new Array(this.dataset.length);
        this._coreDistance = 0;
        this._orderedList = [];
      }
      if (epsilon) {
        this.epsilon = epsilon;
      }
      if (minPts) {
        this.minPts = minPts;
      }
      if (distance) {
        this.distance = distance;
      }
    };
    OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
      var self2 = this;
      this._coreDistance = this._distanceToCore(pointId);
      neighbors.forEach(function(pointId2) {
        if (self2._processed[pointId2] === void 0) {
          var dist = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
          var newReachableDistance = Math.max(self2._coreDistance, dist);
          if (self2._reachability[pointId2] === void 0) {
            self2._reachability[pointId2] = newReachableDistance;
            queue.insert(pointId2, newReachableDistance);
          } else {
            if (newReachableDistance < self2._reachability[pointId2]) {
              self2._reachability[pointId2] = newReachableDistance;
              queue.remove(pointId2);
              queue.insert(pointId2, newReachableDistance);
            }
          }
        }
      });
    };
    OPTICS.prototype._expandCluster = function(clusterId, queue) {
      var queueElements = queue.getElements();
      for (var p = 0, l = queueElements.length; p < l; p++) {
        var pointId = queueElements[p];
        if (this._processed[pointId] === void 0) {
          var neighbors = this._regionQuery(pointId);
          this._processed[pointId] = 1;
          this.clusters[clusterId].push(pointId);
          this._orderedList.push(pointId);
          if (this._distanceToCore(pointId) !== void 0) {
            this._updateQueue(pointId, neighbors, queue);
            this._expandCluster(clusterId, queue);
          }
        }
      }
    };
    OPTICS.prototype._distanceToCore = function(pointId) {
      var l = this.epsilon;
      for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
        var neighbors = this._regionQuery(pointId, coreDistCand);
        if (neighbors.length >= this.minPts) {
          return coreDistCand;
        }
      }
      return;
    };
    OPTICS.prototype._regionQuery = function(pointId, epsilon) {
      epsilon = epsilon || this.epsilon;
      var neighbors = [];
      for (var id = 0, l = this.dataset.length; id < l; id++) {
        if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {
          neighbors.push(id);
        }
      }
      return neighbors;
    };
    OPTICS.prototype._euclideanDistance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);
      while (i--) {
        sum += (p[i] - q[i]) * (p[i] - q[i]);
      }
      return Math.sqrt(sum);
    };
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = OPTICS;
    }
  }
});

// node_modules/density-clustering/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/density-clustering/lib/index.js"(exports2, module2) {
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = {
        DBSCAN: require_DBSCAN(),
        KMEANS: require_KMEANS(),
        OPTICS: require_OPTICS(),
        PriorityQueue: require_PriorityQueue()
      };
    }
  }
});

// node_modules/@turf/clusters-dbscan/dist/js/index.js
var require_js80 = __commonJS({
  "node_modules/@turf/clusters-dbscan/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var clone_1 = __importDefault(require_js11());
    var distance_1 = __importDefault(require_js9());
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    var density_clustering_1 = __importDefault(require_lib9());
    function clustersDbscan(points, maxDistance, options) {
      if (options === void 0) {
        options = {};
      }
      if (options.mutate !== true)
        points = clone_1.default(points);
      options.minPoints = options.minPoints || 3;
      var dbscan = new density_clustering_1.default.DBSCAN();
      var clusteredIds = dbscan.run(meta_1.coordAll(points), helpers_1.convertLength(maxDistance, options.units), options.minPoints, distance_1.default);
      var clusterId = -1;
      clusteredIds.forEach(function(clusterIds) {
        clusterId++;
        clusterIds.forEach(function(idx) {
          var clusterPoint = points.features[idx];
          if (!clusterPoint.properties)
            clusterPoint.properties = {};
          clusterPoint.properties.cluster = clusterId;
          clusterPoint.properties.dbscan = "core";
        });
      });
      dbscan.noise.forEach(function(noiseId) {
        var noisePoint = points.features[noiseId];
        if (!noisePoint.properties)
          noisePoint.properties = {};
        if (noisePoint.properties.cluster)
          noisePoint.properties.dbscan = "edge";
        else
          noisePoint.properties.dbscan = "noise";
      });
      return points;
    }
    exports2.default = clustersDbscan;
  }
});

// node_modules/skmeans/dist/node/distance.js
var require_distance = __commonJS({
  "node_modules/skmeans/dist/node/distance.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * Euclidean distance
       */
      eudist: function eudist(v12, v2, sqrt) {
        var len = v12.length;
        var sum = 0;
        for (var i = 0; i < len; i++) {
          var d = (v12[i] || 0) - (v2[i] || 0);
          sum += d * d;
        }
        return sqrt ? Math.sqrt(sum) : sum;
      },
      mandist: function mandist(v12, v2, sqrt) {
        var len = v12.length;
        var sum = 0;
        for (var i = 0; i < len; i++) {
          sum += Math.abs((v12[i] || 0) - (v2[i] || 0));
        }
        return sqrt ? Math.sqrt(sum) : sum;
      },
      /**
       * Unidimensional distance
       */
      dist: function dist(v12, v2, sqrt) {
        var d = Math.abs(v12 - v2);
        return sqrt ? d : d * d;
      }
    };
  }
});

// node_modules/skmeans/dist/node/kinit.js
var require_kinit = __commonJS({
  "node_modules/skmeans/dist/node/kinit.js"(exports2, module2) {
    "use strict";
    var Distance = require_distance();
    var eudist = Distance.eudist;
    var dist = Distance.dist;
    module2.exports = {
      kmrand: function kmrand(data, k) {
        var map2 = {}, ks = [], t = k << 2;
        var len = data.length;
        var multi = data[0].length > 0;
        while (ks.length < k && t-- > 0) {
          var d = data[Math.floor(Math.random() * len)];
          var key = multi ? d.join("_") : "" + d;
          if (!map2[key]) {
            map2[key] = true;
            ks.push(d);
          }
        }
        if (ks.length < k) throw new Error("Error initializating clusters");
        else return ks;
      },
      /**
       * K-means++ initial centroid selection
       */
      kmpp: function kmpp(data, k) {
        var distance = data[0].length ? eudist : dist;
        var ks = [], len = data.length;
        var multi = data[0].length > 0;
        var map2 = {};
        var c = data[Math.floor(Math.random() * len)];
        var key = multi ? c.join("_") : "" + c;
        ks.push(c);
        map2[key] = true;
        while (ks.length < k) {
          var dists = [], lk = ks.length;
          var dsum = 0, prs = [];
          for (var i = 0; i < len; i++) {
            var min = Infinity;
            for (var j = 0; j < lk; j++) {
              var _dist = distance(data[i], ks[j]);
              if (_dist <= min) min = _dist;
            }
            dists[i] = min;
          }
          for (var _i = 0; _i < len; _i++) {
            dsum += dists[_i];
          }
          for (var _i2 = 0; _i2 < len; _i2++) {
            prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
          }
          prs.sort(function(a, b) {
            return a.pr - b.pr;
          });
          prs[0].cs = prs[0].pr;
          for (var _i3 = 1; _i3 < len; _i3++) {
            prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
          }
          var rnd = Math.random();
          var idx = 0;
          while (idx < len - 1 && prs[idx++].cs < rnd) {
          }
          ks.push(prs[idx - 1].v);
        }
        return ks;
      }
    };
  }
});

// node_modules/skmeans/dist/node/main.js
var require_main3 = __commonJS({
  "node_modules/skmeans/dist/node/main.js"(exports2, module2) {
    "use strict";
    var Distance = require_distance();
    var ClusterInit = require_kinit();
    var eudist = Distance.eudist;
    var mandist = Distance.mandist;
    var dist = Distance.dist;
    var kmrand = ClusterInit.kmrand;
    var kmpp = ClusterInit.kmpp;
    var MAX = 1e4;
    function init(len, val, v) {
      v = v || [];
      for (var i = 0; i < len; i++) {
        v[i] = val;
      }
      return v;
    }
    function skmeans(data, k, initial, maxit) {
      var ks = [], old = [], idxs = [], dist2 = [];
      var conv = false, it = maxit || MAX;
      var len = data.length, vlen = data[0].length, multi = vlen > 0;
      var count = [];
      if (!initial) {
        var _idxs = {};
        while (ks.length < k) {
          var idx = Math.floor(Math.random() * len);
          if (!_idxs[idx]) {
            _idxs[idx] = true;
            ks.push(data[idx]);
          }
        }
      } else if (initial == "kmrand") {
        ks = kmrand(data, k);
      } else if (initial == "kmpp") {
        ks = kmpp(data, k);
      } else {
        ks = initial;
      }
      do {
        init(k, 0, count);
        for (var i = 0; i < len; i++) {
          var min = Infinity, _idx = 0;
          for (var j = 0; j < k; j++) {
            var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
            if (dist2 <= min) {
              min = dist2;
              _idx = j;
            }
          }
          idxs[i] = _idx;
          count[_idx]++;
        }
        var sum = [], old = [], dif = 0;
        for (var _j = 0; _j < k; _j++) {
          sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;
          old[_j] = ks[_j];
        }
        if (multi) {
          for (var _j2 = 0; _j2 < k; _j2++) {
            ks[_j2] = [];
          }
          for (var _i = 0; _i < len; _i++) {
            var _idx2 = idxs[_i], vsum = sum[_idx2], vect = data[_i];
            for (var h = 0; h < vlen; h++) {
              vsum[h] += vect[h];
            }
          }
          conv = true;
          for (var _j3 = 0; _j3 < k; _j3++) {
            var ksj = ks[_j3], sumj = sum[_j3], oldj = old[_j3], cj = count[_j3];
            for (var _h = 0; _h < vlen; _h++) {
              ksj[_h] = sumj[_h] / cj || 0;
            }
            if (conv) {
              for (var _h2 = 0; _h2 < vlen; _h2++) {
                if (oldj[_h2] != ksj[_h2]) {
                  conv = false;
                  break;
                }
              }
            }
          }
        } else {
          for (var _i2 = 0; _i2 < len; _i2++) {
            var _idx3 = idxs[_i2];
            sum[_idx3] += data[_i2];
          }
          for (var _j4 = 0; _j4 < k; _j4++) {
            ks[_j4] = sum[_j4] / count[_j4] || 0;
          }
          conv = true;
          for (var _j5 = 0; _j5 < k; _j5++) {
            if (old[_j5] != ks[_j5]) {
              conv = false;
              break;
            }
          }
        }
        conv = conv || --it <= 0;
      } while (!conv);
      return {
        it: MAX - it,
        k,
        idxs,
        centroids: ks
      };
    }
    module2.exports = skmeans;
  }
});

// node_modules/@turf/clusters-kmeans/dist/js/index.js
var require_js81 = __commonJS({
  "node_modules/@turf/clusters-kmeans/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var clone_1 = __importDefault(require_js11());
    var meta_1 = require_js2();
    var skmeans_1 = __importDefault(require_main3());
    function clustersKmeans(points, options) {
      if (options === void 0) {
        options = {};
      }
      var count = points.features.length;
      options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2));
      if (options.numberOfClusters > count)
        options.numberOfClusters = count;
      if (options.mutate !== true)
        points = clone_1.default(points);
      var data = meta_1.coordAll(points);
      var initialCentroids = data.slice(0, options.numberOfClusters);
      var skmeansResult = skmeans_1.default(data, options.numberOfClusters, initialCentroids);
      var centroids = {};
      skmeansResult.centroids.forEach(function(coord, idx) {
        centroids[idx] = coord;
      });
      meta_1.featureEach(points, function(point, index) {
        var clusterId = skmeansResult.idxs[index];
        point.properties.cluster = clusterId;
        point.properties.centroid = centroids[clusterId];
      });
      return points;
    }
    exports2.default = clustersKmeans;
  }
});

// node_modules/@turf/boolean-parallel/dist/js/index.js
var require_js82 = __commonJS({
  "node_modules/@turf/boolean-parallel/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var clean_coords_1 = __importDefault(require_js15());
    var line_segment_1 = __importDefault(require_js34());
    var rhumb_bearing_1 = __importDefault(require_js63());
    var helpers_1 = require_js();
    function booleanParallel(line1, line2) {
      if (!line1)
        throw new Error("line1 is required");
      if (!line2)
        throw new Error("line2 is required");
      var type1 = getType(line1, "line1");
      if (type1 !== "LineString")
        throw new Error("line1 must be a LineString");
      var type2 = getType(line2, "line2");
      if (type2 !== "LineString")
        throw new Error("line2 must be a LineString");
      var segments1 = line_segment_1.default(clean_coords_1.default(line1)).features;
      var segments2 = line_segment_1.default(clean_coords_1.default(line2)).features;
      for (var i = 0; i < segments1.length; i++) {
        var segment1 = segments1[i].geometry.coordinates;
        if (!segments2[i])
          break;
        var segment2 = segments2[i].geometry.coordinates;
        if (!isParallel(segment1, segment2))
          return false;
      }
      return true;
    }
    function isParallel(segment1, segment2) {
      var slope1 = helpers_1.bearingToAzimuth(rhumb_bearing_1.default(segment1[0], segment1[1]));
      var slope2 = helpers_1.bearingToAzimuth(rhumb_bearing_1.default(segment2[0], segment2[1]));
      return slope1 === slope2;
    }
    function getType(geojson, name) {
      if (geojson.geometry && geojson.geometry.type)
        return geojson.geometry.type;
      if (geojson.type)
        return geojson.type;
      throw new Error("Invalid GeoJSON object for " + name);
    }
    exports2.default = booleanParallel;
  }
});

// node_modules/@turf/shortest-path/dist/js/index.js
var require_js83 = __commonJS({
  "node_modules/@turf/shortest-path/dist/js/index.js"(exports2, module2) {
    "use strict";
    var bbox = require_js3();
    var booleanPointInPolygon = require_js7();
    var distance = require_js9();
    var scale = require_js70();
    var cleanCoords = require_js15();
    var bboxPolygon = require_js20();
    var invariant = require_js4();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bbox__default = /* @__PURE__ */ _interopDefaultLegacy(bbox);
    var booleanPointInPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(booleanPointInPolygon);
    var distance__default = /* @__PURE__ */ _interopDefaultLegacy(distance);
    var scale__default = /* @__PURE__ */ _interopDefaultLegacy(scale);
    var cleanCoords__default = /* @__PURE__ */ _interopDefaultLegacy(cleanCoords);
    var bboxPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(bboxPolygon);
    function pathTo(node) {
      var curr = node, path = [];
      while (curr.parent) {
        path.unshift(curr);
        curr = curr.parent;
      }
      return path;
    }
    function getHeap() {
      return new BinaryHeap(function(node) {
        return node.f;
      });
    }
    var astar = {
      /**
       * Perform an A* Search on a graph given a start and end node.
       *
       * @private
       * @memberof astar
       * @param {Graph} graph Graph
       * @param {GridNode} start Start
       * @param {GridNode} end End
       * @param {Object} [options] Options
       * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
       * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
       * @returns {Object} Search
       */
      search: function(graph, start, end, options) {
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
        var openHeap = getHeap(), closestNode = start;
        start.h = heuristic(start, end);
        openHeap.push(start);
        while (openHeap.size() > 0) {
          var currentNode = openHeap.pop();
          if (currentNode === end) {
            return pathTo(currentNode);
          }
          currentNode.closed = true;
          var neighbors = graph.neighbors(currentNode);
          for (var i = 0, il = neighbors.length; i < il; ++i) {
            var neighbor = neighbors[i];
            if (neighbor.closed || neighbor.isWall()) {
              continue;
            }
            var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
            if (!beenVisited || gScore < neighbor.g) {
              neighbor.visited = true;
              neighbor.parent = currentNode;
              neighbor.h = neighbor.h || heuristic(neighbor, end);
              neighbor.g = gScore;
              neighbor.f = neighbor.g + neighbor.h;
              graph.markDirty(neighbor);
              if (closest) {
                if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                  closestNode = neighbor;
                }
              }
              if (!beenVisited) {
                openHeap.push(neighbor);
              } else {
                openHeap.rescoreElement(neighbor);
              }
            }
          }
        }
        if (closest) {
          return pathTo(closestNode);
        }
        return [];
      },
      // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
      heuristics: {
        manhattan: function(pos0, pos1) {
          var d1 = Math.abs(pos1.x - pos0.x);
          var d2 = Math.abs(pos1.y - pos0.y);
          return d1 + d2;
        },
        diagonal: function(pos0, pos1) {
          var D = 1;
          var D2 = Math.sqrt(2);
          var d1 = Math.abs(pos1.x - pos0.x);
          var d2 = Math.abs(pos1.y - pos0.y);
          return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
        }
      },
      cleanNode: function(node) {
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
      }
    };
    function Graph(gridIn, options) {
      options = options || {};
      this.nodes = [];
      this.diagonal = !!options.diagonal;
      this.grid = [];
      for (var x = 0; x < gridIn.length; x++) {
        this.grid[x] = [];
        for (var y = 0, row = gridIn[x]; y < row.length; y++) {
          var node = new GridNode(x, y, row[y]);
          this.grid[x][y] = node;
          this.nodes.push(node);
        }
      }
      this.init();
    }
    Graph.prototype.init = function() {
      this.dirtyNodes = [];
      for (var i = 0; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
      }
    };
    Graph.prototype.cleanDirty = function() {
      for (var i = 0; i < this.dirtyNodes.length; i++) {
        astar.cleanNode(this.dirtyNodes[i]);
      }
      this.dirtyNodes = [];
    };
    Graph.prototype.markDirty = function(node) {
      this.dirtyNodes.push(node);
    };
    Graph.prototype.neighbors = function(node) {
      var ret = [], x = node.x, y = node.y, grid = this.grid;
      if (grid[x - 1] && grid[x - 1][y]) {
        ret.push(grid[x - 1][y]);
      }
      if (grid[x + 1] && grid[x + 1][y]) {
        ret.push(grid[x + 1][y]);
      }
      if (grid[x] && grid[x][y - 1]) {
        ret.push(grid[x][y - 1]);
      }
      if (grid[x] && grid[x][y + 1]) {
        ret.push(grid[x][y + 1]);
      }
      if (this.diagonal) {
        if (grid[x - 1] && grid[x - 1][y - 1]) {
          ret.push(grid[x - 1][y - 1]);
        }
        if (grid[x + 1] && grid[x + 1][y - 1]) {
          ret.push(grid[x + 1][y - 1]);
        }
        if (grid[x - 1] && grid[x - 1][y + 1]) {
          ret.push(grid[x - 1][y + 1]);
        }
        if (grid[x + 1] && grid[x + 1][y + 1]) {
          ret.push(grid[x + 1][y + 1]);
        }
      }
      return ret;
    };
    Graph.prototype.toString = function() {
      var graphString = [], nodes = this.grid, rowDebug, row, y, l;
      for (var x = 0, len = nodes.length; x < len; x++) {
        rowDebug = [];
        row = nodes[x];
        for (y = 0, l = row.length; y < l; y++) {
          rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(" "));
      }
      return graphString.join("\n");
    };
    function GridNode(x, y, weight) {
      this.x = x;
      this.y = y;
      this.weight = weight;
    }
    GridNode.prototype.toString = function() {
      return "[" + this.x + " " + this.y + "]";
    };
    GridNode.prototype.getCost = function(fromNeighbor) {
      if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
      }
      return this.weight;
    };
    GridNode.prototype.isWall = function() {
      return this.weight === 0;
    };
    function BinaryHeap(scoreFunction) {
      this.content = [];
      this.scoreFunction = scoreFunction;
    }
    BinaryHeap.prototype = {
      push: function(element) {
        this.content.push(element);
        this.sinkDown(this.content.length - 1);
      },
      pop: function() {
        var result2 = this.content[0];
        var end = this.content.pop();
        if (this.content.length > 0) {
          this.content[0] = end;
          this.bubbleUp(0);
        }
        return result2;
      },
      remove: function(node) {
        var i = this.content.indexOf(node);
        var end = this.content.pop();
        if (i !== this.content.length - 1) {
          this.content[i] = end;
          if (this.scoreFunction(end) < this.scoreFunction(node)) {
            this.sinkDown(i);
          } else {
            this.bubbleUp(i);
          }
        }
      },
      size: function() {
        return this.content.length;
      },
      rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
      },
      sinkDown: function(n) {
        var element = this.content[n];
        while (n > 0) {
          var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
          if (this.scoreFunction(element) < this.scoreFunction(parent)) {
            this.content[parentN] = element;
            this.content[n] = parent;
            n = parentN;
          } else {
            break;
          }
        }
      },
      bubbleUp: function(n) {
        var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
        while (true) {
          var child2N = n + 1 << 1, child1N = child2N - 1;
          var swap = null, child1Score;
          if (child1N < length) {
            var child1 = this.content[child1N];
            child1Score = this.scoreFunction(child1);
            if (child1Score < elemScore) {
              swap = child1N;
            }
          }
          if (child2N < length) {
            var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
            if (child2Score < (swap === null ? elemScore : child1Score)) {
              swap = child2N;
            }
          }
          if (swap !== null) {
            this.content[n] = this.content[swap];
            this.content[swap] = element;
            n = swap;
          } else {
            break;
          }
        }
      }
    };
    function shortestPath(start, end, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var resolution = options.resolution;
      var minDistance = options.minDistance;
      var obstacles = options.obstacles || helpers.featureCollection([]);
      if (!start) throw new Error("start is required");
      if (!end) throw new Error("end is required");
      if (resolution && !helpers.isNumber(resolution) || resolution <= 0)
        throw new Error("options.resolution must be a number, greater than 0");
      if (minDistance)
        throw new Error("options.minDistance is not yet implemented");
      var startCoord = invariant.getCoord(start);
      var endCoord = invariant.getCoord(end);
      start = helpers.point(startCoord);
      end = helpers.point(endCoord);
      switch (invariant.getType(obstacles)) {
        case "FeatureCollection":
          if (obstacles.features.length === 0)
            return helpers.lineString([startCoord, endCoord]);
          break;
        case "Polygon":
          obstacles = helpers.featureCollection([helpers.feature(invariant.getGeom(obstacles))]);
          break;
        default:
          throw new Error("invalid obstacles");
      }
      var collection = obstacles;
      collection.features.push(start);
      collection.features.push(end);
      var box = bbox__default["default"](scale__default["default"](bboxPolygon__default["default"](bbox__default["default"](collection)), 1.15));
      if (!resolution) {
        var width = distance__default["default"]([box[0], box[1]], [box[2], box[1]], options);
        resolution = width / 100;
      }
      collection.features.pop();
      collection.features.pop();
      var west = box[0];
      var south = box[1];
      var east = box[2];
      var north = box[3];
      var xFraction = resolution / distance__default["default"]([west, south], [east, south], options);
      var cellWidth = xFraction * (east - west);
      var yFraction = resolution / distance__default["default"]([west, south], [west, north], options);
      var cellHeight = yFraction * (north - south);
      var bboxHorizontalSide = east - west;
      var bboxVerticalSide = north - south;
      var columns = Math.floor(bboxHorizontalSide / cellWidth);
      var rows = Math.floor(bboxVerticalSide / cellHeight);
      var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
      var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;
      var pointMatrix = [];
      var matrix = [];
      var closestToStart = [];
      var closestToEnd = [];
      var minDistStart = Infinity;
      var minDistEnd = Infinity;
      var currentY = north - deltaY;
      var r = 0;
      while (currentY >= south) {
        var matrixRow = [];
        var pointMatrixRow = [];
        var currentX = west + deltaX;
        var c = 0;
        while (currentX <= east) {
          var pt = helpers.point([currentX, currentY]);
          var isInsideObstacle = isInside(pt, obstacles);
          matrixRow.push(isInsideObstacle ? 0 : 1);
          pointMatrixRow.push(currentX + "|" + currentY);
          var distStart = distance__default["default"](pt, start);
          if (!isInsideObstacle && distStart < minDistStart) {
            minDistStart = distStart;
            closestToStart = { x: c, y: r };
          }
          var distEnd = distance__default["default"](pt, end);
          if (!isInsideObstacle && distEnd < minDistEnd) {
            minDistEnd = distEnd;
            closestToEnd = { x: c, y: r };
          }
          currentX += cellWidth;
          c++;
        }
        matrix.push(matrixRow);
        pointMatrix.push(pointMatrixRow);
        currentY -= cellHeight;
        r++;
      }
      var graph = new Graph(matrix, { diagonal: true });
      var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
      var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
      var result2 = astar.search(graph, startOnMatrix, endOnMatrix);
      var path = [startCoord];
      result2.forEach(function(coord) {
        var coords = pointMatrix[coord.x][coord.y].split("|");
        path.push([+coords[0], +coords[1]]);
      });
      path.push(endCoord);
      return cleanCoords__default["default"](helpers.lineString(path));
    }
    function isInside(pt, polygons) {
      for (var i = 0; i < polygons.features.length; i++) {
        if (booleanPointInPolygon__default["default"](pt, polygons.features[i])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = shortestPath;
    module2.exports.default = shortestPath;
  }
});

// node_modules/d3-voronoi/build/d3-voronoi.js
var require_d3_voronoi = __commonJS({
  "node_modules/d3-voronoi/build/d3-voronoi.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
    })(exports2, function(exports3) {
      "use strict";
      var constant = function(x2) {
        return function() {
          return x2;
        };
      };
      function x(d) {
        return d[0];
      }
      function y(d) {
        return d[1];
      }
      function RedBlackTree() {
        this._ = null;
      }
      function RedBlackNode(node) {
        node.U = // parent node
        node.C = // color - true for red, false for black
        node.L = // left node
        node.R = // right node
        node.P = // previous node
        node.N = null;
      }
      RedBlackTree.prototype = {
        constructor: RedBlackTree,
        insert: function(after, node) {
          var parent, grandpa, uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N) after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L) after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = RedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  RedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                RedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  RedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                RedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function(node) {
          if (node.N) node.N.P = node.P;
          if (node.P) node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U, sibling, left = node.L, right = node.R, next, red;
          if (!left) next = right;
          else if (!right) next = left;
          else next = RedBlackFirst(right);
          if (parent) {
            if (parent.L === node) parent.L = next;
            else parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node) node.U = parent;
          if (red) return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._) break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                RedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  RedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                RedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                RedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  RedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                RedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node) node.C = false;
        }
      };
      function RedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;
          else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
      }
      function RedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;
          else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
      }
      function RedBlackFirst(node) {
        while (node.L) node = node.L;
        return node;
      }
      function createEdge(left, right, v0, v12) {
        var edge = [null, null], index = edges.push(edge) - 1;
        edge.left = left;
        edge.right = right;
        if (v0) setEdgeEnd(edge, left, right, v0);
        if (v12) setEdgeEnd(edge, right, left, v12);
        cells[left.index].halfedges.push(index);
        cells[right.index].halfedges.push(index);
        return edge;
      }
      function createBorderEdge(left, v0, v12) {
        var edge = [v0, v12];
        edge.left = left;
        return edge;
      }
      function setEdgeEnd(edge, left, right, vertex) {
        if (!edge[0] && !edge[1]) {
          edge[0] = vertex;
          edge.left = left;
          edge.right = right;
        } else if (edge.left === right) {
          edge[1] = vertex;
        } else {
          edge[0] = vertex;
        }
      }
      function clipEdge(edge, x0, y0, x1, y1) {
        var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
        r = x0 - ax;
        if (!dx && r > 0) return;
        r /= dx;
        if (dx < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dx > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = x1 - ax;
        if (!dx && r < 0) return;
        r /= dx;
        if (dx < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dx > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        r = y0 - ay;
        if (!dy && r > 0) return;
        r /= dy;
        if (dy < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dy > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = y1 - ay;
        if (!dy && r < 0) return;
        r /= dy;
        if (dy < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dy > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        if (!(t0 > 0) && !(t1 < 1)) return true;
        if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
        if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
        return true;
      }
      function connectEdge(edge, x0, y0, x1, y1) {
        var v12 = edge[1];
        if (v12) return true;
        var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1) return;
          if (lx > rx) {
            if (!v0) v0 = [fx, y0];
            else if (v0[1] >= y1) return;
            v12 = [fx, y1];
          } else {
            if (!v0) v0 = [fx, y1];
            else if (v0[1] < y0) return;
            v12 = [fx, y0];
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!v0) v0 = [(y0 - fb) / fm, y0];
              else if (v0[1] >= y1) return;
              v12 = [(y1 - fb) / fm, y1];
            } else {
              if (!v0) v0 = [(y1 - fb) / fm, y1];
              else if (v0[1] < y0) return;
              v12 = [(y0 - fb) / fm, y0];
            }
          } else {
            if (ly < ry) {
              if (!v0) v0 = [x0, fm * x0 + fb];
              else if (v0[0] >= x1) return;
              v12 = [x1, fm * x1 + fb];
            } else {
              if (!v0) v0 = [x1, fm * x1 + fb];
              else if (v0[0] < x0) return;
              v12 = [x0, fm * x0 + fb];
            }
          }
        }
        edge[0] = v0;
        edge[1] = v12;
        return true;
      }
      function clipEdges(x0, y0, x1, y1) {
        var i = edges.length, edge;
        while (i--) {
          if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
            delete edges[i];
          }
        }
      }
      function createCell(site) {
        return cells[site.index] = {
          site,
          halfedges: []
        };
      }
      function cellHalfedgeAngle(cell, edge) {
        var site = cell.site, va = edge.left, vb = edge.right;
        if (site === vb) vb = va, va = site;
        if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
        if (site === va) va = edge[1], vb = edge[0];
        else va = edge[0], vb = edge[1];
        return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
      }
      function cellHalfedgeStart(cell, edge) {
        return edge[+(edge.left !== cell.site)];
      }
      function cellHalfedgeEnd(cell, edge) {
        return edge[+(edge.left === cell.site)];
      }
      function sortCellHalfedges() {
        for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
          if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
            var index = new Array(m), array = new Array(m);
            for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
            index.sort(function(i2, j2) {
              return array[j2] - array[i2];
            });
            for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
            for (j = 0; j < m; ++j) halfedges[j] = array[j];
          }
        }
      }
      function clipCells(x0, y0, x1, y1) {
        var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
        for (iCell = 0; iCell < nCells; ++iCell) {
          if (cell = cells[iCell]) {
            site = cell.site;
            halfedges = cell.halfedges;
            iHalfedge = halfedges.length;
            while (iHalfedge--) {
              if (!edges[halfedges[iHalfedge]]) {
                halfedges.splice(iHalfedge, 1);
              }
            }
            iHalfedge = 0, nHalfedges = halfedges.length;
            while (iHalfedge < nHalfedges) {
              end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
              start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
              if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
                halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
                  site,
                  end,
                  Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1] : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0] : null
                )) - 1);
                ++nHalfedges;
              }
            }
            if (nHalfedges) cover = false;
          }
        }
        if (cover) {
          var dx, dy, d2, dc = Infinity;
          for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
            if (cell = cells[iCell]) {
              site = cell.site;
              dx = site[0] - x0;
              dy = site[1] - y0;
              d2 = dx * dx + dy * dy;
              if (d2 < dc) dc = d2, cover = cell;
            }
          }
          if (cover) {
            var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
            cover.halfedges.push(
              edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
              edges.push(createBorderEdge(site, v01, v11)) - 1,
              edges.push(createBorderEdge(site, v11, v10)) - 1,
              edges.push(createBorderEdge(site, v10, v00)) - 1
            );
          }
        }
        for (iCell = 0; iCell < nCells; ++iCell) {
          if (cell = cells[iCell]) {
            if (!cell.halfedges.length) {
              delete cells[iCell];
            }
          }
        }
      }
      var circlePool = [];
      var firstCircle;
      function Circle() {
        RedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function attachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -epsilon2) return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
        var circle = circlePool.pop() || new Circle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x2 + bx;
        circle.y = (circle.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
        arc.circle = circle;
        var before = null, node = circles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L) node = node.L;
            else {
              before = node.P;
              break;
            }
          } else {
            if (node.R) node = node.R;
            else {
              before = node;
              break;
            }
          }
        }
        circles.insert(before, circle);
        if (!before) firstCircle = circle;
      }
      function detachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P) firstCircle = circle.N;
          circles.remove(circle);
          circlePool.push(circle);
          RedBlackNode(circle);
          arc.circle = null;
        }
      }
      var beachPool = [];
      function Beach() {
        RedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function createBeach(site) {
        var beach = beachPool.pop() || new Beach();
        beach.site = site;
        return beach;
      }
      function detachBeach(beach) {
        detachCircle(beach);
        beaches.remove(beach);
        beachPool.push(beach);
        RedBlackNode(beach);
      }
      function removeBeach(beach) {
        var circle = beach.circle, x2 = circle.x, y2 = circle.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
        detachBeach(beach);
        var lArc = previous;
        while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          detachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        detachCircle(lArc);
        var rArc = next;
        while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
          next = rArc.N;
          disappearing.push(rArc);
          detachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        detachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
        attachCircle(lArc);
        attachCircle(rArc);
      }
      function addBeach(site) {
        var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
        while (node) {
          dxl = leftBreakPoint(node, directrix) - x2;
          if (dxl > epsilon) node = node.L;
          else {
            dxr = x2 - rightBreakPoint(node, directrix);
            if (dxr > epsilon) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -epsilon) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -epsilon) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        createCell(site);
        var newArc = createBeach(site);
        beaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
          detachCircle(lArc);
          rArc = createBeach(lArc.site);
          beaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
          attachCircle(lArc);
          attachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = createEdge(lArc.site, newArc.site);
          return;
        }
        detachCircle(lArc);
        detachCircle(rArc);
        var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
        setEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = createEdge(lSite, site, null, vertex);
        rArc.edge = createEdge(site, rSite, null, vertex);
        attachCircle(lArc);
        attachCircle(rArc);
      }
      function leftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function rightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return leftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site[1] === directrix ? site[0] : Infinity;
      }
      var epsilon = 1e-6;
      var epsilon2 = 1e-12;
      var beaches;
      var cells;
      var circles;
      var edges;
      function triangleArea(a, b, c) {
        return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
      }
      function lexicographic(a, b) {
        return b[1] - a[1] || b[0] - a[0];
      }
      function Diagram(sites, extent) {
        var site = sites.sort(lexicographic).pop(), x2, y2, circle;
        edges = [];
        cells = new Array(sites.length);
        beaches = new RedBlackTree();
        circles = new RedBlackTree();
        while (true) {
          circle = firstCircle;
          if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
            if (site[0] !== x2 || site[1] !== y2) {
              addBeach(site);
              x2 = site[0], y2 = site[1];
            }
            site = sites.pop();
          } else if (circle) {
            removeBeach(circle.arc);
          } else {
            break;
          }
        }
        sortCellHalfedges();
        if (extent) {
          var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];
          clipEdges(x0, y0, x1, y1);
          clipCells(x0, y0, x1, y1);
        }
        this.edges = edges;
        this.cells = cells;
        beaches = circles = edges = cells = null;
      }
      Diagram.prototype = {
        constructor: Diagram,
        polygons: function() {
          var edges2 = this.edges;
          return this.cells.map(function(cell) {
            var polygon = cell.halfedges.map(function(i) {
              return cellHalfedgeStart(cell, edges2[i]);
            });
            polygon.data = cell.site.data;
            return polygon;
          });
        },
        triangles: function() {
          var triangles = [], edges2 = this.edges;
          this.cells.forEach(function(cell, i) {
            if (!(m = (halfedges = cell.halfedges).length)) return;
            var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
            while (++j < m) {
              s0 = s1;
              e1 = edges2[halfedges[j]];
              s1 = e1.left === site ? e1.right : e1.left;
              if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
                triangles.push([site.data, s0.data, s1.data]);
              }
            }
          });
          return triangles;
        },
        links: function() {
          return this.edges.filter(function(edge) {
            return edge.right;
          }).map(function(edge) {
            return {
              source: edge.left.data,
              target: edge.right.data
            };
          });
        },
        find: function(x2, y2, radius) {
          var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
          while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
          var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
          do {
            cell = that.cells[i0 = i1], i1 = null;
            cell.halfedges.forEach(function(e) {
              var edge = that.edges[e], v = edge.left;
              if ((v === cell.site || !v) && !(v = edge.right)) return;
              var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
              if (v2 < d2) d2 = v2, i1 = v.index;
            });
          } while (i1 !== null);
          that._found = i0;
          return radius == null || d2 <= radius * radius ? cell.site : null;
        }
      };
      var voronoi = function() {
        var x$$1 = x, y$$1 = y, extent = null;
        function voronoi2(data) {
          return new Diagram(data.map(function(d, i) {
            var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
            s.index = i;
            s.data = d;
            return s;
          }), extent);
        }
        voronoi2.polygons = function(data) {
          return voronoi2(data).polygons();
        };
        voronoi2.links = function(data) {
          return voronoi2(data).links();
        };
        voronoi2.triangles = function(data) {
          return voronoi2(data).triangles();
        };
        voronoi2.x = function(_) {
          return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : x$$1;
        };
        voronoi2.y = function(_) {
          return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : y$$1;
        };
        voronoi2.extent = function(_) {
          return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi2) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
        };
        voronoi2.size = function(_) {
          return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi2) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
        };
        return voronoi2;
      };
      exports3.voronoi = voronoi;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@turf/voronoi/dist/js/index.js
var require_js84 = __commonJS({
  "node_modules/@turf/voronoi/dist/js/index.js"(exports2, module2) {
    "use strict";
    var helpers = require_js();
    var invariant = require_js4();
    var d3voronoi = require_d3_voronoi();
    function coordsToPolygon(coords) {
      coords = coords.slice();
      coords.push(coords[0]);
      return helpers.polygon([coords]);
    }
    function voronoi(points, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var bbox = options.bbox || [-180, -85, 180, 85];
      if (!points) throw new Error("points is required");
      if (!Array.isArray(bbox)) throw new Error("bbox is invalid");
      invariant.collectionOf(points, "Point", "points");
      return helpers.featureCollection(
        d3voronoi.voronoi().x(function(feature) {
          return feature.geometry.coordinates[0];
        }).y(function(feature) {
          return feature.geometry.coordinates[1];
        }).extent([
          [bbox[0], bbox[1]],
          [bbox[2], bbox[3]]
        ]).polygons(points.features).map(coordsToPolygon)
      );
    }
    module2.exports = voronoi;
    module2.exports.default = voronoi;
  }
});

// node_modules/@turf/ellipse/dist/js/index.js
var require_js85 = __commonJS({
  "node_modules/@turf/ellipse/dist/js/index.js"(exports2, module2) {
    "use strict";
    var helpers = require_js();
    var rhumbDestination = require_js64();
    var transformRotate = require_js69();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var rhumbDestination__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDestination);
    var transformRotate__default = /* @__PURE__ */ _interopDefaultLegacy(transformRotate);
    function ellipse(center, xSemiAxis, ySemiAxis, options) {
      options = options || {};
      var steps = options.steps || 64;
      var units = options.units || "kilometers";
      var angle = options.angle || 0;
      var pivot = options.pivot || center;
      var properties = options.properties || center.properties || {};
      if (!center) throw new Error("center is required");
      if (!xSemiAxis) throw new Error("xSemiAxis is required");
      if (!ySemiAxis) throw new Error("ySemiAxis is required");
      if (!helpers.isObject(options)) throw new Error("options must be an object");
      if (!helpers.isNumber(steps)) throw new Error("steps must be a number");
      if (!helpers.isNumber(angle)) throw new Error("angle must be a number");
      var centerCoords = invariant.getCoord(center);
      if (units === "degrees") {
        var angleRad = helpers.degreesToRadians(angle);
      } else {
        xSemiAxis = rhumbDestination__default["default"](center, xSemiAxis, 90, { units });
        ySemiAxis = rhumbDestination__default["default"](center, ySemiAxis, 0, { units });
        xSemiAxis = invariant.getCoord(xSemiAxis)[0] - centerCoords[0];
        ySemiAxis = invariant.getCoord(ySemiAxis)[1] - centerCoords[1];
      }
      var coordinates = [];
      for (var i = 0; i < steps; i += 1) {
        var stepAngle = i * -360 / steps;
        var x = xSemiAxis * ySemiAxis / Math.sqrt(
          Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)
        );
        var y = xSemiAxis * ySemiAxis / Math.sqrt(
          Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)
        );
        if (stepAngle < -90 && stepAngle >= -270) x = -x;
        if (stepAngle < -180 && stepAngle >= -360) y = -y;
        if (units === "degrees") {
          var newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);
          var newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);
          x = newx;
          y = newy;
        }
        coordinates.push([x + centerCoords[0], y + centerCoords[1]]);
      }
      coordinates.push(coordinates[0]);
      if (units === "degrees") {
        return helpers.polygon([coordinates], properties);
      } else {
        return transformRotate__default["default"](helpers.polygon([coordinates], properties), angle, {
          pivot
        });
      }
    }
    function getTanDeg(deg) {
      var rad = deg * Math.PI / 180;
      return Math.tan(rad);
    }
    module2.exports = ellipse;
    module2.exports.default = ellipse;
  }
});

// node_modules/@turf/center-mean/dist/js/index.js
var require_js86 = __commonJS({
  "node_modules/@turf/center-mean/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    function centerMean(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      var sumXs = 0;
      var sumYs = 0;
      var sumNs = 0;
      meta_1.geomEach(geojson, function(geom, featureIndex, properties) {
        var weight = options.weight ? properties === null || properties === void 0 ? void 0 : properties[options.weight] : void 0;
        weight = weight === void 0 || weight === null ? 1 : weight;
        if (!helpers_1.isNumber(weight))
          throw new Error("weight value must be a number for feature index " + featureIndex);
        weight = Number(weight);
        if (weight > 0) {
          meta_1.coordEach(geom, function(coord) {
            sumXs += coord[0] * weight;
            sumYs += coord[1] * weight;
            sumNs += weight;
          });
        }
      });
      return helpers_1.point([sumXs / sumNs, sumYs / sumNs], options.properties, options);
    }
    exports2.default = centerMean;
  }
});

// node_modules/@turf/center-median/dist/js/index.js
var require_js87 = __commonJS({
  "node_modules/@turf/center-median/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var center_mean_1 = __importDefault(require_js86());
    var distance_1 = __importDefault(require_js9());
    var centroid_1 = __importDefault(require_js28());
    var helpers_1 = require_js();
    var meta_1 = require_js2();
    function centerMedian(features, options) {
      if (options === void 0) {
        options = {};
      }
      options = options || {};
      if (!helpers_1.isObject(options))
        throw new Error("options is invalid");
      var counter = options.counter || 10;
      if (!helpers_1.isNumber(counter))
        throw new Error("counter must be a number");
      var weightTerm = options.weight;
      var meanCenter = center_mean_1.default(features, { weight: options.weight });
      var centroids = helpers_1.featureCollection([]);
      meta_1.featureEach(features, function(feature) {
        var _a;
        centroids.features.push(centroid_1.default(feature, {
          properties: { weight: (_a = feature.properties) === null || _a === void 0 ? void 0 : _a[weightTerm] }
        }));
      });
      var properties = {
        tolerance: options.tolerance,
        medianCandidates: []
      };
      return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);
    }
    function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
      var tolerance = properties.tolerance || 1e-3;
      var candidateXsum = 0;
      var candidateYsum = 0;
      var kSum = 0;
      var centroidCount = 0;
      meta_1.featureEach(centroids, function(theCentroid) {
        var _a;
        var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;
        var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;
        weight = Number(weight);
        if (!helpers_1.isNumber(weight))
          throw new Error("weight value must be a number");
        if (weight > 0) {
          centroidCount += 1;
          var distanceFromCandidate = weight * distance_1.default(theCentroid, candidateMedian);
          if (distanceFromCandidate === 0)
            distanceFromCandidate = 1;
          var k = weight / distanceFromCandidate;
          candidateXsum += theCentroid.geometry.coordinates[0] * k;
          candidateYsum += theCentroid.geometry.coordinates[1] * k;
          kSum += k;
        }
      });
      if (centroidCount < 1)
        throw new Error("no features to measure");
      var candidateX = candidateXsum / kSum;
      var candidateY = candidateYsum / kSum;
      if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {
        return helpers_1.point([candidateX, candidateY], {
          medianCandidates: properties.medianCandidates
        });
      } else {
        properties.medianCandidates.push([candidateX, candidateY]);
        return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);
      }
    }
    exports2.default = centerMedian;
  }
});

// node_modules/@turf/standard-deviational-ellipse/dist/js/index.js
var require_js88 = __commonJS({
  "node_modules/@turf/standard-deviational-ellipse/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var invariant = require_js4();
    var helpers = require_js();
    var centerMean = require_js86();
    var pointsWithinPolygon = require_js8();
    var ellipse = require_js85();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var centerMean__default = /* @__PURE__ */ _interopDefaultLegacy(centerMean);
    var pointsWithinPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(pointsWithinPolygon);
    var ellipse__default = /* @__PURE__ */ _interopDefaultLegacy(ellipse);
    function standardDeviationalEllipse(points, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var steps = options.steps || 64;
      var weightTerm = options.weight;
      var properties = options.properties || {};
      if (!helpers.isNumber(steps)) throw new Error("steps must be a number");
      if (!helpers.isObject(properties)) throw new Error("properties must be a number");
      var numberOfFeatures = meta.coordAll(points).length;
      var meanCenter = centerMean__default["default"](points, { weight: weightTerm });
      var xDeviationSquaredSum = 0;
      var yDeviationSquaredSum = 0;
      var xyDeviationSum = 0;
      meta.featureEach(points, function(point) {
        var weight = point.properties[weightTerm] || 1;
        var deviation = getDeviations(invariant.getCoords(point), invariant.getCoords(meanCenter));
        xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
        yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
        xyDeviationSum += deviation.x * deviation.y * weight;
      });
      var bigA = xDeviationSquaredSum - yDeviationSquaredSum;
      var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
      var bigC = 2 * xyDeviationSum;
      var theta = Math.atan((bigA + bigB) / bigC);
      var thetaDeg = theta * 180 / Math.PI;
      var sigmaXsum = 0;
      var sigmaYsum = 0;
      var weightsum = 0;
      meta.featureEach(points, function(point) {
        var weight = point.properties[weightTerm] || 1;
        var deviation = getDeviations(invariant.getCoords(point), invariant.getCoords(meanCenter));
        sigmaXsum += Math.pow(
          deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
          2
        ) * weight;
        sigmaYsum += Math.pow(
          deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
          2
        ) * weight;
        weightsum += weight;
      });
      var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
      var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
      var theEllipse = ellipse__default["default"](meanCenter, sigmaX, sigmaY, {
        units: "degrees",
        angle: thetaDeg,
        steps,
        properties
      });
      var pointsWithinEllipse = pointsWithinPolygon__default["default"](
        points,
        helpers.featureCollection([theEllipse])
      );
      var standardDeviationalEllipseProperties = {
        meanCenterCoordinates: invariant.getCoords(meanCenter),
        semiMajorAxis: sigmaX,
        semiMinorAxis: sigmaY,
        numberOfFeatures,
        angle: thetaDeg,
        percentageWithinEllipse: 100 * meta.coordAll(pointsWithinEllipse).length / numberOfFeatures
      };
      theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
      return theEllipse;
    }
    function getDeviations(coordinates, center) {
      return {
        x: coordinates[0] - center[0],
        y: coordinates[1] - center[1]
      };
    }
    module2.exports = standardDeviationalEllipse;
    module2.exports.default = standardDeviationalEllipse;
  }
});

// node_modules/@turf/angle/dist/js/index.js
var require_js89 = __commonJS({
  "node_modules/@turf/angle/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bearing_1 = __importDefault(require_js25());
    var helpers_1 = require_js();
    var rhumb_bearing_1 = __importDefault(require_js63());
    function angle(startPoint, midPoint, endPoint, options) {
      if (options === void 0) {
        options = {};
      }
      if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
      }
      if (!startPoint) {
        throw new Error("startPoint is required");
      }
      if (!midPoint) {
        throw new Error("midPoint is required");
      }
      if (!endPoint) {
        throw new Error("endPoint is required");
      }
      var A = startPoint;
      var O = midPoint;
      var B = endPoint;
      var azimuthAO = helpers_1.bearingToAzimuth(options.mercator !== true ? bearing_1.default(A, O) : rhumb_bearing_1.default(A, O));
      var azimuthBO = helpers_1.bearingToAzimuth(options.mercator !== true ? bearing_1.default(B, O) : rhumb_bearing_1.default(B, O));
      var angleAO = Math.abs(azimuthAO - azimuthBO);
      if (options.explementary === true) {
        return 360 - angleAO;
      }
      return angleAO;
    }
    exports2.default = angle;
  }
});

// node_modules/@turf/polygon-smooth/dist/js/index.js
var require_js90 = __commonJS({
  "node_modules/@turf/polygon-smooth/dist/js/index.js"(exports2, module2) {
    "use strict";
    var meta = require_js2();
    var helpers = require_js();
    function polygonSmooth(inputPolys, options) {
      var outPolys = [];
      var iterations = options.iterations || 1;
      if (!inputPolys) throw new Error("inputPolys is required");
      meta.geomEach(inputPolys, function(geom, geomIndex, properties) {
        var outCoords;
        var poly;
        var tempOutput;
        switch (geom.type) {
          case "Polygon":
            outCoords = [[]];
            for (var i = 0; i < iterations; i++) {
              tempOutput = [[]];
              poly = geom;
              if (i > 0) poly = helpers.polygon(outCoords).geometry;
              processPolygon(poly, tempOutput);
              outCoords = tempOutput.slice(0);
            }
            outPolys.push(helpers.polygon(outCoords, properties));
            break;
          case "MultiPolygon":
            outCoords = [[[]]];
            for (var y = 0; y < iterations; y++) {
              tempOutput = [[[]]];
              poly = geom;
              if (y > 0) poly = helpers.multiPolygon(outCoords).geometry;
              processMultiPolygon(poly, tempOutput);
              outCoords = tempOutput.slice(0);
            }
            outPolys.push(helpers.multiPolygon(outCoords, properties));
            break;
          default:
            throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
        }
      });
      return helpers.featureCollection(outPolys);
    }
    function processPolygon(poly, tempOutput) {
      var prevGeomIndex = 0;
      var subtractCoordIndex = 0;
      meta.coordEach(
        poly,
        function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
          if (geometryIndex > prevGeomIndex) {
            prevGeomIndex = geometryIndex;
            subtractCoordIndex = coordIndex;
            tempOutput.push([]);
          }
          var realCoordIndex = coordIndex - subtractCoordIndex;
          var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];
          var p0x = currentCoord[0];
          var p0y = currentCoord[1];
          var p1x = p1[0];
          var p1y = p1[1];
          tempOutput[geometryIndex].push([
            0.75 * p0x + 0.25 * p1x,
            0.75 * p0y + 0.25 * p1y
          ]);
          tempOutput[geometryIndex].push([
            0.25 * p0x + 0.75 * p1x,
            0.25 * p0y + 0.75 * p1y
          ]);
        },
        true
      );
      tempOutput.forEach(function(ring) {
        ring.push(ring[0]);
      });
    }
    function processMultiPolygon(poly, tempOutput) {
      var prevGeomIndex = 0;
      var subtractCoordIndex = 0;
      var prevMultiIndex = 0;
      meta.coordEach(
        poly,
        function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
          if (multiFeatureIndex > prevMultiIndex) {
            prevMultiIndex = multiFeatureIndex;
            subtractCoordIndex = coordIndex;
            tempOutput.push([[]]);
          }
          if (geometryIndex > prevGeomIndex) {
            prevGeomIndex = geometryIndex;
            subtractCoordIndex = coordIndex;
            tempOutput[multiFeatureIndex].push([]);
          }
          var realCoordIndex = coordIndex - subtractCoordIndex;
          var p1 = poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];
          var p0x = currentCoord[0];
          var p0y = currentCoord[1];
          var p1x = p1[0];
          var p1y = p1[1];
          tempOutput[multiFeatureIndex][geometryIndex].push([
            0.75 * p0x + 0.25 * p1x,
            0.75 * p0y + 0.25 * p1y
          ]);
          tempOutput[multiFeatureIndex][geometryIndex].push([
            0.25 * p0x + 0.75 * p1x,
            0.25 * p0y + 0.75 * p1y
          ]);
        },
        true
      );
      tempOutput.forEach(function(poly2) {
        poly2.forEach(function(ring) {
          ring.push(ring[0]);
        });
      });
    }
    module2.exports = polygonSmooth;
    module2.exports.default = polygonSmooth;
  }
});

// node_modules/@turf/distance-weight/dist/js/index.js
var require_js91 = __commonJS({
  "node_modules/@turf/distance-weight/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var centroid_1 = __importDefault(require_js28());
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    function pNormDistance(feature1, feature2, p) {
      if (p === void 0) {
        p = 2;
      }
      var coordinate1 = invariant_1.getCoord(feature1);
      var coordinate2 = invariant_1.getCoord(feature2);
      var xDiff = coordinate1[0] - coordinate2[0];
      var yDiff = coordinate1[1] - coordinate2[1];
      if (p === 1) {
        return Math.abs(xDiff) + Math.abs(yDiff);
      }
      return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
    }
    exports2.pNormDistance = pNormDistance;
    function distanceWeight(fc, options) {
      options = options || {};
      var threshold = options.threshold || 1e4;
      var p = options.p || 2;
      var binary = options.binary || false;
      var alpha = options.alpha || -1;
      var rowTransform = options.standardization || false;
      var features = [];
      meta_1.featureEach(fc, function(feature) {
        features.push(centroid_1.default(feature));
      });
      var weights = [];
      for (var i = 0; i < features.length; i++) {
        weights[i] = [];
      }
      for (var i = 0; i < features.length; i++) {
        for (var j = i; j < features.length; j++) {
          if (i === j) {
            weights[i][j] = 0;
          }
          var dis = pNormDistance(features[i], features[j], p);
          weights[i][j] = dis;
          weights[j][i] = dis;
        }
      }
      for (var i = 0; i < features.length; i++) {
        for (var j = 0; j < features.length; j++) {
          var dis = weights[i][j];
          if (dis === 0) {
            continue;
          }
          if (binary) {
            if (dis <= threshold) {
              weights[i][j] = 1;
            } else {
              weights[i][j] = 0;
            }
          } else {
            if (dis <= threshold) {
              weights[i][j] = Math.pow(dis, alpha);
            } else {
              weights[i][j] = 0;
            }
          }
        }
      }
      if (rowTransform) {
        for (var i = 0; i < features.length; i++) {
          var rowSum = weights[i].reduce(function(sum, currentVal) {
            return sum + currentVal;
          }, 0);
          for (var j = 0; j < features.length; j++) {
            weights[i][j] = weights[i][j] / rowSum;
          }
        }
      }
      return weights;
    }
    exports2.default = distanceWeight;
  }
});

// node_modules/@turf/moran-index/dist/js/index.js
var require_js92 = __commonJS({
  "node_modules/@turf/moran-index/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var distance_weight_1 = __importDefault(require_js91());
    var meta_1 = require_js2();
    function default_1(fc, options) {
      var inputField = options.inputField;
      var threshold = options.threshold || 1e5;
      var p = options.p || 2;
      var binary = options.binary || false;
      var alpha = options.alpha || -1;
      var standardization = options.standardization || true;
      var weight = distance_weight_1.default(fc, {
        alpha,
        binary,
        p,
        standardization,
        threshold
      });
      var y = [];
      meta_1.featureEach(fc, function(feature) {
        var feaProperties = feature.properties || {};
        y.push(feaProperties[inputField]);
      });
      var yMean = mean(y);
      var yVar = variance(y);
      var weightSum = 0;
      var s0 = 0;
      var s1 = 0;
      var s2 = 0;
      var n = weight.length;
      for (var i = 0; i < n; i++) {
        var subS2 = 0;
        for (var j = 0; j < n; j++) {
          weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);
          s0 += weight[i][j];
          s1 += Math.pow(weight[i][j] + weight[j][i], 2);
          subS2 += weight[i][j] + weight[j][i];
        }
        s2 += Math.pow(subS2, 2);
      }
      s1 = 0.5 * s1;
      var moranIndex = weightSum / s0 / yVar;
      var expectedMoranIndex = -1 / (n - 1);
      var vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
      var vDen = (n - 1) * (n + 1) * (s0 * s0);
      var vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
      var stdNorm = Math.sqrt(vNorm);
      var zNorm = (moranIndex - expectedMoranIndex) / stdNorm;
      return {
        expectedMoranIndex,
        moranIndex,
        stdNorm,
        zNorm
      };
    }
    exports2.default = default_1;
    function mean(y) {
      var sum = 0;
      for (var _i = 0, y_1 = y; _i < y_1.length; _i++) {
        var item = y_1[_i];
        sum += item;
      }
      return sum / y.length;
    }
    function variance(y) {
      var yMean = mean(y);
      var sum = 0;
      for (var _i = 0, y_2 = y; _i < y_2.length; _i++) {
        var item = y_2[_i];
        sum += Math.pow(item - yMean, 2);
      }
      return sum / y.length;
    }
  }
});

// node_modules/@turf/projection/dist/js/index.js
var require_js93 = __commonJS({
  "node_modules/@turf/projection/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    var clone_1 = __importDefault(require_js11());
    function toMercator(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      return convert(geojson, "mercator", options);
    }
    exports2.toMercator = toMercator;
    function toWgs84(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      return convert(geojson, "wgs84", options);
    }
    exports2.toWgs84 = toWgs84;
    function convert(geojson, projection, options) {
      if (options === void 0) {
        options = {};
      }
      options = options || {};
      var mutate = options.mutate;
      if (!geojson)
        throw new Error("geojson is required");
      if (Array.isArray(geojson) && helpers_1.isNumber(geojson[0]))
        geojson = projection === "mercator" ? convertToMercator(geojson) : convertToWgs84(geojson);
      else {
        if (mutate !== true)
          geojson = clone_1.default(geojson);
        meta_1.coordEach(geojson, function(coord) {
          var newCoord = projection === "mercator" ? convertToMercator(coord) : convertToWgs84(coord);
          coord[0] = newCoord[0];
          coord[1] = newCoord[1];
        });
      }
      return geojson;
    }
    function convertToMercator(lonLat) {
      var D2R = Math.PI / 180, A = 6378137, MAXEXTENT = 20037508342789244e-9;
      var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;
      var xy = [
        A * adjusted * D2R,
        A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R))
      ];
      if (xy[0] > MAXEXTENT)
        xy[0] = MAXEXTENT;
      if (xy[0] < -MAXEXTENT)
        xy[0] = -MAXEXTENT;
      if (xy[1] > MAXEXTENT)
        xy[1] = MAXEXTENT;
      if (xy[1] < -MAXEXTENT)
        xy[1] = -MAXEXTENT;
      return xy;
    }
    function convertToWgs84(xy) {
      var R2D = 180 / Math.PI;
      var A = 6378137;
      return [
        xy[0] * R2D / A,
        (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-xy[1] / A))) * R2D
      ];
    }
    function sign(x) {
      return x < 0 ? -1 : x > 0 ? 1 : 0;
    }
  }
});

// node_modules/@turf/random/dist/js/index.js
var require_js94 = __commonJS({
  "node_modules/@turf/random/dist/js/index.js"(exports2) {
    "use strict";
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    function randomPosition(bbox) {
      if (Array.isArray(bbox)) {
        return coordInBBox(bbox);
      }
      if (bbox && bbox.bbox) {
        return coordInBBox(bbox.bbox);
      }
      return [lon(), lat()];
    }
    exports2.randomPosition = randomPosition;
    function randomPoint(count, options) {
      if (options === void 0) {
        options = {};
      }
      if (count === void 0 || count === null) {
        count = 1;
      }
      var features = [];
      for (var i = 0; i < count; i++) {
        features.push(helpers_1.point(randomPosition(options.bbox)));
      }
      return helpers_1.featureCollection(features);
    }
    exports2.randomPoint = randomPoint;
    function randomPolygon(count, options) {
      if (options === void 0) {
        options = {};
      }
      if (count === void 0 || count === null) {
        count = 1;
      }
      if (!helpers_1.isNumber(options.num_vertices) || options.num_vertices === void 0) {
        options.num_vertices = 10;
      }
      if (!helpers_1.isNumber(options.max_radial_length) || options.max_radial_length === void 0) {
        options.max_radial_length = 10;
      }
      var features = [];
      var _loop_1 = function(i2) {
        var vertices = [];
        var circleOffsets = __spreadArrays(Array(options.num_vertices + 1)).map(Math.random);
        circleOffsets.forEach(function(cur, index, arr) {
          arr[index] = index > 0 ? cur + arr[index - 1] : cur;
        });
        circleOffsets.forEach(function(cur) {
          cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];
          var radialScaler = Math.random();
          vertices.push([
            radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
            radialScaler * (options.max_radial_length || 10) * Math.cos(cur)
          ]);
        });
        vertices[vertices.length - 1] = vertices[0];
        vertices = vertices.map(vertexToCoordinate(randomPosition(options.bbox)));
        features.push(helpers_1.polygon([vertices]));
      };
      for (var i = 0; i < count; i++) {
        _loop_1(i);
      }
      return helpers_1.featureCollection(features);
    }
    exports2.randomPolygon = randomPolygon;
    function randomLineString(count, options) {
      if (options === void 0) {
        options = {};
      }
      options = options || {};
      if (!helpers_1.isObject(options)) {
        throw new Error("options is invalid");
      }
      var bbox = options.bbox;
      var num_vertices = options.num_vertices;
      var max_length = options.max_length;
      var max_rotation = options.max_rotation;
      if (count === void 0 || count === null) {
        count = 1;
      }
      if (!helpers_1.isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {
        num_vertices = 10;
      }
      if (!helpers_1.isNumber(max_length) || max_length === void 0) {
        max_length = 1e-4;
      }
      if (!helpers_1.isNumber(max_rotation) || max_rotation === void 0) {
        max_rotation = Math.PI / 8;
      }
      var features = [];
      for (var i = 0; i < count; i++) {
        var startingPoint = randomPosition(bbox);
        var vertices = [startingPoint];
        for (var j = 0; j < num_vertices - 1; j++) {
          var priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));
          var angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
          var distance = Math.random() * max_length;
          vertices.push([
            vertices[j][0] + distance * Math.cos(angle),
            vertices[j][1] + distance * Math.sin(angle)
          ]);
        }
        features.push(helpers_1.lineString(vertices));
      }
      return helpers_1.featureCollection(features);
    }
    exports2.randomLineString = randomLineString;
    function vertexToCoordinate(hub) {
      return function(cur) {
        return [cur[0] + hub[0], cur[1] + hub[1]];
      };
    }
    function rnd() {
      return Math.random() - 0.5;
    }
    function lon() {
      return rnd() * 360;
    }
    function lat() {
      return rnd() * 180;
    }
    function coordInBBox(bbox) {
      return [
        Math.random() * (bbox[2] - bbox[0]) + bbox[0],
        Math.random() * (bbox[3] - bbox[1]) + bbox[1]
      ];
    }
  }
});

// node_modules/@turf/clusters/dist/js/index.js
var require_js95 = __commonJS({
  "node_modules/@turf/clusters/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    function getCluster(geojson, filter) {
      if (!geojson)
        throw new Error("geojson is required");
      if (geojson.type !== "FeatureCollection")
        throw new Error("geojson must be a FeatureCollection");
      if (filter === void 0 || filter === null)
        throw new Error("filter is required");
      var features = [];
      meta_1.featureEach(geojson, function(feature) {
        if (applyFilter(feature.properties, filter))
          features.push(feature);
      });
      return helpers_1.featureCollection(features);
    }
    exports2.getCluster = getCluster;
    function clusterEach(geojson, property, callback) {
      if (!geojson)
        throw new Error("geojson is required");
      if (geojson.type !== "FeatureCollection")
        throw new Error("geojson must be a FeatureCollection");
      if (property === void 0 || property === null)
        throw new Error("property is required");
      var bins = createBins(geojson, property);
      var values = Object.keys(bins);
      for (var index = 0; index < values.length; index++) {
        var value = values[index];
        var bin = bins[value];
        var features = [];
        for (var i = 0; i < bin.length; i++) {
          features.push(geojson.features[bin[i]]);
        }
        callback(helpers_1.featureCollection(features), value, index);
      }
    }
    exports2.clusterEach = clusterEach;
    function clusterReduce(geojson, property, callback, initialValue) {
      var previousValue = initialValue;
      clusterEach(geojson, property, function(cluster, clusterValue, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0)
          previousValue = cluster;
        else
          previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
      });
      return previousValue;
    }
    exports2.clusterReduce = clusterReduce;
    function createBins(geojson, property) {
      var bins = {};
      meta_1.featureEach(geojson, function(feature, i) {
        var properties = feature.properties || {};
        if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
          var value = properties[property];
          if (Object.prototype.hasOwnProperty.call(bins, value))
            bins[value].push(i);
          else
            bins[value] = [i];
        }
      });
      return bins;
    }
    exports2.createBins = createBins;
    function applyFilter(properties, filter) {
      if (properties === void 0)
        return false;
      var filterType = typeof filter;
      if (filterType === "number" || filterType === "string")
        return Object.prototype.hasOwnProperty.call(properties, filter);
      else if (Array.isArray(filter)) {
        for (var i = 0; i < filter.length; i++) {
          if (!applyFilter(properties, filter[i]))
            return false;
        }
        return true;
      } else {
        return propertiesContainsFilter(properties, filter);
      }
    }
    exports2.applyFilter = applyFilter;
    function propertiesContainsFilter(properties, filter) {
      var keys = Object.keys(filter);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (properties[key] !== filter[key])
          return false;
      }
      return true;
    }
    exports2.propertiesContainsFilter = propertiesContainsFilter;
    function filterProperties(properties, keys) {
      if (!keys)
        return {};
      if (!keys.length)
        return {};
      var newProperties = {};
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (Object.prototype.hasOwnProperty.call(properties, key))
          newProperties[key] = properties[key];
      }
      return newProperties;
    }
    exports2.filterProperties = filterProperties;
  }
});

// node_modules/splaytree/dist/splay.js
var require_splay = __commonJS({
  "node_modules/splaytree/dist/splay.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.SplayTree = factory();
    })(exports2, function() {
      "use strict";
      var Node = (
        /** @class */
        /* @__PURE__ */ function() {
          function Node2(key, data) {
            this.next = null;
            this.key = key;
            this.data = data;
            this.left = null;
            this.right = null;
          }
          return Node2;
        }()
      );
      function DEFAULT_COMPARE(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
      }
      function splay(i, t, comparator) {
        var N = new Node(null, null);
        var l = N;
        var r = N;
        while (true) {
          var cmp = comparator(i, t.key);
          if (cmp < 0) {
            if (t.left === null)
              break;
            if (comparator(i, t.left.key) < 0) {
              var y = t.left;
              t.left = y.right;
              y.right = t;
              t = y;
              if (t.left === null)
                break;
            }
            r.left = t;
            r = t;
            t = t.left;
          } else if (cmp > 0) {
            if (t.right === null)
              break;
            if (comparator(i, t.right.key) > 0) {
              var y = t.right;
              t.right = y.left;
              y.left = t;
              t = y;
              if (t.right === null)
                break;
            }
            l.right = t;
            l = t;
            t = t.right;
          } else
            break;
        }
        l.right = t.left;
        r.left = t.right;
        t.left = N.right;
        t.right = N.left;
        return t;
      }
      function insert(i, data, t, comparator) {
        var node = new Node(i, data);
        if (t === null) {
          node.left = node.right = null;
          return node;
        }
        t = splay(i, t, comparator);
        var cmp = comparator(i, t.key);
        if (cmp < 0) {
          node.left = t.left;
          node.right = t;
          t.left = null;
        } else if (cmp >= 0) {
          node.right = t.right;
          node.left = t;
          t.right = null;
        }
        return node;
      }
      function split(key, v, comparator) {
        var left = null;
        var right = null;
        if (v) {
          v = splay(key, v, comparator);
          var cmp = comparator(v.key, key);
          if (cmp === 0) {
            left = v.left;
            right = v.right;
          } else if (cmp < 0) {
            right = v.right;
            v.right = null;
            left = v;
          } else {
            left = v.left;
            v.left = null;
            right = v;
          }
        }
        return { left, right };
      }
      function merge(left, right, comparator) {
        if (right === null)
          return left;
        if (left === null)
          return right;
        right = splay(left.key, right, comparator);
        right.left = left;
        return right;
      }
      function printRow(root, prefix, isTail, out, printNode) {
        if (root) {
          out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root) + "\n");
          var indent = prefix + (isTail ? "    " : "\u2502   ");
          if (root.left)
            printRow(root.left, indent, false, out, printNode);
          if (root.right)
            printRow(root.right, indent, true, out, printNode);
        }
      }
      var Tree = (
        /** @class */
        function() {
          function Tree2(comparator) {
            if (comparator === void 0) {
              comparator = DEFAULT_COMPARE;
            }
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
          }
          Tree2.prototype.insert = function(key, data) {
            this._size++;
            return this._root = insert(key, data, this._root, this._comparator);
          };
          Tree2.prototype.add = function(key, data) {
            var node = new Node(key, data);
            if (this._root === null) {
              node.left = node.right = null;
              this._size++;
              this._root = node;
            }
            var comparator = this._comparator;
            var t = splay(key, this._root, comparator);
            var cmp = comparator(key, t.key);
            if (cmp === 0)
              this._root = t;
            else {
              if (cmp < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
              } else if (cmp > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
              }
              this._size++;
              this._root = node;
            }
            return this._root;
          };
          Tree2.prototype.remove = function(key) {
            this._root = this._remove(key, this._root, this._comparator);
          };
          Tree2.prototype._remove = function(i, t, comparator) {
            var x;
            if (t === null)
              return null;
            t = splay(i, t, comparator);
            var cmp = comparator(i, t.key);
            if (cmp === 0) {
              if (t.left === null) {
                x = t.right;
              } else {
                x = splay(i, t.left, comparator);
                x.right = t.right;
              }
              this._size--;
              return x;
            }
            return t;
          };
          Tree2.prototype.pop = function() {
            var node = this._root;
            if (node) {
              while (node.left)
                node = node.left;
              this._root = splay(node.key, this._root, this._comparator);
              this._root = this._remove(node.key, this._root, this._comparator);
              return { key: node.key, data: node.data };
            }
            return null;
          };
          Tree2.prototype.findStatic = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp = compare(key, current.key);
              if (cmp === 0)
                return current;
              else if (cmp < 0)
                current = current.left;
              else
                current = current.right;
            }
            return null;
          };
          Tree2.prototype.find = function(key) {
            if (this._root) {
              this._root = splay(key, this._root, this._comparator);
              if (this._comparator(key, this._root.key) !== 0)
                return null;
            }
            return this._root;
          };
          Tree2.prototype.contains = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp = compare(key, current.key);
              if (cmp === 0)
                return true;
              else if (cmp < 0)
                current = current.left;
              else
                current = current.right;
            }
            return false;
          };
          Tree2.prototype.forEach = function(visitor, ctx) {
            var current = this._root;
            var Q = [];
            var done = false;
            while (!done) {
              if (current !== null) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length !== 0) {
                  current = Q.pop();
                  visitor.call(ctx, current);
                  current = current.right;
                } else
                  done = true;
              }
            }
            return this;
          };
          Tree2.prototype.range = function(low, high, fn, ctx) {
            var Q = [];
            var compare = this._comparator;
            var node = this._root;
            var cmp;
            while (Q.length !== 0 || node) {
              if (node) {
                Q.push(node);
                node = node.left;
              } else {
                node = Q.pop();
                cmp = compare(node.key, high);
                if (cmp > 0) {
                  break;
                } else if (compare(node.key, low) >= 0) {
                  if (fn.call(ctx, node))
                    return this;
                }
                node = node.right;
              }
            }
            return this;
          };
          Tree2.prototype.keys = function() {
            var keys = [];
            this.forEach(function(_a) {
              var key = _a.key;
              return keys.push(key);
            });
            return keys;
          };
          Tree2.prototype.values = function() {
            var values = [];
            this.forEach(function(_a) {
              var data = _a.data;
              return values.push(data);
            });
            return values;
          };
          Tree2.prototype.min = function() {
            if (this._root)
              return this.minNode(this._root).key;
            return null;
          };
          Tree2.prototype.max = function() {
            if (this._root)
              return this.maxNode(this._root).key;
            return null;
          };
          Tree2.prototype.minNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.left)
                t = t.left;
            return t;
          };
          Tree2.prototype.maxNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.right)
                t = t.right;
            return t;
          };
          Tree2.prototype.at = function(index) {
            var current = this._root;
            var done = false;
            var i = 0;
            var Q = [];
            while (!done) {
              if (current) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length > 0) {
                  current = Q.pop();
                  if (i === index)
                    return current;
                  i++;
                  current = current.right;
                } else
                  done = true;
              }
            }
            return null;
          };
          Tree2.prototype.next = function(d) {
            var root = this._root;
            var successor = null;
            if (d.right) {
              successor = d.right;
              while (successor.left)
                successor = successor.left;
              return successor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp = comparator(d.key, root.key);
              if (cmp === 0)
                break;
              else if (cmp < 0) {
                successor = root;
                root = root.left;
              } else
                root = root.right;
            }
            return successor;
          };
          Tree2.prototype.prev = function(d) {
            var root = this._root;
            var predecessor = null;
            if (d.left !== null) {
              predecessor = d.left;
              while (predecessor.right)
                predecessor = predecessor.right;
              return predecessor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp = comparator(d.key, root.key);
              if (cmp === 0)
                break;
              else if (cmp < 0)
                root = root.left;
              else {
                predecessor = root;
                root = root.right;
              }
            }
            return predecessor;
          };
          Tree2.prototype.clear = function() {
            this._root = null;
            this._size = 0;
            return this;
          };
          Tree2.prototype.toList = function() {
            return toList(this._root);
          };
          Tree2.prototype.load = function(keys, values, presort) {
            if (values === void 0) {
              values = [];
            }
            if (presort === void 0) {
              presort = false;
            }
            var size = keys.length;
            var comparator = this._comparator;
            if (presort)
              sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) {
              this._root = loadRecursive(keys, values, 0, size);
              this._size = size;
            } else {
              var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
              size = this._size + size;
              this._root = sortedListToBST({ head: mergedList }, 0, size);
            }
            return this;
          };
          Tree2.prototype.isEmpty = function() {
            return this._root === null;
          };
          Object.defineProperty(Tree2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Tree2.prototype, "root", {
            get: function() {
              return this._root;
            },
            enumerable: true,
            configurable: true
          });
          Tree2.prototype.toString = function(printNode) {
            if (printNode === void 0) {
              printNode = function(n) {
                return String(n.key);
              };
            }
            var out = [];
            printRow(this._root, "", true, function(v) {
              return out.push(v);
            }, printNode);
            return out.join("");
          };
          Tree2.prototype.update = function(key, newKey, newData) {
            var comparator = this._comparator;
            var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
            if (comparator(key, newKey) < 0) {
              right = insert(newKey, newData, right, comparator);
            } else {
              left = insert(newKey, newData, left, comparator);
            }
            this._root = merge(left, right, comparator);
          };
          Tree2.prototype.split = function(key) {
            return split(key, this._root, this._comparator);
          };
          return Tree2;
        }()
      );
      function loadRecursive(keys, values, start, end) {
        var size = end - start;
        if (size > 0) {
          var middle = start + Math.floor(size / 2);
          var key = keys[middle];
          var data = values[middle];
          var node = new Node(key, data);
          node.left = loadRecursive(keys, values, start, middle);
          node.right = loadRecursive(keys, values, middle + 1, end);
          return node;
        }
        return null;
      }
      function createList(keys, values) {
        var head = new Node(null, null);
        var p = head;
        for (var i = 0; i < keys.length; i++) {
          p = p.next = new Node(keys[i], values[i]);
        }
        p.next = null;
        return head.next;
      }
      function toList(root) {
        var current = root;
        var Q = [];
        var done = false;
        var head = new Node(null, null);
        var p = head;
        while (!done) {
          if (current) {
            Q.push(current);
            current = current.left;
          } else {
            if (Q.length > 0) {
              current = p = p.next = Q.pop();
              current = current.right;
            } else
              done = true;
          }
        }
        p.next = null;
        return head.next;
      }
      function sortedListToBST(list, start, end) {
        var size = end - start;
        if (size > 0) {
          var middle = start + Math.floor(size / 2);
          var left = sortedListToBST(list, start, middle);
          var root = list.head;
          root.left = left;
          list.head = list.head.next;
          root.right = sortedListToBST(list, middle + 1, end);
          return root;
        }
        return null;
      }
      function mergeLists(l1, l2, compare) {
        var head = new Node(null, null);
        var p = head;
        var p1 = l1;
        var p2 = l2;
        while (p1 !== null && p2 !== null) {
          if (compare(p1.key, p2.key) < 0) {
            p.next = p1;
            p1 = p1.next;
          } else {
            p.next = p2;
            p2 = p2.next;
          }
          p = p.next;
        }
        if (p1 !== null) {
          p.next = p1;
        } else if (p2 !== null) {
          p.next = p2;
        }
        return head.next;
      }
      function sort(keys, values, left, right, compare) {
        if (left >= right)
          return;
        var pivot = keys[left + right >> 1];
        var i = left - 1;
        var j = right + 1;
        while (true) {
          do
            i++;
          while (compare(keys[i], pivot) < 0);
          do
            j--;
          while (compare(keys[j], pivot) > 0);
          if (i >= j)
            break;
          var tmp = keys[i];
          keys[i] = keys[j];
          keys[j] = tmp;
          tmp = values[i];
          values[i] = values[j];
          values[j] = tmp;
        }
        sort(keys, values, left, j, compare);
        sort(keys, values, j + 1, right, compare);
      }
      return Tree;
    });
  }
});

// node_modules/polygon-clipping/dist/polygon-clipping.cjs.js
var require_polygon_clipping_cjs = __commonJS({
  "node_modules/polygon-clipping/dist/polygon-clipping.cjs.js"(exports2, module2) {
    "use strict";
    var SplayTree = require_splay();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var SplayTree__default = /* @__PURE__ */ _interopDefaultLegacy(SplayTree);
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var isInBbox = function isInBbox2(bbox, point) {
      return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
    };
    var getBboxOverlap = function getBboxOverlap2(b1, b2) {
      if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;
      var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
      var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
      var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
      var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
      return {
        ll: {
          x: lowerX,
          y: lowerY
        },
        ur: {
          x: upperX,
          y: upperY
        }
      };
    };
    var epsilon = Number.EPSILON;
    if (epsilon === void 0) epsilon = Math.pow(2, -52);
    var EPSILON_SQ = epsilon * epsilon;
    var cmp = function cmp2(a, b) {
      if (-epsilon < a && a < epsilon) {
        if (-epsilon < b && b < epsilon) {
          return 0;
        }
      }
      var ab = a - b;
      if (ab * ab < EPSILON_SQ * a * b) {
        return 0;
      }
      return a < b ? -1 : 1;
    };
    var PtRounder = /* @__PURE__ */ function() {
      function PtRounder2() {
        _classCallCheck(this, PtRounder2);
        this.reset();
      }
      _createClass(PtRounder2, [{
        key: "reset",
        value: function reset() {
          this.xRounder = new CoordRounder();
          this.yRounder = new CoordRounder();
        }
      }, {
        key: "round",
        value: function round(x, y) {
          return {
            x: this.xRounder.round(x),
            y: this.yRounder.round(y)
          };
        }
      }]);
      return PtRounder2;
    }();
    var CoordRounder = /* @__PURE__ */ function() {
      function CoordRounder2() {
        _classCallCheck(this, CoordRounder2);
        this.tree = new SplayTree__default["default"]();
        this.round(0);
      }
      _createClass(CoordRounder2, [{
        key: "round",
        value: function round(coord) {
          var node = this.tree.add(coord);
          var prevNode = this.tree.prev(node);
          if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
            this.tree.remove(coord);
            return prevNode.key;
          }
          var nextNode = this.tree.next(node);
          if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
            this.tree.remove(coord);
            return nextNode.key;
          }
          return coord;
        }
      }]);
      return CoordRounder2;
    }();
    var rounder = new PtRounder();
    var crossProduct = function crossProduct2(a, b) {
      return a.x * b.y - a.y * b.x;
    };
    var dotProduct = function dotProduct2(a, b) {
      return a.x * b.x + a.y * b.y;
    };
    var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
      var v12 = {
        x: endPt1.x - basePt.x,
        y: endPt1.y - basePt.y
      };
      var v2 = {
        x: endPt2.x - basePt.x,
        y: endPt2.y - basePt.y
      };
      var kross = crossProduct(v12, v2);
      return cmp(kross, 0);
    };
    var length = function length2(v) {
      return Math.sqrt(dotProduct(v, v));
    };
    var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
      var vBase = {
        x: pBase.x - pShared.x,
        y: pBase.y - pShared.y
      };
      var vAngle = {
        x: pAngle.x - pShared.x,
        y: pAngle.y - pShared.y
      };
      return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };
    var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
      var vBase = {
        x: pBase.x - pShared.x,
        y: pBase.y - pShared.y
      };
      var vAngle = {
        x: pAngle.x - pShared.x,
        y: pAngle.y - pShared.y
      };
      return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };
    var horizontalIntersection = function horizontalIntersection2(pt, v, y) {
      if (v.y === 0) return null;
      return {
        x: pt.x + v.x / v.y * (y - pt.y),
        y
      };
    };
    var verticalIntersection = function verticalIntersection2(pt, v, x) {
      if (v.x === 0) return null;
      return {
        x,
        y: pt.y + v.y / v.x * (x - pt.x)
      };
    };
    var intersection = function intersection2(pt1, v12, pt2, v2) {
      if (v12.x === 0) return verticalIntersection(pt2, v2, pt1.x);
      if (v2.x === 0) return verticalIntersection(pt1, v12, pt2.x);
      if (v12.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
      if (v2.y === 0) return horizontalIntersection(pt1, v12, pt2.y);
      var kross = crossProduct(v12, v2);
      if (kross == 0) return null;
      var ve = {
        x: pt2.x - pt1.x,
        y: pt2.y - pt1.y
      };
      var d1 = crossProduct(ve, v12) / kross;
      var d2 = crossProduct(ve, v2) / kross;
      var x1 = pt1.x + d2 * v12.x, x2 = pt2.x + d1 * v2.x;
      var y1 = pt1.y + d2 * v12.y, y2 = pt2.y + d1 * v2.y;
      var x = (x1 + x2) / 2;
      var y = (y1 + y2) / 2;
      return {
        x,
        y
      };
    };
    var SweepEvent = /* @__PURE__ */ function() {
      _createClass(SweepEvent2, null, [{
        key: "compare",
        // for ordering sweep events in the sweep event queue
        value: function compare(a, b) {
          var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
          if (ptCmp !== 0) return ptCmp;
          if (a.point !== b.point) a.link(b);
          if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
          return Segment.compare(a.segment, b.segment);
        }
        // for ordering points in sweep line order
      }, {
        key: "comparePoints",
        value: function comparePoints(aPt, bPt) {
          if (aPt.x < bPt.x) return -1;
          if (aPt.x > bPt.x) return 1;
          if (aPt.y < bPt.y) return -1;
          if (aPt.y > bPt.y) return 1;
          return 0;
        }
        // Warning: 'point' input will be modified and re-used (for performance)
      }]);
      function SweepEvent2(point, isLeft) {
        _classCallCheck(this, SweepEvent2);
        if (point.events === void 0) point.events = [this];
        else point.events.push(this);
        this.point = point;
        this.isLeft = isLeft;
      }
      _createClass(SweepEvent2, [{
        key: "link",
        value: function link(other) {
          if (other.point === this.point) {
            throw new Error("Tried to link already linked events");
          }
          var otherEvents = other.point.events;
          for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
            var evt = otherEvents[i];
            this.point.events.push(evt);
            evt.point = this.point;
          }
          this.checkForConsuming();
        }
        /* Do a pass over our linked events and check to see if any pair
         * of segments match, and should be consumed. */
      }, {
        key: "checkForConsuming",
        value: function checkForConsuming() {
          var numEvents = this.point.events.length;
          for (var i = 0; i < numEvents; i++) {
            var evt1 = this.point.events[i];
            if (evt1.segment.consumedBy !== void 0) continue;
            for (var j = i + 1; j < numEvents; j++) {
              var evt2 = this.point.events[j];
              if (evt2.consumedBy !== void 0) continue;
              if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
              evt1.segment.consume(evt2.segment);
            }
          }
        }
      }, {
        key: "getAvailableLinkedEvents",
        value: function getAvailableLinkedEvents() {
          var events = [];
          for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
            var evt = this.point.events[i];
            if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
              events.push(evt);
            }
          }
          return events;
        }
        /**
         * Returns a comparator function for sorting linked events that will
         * favor the event that will give us the smallest left-side angle.
         * All ring construction starts as low as possible heading to the right,
         * so by always turning left as sharp as possible we'll get polygons
         * without uncessary loops & holes.
         *
         * The comparator function has a compute cache such that it avoids
         * re-computing already-computed values.
         */
      }, {
        key: "getLeftmostComparator",
        value: function getLeftmostComparator(baseEvent) {
          var _this = this;
          var cache = /* @__PURE__ */ new Map();
          var fillCache = function fillCache2(linkedEvent) {
            var nextEvent = linkedEvent.otherSE;
            cache.set(linkedEvent, {
              sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
              cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
            });
          };
          return function(a, b) {
            if (!cache.has(a)) fillCache(a);
            if (!cache.has(b)) fillCache(b);
            var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
            var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
            if (asine >= 0 && bsine >= 0) {
              if (acosine < bcosine) return 1;
              if (acosine > bcosine) return -1;
              return 0;
            }
            if (asine < 0 && bsine < 0) {
              if (acosine < bcosine) return -1;
              if (acosine > bcosine) return 1;
              return 0;
            }
            if (bsine < asine) return -1;
            if (bsine > asine) return 1;
            return 0;
          };
        }
      }]);
      return SweepEvent2;
    }();
    var segmentId = 0;
    var Segment = /* @__PURE__ */ function() {
      _createClass(Segment2, null, [{
        key: "compare",
        /* This compare() function is for ordering segments in the sweep
         * line tree, and does so according to the following criteria:
         *
         * Consider the vertical line that lies an infinestimal step to the
         * right of the right-more of the two left endpoints of the input
         * segments. Imagine slowly moving a point up from negative infinity
         * in the increasing y direction. Which of the two segments will that
         * point intersect first? That segment comes 'before' the other one.
         *
         * If neither segment would be intersected by such a line, (if one
         * or more of the segments are vertical) then the line to be considered
         * is directly on the right-more of the two left inputs.
         */
        value: function compare(a, b) {
          var alx = a.leftSE.point.x;
          var blx = b.leftSE.point.x;
          var arx = a.rightSE.point.x;
          var brx = b.rightSE.point.x;
          if (brx < alx) return 1;
          if (arx < blx) return -1;
          var aly = a.leftSE.point.y;
          var bly = b.leftSE.point.y;
          var ary = a.rightSE.point.y;
          var bry = b.rightSE.point.y;
          if (alx < blx) {
            if (bly < aly && bly < ary) return 1;
            if (bly > aly && bly > ary) return -1;
            var aCmpBLeft = a.comparePoint(b.leftSE.point);
            if (aCmpBLeft < 0) return 1;
            if (aCmpBLeft > 0) return -1;
            var bCmpARight = b.comparePoint(a.rightSE.point);
            if (bCmpARight !== 0) return bCmpARight;
            return -1;
          }
          if (alx > blx) {
            if (aly < bly && aly < bry) return -1;
            if (aly > bly && aly > bry) return 1;
            var bCmpALeft = b.comparePoint(a.leftSE.point);
            if (bCmpALeft !== 0) return bCmpALeft;
            var aCmpBRight = a.comparePoint(b.rightSE.point);
            if (aCmpBRight < 0) return 1;
            if (aCmpBRight > 0) return -1;
            return 1;
          }
          if (aly < bly) return -1;
          if (aly > bly) return 1;
          if (arx < brx) {
            var _bCmpARight = b.comparePoint(a.rightSE.point);
            if (_bCmpARight !== 0) return _bCmpARight;
          }
          if (arx > brx) {
            var _aCmpBRight = a.comparePoint(b.rightSE.point);
            if (_aCmpBRight < 0) return 1;
            if (_aCmpBRight > 0) return -1;
          }
          if (arx !== brx) {
            var ay = ary - aly;
            var ax = arx - alx;
            var by = bry - bly;
            var bx = brx - blx;
            if (ay > ax && by < bx) return 1;
            if (ay < ax && by > bx) return -1;
          }
          if (arx > brx) return 1;
          if (arx < brx) return -1;
          if (ary < bry) return -1;
          if (ary > bry) return 1;
          if (a.id < b.id) return -1;
          if (a.id > b.id) return 1;
          return 0;
        }
        /* Warning: a reference to ringWindings input will be stored,
         *  and possibly will be later modified */
      }]);
      function Segment2(leftSE, rightSE, rings, windings) {
        _classCallCheck(this, Segment2);
        this.id = ++segmentId;
        this.leftSE = leftSE;
        leftSE.segment = this;
        leftSE.otherSE = rightSE;
        this.rightSE = rightSE;
        rightSE.segment = this;
        rightSE.otherSE = leftSE;
        this.rings = rings;
        this.windings = windings;
      }
      _createClass(Segment2, [{
        key: "replaceRightSE",
        /* When a segment is split, the rightSE is replaced with a new sweep event */
        value: function replaceRightSE(newRightSE) {
          this.rightSE = newRightSE;
          this.rightSE.segment = this;
          this.rightSE.otherSE = this.leftSE;
          this.leftSE.otherSE = this.rightSE;
        }
      }, {
        key: "bbox",
        value: function bbox() {
          var y1 = this.leftSE.point.y;
          var y2 = this.rightSE.point.y;
          return {
            ll: {
              x: this.leftSE.point.x,
              y: y1 < y2 ? y1 : y2
            },
            ur: {
              x: this.rightSE.point.x,
              y: y1 > y2 ? y1 : y2
            }
          };
        }
        /* A vector from the left point to the right */
      }, {
        key: "vector",
        value: function vector() {
          return {
            x: this.rightSE.point.x - this.leftSE.point.x,
            y: this.rightSE.point.y - this.leftSE.point.y
          };
        }
      }, {
        key: "isAnEndpoint",
        value: function isAnEndpoint(pt) {
          return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
        }
        /* Compare this segment with a point.
         *
         * A point P is considered to be colinear to a segment if there
         * exists a distance D such that if we travel along the segment
         * from one * endpoint towards the other a distance D, we find
         * ourselves at point P.
         *
         * Return value indicates:
         *
         *   1: point lies above the segment (to the left of vertical)
         *   0: point is colinear to segment
         *  -1: point lies below the segment (to the right of vertical)
         */
      }, {
        key: "comparePoint",
        value: function comparePoint(point) {
          if (this.isAnEndpoint(point)) return 0;
          var lPt = this.leftSE.point;
          var rPt = this.rightSE.point;
          var v = this.vector();
          if (lPt.x === rPt.x) {
            if (point.x === lPt.x) return 0;
            return point.x < lPt.x ? 1 : -1;
          }
          var yDist = (point.y - lPt.y) / v.y;
          var xFromYDist = lPt.x + yDist * v.x;
          if (point.x === xFromYDist) return 0;
          var xDist = (point.x - lPt.x) / v.x;
          var yFromXDist = lPt.y + xDist * v.y;
          if (point.y === yFromXDist) return 0;
          return point.y < yFromXDist ? -1 : 1;
        }
        /**
         * Given another segment, returns the first non-trivial intersection
         * between the two segments (in terms of sweep line ordering), if it exists.
         *
         * A 'non-trivial' intersection is one that will cause one or both of the
         * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
         *
         *   * endpoint of segA with endpoint of segB --> trivial
         *   * endpoint of segA with point along segB --> non-trivial
         *   * endpoint of segB with point along segA --> non-trivial
         *   * point along segA with point along segB --> non-trivial
         *
         * If no non-trivial intersection exists, return null
         * Else, return null.
         */
      }, {
        key: "getIntersection",
        value: function getIntersection(other) {
          var tBbox = this.bbox();
          var oBbox = other.bbox();
          var bboxOverlap = getBboxOverlap(tBbox, oBbox);
          if (bboxOverlap === null) return null;
          var tlp = this.leftSE.point;
          var trp = this.rightSE.point;
          var olp = other.leftSE.point;
          var orp = other.rightSE.point;
          var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
          var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
          var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
          var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
          if (touchesThisLSE && touchesOtherLSE) {
            if (touchesThisRSE && !touchesOtherRSE) return trp;
            if (!touchesThisRSE && touchesOtherRSE) return orp;
            return null;
          }
          if (touchesThisLSE) {
            if (touchesOtherRSE) {
              if (tlp.x === orp.x && tlp.y === orp.y) return null;
            }
            return tlp;
          }
          if (touchesOtherLSE) {
            if (touchesThisRSE) {
              if (trp.x === olp.x && trp.y === olp.y) return null;
            }
            return olp;
          }
          if (touchesThisRSE && touchesOtherRSE) return null;
          if (touchesThisRSE) return trp;
          if (touchesOtherRSE) return orp;
          var pt = intersection(tlp, this.vector(), olp, other.vector());
          if (pt === null) return null;
          if (!isInBbox(bboxOverlap, pt)) return null;
          return rounder.round(pt.x, pt.y);
        }
        /**
         * Split the given segment into multiple segments on the given points.
         *  * Each existing segment will retain its leftSE and a new rightSE will be
         *    generated for it.
         *  * A new segment will be generated which will adopt the original segment's
         *    rightSE, and a new leftSE will be generated for it.
         *  * If there are more than two points given to split on, new segments
         *    in the middle will be generated with new leftSE and rightSE's.
         *  * An array of the newly generated SweepEvents will be returned.
         *
         * Warning: input array of points is modified
         */
      }, {
        key: "split",
        value: function split(point) {
          var newEvents = [];
          var alreadyLinked = point.events !== void 0;
          var newLeftSE = new SweepEvent(point, true);
          var newRightSE = new SweepEvent(point, false);
          var oldRightSE = this.rightSE;
          this.replaceRightSE(newRightSE);
          newEvents.push(newRightSE);
          newEvents.push(newLeftSE);
          var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
          if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
            newSeg.swapEvents();
          }
          if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
            this.swapEvents();
          }
          if (alreadyLinked) {
            newLeftSE.checkForConsuming();
            newRightSE.checkForConsuming();
          }
          return newEvents;
        }
        /* Swap which event is left and right */
      }, {
        key: "swapEvents",
        value: function swapEvents() {
          var tmpEvt = this.rightSE;
          this.rightSE = this.leftSE;
          this.leftSE = tmpEvt;
          this.leftSE.isLeft = true;
          this.rightSE.isLeft = false;
          for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
            this.windings[i] *= -1;
          }
        }
        /* Consume another segment. We take their rings under our wing
         * and mark them as consumed. Use for perfectly overlapping segments */
      }, {
        key: "consume",
        value: function consume(other) {
          var consumer = this;
          var consumee = other;
          while (consumer.consumedBy) {
            consumer = consumer.consumedBy;
          }
          while (consumee.consumedBy) {
            consumee = consumee.consumedBy;
          }
          var cmp2 = Segment2.compare(consumer, consumee);
          if (cmp2 === 0) return;
          if (cmp2 > 0) {
            var tmp = consumer;
            consumer = consumee;
            consumee = tmp;
          }
          if (consumer.prev === consumee) {
            var _tmp = consumer;
            consumer = consumee;
            consumee = _tmp;
          }
          for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
            var ring = consumee.rings[i];
            var winding = consumee.windings[i];
            var index2 = consumer.rings.indexOf(ring);
            if (index2 === -1) {
              consumer.rings.push(ring);
              consumer.windings.push(winding);
            } else consumer.windings[index2] += winding;
          }
          consumee.rings = null;
          consumee.windings = null;
          consumee.consumedBy = consumer;
          consumee.leftSE.consumedBy = consumer.leftSE;
          consumee.rightSE.consumedBy = consumer.rightSE;
        }
        /* The first segment previous segment chain that is in the result */
      }, {
        key: "prevInResult",
        value: function prevInResult() {
          if (this._prevInResult !== void 0) return this._prevInResult;
          if (!this.prev) this._prevInResult = null;
          else if (this.prev.isInResult()) this._prevInResult = this.prev;
          else this._prevInResult = this.prev.prevInResult();
          return this._prevInResult;
        }
      }, {
        key: "beforeState",
        value: function beforeState() {
          if (this._beforeState !== void 0) return this._beforeState;
          if (!this.prev) this._beforeState = {
            rings: [],
            windings: [],
            multiPolys: []
          };
          else {
            var seg = this.prev.consumedBy || this.prev;
            this._beforeState = seg.afterState();
          }
          return this._beforeState;
        }
      }, {
        key: "afterState",
        value: function afterState() {
          if (this._afterState !== void 0) return this._afterState;
          var beforeState = this.beforeState();
          this._afterState = {
            rings: beforeState.rings.slice(0),
            windings: beforeState.windings.slice(0),
            multiPolys: []
          };
          var ringsAfter = this._afterState.rings;
          var windingsAfter = this._afterState.windings;
          var mpsAfter = this._afterState.multiPolys;
          for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
            var ring = this.rings[i];
            var winding = this.windings[i];
            var index2 = ringsAfter.indexOf(ring);
            if (index2 === -1) {
              ringsAfter.push(ring);
              windingsAfter.push(winding);
            } else windingsAfter[index2] += winding;
          }
          var polysAfter = [];
          var polysExclude = [];
          for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
            if (windingsAfter[_i] === 0) continue;
            var _ring = ringsAfter[_i];
            var poly = _ring.poly;
            if (polysExclude.indexOf(poly) !== -1) continue;
            if (_ring.isExterior) polysAfter.push(poly);
            else {
              if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
              var _index = polysAfter.indexOf(_ring.poly);
              if (_index !== -1) polysAfter.splice(_index, 1);
            }
          }
          for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
            var mp = polysAfter[_i2].multiPoly;
            if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
          }
          return this._afterState;
        }
        /* Is this segment part of the final result? */
      }, {
        key: "isInResult",
        value: function isInResult() {
          if (this.consumedBy) return false;
          if (this._isInResult !== void 0) return this._isInResult;
          var mpsBefore = this.beforeState().multiPolys;
          var mpsAfter = this.afterState().multiPolys;
          switch (operation.type) {
            case "union": {
              var noBefores = mpsBefore.length === 0;
              var noAfters = mpsAfter.length === 0;
              this._isInResult = noBefores !== noAfters;
              break;
            }
            case "intersection": {
              var least;
              var most;
              if (mpsBefore.length < mpsAfter.length) {
                least = mpsBefore.length;
                most = mpsAfter.length;
              } else {
                least = mpsAfter.length;
                most = mpsBefore.length;
              }
              this._isInResult = most === operation.numMultiPolys && least < most;
              break;
            }
            case "xor": {
              var diff = Math.abs(mpsBefore.length - mpsAfter.length);
              this._isInResult = diff % 2 === 1;
              break;
            }
            case "difference": {
              var isJustSubject = function isJustSubject2(mps) {
                return mps.length === 1 && mps[0].isSubject;
              };
              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
              break;
            }
            default:
              throw new Error("Unrecognized operation type found ".concat(operation.type));
          }
          return this._isInResult;
        }
      }], [{
        key: "fromRing",
        value: function fromRing(pt1, pt2, ring) {
          var leftPt, rightPt, winding;
          var cmpPts = SweepEvent.comparePoints(pt1, pt2);
          if (cmpPts < 0) {
            leftPt = pt1;
            rightPt = pt2;
            winding = 1;
          } else if (cmpPts > 0) {
            leftPt = pt2;
            rightPt = pt1;
            winding = -1;
          } else throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
          var leftSE = new SweepEvent(leftPt, true);
          var rightSE = new SweepEvent(rightPt, false);
          return new Segment2(leftSE, rightSE, [ring], [winding]);
        }
      }]);
      return Segment2;
    }();
    var RingIn = /* @__PURE__ */ function() {
      function RingIn2(geomRing, poly, isExterior) {
        _classCallCheck(this, RingIn2);
        if (!Array.isArray(geomRing) || geomRing.length === 0) {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.poly = poly;
        this.isExterior = isExterior;
        this.segments = [];
        if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
        this.bbox = {
          ll: {
            x: firstPoint.x,
            y: firstPoint.y
          },
          ur: {
            x: firstPoint.x,
            y: firstPoint.y
          }
        };
        var prevPoint = firstPoint;
        for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
          if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          }
          var point = rounder.round(geomRing[i][0], geomRing[i][1]);
          if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
          this.segments.push(Segment.fromRing(prevPoint, point, this));
          if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
          if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
          if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
          if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
          prevPoint = point;
        }
        if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
          this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
        }
      }
      _createClass(RingIn2, [{
        key: "getSweepEvents",
        value: function getSweepEvents() {
          var sweepEvents = [];
          for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
            var segment = this.segments[i];
            sweepEvents.push(segment.leftSE);
            sweepEvents.push(segment.rightSE);
          }
          return sweepEvents;
        }
      }]);
      return RingIn2;
    }();
    var PolyIn = /* @__PURE__ */ function() {
      function PolyIn2(geomPoly, multiPoly) {
        _classCallCheck(this, PolyIn2);
        if (!Array.isArray(geomPoly)) {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.exteriorRing = new RingIn(geomPoly[0], this, true);
        this.bbox = {
          ll: {
            x: this.exteriorRing.bbox.ll.x,
            y: this.exteriorRing.bbox.ll.y
          },
          ur: {
            x: this.exteriorRing.bbox.ur.x,
            y: this.exteriorRing.bbox.ur.y
          }
        };
        this.interiorRings = [];
        for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
          var ring = new RingIn(geomPoly[i], this, false);
          if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
          if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
          if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
          if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
          this.interiorRings.push(ring);
        }
        this.multiPoly = multiPoly;
      }
      _createClass(PolyIn2, [{
        key: "getSweepEvents",
        value: function getSweepEvents() {
          var sweepEvents = this.exteriorRing.getSweepEvents();
          for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
            var ringSweepEvents = this.interiorRings[i].getSweepEvents();
            for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
              sweepEvents.push(ringSweepEvents[j]);
            }
          }
          return sweepEvents;
        }
      }]);
      return PolyIn2;
    }();
    var MultiPolyIn = /* @__PURE__ */ function() {
      function MultiPolyIn2(geom, isSubject) {
        _classCallCheck(this, MultiPolyIn2);
        if (!Array.isArray(geom)) {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        try {
          if (typeof geom[0][0][0] === "number") geom = [geom];
        } catch (ex) {
        }
        this.polys = [];
        this.bbox = {
          ll: {
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
          },
          ur: {
            x: Number.NEGATIVE_INFINITY,
            y: Number.NEGATIVE_INFINITY
          }
        };
        for (var i = 0, iMax = geom.length; i < iMax; i++) {
          var poly = new PolyIn(geom[i], this);
          if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
          if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
          if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
          if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
          this.polys.push(poly);
        }
        this.isSubject = isSubject;
      }
      _createClass(MultiPolyIn2, [{
        key: "getSweepEvents",
        value: function getSweepEvents() {
          var sweepEvents = [];
          for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
            var polySweepEvents = this.polys[i].getSweepEvents();
            for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
              sweepEvents.push(polySweepEvents[j]);
            }
          }
          return sweepEvents;
        }
      }]);
      return MultiPolyIn2;
    }();
    var RingOut = /* @__PURE__ */ function() {
      _createClass(RingOut2, null, [{
        key: "factory",
        /* Given the segments from the sweep line pass, compute & return a series
         * of closed rings from all the segments marked to be part of the result */
        value: function factory(allSegments) {
          var ringsOut = [];
          for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
            var segment = allSegments[i];
            if (!segment.isInResult() || segment.ringOut) continue;
            var prevEvent = null;
            var event = segment.leftSE;
            var nextEvent = segment.rightSE;
            var events = [event];
            var startingPoint = event.point;
            var intersectionLEs = [];
            while (true) {
              prevEvent = event;
              event = nextEvent;
              events.push(event);
              if (event.point === startingPoint) break;
              while (true) {
                var availableLEs = event.getAvailableLinkedEvents();
                if (availableLEs.length === 0) {
                  var firstPt = events[0].point;
                  var lastPt = events[events.length - 1].point;
                  throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                }
                if (availableLEs.length === 1) {
                  nextEvent = availableLEs[0].otherSE;
                  break;
                }
                var indexLE = null;
                for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                  if (intersectionLEs[j].point === event.point) {
                    indexLE = j;
                    break;
                  }
                }
                if (indexLE !== null) {
                  var intersectionLE = intersectionLEs.splice(indexLE)[0];
                  var ringEvents = events.splice(intersectionLE.index);
                  ringEvents.unshift(ringEvents[0].otherSE);
                  ringsOut.push(new RingOut2(ringEvents.reverse()));
                  continue;
                }
                intersectionLEs.push({
                  index: events.length,
                  point: event.point
                });
                var comparator = event.getLeftmostComparator(prevEvent);
                nextEvent = availableLEs.sort(comparator)[0].otherSE;
                break;
              }
            }
            ringsOut.push(new RingOut2(events));
          }
          return ringsOut;
        }
      }]);
      function RingOut2(events) {
        _classCallCheck(this, RingOut2);
        this.events = events;
        for (var i = 0, iMax = events.length; i < iMax; i++) {
          events[i].segment.ringOut = this;
        }
        this.poly = null;
      }
      _createClass(RingOut2, [{
        key: "getGeom",
        value: function getGeom() {
          var prevPt = this.events[0].point;
          var points = [prevPt];
          for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
            var _pt = this.events[i].point;
            var _nextPt = this.events[i + 1].point;
            if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;
            points.push(_pt);
            prevPt = _pt;
          }
          if (points.length === 1) return null;
          var pt = points[0];
          var nextPt = points[1];
          if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
          points.push(points[0]);
          var step = this.isExteriorRing() ? 1 : -1;
          var iStart = this.isExteriorRing() ? 0 : points.length - 1;
          var iEnd = this.isExteriorRing() ? points.length : -1;
          var orderedPoints = [];
          for (var _i = iStart; _i != iEnd; _i += step) {
            orderedPoints.push([points[_i].x, points[_i].y]);
          }
          return orderedPoints;
        }
      }, {
        key: "isExteriorRing",
        value: function isExteriorRing() {
          if (this._isExteriorRing === void 0) {
            var enclosing = this.enclosingRing();
            this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
          }
          return this._isExteriorRing;
        }
      }, {
        key: "enclosingRing",
        value: function enclosingRing() {
          if (this._enclosingRing === void 0) {
            this._enclosingRing = this._calcEnclosingRing();
          }
          return this._enclosingRing;
        }
        /* Returns the ring that encloses this one, if any */
      }, {
        key: "_calcEnclosingRing",
        value: function _calcEnclosingRing() {
          var leftMostEvt = this.events[0];
          for (var i = 1, iMax = this.events.length; i < iMax; i++) {
            var evt = this.events[i];
            if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
          }
          var prevSeg = leftMostEvt.segment.prevInResult();
          var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
          while (true) {
            if (!prevSeg) return null;
            if (!prevPrevSeg) return prevSeg.ringOut;
            if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
              if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                return prevSeg.ringOut;
              } else return prevSeg.ringOut.enclosingRing();
            }
            prevSeg = prevPrevSeg.prevInResult();
            prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
          }
        }
      }]);
      return RingOut2;
    }();
    var PolyOut = /* @__PURE__ */ function() {
      function PolyOut2(exteriorRing) {
        _classCallCheck(this, PolyOut2);
        this.exteriorRing = exteriorRing;
        exteriorRing.poly = this;
        this.interiorRings = [];
      }
      _createClass(PolyOut2, [{
        key: "addInterior",
        value: function addInterior(ring) {
          this.interiorRings.push(ring);
          ring.poly = this;
        }
      }, {
        key: "getGeom",
        value: function getGeom() {
          var geom = [this.exteriorRing.getGeom()];
          if (geom[0] === null) return null;
          for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
            var ringGeom = this.interiorRings[i].getGeom();
            if (ringGeom === null) continue;
            geom.push(ringGeom);
          }
          return geom;
        }
      }]);
      return PolyOut2;
    }();
    var MultiPolyOut = /* @__PURE__ */ function() {
      function MultiPolyOut2(rings) {
        _classCallCheck(this, MultiPolyOut2);
        this.rings = rings;
        this.polys = this._composePolys(rings);
      }
      _createClass(MultiPolyOut2, [{
        key: "getGeom",
        value: function getGeom() {
          var geom = [];
          for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
            var polyGeom = this.polys[i].getGeom();
            if (polyGeom === null) continue;
            geom.push(polyGeom);
          }
          return geom;
        }
      }, {
        key: "_composePolys",
        value: function _composePolys(rings) {
          var polys = [];
          for (var i = 0, iMax = rings.length; i < iMax; i++) {
            var ring = rings[i];
            if (ring.poly) continue;
            if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
            else {
              var enclosingRing = ring.enclosingRing();
              if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
              enclosingRing.poly.addInterior(ring);
            }
          }
          return polys;
        }
      }]);
      return MultiPolyOut2;
    }();
    var SweepLine = /* @__PURE__ */ function() {
      function SweepLine2(queue) {
        var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
        _classCallCheck(this, SweepLine2);
        this.queue = queue;
        this.tree = new SplayTree__default["default"](comparator);
        this.segments = [];
      }
      _createClass(SweepLine2, [{
        key: "process",
        value: function process2(event) {
          var segment = event.segment;
          var newEvents = [];
          if (event.consumedBy) {
            if (event.isLeft) this.queue.remove(event.otherSE);
            else this.tree.remove(segment);
            return newEvents;
          }
          var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
          if (!node) throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
          var prevNode = node;
          var nextNode = node;
          var prevSeg = void 0;
          var nextSeg = void 0;
          while (prevSeg === void 0) {
            prevNode = this.tree.prev(prevNode);
            if (prevNode === null) prevSeg = null;
            else if (prevNode.key.consumedBy === void 0) prevSeg = prevNode.key;
          }
          while (nextSeg === void 0) {
            nextNode = this.tree.next(nextNode);
            if (nextNode === null) nextSeg = null;
            else if (nextNode.key.consumedBy === void 0) nextSeg = nextNode.key;
          }
          if (event.isLeft) {
            var prevMySplitter = null;
            if (prevSeg) {
              var prevInter = prevSeg.getIntersection(segment);
              if (prevInter !== null) {
                if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
                if (!prevSeg.isAnEndpoint(prevInter)) {
                  var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                  for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                    newEvents.push(newEventsFromSplit[i]);
                  }
                }
              }
            }
            var nextMySplitter = null;
            if (nextSeg) {
              var nextInter = nextSeg.getIntersection(segment);
              if (nextInter !== null) {
                if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
                if (!nextSeg.isAnEndpoint(nextInter)) {
                  var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                  for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                    newEvents.push(_newEventsFromSplit[_i]);
                  }
                }
              }
            }
            if (prevMySplitter !== null || nextMySplitter !== null) {
              var mySplitter = null;
              if (prevMySplitter === null) mySplitter = nextMySplitter;
              else if (nextMySplitter === null) mySplitter = prevMySplitter;
              else {
                var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
              }
              this.queue.remove(segment.rightSE);
              newEvents.push(segment.rightSE);
              var _newEventsFromSplit2 = segment.split(mySplitter);
              for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                newEvents.push(_newEventsFromSplit2[_i2]);
              }
            }
            if (newEvents.length > 0) {
              this.tree.remove(segment);
              newEvents.push(event);
            } else {
              this.segments.push(segment);
              segment.prev = prevSeg;
            }
          } else {
            if (prevSeg && nextSeg) {
              var inter = prevSeg.getIntersection(nextSeg);
              if (inter !== null) {
                if (!prevSeg.isAnEndpoint(inter)) {
                  var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
                  for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                    newEvents.push(_newEventsFromSplit3[_i3]);
                  }
                }
                if (!nextSeg.isAnEndpoint(inter)) {
                  var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
                  for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                    newEvents.push(_newEventsFromSplit4[_i4]);
                  }
                }
              }
            }
            this.tree.remove(segment);
          }
          return newEvents;
        }
        /* Safely split a segment that is currently in the datastructures
         * IE - a segment other than the one that is currently being processed. */
      }, {
        key: "_splitSafely",
        value: function _splitSafely(seg, pt) {
          this.tree.remove(seg);
          var rightSE = seg.rightSE;
          this.queue.remove(rightSE);
          var newEvents = seg.split(pt);
          newEvents.push(rightSE);
          if (seg.consumedBy === void 0) this.tree.insert(seg);
          return newEvents;
        }
      }]);
      return SweepLine2;
    }();
    var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
    var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
    var Operation = /* @__PURE__ */ function() {
      function Operation2() {
        _classCallCheck(this, Operation2);
      }
      _createClass(Operation2, [{
        key: "run",
        value: function run(type, geom, moreGeoms) {
          operation.type = type;
          rounder.reset();
          var multipolys = [new MultiPolyIn(geom, true)];
          for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
            multipolys.push(new MultiPolyIn(moreGeoms[i], false));
          }
          operation.numMultiPolys = multipolys.length;
          if (operation.type === "difference") {
            var subject = multipolys[0];
            var _i = 1;
            while (_i < multipolys.length) {
              if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;
              else multipolys.splice(_i, 1);
            }
          }
          if (operation.type === "intersection") {
            for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
              var mpA = multipolys[_i2];
              for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
              }
            }
          }
          var queue = new SplayTree__default["default"](SweepEvent.compare);
          for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
            var sweepEvents = multipolys[_i3].getSweepEvents();
            for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
              queue.insert(sweepEvents[_j]);
              if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
              }
            }
          }
          var sweepLine = new SweepLine(queue);
          var prevQueueSize = queue.size;
          var node = queue.pop();
          while (node) {
            var evt = node.key;
            if (queue.size === prevQueueSize) {
              var seg = evt.segment;
              throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
            }
            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
              throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
            }
            if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
              throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
            }
            var newEvents = sweepLine.process(evt);
            for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
              var _evt = newEvents[_i4];
              if (_evt.consumedBy === void 0) queue.insert(_evt);
            }
            prevQueueSize = queue.size;
            node = queue.pop();
          }
          rounder.reset();
          var ringsOut = RingOut.factory(sweepLine.segments);
          var result2 = new MultiPolyOut(ringsOut);
          return result2.getGeom();
        }
      }]);
      return Operation2;
    }();
    var operation = new Operation();
    var union = function union2(geom) {
      for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        moreGeoms[_key - 1] = arguments[_key];
      }
      return operation.run("union", geom, moreGeoms);
    };
    var intersection$1 = function intersection2(geom) {
      for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        moreGeoms[_key2 - 1] = arguments[_key2];
      }
      return operation.run("intersection", geom, moreGeoms);
    };
    var xor = function xor2(geom) {
      for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        moreGeoms[_key3 - 1] = arguments[_key3];
      }
      return operation.run("xor", geom, moreGeoms);
    };
    var difference = function difference2(subjectGeom) {
      for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        clippingGeoms[_key4 - 1] = arguments[_key4];
      }
      return operation.run("difference", subjectGeom, clippingGeoms);
    };
    var index = {
      union,
      intersection: intersection$1,
      xor,
      difference
    };
    module2.exports = index;
  }
});

// node_modules/@turf/difference/dist/js/index.js
var require_js96 = __commonJS({
  "node_modules/@turf/difference/dist/js/index.js"(exports2, module2) {
    "use strict";
    var polygonClipping = require_polygon_clipping_cjs();
    var helpers = require_js();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var polygonClipping__default = /* @__PURE__ */ _interopDefaultLegacy(polygonClipping);
    function difference(polygon1, polygon2) {
      var geom1 = invariant.getGeom(polygon1);
      var geom2 = invariant.getGeom(polygon2);
      var properties = polygon1.properties || {};
      var differenced = polygonClipping__default["default"].difference(
        geom1.coordinates,
        geom2.coordinates
      );
      if (differenced.length === 0) return null;
      if (differenced.length === 1) return helpers.polygon(differenced[0], properties);
      return helpers.multiPolygon(differenced, properties);
    }
    module2.exports = difference;
    module2.exports.default = difference;
  }
});

// node_modules/turf-jsts/jsts.js
var require_jsts = __commonJS({
  "node_modules/turf-jsts/jsts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    if (!("fill" in Array.prototype)) {
      Object.defineProperty(Array.prototype, "fill", {
        configurable: true,
        value: function fill(value) {
          if (this === void 0 || this === null) {
            throw new TypeError(this + " is not an object");
          }
          var arrayLike = Object(this);
          var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;
          var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
          relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);
          var relativeEnd = 2 in arguments && arguments[2] !== void 0 ? parseInt(Number(arguments[2]), 10) || 0 : length;
          relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);
          while (relativeStart < relativeEnd) {
            arrayLike[relativeStart] = value;
            ++relativeStart;
          }
          return arrayLike;
        },
        writable: true
      });
    }
    Number.isFinite = Number.isFinite || function(value) {
      return typeof value === "number" && isFinite(value);
    };
    Number.isInteger = Number.isInteger || function(val) {
      return typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    };
    Number.parseFloat = Number.parseFloat || parseFloat;
    Number.isNaN = Number.isNaN || function(value) {
      return value !== value;
    };
    Math.trunc = Math.trunc || function(x) {
      return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
    var NumberUtil = function NumberUtil2() {
    };
    NumberUtil.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    NumberUtil.prototype.getClass = function getClass() {
      return NumberUtil;
    };
    NumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance(x1, x2, tolerance) {
      return Math.abs(x1 - x2) <= tolerance;
    };
    var IllegalArgumentException = function(Error2) {
      function IllegalArgumentException2(message) {
        Error2.call(this, message);
        this.name = "IllegalArgumentException";
        this.message = message;
        this.stack = new Error2().stack;
      }
      if (Error2) IllegalArgumentException2.__proto__ = Error2;
      IllegalArgumentException2.prototype = Object.create(Error2 && Error2.prototype);
      IllegalArgumentException2.prototype.constructor = IllegalArgumentException2;
      return IllegalArgumentException2;
    }(Error);
    var Double = function Double2() {
    };
    var staticAccessors$1 = { MAX_VALUE: { configurable: true } };
    Double.isNaN = function isNaN2(n) {
      return Number.isNaN(n);
    };
    Double.doubleToLongBits = function doubleToLongBits(n) {
      return n;
    };
    Double.longBitsToDouble = function longBitsToDouble(n) {
      return n;
    };
    Double.isInfinite = function isInfinite(n) {
      return !Number.isFinite(n);
    };
    staticAccessors$1.MAX_VALUE.get = function() {
      return Number.MAX_VALUE;
    };
    Object.defineProperties(Double, staticAccessors$1);
    var Comparable = function Comparable2() {
    };
    var Clonable = function Clonable2() {
    };
    var Comparator = function Comparator2() {
    };
    function Serializable() {
    }
    var Coordinate = function Coordinate2() {
      this.x = null;
      this.y = null;
      this.z = null;
      if (arguments.length === 0) {
        this.x = 0;
        this.y = 0;
        this.z = Coordinate2.NULL_ORDINATE;
      } else if (arguments.length === 1) {
        var c = arguments[0];
        this.x = c.x;
        this.y = c.y;
        this.z = c.z;
      } else if (arguments.length === 2) {
        this.x = arguments[0];
        this.y = arguments[1];
        this.z = Coordinate2.NULL_ORDINATE;
      } else if (arguments.length === 3) {
        this.x = arguments[0];
        this.y = arguments[1];
        this.z = arguments[2];
      }
    };
    var staticAccessors = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
    Coordinate.prototype.setOrdinate = function setOrdinate(ordinateIndex, value) {
      switch (ordinateIndex) {
        case Coordinate.X:
          this.x = value;
          break;
        case Coordinate.Y:
          this.y = value;
          break;
        case Coordinate.Z:
          this.z = value;
          break;
        default:
          throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
      }
    };
    Coordinate.prototype.equals2D = function equals2D() {
      if (arguments.length === 1) {
        var other = arguments[0];
        if (this.x !== other.x) {
          return false;
        }
        if (this.y !== other.y) {
          return false;
        }
        return true;
      } else if (arguments.length === 2) {
        var c = arguments[0];
        var tolerance = arguments[1];
        if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
          return false;
        }
        if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
          return false;
        }
        return true;
      }
    };
    Coordinate.prototype.getOrdinate = function getOrdinate(ordinateIndex) {
      switch (ordinateIndex) {
        case Coordinate.X:
          return this.x;
        case Coordinate.Y:
          return this.y;
        case Coordinate.Z:
          return this.z;
        default:
      }
      throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
    };
    Coordinate.prototype.equals3D = function equals3D(other) {
      return this.x === other.x && this.y === other.y && ((this.z === other.z || Double.isNaN(this.z)) && Double.isNaN(other.z));
    };
    Coordinate.prototype.equals = function equals(other) {
      if (!(other instanceof Coordinate)) {
        return false;
      }
      return this.equals2D(other);
    };
    Coordinate.prototype.equalInZ = function equalInZ(c, tolerance) {
      return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);
    };
    Coordinate.prototype.compareTo = function compareTo(o) {
      var other = o;
      if (this.x < other.x) {
        return -1;
      }
      if (this.x > other.x) {
        return 1;
      }
      if (this.y < other.y) {
        return -1;
      }
      if (this.y > other.y) {
        return 1;
      }
      return 0;
    };
    Coordinate.prototype.clone = function clone() {
    };
    Coordinate.prototype.copy = function copy() {
      return new Coordinate(this);
    };
    Coordinate.prototype.toString = function toString() {
      return "(" + this.x + ", " + this.y + ", " + this.z + ")";
    };
    Coordinate.prototype.distance3D = function distance3D(c) {
      var dx = this.x - c.x;
      var dy = this.y - c.y;
      var dz = this.z - c.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };
    Coordinate.prototype.distance = function distance(c) {
      var dx = this.x - c.x;
      var dy = this.y - c.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    Coordinate.prototype.hashCode = function hashCode() {
      var result2 = 17;
      result2 = 37 * result2 + Coordinate.hashCode(this.x);
      result2 = 37 * result2 + Coordinate.hashCode(this.y);
      return result2;
    };
    Coordinate.prototype.setCoordinate = function setCoordinate(other) {
      this.x = other.x;
      this.y = other.y;
      this.z = other.z;
    };
    Coordinate.prototype.interfaces_ = function interfaces_() {
      return [Comparable, Clonable, Serializable];
    };
    Coordinate.prototype.getClass = function getClass() {
      return Coordinate;
    };
    Coordinate.hashCode = function hashCode() {
      if (arguments.length === 1) {
        var x = arguments[0];
        var f = Double.doubleToLongBits(x);
        return Math.trunc((f ^ f) >>> 32);
      }
    };
    staticAccessors.DimensionalComparator.get = function() {
      return DimensionalComparator;
    };
    staticAccessors.serialVersionUID.get = function() {
      return 6683108902428367e3;
    };
    staticAccessors.NULL_ORDINATE.get = function() {
      return Double.NaN;
    };
    staticAccessors.X.get = function() {
      return 0;
    };
    staticAccessors.Y.get = function() {
      return 1;
    };
    staticAccessors.Z.get = function() {
      return 2;
    };
    Object.defineProperties(Coordinate, staticAccessors);
    var DimensionalComparator = function DimensionalComparator2(dimensionsToTest) {
      this._dimensionsToTest = 2;
      if (arguments.length === 0) {
      } else if (arguments.length === 1) {
        var dimensionsToTest$1 = arguments[0];
        if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) {
          throw new IllegalArgumentException("only 2 or 3 dimensions may be specified");
        }
        this._dimensionsToTest = dimensionsToTest$1;
      }
    };
    DimensionalComparator.prototype.compare = function compare(o1, o2) {
      var c1 = o1;
      var c2 = o2;
      var compX = DimensionalComparator.compare(c1.x, c2.x);
      if (compX !== 0) {
        return compX;
      }
      var compY = DimensionalComparator.compare(c1.y, c2.y);
      if (compY !== 0) {
        return compY;
      }
      if (this._dimensionsToTest <= 2) {
        return 0;
      }
      var compZ = DimensionalComparator.compare(c1.z, c2.z);
      return compZ;
    };
    DimensionalComparator.prototype.interfaces_ = function interfaces_() {
      return [Comparator];
    };
    DimensionalComparator.prototype.getClass = function getClass() {
      return DimensionalComparator;
    };
    DimensionalComparator.compare = function compare(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      if (Double.isNaN(a)) {
        if (Double.isNaN(b)) {
          return 0;
        }
        return -1;
      }
      if (Double.isNaN(b)) {
        return 1;
      }
      return 0;
    };
    var CoordinateSequenceFactory = function CoordinateSequenceFactory2() {
    };
    CoordinateSequenceFactory.prototype.create = function create() {
    };
    CoordinateSequenceFactory.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CoordinateSequenceFactory.prototype.getClass = function getClass() {
      return CoordinateSequenceFactory;
    };
    var Location = function Location2() {
    };
    var staticAccessors$4 = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
    Location.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Location.prototype.getClass = function getClass() {
      return Location;
    };
    Location.toLocationSymbol = function toLocationSymbol(locationValue) {
      switch (locationValue) {
        case Location.EXTERIOR:
          return "e";
        case Location.BOUNDARY:
          return "b";
        case Location.INTERIOR:
          return "i";
        case Location.NONE:
          return "-";
        default:
      }
      throw new IllegalArgumentException("Unknown location value: " + locationValue);
    };
    staticAccessors$4.INTERIOR.get = function() {
      return 0;
    };
    staticAccessors$4.BOUNDARY.get = function() {
      return 1;
    };
    staticAccessors$4.EXTERIOR.get = function() {
      return 2;
    };
    staticAccessors$4.NONE.get = function() {
      return -1;
    };
    Object.defineProperties(Location, staticAccessors$4);
    var hasInterface = function(o, i) {
      return o.interfaces_ && o.interfaces_().indexOf(i) > -1;
    };
    var MathUtil = function MathUtil2() {
    };
    var staticAccessors$5 = { LOG_10: { configurable: true } };
    MathUtil.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MathUtil.prototype.getClass = function getClass() {
      return MathUtil;
    };
    MathUtil.log10 = function log10(x) {
      var ln = Math.log(x);
      if (Double.isInfinite(ln)) {
        return ln;
      }
      if (Double.isNaN(ln)) {
        return ln;
      }
      return ln / MathUtil.LOG_10;
    };
    MathUtil.min = function min(v12, v2, v32, v42) {
      var min2 = v12;
      if (v2 < min2) {
        min2 = v2;
      }
      if (v32 < min2) {
        min2 = v32;
      }
      if (v42 < min2) {
        min2 = v42;
      }
      return min2;
    };
    MathUtil.clamp = function clamp() {
      if (typeof arguments[2] === "number" && (typeof arguments[0] === "number" && typeof arguments[1] === "number")) {
        var x = arguments[0];
        var min = arguments[1];
        var max = arguments[2];
        if (x < min) {
          return min;
        }
        if (x > max) {
          return max;
        }
        return x;
      } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
        var x$1 = arguments[0];
        var min$1 = arguments[1];
        var max$1 = arguments[2];
        if (x$1 < min$1) {
          return min$1;
        }
        if (x$1 > max$1) {
          return max$1;
        }
        return x$1;
      }
    };
    MathUtil.wrap = function wrap(index, max) {
      if (index < 0) {
        return max - -index % max;
      }
      return index % max;
    };
    MathUtil.max = function max() {
      if (arguments.length === 3) {
        var v12 = arguments[0];
        var v2 = arguments[1];
        var v32 = arguments[2];
        var max2 = v12;
        if (v2 > max2) {
          max2 = v2;
        }
        if (v32 > max2) {
          max2 = v32;
        }
        return max2;
      } else if (arguments.length === 4) {
        var v1$1 = arguments[0];
        var v2$1 = arguments[1];
        var v3$1 = arguments[2];
        var v42 = arguments[3];
        var max$1 = v1$1;
        if (v2$1 > max$1) {
          max$1 = v2$1;
        }
        if (v3$1 > max$1) {
          max$1 = v3$1;
        }
        if (v42 > max$1) {
          max$1 = v42;
        }
        return max$1;
      }
    };
    MathUtil.average = function average(x1, x2) {
      return (x1 + x2) / 2;
    };
    staticAccessors$5.LOG_10.get = function() {
      return Math.log(10);
    };
    Object.defineProperties(MathUtil, staticAccessors$5);
    var StringBuffer = function StringBuffer2(str) {
      this.str = str;
    };
    StringBuffer.prototype.append = function append(e) {
      this.str += e;
    };
    StringBuffer.prototype.setCharAt = function setCharAt(i, c) {
      this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
    };
    StringBuffer.prototype.toString = function toString(e) {
      return this.str;
    };
    var Integer = function Integer2(value) {
      this.value = value;
    };
    Integer.prototype.intValue = function intValue() {
      return this.value;
    };
    Integer.prototype.compareTo = function compareTo(o) {
      if (this.value < o) {
        return -1;
      }
      if (this.value > o) {
        return 1;
      }
      return 0;
    };
    Integer.isNaN = function isNaN2(n) {
      return Number.isNaN(n);
    };
    var Character = function Character2() {
    };
    Character.isWhitespace = function isWhitespace(c) {
      return c <= 32 && c >= 0 || c === 127;
    };
    Character.toUpperCase = function toUpperCase(c) {
      return c.toUpperCase();
    };
    var DD = function DD2() {
      this._hi = 0;
      this._lo = 0;
      if (arguments.length === 0) {
        this.init(0);
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === "number") {
          var x = arguments[0];
          this.init(x);
        } else if (arguments[0] instanceof DD2) {
          var dd = arguments[0];
          this.init(dd);
        } else if (typeof arguments[0] === "string") {
          var str = arguments[0];
          DD2.call(this, DD2.parse(str));
        }
      } else if (arguments.length === 2) {
        var hi = arguments[0];
        var lo = arguments[1];
        this.init(hi, lo);
      }
    };
    var staticAccessors$7 = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
    DD.prototype.le = function le(y) {
      return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo;
    };
    DD.prototype.extractSignificantDigits = function extractSignificantDigits(insertDecimalPoint, magnitude) {
      var y = this.abs();
      var mag = DD.magnitude(y._hi);
      var scale = DD.TEN.pow(mag);
      y = y.divide(scale);
      if (y.gt(DD.TEN)) {
        y = y.divide(DD.TEN);
        mag += 1;
      } else if (y.lt(DD.ONE)) {
        y = y.multiply(DD.TEN);
        mag -= 1;
      }
      var decimalPointPos = mag + 1;
      var buf = new StringBuffer();
      var numDigits = DD.MAX_PRINT_DIGITS - 1;
      for (var i = 0; i <= numDigits; i++) {
        if (insertDecimalPoint && i === decimalPointPos) {
          buf.append(".");
        }
        var digit = Math.trunc(y._hi);
        if (digit < 0) {
          break;
        }
        var rebiasBy10 = false;
        var digitChar = 0;
        if (digit > 9) {
          rebiasBy10 = true;
          digitChar = "9";
        } else {
          digitChar = "0" + digit;
        }
        buf.append(digitChar);
        y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
        if (rebiasBy10) {
          y.selfAdd(DD.TEN);
        }
        var continueExtractingDigits = true;
        var remMag = DD.magnitude(y._hi);
        if (remMag < 0 && Math.abs(remMag) >= numDigits - i) {
          continueExtractingDigits = false;
        }
        if (!continueExtractingDigits) {
          break;
        }
      }
      magnitude[0] = mag;
      return buf.toString();
    };
    DD.prototype.sqr = function sqr() {
      return this.multiply(this);
    };
    DD.prototype.doubleValue = function doubleValue() {
      return this._hi + this._lo;
    };
    DD.prototype.subtract = function subtract() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        return this.add(y.negate());
      } else if (typeof arguments[0] === "number") {
        var y$1 = arguments[0];
        return this.add(-y$1);
      }
    };
    DD.prototype.equals = function equals() {
      if (arguments.length === 1) {
        var y = arguments[0];
        return this._hi === y._hi && this._lo === y._lo;
      }
    };
    DD.prototype.isZero = function isZero() {
      return this._hi === 0 && this._lo === 0;
    };
    DD.prototype.selfSubtract = function selfSubtract() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        if (this.isNaN()) {
          return this;
        }
        return this.selfAdd(-y._hi, -y._lo);
      } else if (typeof arguments[0] === "number") {
        var y$1 = arguments[0];
        if (this.isNaN()) {
          return this;
        }
        return this.selfAdd(-y$1, 0);
      }
    };
    DD.prototype.getSpecialNumberString = function getSpecialNumberString() {
      if (this.isZero()) {
        return "0.0";
      }
      if (this.isNaN()) {
        return "NaN ";
      }
      return null;
    };
    DD.prototype.min = function min(x) {
      if (this.le(x)) {
        return this;
      } else {
        return x;
      }
    };
    DD.prototype.selfDivide = function selfDivide() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof DD) {
          var y = arguments[0];
          return this.selfDivide(y._hi, y._lo);
        } else if (typeof arguments[0] === "number") {
          var y$1 = arguments[0];
          return this.selfDivide(y$1, 0);
        }
      } else if (arguments.length === 2) {
        var yhi = arguments[0];
        var ylo = arguments[1];
        var hc = null;
        var tc = null;
        var hy = null;
        var ty = null;
        var C = null;
        var c = null;
        var U = null;
        var u = null;
        C = this._hi / yhi;
        c = DD.SPLIT * C;
        hc = c - C;
        u = DD.SPLIT * yhi;
        hc = c - hc;
        tc = C - hc;
        hy = u - yhi;
        U = C * yhi;
        hy = u - hy;
        ty = yhi - hy;
        u = hc * hy - U + hc * ty + tc * hy + tc * ty;
        c = (this._hi - U - u + this._lo - C * ylo) / yhi;
        u = C + c;
        this._hi = u;
        this._lo = C - u + c;
        return this;
      }
    };
    DD.prototype.dump = function dump() {
      return "DD<" + this._hi + ", " + this._lo + ">";
    };
    DD.prototype.divide = function divide() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        var hc = null;
        var tc = null;
        var hy = null;
        var ty = null;
        var C = null;
        var c = null;
        var U = null;
        var u = null;
        C = this._hi / y._hi;
        c = DD.SPLIT * C;
        hc = c - C;
        u = DD.SPLIT * y._hi;
        hc = c - hc;
        tc = C - hc;
        hy = u - y._hi;
        U = C * y._hi;
        hy = u - hy;
        ty = y._hi - hy;
        u = hc * hy - U + hc * ty + tc * hy + tc * ty;
        c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
        u = C + c;
        var zhi = u;
        var zlo = C - u + c;
        return new DD(zhi, zlo);
      } else if (typeof arguments[0] === "number") {
        var y$1 = arguments[0];
        if (Double.isNaN(y$1)) {
          return DD.createNaN();
        }
        return DD.copy(this).selfDivide(y$1, 0);
      }
    };
    DD.prototype.ge = function ge(y) {
      return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo;
    };
    DD.prototype.pow = function pow(exp) {
      if (exp === 0) {
        return DD.valueOf(1);
      }
      var r = new DD(this);
      var s = DD.valueOf(1);
      var n = Math.abs(exp);
      if (n > 1) {
        while (n > 0) {
          if (n % 2 === 1) {
            s.selfMultiply(r);
          }
          n /= 2;
          if (n > 0) {
            r = r.sqr();
          }
        }
      } else {
        s = r;
      }
      if (exp < 0) {
        return s.reciprocal();
      }
      return s;
    };
    DD.prototype.ceil = function ceil() {
      if (this.isNaN()) {
        return DD.NaN;
      }
      var fhi = Math.ceil(this._hi);
      var flo = 0;
      if (fhi === this._hi) {
        flo = Math.ceil(this._lo);
      }
      return new DD(fhi, flo);
    };
    DD.prototype.compareTo = function compareTo(o) {
      var other = o;
      if (this._hi < other._hi) {
        return -1;
      }
      if (this._hi > other._hi) {
        return 1;
      }
      if (this._lo < other._lo) {
        return -1;
      }
      if (this._lo > other._lo) {
        return 1;
      }
      return 0;
    };
    DD.prototype.rint = function rint() {
      if (this.isNaN()) {
        return this;
      }
      var plus5 = this.add(0.5);
      return plus5.floor();
    };
    DD.prototype.setValue = function setValue() {
      if (arguments[0] instanceof DD) {
        var value = arguments[0];
        this.init(value);
        return this;
      } else if (typeof arguments[0] === "number") {
        var value$1 = arguments[0];
        this.init(value$1);
        return this;
      }
    };
    DD.prototype.max = function max(x) {
      if (this.ge(x)) {
        return this;
      } else {
        return x;
      }
    };
    DD.prototype.sqrt = function sqrt() {
      if (this.isZero()) {
        return DD.valueOf(0);
      }
      if (this.isNegative()) {
        return DD.NaN;
      }
      var x = 1 / Math.sqrt(this._hi);
      var ax = this._hi * x;
      var axdd = DD.valueOf(ax);
      var diffSq = this.subtract(axdd.sqr());
      var d2 = diffSq._hi * (x * 0.5);
      return axdd.add(d2);
    };
    DD.prototype.selfAdd = function selfAdd() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof DD) {
          var y = arguments[0];
          return this.selfAdd(y._hi, y._lo);
        } else if (typeof arguments[0] === "number") {
          var y$1 = arguments[0];
          var H = null;
          var h = null;
          var S = null;
          var s = null;
          var e = null;
          var f = null;
          S = this._hi + y$1;
          e = S - this._hi;
          s = S - e;
          s = y$1 - e + (this._hi - s);
          f = s + this._lo;
          H = S + f;
          h = f + (S - H);
          this._hi = H + h;
          this._lo = h + (H - this._hi);
          return this;
        }
      } else if (arguments.length === 2) {
        var yhi = arguments[0];
        var ylo = arguments[1];
        var H$1 = null;
        var h$1 = null;
        var T = null;
        var t = null;
        var S$1 = null;
        var s$1 = null;
        var e$1 = null;
        var f$1 = null;
        S$1 = this._hi + yhi;
        T = this._lo + ylo;
        e$1 = S$1 - this._hi;
        f$1 = T - this._lo;
        s$1 = S$1 - e$1;
        t = T - f$1;
        s$1 = yhi - e$1 + (this._hi - s$1);
        t = ylo - f$1 + (this._lo - t);
        e$1 = s$1 + T;
        H$1 = S$1 + e$1;
        h$1 = e$1 + (S$1 - H$1);
        e$1 = t + h$1;
        var zhi = H$1 + e$1;
        var zlo = e$1 + (H$1 - zhi);
        this._hi = zhi;
        this._lo = zlo;
        return this;
      }
    };
    DD.prototype.selfMultiply = function selfMultiply() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof DD) {
          var y = arguments[0];
          return this.selfMultiply(y._hi, y._lo);
        } else if (typeof arguments[0] === "number") {
          var y$1 = arguments[0];
          return this.selfMultiply(y$1, 0);
        }
      } else if (arguments.length === 2) {
        var yhi = arguments[0];
        var ylo = arguments[1];
        var hx = null;
        var tx = null;
        var hy = null;
        var ty = null;
        var C = null;
        var c = null;
        C = DD.SPLIT * this._hi;
        hx = C - this._hi;
        c = DD.SPLIT * yhi;
        hx = C - hx;
        tx = this._hi - hx;
        hy = c - yhi;
        C = this._hi * yhi;
        hy = c - hy;
        ty = yhi - hy;
        c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
        var zhi = C + c;
        hx = C - zhi;
        var zlo = c + hx;
        this._hi = zhi;
        this._lo = zlo;
        return this;
      }
    };
    DD.prototype.selfSqr = function selfSqr() {
      return this.selfMultiply(this);
    };
    DD.prototype.floor = function floor() {
      if (this.isNaN()) {
        return DD.NaN;
      }
      var fhi = Math.floor(this._hi);
      var flo = 0;
      if (fhi === this._hi) {
        flo = Math.floor(this._lo);
      }
      return new DD(fhi, flo);
    };
    DD.prototype.negate = function negate() {
      if (this.isNaN()) {
        return this;
      }
      return new DD(-this._hi, -this._lo);
    };
    DD.prototype.clone = function clone() {
    };
    DD.prototype.multiply = function multiply() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        if (y.isNaN()) {
          return DD.createNaN();
        }
        return DD.copy(this).selfMultiply(y);
      } else if (typeof arguments[0] === "number") {
        var y$1 = arguments[0];
        if (Double.isNaN(y$1)) {
          return DD.createNaN();
        }
        return DD.copy(this).selfMultiply(y$1, 0);
      }
    };
    DD.prototype.isNaN = function isNaN2() {
      return Double.isNaN(this._hi);
    };
    DD.prototype.intValue = function intValue() {
      return Math.trunc(this._hi);
    };
    DD.prototype.toString = function toString() {
      var mag = DD.magnitude(this._hi);
      if (mag >= -3 && mag <= 20) {
        return this.toStandardNotation();
      }
      return this.toSciNotation();
    };
    DD.prototype.toStandardNotation = function toStandardNotation() {
      var specialStr = this.getSpecialNumberString();
      if (specialStr !== null) {
        return specialStr;
      }
      var magnitude = new Array(1).fill(null);
      var sigDigits = this.extractSignificantDigits(true, magnitude);
      var decimalPointPos = magnitude[0] + 1;
      var num = sigDigits;
      if (sigDigits.charAt(0) === ".") {
        num = "0" + sigDigits;
      } else if (decimalPointPos < 0) {
        num = "0." + DD.stringOfChar("0", -decimalPointPos) + sigDigits;
      } else if (sigDigits.indexOf(".") === -1) {
        var numZeroes = decimalPointPos - sigDigits.length;
        var zeroes = DD.stringOfChar("0", numZeroes);
        num = sigDigits + zeroes + ".0";
      }
      if (this.isNegative()) {
        return "-" + num;
      }
      return num;
    };
    DD.prototype.reciprocal = function reciprocal() {
      var hc = null;
      var tc = null;
      var hy = null;
      var ty = null;
      var C = null;
      var c = null;
      var U = null;
      var u = null;
      C = 1 / this._hi;
      c = DD.SPLIT * C;
      hc = c - C;
      u = DD.SPLIT * this._hi;
      hc = c - hc;
      tc = C - hc;
      hy = u - this._hi;
      U = C * this._hi;
      hy = u - hy;
      ty = this._hi - hy;
      u = hc * hy - U + hc * ty + tc * hy + tc * ty;
      c = (1 - U - u - C * this._lo) / this._hi;
      var zhi = C + c;
      var zlo = C - zhi + c;
      return new DD(zhi, zlo);
    };
    DD.prototype.toSciNotation = function toSciNotation() {
      if (this.isZero()) {
        return DD.SCI_NOT_ZERO;
      }
      var specialStr = this.getSpecialNumberString();
      if (specialStr !== null) {
        return specialStr;
      }
      var magnitude = new Array(1).fill(null);
      var digits = this.extractSignificantDigits(false, magnitude);
      var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
      if (digits.charAt(0) === "0") {
        throw new Error("Found leading zero: " + digits);
      }
      var trailingDigits = "";
      if (digits.length > 1) {
        trailingDigits = digits.substring(1);
      }
      var digitsWithDecimal = digits.charAt(0) + "." + trailingDigits;
      if (this.isNegative()) {
        return "-" + digitsWithDecimal + expStr;
      }
      return digitsWithDecimal + expStr;
    };
    DD.prototype.abs = function abs() {
      if (this.isNaN()) {
        return DD.NaN;
      }
      if (this.isNegative()) {
        return this.negate();
      }
      return new DD(this);
    };
    DD.prototype.isPositive = function isPositive() {
      return (this._hi > 0 || this._hi === 0) && this._lo > 0;
    };
    DD.prototype.lt = function lt(y) {
      return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo;
    };
    DD.prototype.add = function add() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        return DD.copy(this).selfAdd(y);
      } else if (typeof arguments[0] === "number") {
        var y$1 = arguments[0];
        return DD.copy(this).selfAdd(y$1);
      }
    };
    DD.prototype.init = function init() {
      if (arguments.length === 1) {
        if (typeof arguments[0] === "number") {
          var x = arguments[0];
          this._hi = x;
          this._lo = 0;
        } else if (arguments[0] instanceof DD) {
          var dd = arguments[0];
          this._hi = dd._hi;
          this._lo = dd._lo;
        }
      } else if (arguments.length === 2) {
        var hi = arguments[0];
        var lo = arguments[1];
        this._hi = hi;
        this._lo = lo;
      }
    };
    DD.prototype.gt = function gt(y) {
      return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo;
    };
    DD.prototype.isNegative = function isNegative() {
      return (this._hi < 0 || this._hi === 0) && this._lo < 0;
    };
    DD.prototype.trunc = function trunc() {
      if (this.isNaN()) {
        return DD.NaN;
      }
      if (this.isPositive()) {
        return this.floor();
      } else {
        return this.ceil();
      }
    };
    DD.prototype.signum = function signum() {
      if (this._hi > 0) {
        return 1;
      }
      if (this._hi < 0) {
        return -1;
      }
      if (this._lo > 0) {
        return 1;
      }
      if (this._lo < 0) {
        return -1;
      }
      return 0;
    };
    DD.prototype.interfaces_ = function interfaces_() {
      return [Serializable, Comparable, Clonable];
    };
    DD.prototype.getClass = function getClass() {
      return DD;
    };
    DD.sqr = function sqr(x) {
      return DD.valueOf(x).selfMultiply(x);
    };
    DD.valueOf = function valueOf() {
      if (typeof arguments[0] === "string") {
        var str = arguments[0];
        return DD.parse(str);
      } else if (typeof arguments[0] === "number") {
        var x = arguments[0];
        return new DD(x);
      }
    };
    DD.sqrt = function sqrt(x) {
      return DD.valueOf(x).sqrt();
    };
    DD.parse = function parse3(str) {
      var i = 0;
      var strlen = str.length;
      while (Character.isWhitespace(str.charAt(i))) {
        i++;
      }
      var isNegative = false;
      if (i < strlen) {
        var signCh = str.charAt(i);
        if (signCh === "-" || signCh === "+") {
          i++;
          if (signCh === "-") {
            isNegative = true;
          }
        }
      }
      var val = new DD();
      var numDigits = 0;
      var numBeforeDec = 0;
      var exp = 0;
      while (true) {
        if (i >= strlen) {
          break;
        }
        var ch = str.charAt(i);
        i++;
        if (Character.isDigit(ch)) {
          var d = ch - "0";
          val.selfMultiply(DD.TEN);
          val.selfAdd(d);
          numDigits++;
          continue;
        }
        if (ch === ".") {
          numBeforeDec = numDigits;
          continue;
        }
        if (ch === "e" || ch === "E") {
          var expStr = str.substring(i);
          try {
            exp = Integer.parseInt(expStr);
          } catch (ex) {
            if (ex instanceof Error) {
              throw new Error("Invalid exponent " + expStr + " in string " + str);
            } else {
              throw ex;
            }
          } finally {
          }
          break;
        }
        throw new Error("Unexpected character '" + ch + "' at position " + i + " in string " + str);
      }
      var val2 = val;
      var numDecPlaces = numDigits - numBeforeDec - exp;
      if (numDecPlaces === 0) {
        val2 = val;
      } else if (numDecPlaces > 0) {
        var scale = DD.TEN.pow(numDecPlaces);
        val2 = val.divide(scale);
      } else if (numDecPlaces < 0) {
        var scale$1 = DD.TEN.pow(-numDecPlaces);
        val2 = val.multiply(scale$1);
      }
      if (isNegative) {
        return val2.negate();
      }
      return val2;
    };
    DD.createNaN = function createNaN() {
      return new DD(Double.NaN, Double.NaN);
    };
    DD.copy = function copy(dd) {
      return new DD(dd);
    };
    DD.magnitude = function magnitude(x) {
      var xAbs = Math.abs(x);
      var xLog10 = Math.log(xAbs) / Math.log(10);
      var xMag = Math.trunc(Math.floor(xLog10));
      var xApprox = Math.pow(10, xMag);
      if (xApprox * 10 <= xAbs) {
        xMag += 1;
      }
      return xMag;
    };
    DD.stringOfChar = function stringOfChar(ch, len) {
      var buf = new StringBuffer();
      for (var i = 0; i < len; i++) {
        buf.append(ch);
      }
      return buf.toString();
    };
    staticAccessors$7.PI.get = function() {
      return new DD(3.141592653589793, 12246467991473532e-32);
    };
    staticAccessors$7.TWO_PI.get = function() {
      return new DD(6.283185307179586, 24492935982947064e-32);
    };
    staticAccessors$7.PI_2.get = function() {
      return new DD(1.5707963267948966, 6123233995736766e-32);
    };
    staticAccessors$7.E.get = function() {
      return new DD(2.718281828459045, 14456468917292502e-32);
    };
    staticAccessors$7.NaN.get = function() {
      return new DD(Double.NaN, Double.NaN);
    };
    staticAccessors$7.EPS.get = function() {
      return 123259516440783e-46;
    };
    staticAccessors$7.SPLIT.get = function() {
      return 134217729;
    };
    staticAccessors$7.MAX_PRINT_DIGITS.get = function() {
      return 32;
    };
    staticAccessors$7.TEN.get = function() {
      return DD.valueOf(10);
    };
    staticAccessors$7.ONE.get = function() {
      return DD.valueOf(1);
    };
    staticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function() {
      return "E";
    };
    staticAccessors$7.SCI_NOT_ZERO.get = function() {
      return "0.0E0";
    };
    Object.defineProperties(DD, staticAccessors$7);
    var CGAlgorithmsDD = function CGAlgorithmsDD2() {
    };
    var staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };
    CGAlgorithmsDD.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CGAlgorithmsDD.prototype.getClass = function getClass() {
      return CGAlgorithmsDD;
    };
    CGAlgorithmsDD.orientationIndex = function orientationIndex(p1, p2, q) {
      var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
      if (index <= 1) {
        return index;
      }
      var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
      var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
      var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
      var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
      return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
    };
    CGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2(x1, y1, x2, y2) {
      var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
      return det.signum();
    };
    CGAlgorithmsDD.intersection = function intersection(p1, p2, q1, q2) {
      var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
      var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
      var denom = denom1.subtract(denom2);
      var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
      var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
      var numx = numx1.subtract(numx2);
      var fracP = numx.selfDivide(denom).doubleValue();
      var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
      var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
      var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
      var numy = numy1.subtract(numy2);
      var fracQ = numy.selfDivide(denom).doubleValue();
      var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
      return new Coordinate(x, y);
    };
    CGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter(pa, pb, pc) {
      var detsum = null;
      var detleft = (pa.x - pc.x) * (pb.y - pc.y);
      var detright = (pa.y - pc.y) * (pb.x - pc.x);
      var det = detleft - detright;
      if (detleft > 0) {
        if (detright <= 0) {
          return CGAlgorithmsDD.signum(det);
        } else {
          detsum = detleft + detright;
        }
      } else if (detleft < 0) {
        if (detright >= 0) {
          return CGAlgorithmsDD.signum(det);
        } else {
          detsum = -detleft - detright;
        }
      } else {
        return CGAlgorithmsDD.signum(det);
      }
      var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
      if (det >= errbound || -det >= errbound) {
        return CGAlgorithmsDD.signum(det);
      }
      return 2;
    };
    CGAlgorithmsDD.signum = function signum(x) {
      if (x > 0) {
        return 1;
      }
      if (x < 0) {
        return -1;
      }
      return 0;
    };
    staticAccessors$6.DP_SAFE_EPSILON.get = function() {
      return 1e-15;
    };
    Object.defineProperties(CGAlgorithmsDD, staticAccessors$6);
    var CoordinateSequence = function CoordinateSequence2() {
    };
    var staticAccessors$8 = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
    staticAccessors$8.X.get = function() {
      return 0;
    };
    staticAccessors$8.Y.get = function() {
      return 1;
    };
    staticAccessors$8.Z.get = function() {
      return 2;
    };
    staticAccessors$8.M.get = function() {
      return 3;
    };
    CoordinateSequence.prototype.setOrdinate = function setOrdinate(index, ordinateIndex, value) {
    };
    CoordinateSequence.prototype.size = function size() {
    };
    CoordinateSequence.prototype.getOrdinate = function getOrdinate(index, ordinateIndex) {
    };
    CoordinateSequence.prototype.getCoordinate = function getCoordinate() {
    };
    CoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) {
    };
    CoordinateSequence.prototype.getDimension = function getDimension() {
    };
    CoordinateSequence.prototype.getX = function getX(index) {
    };
    CoordinateSequence.prototype.clone = function clone() {
    };
    CoordinateSequence.prototype.expandEnvelope = function expandEnvelope(env) {
    };
    CoordinateSequence.prototype.copy = function copy() {
    };
    CoordinateSequence.prototype.getY = function getY(index) {
    };
    CoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray() {
    };
    CoordinateSequence.prototype.interfaces_ = function interfaces_() {
      return [Clonable];
    };
    CoordinateSequence.prototype.getClass = function getClass() {
      return CoordinateSequence;
    };
    Object.defineProperties(CoordinateSequence, staticAccessors$8);
    var Exception = function Exception2() {
    };
    var NotRepresentableException = function(Exception$$1) {
      function NotRepresentableException2() {
        Exception$$1.call(this, "Projective point not representable on the Cartesian plane.");
      }
      if (Exception$$1) NotRepresentableException2.__proto__ = Exception$$1;
      NotRepresentableException2.prototype = Object.create(Exception$$1 && Exception$$1.prototype);
      NotRepresentableException2.prototype.constructor = NotRepresentableException2;
      NotRepresentableException2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      NotRepresentableException2.prototype.getClass = function getClass() {
        return NotRepresentableException2;
      };
      return NotRepresentableException2;
    }(Exception);
    var System = function System2() {
    };
    System.arraycopy = function arraycopy(src, srcPos, dest, destPos, len) {
      var c = 0;
      for (var i = srcPos; i < srcPos + len; i++) {
        dest[destPos + c] = src[i];
        c++;
      }
    };
    System.getProperty = function getProperty(name) {
      return {
        "line.separator": "\n"
      }[name];
    };
    var HCoordinate = function HCoordinate2() {
      this.x = null;
      this.y = null;
      this.w = null;
      if (arguments.length === 0) {
        this.x = 0;
        this.y = 0;
        this.w = 1;
      } else if (arguments.length === 1) {
        var p = arguments[0];
        this.x = p.x;
        this.y = p.y;
        this.w = 1;
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
          var _x = arguments[0];
          var _y = arguments[1];
          this.x = _x;
          this.y = _y;
          this.w = 1;
        } else if (arguments[0] instanceof HCoordinate2 && arguments[1] instanceof HCoordinate2) {
          var p1 = arguments[0];
          var p2 = arguments[1];
          this.x = p1.y * p2.w - p2.y * p1.w;
          this.y = p2.x * p1.w - p1.x * p2.w;
          this.w = p1.x * p2.y - p2.x * p1.y;
        } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
          var p1$1 = arguments[0];
          var p2$1 = arguments[1];
          this.x = p1$1.y - p2$1.y;
          this.y = p2$1.x - p1$1.x;
          this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;
        }
      } else if (arguments.length === 3) {
        var _x$1 = arguments[0];
        var _y$1 = arguments[1];
        var _w = arguments[2];
        this.x = _x$1;
        this.y = _y$1;
        this.w = _w;
      } else if (arguments.length === 4) {
        var p1$2 = arguments[0];
        var p2$2 = arguments[1];
        var q1 = arguments[2];
        var q2 = arguments[3];
        var px = p1$2.y - p2$2.y;
        var py = p2$2.x - p1$2.x;
        var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;
        var qx = q1.y - q2.y;
        var qy = q2.x - q1.x;
        var qw = q1.x * q2.y - q2.x * q1.y;
        this.x = py * qw - qy * pw;
        this.y = qx * pw - px * qw;
        this.w = px * qy - qx * py;
      }
    };
    HCoordinate.prototype.getY = function getY() {
      var a = this.y / this.w;
      if (Double.isNaN(a) || Double.isInfinite(a)) {
        throw new NotRepresentableException();
      }
      return a;
    };
    HCoordinate.prototype.getX = function getX() {
      var a = this.x / this.w;
      if (Double.isNaN(a) || Double.isInfinite(a)) {
        throw new NotRepresentableException();
      }
      return a;
    };
    HCoordinate.prototype.getCoordinate = function getCoordinate() {
      var p = new Coordinate();
      p.x = this.getX();
      p.y = this.getY();
      return p;
    };
    HCoordinate.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    HCoordinate.prototype.getClass = function getClass() {
      return HCoordinate;
    };
    HCoordinate.intersection = function intersection(p1, p2, q1, q2) {
      var px = p1.y - p2.y;
      var py = p2.x - p1.x;
      var pw = p1.x * p2.y - p2.x * p1.y;
      var qx = q1.y - q2.y;
      var qy = q2.x - q1.x;
      var qw = q1.x * q2.y - q2.x * q1.y;
      var x = py * qw - qy * pw;
      var y = qx * pw - px * qw;
      var w = px * qy - qx * py;
      var xInt = x / w;
      var yInt = y / w;
      if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {
        throw new NotRepresentableException();
      }
      return new Coordinate(xInt, yInt);
    };
    var Envelope = function Envelope2() {
      this._minx = null;
      this._maxx = null;
      this._miny = null;
      this._maxy = null;
      if (arguments.length === 0) {
        this.init();
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          this.init(p.x, p.x, p.y, p.y);
        } else if (arguments[0] instanceof Envelope2) {
          var env = arguments[0];
          this.init(env);
        }
      } else if (arguments.length === 2) {
        var p1 = arguments[0];
        var p2 = arguments[1];
        this.init(p1.x, p2.x, p1.y, p2.y);
      } else if (arguments.length === 4) {
        var x1 = arguments[0];
        var x2 = arguments[1];
        var y1 = arguments[2];
        var y2 = arguments[3];
        this.init(x1, x2, y1, y2);
      }
    };
    var staticAccessors$9 = { serialVersionUID: { configurable: true } };
    Envelope.prototype.getArea = function getArea() {
      return this.getWidth() * this.getHeight();
    };
    Envelope.prototype.equals = function equals(other) {
      if (!(other instanceof Envelope)) {
        return false;
      }
      var otherEnvelope = other;
      if (this.isNull()) {
        return otherEnvelope.isNull();
      }
      return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
    };
    Envelope.prototype.intersection = function intersection(env) {
      if (this.isNull() || env.isNull() || !this.intersects(env)) {
        return new Envelope();
      }
      var intMinX = this._minx > env._minx ? this._minx : env._minx;
      var intMinY = this._miny > env._miny ? this._miny : env._miny;
      var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
      var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
      return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
    };
    Envelope.prototype.isNull = function isNull() {
      return this._maxx < this._minx;
    };
    Envelope.prototype.getMaxX = function getMaxX() {
      return this._maxx;
    };
    Envelope.prototype.covers = function covers() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          return this.covers(p.x, p.y);
        } else if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          if (this.isNull() || other.isNull()) {
            return false;
          }
          return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        if (this.isNull()) {
          return false;
        }
        return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;
      }
    };
    Envelope.prototype.intersects = function intersects() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          if (this.isNull() || other.isNull()) {
            return false;
          }
          return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
        } else if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          return this.intersects(p.x, p.y);
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        if (this.isNull()) {
          return false;
        }
        return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);
      }
    };
    Envelope.prototype.getMinY = function getMinY() {
      return this._miny;
    };
    Envelope.prototype.getMinX = function getMinX() {
      return this._minx;
    };
    Envelope.prototype.expandToInclude = function expandToInclude() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          this.expandToInclude(p.x, p.y);
        } else if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          if (other.isNull()) {
            return null;
          }
          if (this.isNull()) {
            this._minx = other.getMinX();
            this._maxx = other.getMaxX();
            this._miny = other.getMinY();
            this._maxy = other.getMaxY();
          } else {
            if (other._minx < this._minx) {
              this._minx = other._minx;
            }
            if (other._maxx > this._maxx) {
              this._maxx = other._maxx;
            }
            if (other._miny < this._miny) {
              this._miny = other._miny;
            }
            if (other._maxy > this._maxy) {
              this._maxy = other._maxy;
            }
          }
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        if (this.isNull()) {
          this._minx = x;
          this._maxx = x;
          this._miny = y;
          this._maxy = y;
        } else {
          if (x < this._minx) {
            this._minx = x;
          }
          if (x > this._maxx) {
            this._maxx = x;
          }
          if (y < this._miny) {
            this._miny = y;
          }
          if (y > this._maxy) {
            this._maxy = y;
          }
        }
      }
    };
    Envelope.prototype.minExtent = function minExtent() {
      if (this.isNull()) {
        return 0;
      }
      var w = this.getWidth();
      var h = this.getHeight();
      if (w < h) {
        return w;
      }
      return h;
    };
    Envelope.prototype.getWidth = function getWidth() {
      if (this.isNull()) {
        return 0;
      }
      return this._maxx - this._minx;
    };
    Envelope.prototype.compareTo = function compareTo(o) {
      var env = o;
      if (this.isNull()) {
        if (env.isNull()) {
          return 0;
        }
        return -1;
      } else {
        if (env.isNull()) {
          return 1;
        }
      }
      if (this._minx < env._minx) {
        return -1;
      }
      if (this._minx > env._minx) {
        return 1;
      }
      if (this._miny < env._miny) {
        return -1;
      }
      if (this._miny > env._miny) {
        return 1;
      }
      if (this._maxx < env._maxx) {
        return -1;
      }
      if (this._maxx > env._maxx) {
        return 1;
      }
      if (this._maxy < env._maxy) {
        return -1;
      }
      if (this._maxy > env._maxy) {
        return 1;
      }
      return 0;
    };
    Envelope.prototype.translate = function translate(transX, transY) {
      if (this.isNull()) {
        return null;
      }
      this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
    };
    Envelope.prototype.toString = function toString() {
      return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
    };
    Envelope.prototype.setToNull = function setToNull() {
      this._minx = 0;
      this._maxx = -1;
      this._miny = 0;
      this._maxy = -1;
    };
    Envelope.prototype.getHeight = function getHeight() {
      if (this.isNull()) {
        return 0;
      }
      return this._maxy - this._miny;
    };
    Envelope.prototype.maxExtent = function maxExtent() {
      if (this.isNull()) {
        return 0;
      }
      var w = this.getWidth();
      var h = this.getHeight();
      if (w > h) {
        return w;
      }
      return h;
    };
    Envelope.prototype.expandBy = function expandBy() {
      if (arguments.length === 1) {
        var distance = arguments[0];
        this.expandBy(distance, distance);
      } else if (arguments.length === 2) {
        var deltaX = arguments[0];
        var deltaY = arguments[1];
        if (this.isNull()) {
          return null;
        }
        this._minx -= deltaX;
        this._maxx += deltaX;
        this._miny -= deltaY;
        this._maxy += deltaY;
        if (this._minx > this._maxx || this._miny > this._maxy) {
          this.setToNull();
        }
      }
    };
    Envelope.prototype.contains = function contains() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          return this.covers(other);
        } else if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          return this.covers(p);
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        return this.covers(x, y);
      }
    };
    Envelope.prototype.centre = function centre() {
      if (this.isNull()) {
        return null;
      }
      return new Coordinate((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
    };
    Envelope.prototype.init = function init() {
      if (arguments.length === 0) {
        this.setToNull();
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          this.init(p.x, p.x, p.y, p.y);
        } else if (arguments[0] instanceof Envelope) {
          var env = arguments[0];
          this._minx = env._minx;
          this._maxx = env._maxx;
          this._miny = env._miny;
          this._maxy = env._maxy;
        }
      } else if (arguments.length === 2) {
        var p1 = arguments[0];
        var p2 = arguments[1];
        this.init(p1.x, p2.x, p1.y, p2.y);
      } else if (arguments.length === 4) {
        var x1 = arguments[0];
        var x2 = arguments[1];
        var y1 = arguments[2];
        var y2 = arguments[3];
        if (x1 < x2) {
          this._minx = x1;
          this._maxx = x2;
        } else {
          this._minx = x2;
          this._maxx = x1;
        }
        if (y1 < y2) {
          this._miny = y1;
          this._maxy = y2;
        } else {
          this._miny = y2;
          this._maxy = y1;
        }
      }
    };
    Envelope.prototype.getMaxY = function getMaxY() {
      return this._maxy;
    };
    Envelope.prototype.distance = function distance(env) {
      if (this.intersects(env)) {
        return 0;
      }
      var dx = 0;
      if (this._maxx < env._minx) {
        dx = env._minx - this._maxx;
      } else if (this._minx > env._maxx) {
        dx = this._minx - env._maxx;
      }
      var dy = 0;
      if (this._maxy < env._miny) {
        dy = env._miny - this._maxy;
      } else if (this._miny > env._maxy) {
        dy = this._miny - env._maxy;
      }
      if (dx === 0) {
        return dy;
      }
      if (dy === 0) {
        return dx;
      }
      return Math.sqrt(dx * dx + dy * dy);
    };
    Envelope.prototype.hashCode = function hashCode() {
      var result2 = 17;
      result2 = 37 * result2 + Coordinate.hashCode(this._minx);
      result2 = 37 * result2 + Coordinate.hashCode(this._maxx);
      result2 = 37 * result2 + Coordinate.hashCode(this._miny);
      result2 = 37 * result2 + Coordinate.hashCode(this._maxy);
      return result2;
    };
    Envelope.prototype.interfaces_ = function interfaces_() {
      return [Comparable, Serializable];
    };
    Envelope.prototype.getClass = function getClass() {
      return Envelope;
    };
    Envelope.intersects = function intersects() {
      if (arguments.length === 3) {
        var p1 = arguments[0];
        var p2 = arguments[1];
        var q = arguments[2];
        if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
          return true;
        }
        return false;
      } else if (arguments.length === 4) {
        var p1$1 = arguments[0];
        var p2$1 = arguments[1];
        var q1 = arguments[2];
        var q2 = arguments[3];
        var minq = Math.min(q1.x, q2.x);
        var maxq = Math.max(q1.x, q2.x);
        var minp = Math.min(p1$1.x, p2$1.x);
        var maxp = Math.max(p1$1.x, p2$1.x);
        if (minp > maxq) {
          return false;
        }
        if (maxp < minq) {
          return false;
        }
        minq = Math.min(q1.y, q2.y);
        maxq = Math.max(q1.y, q2.y);
        minp = Math.min(p1$1.y, p2$1.y);
        maxp = Math.max(p1$1.y, p2$1.y);
        if (minp > maxq) {
          return false;
        }
        if (maxp < minq) {
          return false;
        }
        return true;
      }
    };
    staticAccessors$9.serialVersionUID.get = function() {
      return 5873921885273102e3;
    };
    Object.defineProperties(Envelope, staticAccessors$9);
    var regExes = {
      "typeStr": /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
      "emptyTypeStr": /^\s*(\w+)\s*EMPTY\s*$/,
      "spaces": /\s+/,
      "parenComma": /\)\s*,\s*\(/,
      "doubleParenComma": /\)\s*\)\s*,\s*\(\s*\(/,
      // can't use {2} here
      "trimParens": /^\s*\(?(.*?)\)?\s*$/
    };
    var WKTParser = function WKTParser2(geometryFactory) {
      this.geometryFactory = geometryFactory || new GeometryFactory();
    };
    WKTParser.prototype.read = function read(wkt) {
      var geometry, type, str;
      wkt = wkt.replace(/[\n\r]/g, " ");
      var matches = regExes.typeStr.exec(wkt);
      if (wkt.search("EMPTY") !== -1) {
        matches = regExes.emptyTypeStr.exec(wkt);
        matches[2] = void 0;
      }
      if (matches) {
        type = matches[1].toLowerCase();
        str = matches[2];
        if (parse$1[type]) {
          geometry = parse$1[type].apply(this, [str]);
        }
      }
      if (geometry === void 0) {
        throw new Error("Could not parse WKT " + wkt);
      }
      return geometry;
    };
    WKTParser.prototype.write = function write(geometry) {
      return this.extractGeometry(geometry);
    };
    WKTParser.prototype.extractGeometry = function extractGeometry(geometry) {
      var type = geometry.getGeometryType().toLowerCase();
      if (!extract$1[type]) {
        return null;
      }
      var wktType = type.toUpperCase();
      var data;
      if (geometry.isEmpty()) {
        data = wktType + " EMPTY";
      } else {
        data = wktType + "(" + extract$1[type].apply(this, [geometry]) + ")";
      }
      return data;
    };
    var extract$1 = {
      coordinate: function coordinate(coordinate$1) {
        return coordinate$1.x + " " + coordinate$1.y;
      },
      /**
       * Return a space delimited string of point coordinates.
       *
       * @param {Point}
       *          point
       * @return {String} A string of coordinates representing the point.
       */
      point: function point(point$1) {
        return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0]);
      },
      /**
       * Return a comma delimited string of point coordinates from a multipoint.
       *
       * @param {MultiPoint}
       *          multipoint
       * @return {String} A string of point coordinate strings representing the
       *         multipoint.
       */
      multipoint: function multipoint(multipoint$1) {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = multipoint$1._geometries.length; i < len; ++i) {
          array.push("(" + extract$1.point.apply(this$1, [multipoint$1._geometries[i]]) + ")");
        }
        return array.join(",");
      },
      /**
       * Return a comma delimited string of point coordinates from a line.
       *
       * @param {LineString} linestring
       * @return {String} A string of point coordinate strings representing the linestring.
       */
      linestring: function linestring(linestring$1) {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i) {
          array.push(extract$1.coordinate.apply(this$1, [linestring$1._points._coordinates[i]]));
        }
        return array.join(",");
      },
      linearring: function linearring(linearring$1) {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i) {
          array.push(extract$1.coordinate.apply(this$1, [linearring$1._points._coordinates[i]]));
        }
        return array.join(",");
      },
      /**
       * Return a comma delimited string of linestring strings from a
       * multilinestring.
       *
       * @param {MultiLineString} multilinestring
       * @return {String} A string of of linestring strings representing the multilinestring.
       */
      multilinestring: function multilinestring(multilinestring$1) {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = multilinestring$1._geometries.length; i < len; ++i) {
          array.push("(" + extract$1.linestring.apply(this$1, [multilinestring$1._geometries[i]]) + ")");
        }
        return array.join(",");
      },
      /**
       * Return a comma delimited string of linear ring arrays from a polygon.
       *
       * @param {Polygon} polygon
       * @return {String} An array of linear ring arrays representing the polygon.
       */
      polygon: function polygon(polygon$1) {
        var this$1 = this;
        var array = [];
        array.push("(" + extract$1.linestring.apply(this, [polygon$1._shell]) + ")");
        for (var i = 0, len = polygon$1._holes.length; i < len; ++i) {
          array.push("(" + extract$1.linestring.apply(this$1, [polygon$1._holes[i]]) + ")");
        }
        return array.join(",");
      },
      /**
       * Return an array of polygon arrays from a multipolygon.
       *
       * @param {MultiPolygon} multipolygon
       * @return {String} An array of polygon arrays representing the multipolygon.
       */
      multipolygon: function multipolygon(multipolygon$1) {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = multipolygon$1._geometries.length; i < len; ++i) {
          array.push("(" + extract$1.polygon.apply(this$1, [multipolygon$1._geometries[i]]) + ")");
        }
        return array.join(",");
      },
      /**
       * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
       * geometrycollection.
       *
       * @param {GeometryCollection} collection
       * @return {String} internal WKT representation of the collection.
       */
      geometrycollection: function geometrycollection(collection) {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = collection._geometries.length; i < len; ++i) {
          array.push(this$1.extractGeometry(collection._geometries[i]));
        }
        return array.join(",");
      }
    };
    var parse$1 = {
      /**
       * Return point geometry given a point WKT fragment.
       *
       * @param {String} str A WKT fragment representing the point.
       * @return {Point} A point geometry.
       * @private
       */
      point: function point(str) {
        if (str === void 0) {
          return this.geometryFactory.createPoint();
        }
        var coords = str.trim().split(regExes.spaces);
        return this.geometryFactory.createPoint(new Coordinate(
          Number.parseFloat(coords[0]),
          Number.parseFloat(coords[1])
        ));
      },
      /**
       * Return a multipoint geometry given a multipoint WKT fragment.
       *
       * @param {String} str A WKT fragment representing the multipoint.
       * @return {Point} A multipoint feature.
       * @private
       */
      multipoint: function multipoint(str) {
        var this$1 = this;
        if (str === void 0) {
          return this.geometryFactory.createMultiPoint();
        }
        var point;
        var points = str.trim().split(",");
        var components = [];
        for (var i = 0, len = points.length; i < len; ++i) {
          point = points[i].replace(regExes.trimParens, "$1");
          components.push(parse$1.point.apply(this$1, [point]));
        }
        return this.geometryFactory.createMultiPoint(components);
      },
      /**
       * Return a linestring geometry given a linestring WKT fragment.
       *
       * @param {String} str A WKT fragment representing the linestring.
       * @return {LineString} A linestring geometry.
       * @private
       */
      linestring: function linestring(str) {
        if (str === void 0) {
          return this.geometryFactory.createLineString();
        }
        var points = str.trim().split(",");
        var components = [];
        var coords;
        for (var i = 0, len = points.length; i < len; ++i) {
          coords = points[i].trim().split(regExes.spaces);
          components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
        }
        return this.geometryFactory.createLineString(components);
      },
      /**
       * Return a linearring geometry given a linearring WKT fragment.
       *
       * @param {String} str A WKT fragment representing the linearring.
       * @return {LinearRing} A linearring geometry.
       * @private
       */
      linearring: function linearring(str) {
        if (str === void 0) {
          return this.geometryFactory.createLinearRing();
        }
        var points = str.trim().split(",");
        var components = [];
        var coords;
        for (var i = 0, len = points.length; i < len; ++i) {
          coords = points[i].trim().split(regExes.spaces);
          components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
        }
        return this.geometryFactory.createLinearRing(components);
      },
      /**
       * Return a multilinestring geometry given a multilinestring WKT fragment.
       *
       * @param {String} str A WKT fragment representing the multilinestring.
       * @return {MultiLineString} A multilinestring geometry.
       * @private
       */
      multilinestring: function multilinestring(str) {
        var this$1 = this;
        if (str === void 0) {
          return this.geometryFactory.createMultiLineString();
        }
        var line;
        var lines = str.trim().split(regExes.parenComma);
        var components = [];
        for (var i = 0, len = lines.length; i < len; ++i) {
          line = lines[i].replace(regExes.trimParens, "$1");
          components.push(parse$1.linestring.apply(this$1, [line]));
        }
        return this.geometryFactory.createMultiLineString(components);
      },
      /**
       * Return a polygon geometry given a polygon WKT fragment.
       *
       * @param {String} str A WKT fragment representing the polygon.
       * @return {Polygon} A polygon geometry.
       * @private
       */
      polygon: function polygon(str) {
        var this$1 = this;
        if (str === void 0) {
          return this.geometryFactory.createPolygon();
        }
        var ring, linestring, linearring;
        var rings = str.trim().split(regExes.parenComma);
        var shell;
        var holes = [];
        for (var i = 0, len = rings.length; i < len; ++i) {
          ring = rings[i].replace(regExes.trimParens, "$1");
          linestring = parse$1.linestring.apply(this$1, [ring]);
          linearring = this$1.geometryFactory.createLinearRing(linestring._points);
          if (i === 0) {
            shell = linearring;
          } else {
            holes.push(linearring);
          }
        }
        return this.geometryFactory.createPolygon(shell, holes);
      },
      /**
       * Return a multipolygon geometry given a multipolygon WKT fragment.
       *
       * @param {String} str A WKT fragment representing the multipolygon.
       * @return {MultiPolygon} A multipolygon geometry.
       * @private
       */
      multipolygon: function multipolygon(str) {
        var this$1 = this;
        if (str === void 0) {
          return this.geometryFactory.createMultiPolygon();
        }
        var polygon;
        var polygons = str.trim().split(regExes.doubleParenComma);
        var components = [];
        for (var i = 0, len = polygons.length; i < len; ++i) {
          polygon = polygons[i].replace(regExes.trimParens, "$1");
          components.push(parse$1.polygon.apply(this$1, [polygon]));
        }
        return this.geometryFactory.createMultiPolygon(components);
      },
      /**
       * Return a geometrycollection given a geometrycollection WKT fragment.
       *
       * @param {String} str A WKT fragment representing the geometrycollection.
       * @return {GeometryCollection}
       * @private
       */
      geometrycollection: function geometrycollection(str) {
        var this$1 = this;
        if (str === void 0) {
          return this.geometryFactory.createGeometryCollection();
        }
        str = str.replace(/,\s*([A-Za-z])/g, "|$1");
        var wktArray = str.trim().split("|");
        var components = [];
        for (var i = 0, len = wktArray.length; i < len; ++i) {
          components.push(this$1.read(wktArray[i]));
        }
        return this.geometryFactory.createGeometryCollection(components);
      }
    };
    var WKTWriter = function WKTWriter2(geometryFactory) {
      this.parser = new WKTParser(geometryFactory);
    };
    WKTWriter.prototype.write = function write(geometry) {
      return this.parser.write(geometry);
    };
    WKTWriter.toLineString = function toLineString(p0, p1) {
      if (arguments.length !== 2) {
        throw new Error("Not implemented");
      }
      return "LINESTRING ( " + p0.x + " " + p0.y + ", " + p1.x + " " + p1.y + " )";
    };
    var RuntimeException = function(Error2) {
      function RuntimeException2(message) {
        Error2.call(this, message);
        this.name = "RuntimeException";
        this.message = message;
        this.stack = new Error2().stack;
      }
      if (Error2) RuntimeException2.__proto__ = Error2;
      RuntimeException2.prototype = Object.create(Error2 && Error2.prototype);
      RuntimeException2.prototype.constructor = RuntimeException2;
      return RuntimeException2;
    }(Error);
    var AssertionFailedException = function(RuntimeException$$1) {
      function AssertionFailedException2() {
        RuntimeException$$1.call(this);
        if (arguments.length === 0) {
          RuntimeException$$1.call(this);
        } else if (arguments.length === 1) {
          var message = arguments[0];
          RuntimeException$$1.call(this, message);
        }
      }
      if (RuntimeException$$1) AssertionFailedException2.__proto__ = RuntimeException$$1;
      AssertionFailedException2.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
      AssertionFailedException2.prototype.constructor = AssertionFailedException2;
      AssertionFailedException2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      AssertionFailedException2.prototype.getClass = function getClass() {
        return AssertionFailedException2;
      };
      return AssertionFailedException2;
    }(RuntimeException);
    var Assert = function Assert2() {
    };
    Assert.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Assert.prototype.getClass = function getClass() {
      return Assert;
    };
    Assert.shouldNeverReachHere = function shouldNeverReachHere() {
      if (arguments.length === 0) {
        Assert.shouldNeverReachHere(null);
      } else if (arguments.length === 1) {
        var message = arguments[0];
        throw new AssertionFailedException("Should never reach here" + (message !== null ? ": " + message : ""));
      }
    };
    Assert.isTrue = function isTrue() {
      var assertion;
      var message;
      if (arguments.length === 1) {
        assertion = arguments[0];
        Assert.isTrue(assertion, null);
      } else if (arguments.length === 2) {
        assertion = arguments[0];
        message = arguments[1];
        if (!assertion) {
          if (message === null) {
            throw new AssertionFailedException();
          } else {
            throw new AssertionFailedException(message);
          }
        }
      }
    };
    Assert.equals = function equals() {
      var expectedValue;
      var actualValue;
      var message;
      if (arguments.length === 2) {
        expectedValue = arguments[0];
        actualValue = arguments[1];
        Assert.equals(expectedValue, actualValue, null);
      } else if (arguments.length === 3) {
        expectedValue = arguments[0];
        actualValue = arguments[1];
        message = arguments[2];
        if (!actualValue.equals(expectedValue)) {
          throw new AssertionFailedException("Expected " + expectedValue + " but encountered " + actualValue + (message !== null ? ": " + message : ""));
        }
      }
    };
    var LineIntersector = function LineIntersector2() {
      this._result = null;
      this._inputLines = Array(2).fill().map(function() {
        return Array(2);
      });
      this._intPt = new Array(2).fill(null);
      this._intLineIndex = null;
      this._isProper = null;
      this._pa = null;
      this._pb = null;
      this._precisionModel = null;
      this._intPt[0] = new Coordinate();
      this._intPt[1] = new Coordinate();
      this._pa = this._intPt[0];
      this._pb = this._intPt[1];
      this._result = 0;
    };
    var staticAccessors$10 = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
    LineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment(segmentIndex, intIndex) {
      this.computeIntLineIndex();
      return this._intLineIndex[segmentIndex][intIndex];
    };
    LineIntersector.prototype.getTopologySummary = function getTopologySummary() {
      var catBuf = new StringBuffer();
      if (this.isEndPoint()) {
        catBuf.append(" endpoint");
      }
      if (this._isProper) {
        catBuf.append(" proper");
      }
      if (this.isCollinear()) {
        catBuf.append(" collinear");
      }
      return catBuf.toString();
    };
    LineIntersector.prototype.computeIntersection = function computeIntersection(p1, p2, p3, p4) {
      this._inputLines[0][0] = p1;
      this._inputLines[0][1] = p2;
      this._inputLines[1][0] = p3;
      this._inputLines[1][1] = p4;
      this._result = this.computeIntersect(p1, p2, p3, p4);
    };
    LineIntersector.prototype.getIntersectionNum = function getIntersectionNum() {
      return this._result;
    };
    LineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex() {
      if (arguments.length === 0) {
        if (this._intLineIndex === null) {
          this._intLineIndex = Array(2).fill().map(function() {
            return Array(2);
          });
          this.computeIntLineIndex(0);
          this.computeIntLineIndex(1);
        }
      } else if (arguments.length === 1) {
        var segmentIndex = arguments[0];
        var dist0 = this.getEdgeDistance(segmentIndex, 0);
        var dist1 = this.getEdgeDistance(segmentIndex, 1);
        if (dist0 > dist1) {
          this._intLineIndex[segmentIndex][0] = 0;
          this._intLineIndex[segmentIndex][1] = 1;
        } else {
          this._intLineIndex[segmentIndex][0] = 1;
          this._intLineIndex[segmentIndex][1] = 0;
        }
      }
    };
    LineIntersector.prototype.isProper = function isProper() {
      return this.hasIntersection() && this._isProper;
    };
    LineIntersector.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {
      this._precisionModel = precisionModel;
    };
    LineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection() {
      var this$1 = this;
      if (arguments.length === 0) {
        if (this.isInteriorIntersection(0)) {
          return true;
        }
        if (this.isInteriorIntersection(1)) {
          return true;
        }
        return false;
      } else if (arguments.length === 1) {
        var inputLineIndex = arguments[0];
        for (var i = 0; i < this._result; i++) {
          if (!(this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][0]) || this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][1]))) {
            return true;
          }
        }
        return false;
      }
    };
    LineIntersector.prototype.getIntersection = function getIntersection(intIndex) {
      return this._intPt[intIndex];
    };
    LineIntersector.prototype.isEndPoint = function isEndPoint() {
      return this.hasIntersection() && !this._isProper;
    };
    LineIntersector.prototype.hasIntersection = function hasIntersection() {
      return this._result !== LineIntersector.NO_INTERSECTION;
    };
    LineIntersector.prototype.getEdgeDistance = function getEdgeDistance(segmentIndex, intIndex) {
      var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
      return dist;
    };
    LineIntersector.prototype.isCollinear = function isCollinear() {
      return this._result === LineIntersector.COLLINEAR_INTERSECTION;
    };
    LineIntersector.prototype.toString = function toString() {
      return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
    };
    LineIntersector.prototype.getEndpoint = function getEndpoint(segmentIndex, ptIndex) {
      return this._inputLines[segmentIndex][ptIndex];
    };
    LineIntersector.prototype.isIntersection = function isIntersection(pt) {
      var this$1 = this;
      for (var i = 0; i < this._result; i++) {
        if (this$1._intPt[i].equals2D(pt)) {
          return true;
        }
      }
      return false;
    };
    LineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment(segmentIndex, intIndex) {
      this.computeIntLineIndex();
      return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
    };
    LineIntersector.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    LineIntersector.prototype.getClass = function getClass() {
      return LineIntersector;
    };
    LineIntersector.computeEdgeDistance = function computeEdgeDistance(p, p0, p1) {
      var dx = Math.abs(p1.x - p0.x);
      var dy = Math.abs(p1.y - p0.y);
      var dist = -1;
      if (p.equals(p0)) {
        dist = 0;
      } else if (p.equals(p1)) {
        if (dx > dy) {
          dist = dx;
        } else {
          dist = dy;
        }
      } else {
        var pdx = Math.abs(p.x - p0.x);
        var pdy = Math.abs(p.y - p0.y);
        if (dx > dy) {
          dist = pdx;
        } else {
          dist = pdy;
        }
        if (dist === 0 && !p.equals(p0)) {
          dist = Math.max(pdx, pdy);
        }
      }
      Assert.isTrue(!(dist === 0 && !p.equals(p0)), "Bad distance calculation");
      return dist;
    };
    LineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance(p, p1, p2) {
      var dx = p.x - p1.x;
      var dy = p.y - p1.y;
      var dist = Math.sqrt(dx * dx + dy * dy);
      Assert.isTrue(!(dist === 0 && !p.equals(p1)), "Invalid distance calculation");
      return dist;
    };
    staticAccessors$10.DONT_INTERSECT.get = function() {
      return 0;
    };
    staticAccessors$10.DO_INTERSECT.get = function() {
      return 1;
    };
    staticAccessors$10.COLLINEAR.get = function() {
      return 2;
    };
    staticAccessors$10.NO_INTERSECTION.get = function() {
      return 0;
    };
    staticAccessors$10.POINT_INTERSECTION.get = function() {
      return 1;
    };
    staticAccessors$10.COLLINEAR_INTERSECTION.get = function() {
      return 2;
    };
    Object.defineProperties(LineIntersector, staticAccessors$10);
    var RobustLineIntersector = function(LineIntersector$$1) {
      function RobustLineIntersector2() {
        LineIntersector$$1.apply(this, arguments);
      }
      if (LineIntersector$$1) RobustLineIntersector2.__proto__ = LineIntersector$$1;
      RobustLineIntersector2.prototype = Object.create(LineIntersector$$1 && LineIntersector$$1.prototype);
      RobustLineIntersector2.prototype.constructor = RobustLineIntersector2;
      RobustLineIntersector2.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes(intPt) {
        var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
        var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
        return env0.contains(intPt) && env1.contains(intPt);
      };
      RobustLineIntersector2.prototype.computeIntersection = function computeIntersection() {
        if (arguments.length === 3) {
          var p = arguments[0];
          var p1 = arguments[1];
          var p2 = arguments[2];
          this._isProper = false;
          if (Envelope.intersects(p1, p2, p)) {
            if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {
              this._isProper = true;
              if (p.equals(p1) || p.equals(p2)) {
                this._isProper = false;
              }
              this._result = LineIntersector$$1.POINT_INTERSECTION;
              return null;
            }
          }
          this._result = LineIntersector$$1.NO_INTERSECTION;
        } else {
          return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments);
        }
      };
      RobustLineIntersector2.prototype.normalizeToMinimum = function normalizeToMinimum(n1, n2, n3, n4, normPt) {
        normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
        normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
        n1.x -= normPt.x;
        n1.y -= normPt.y;
        n2.x -= normPt.x;
        n2.y -= normPt.y;
        n3.x -= normPt.x;
        n3.y -= normPt.y;
        n4.x -= normPt.x;
        n4.y -= normPt.y;
      };
      RobustLineIntersector2.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection(p1, p2, q1, q2) {
        var intPt = null;
        try {
          intPt = HCoordinate.intersection(p1, p2, q1, q2);
        } catch (e) {
          if (e instanceof NotRepresentableException) {
            intPt = RobustLineIntersector2.nearestEndpoint(p1, p2, q1, q2);
          } else {
            throw e;
          }
        } finally {
        }
        return intPt;
      };
      RobustLineIntersector2.prototype.intersection = function intersection(p1, p2, q1, q2) {
        var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
        if (!this.isInSegmentEnvelopes(intPt)) {
          intPt = new Coordinate(RobustLineIntersector2.nearestEndpoint(p1, p2, q1, q2));
        }
        if (this._precisionModel !== null) {
          this._precisionModel.makePrecise(intPt);
        }
        return intPt;
      };
      RobustLineIntersector2.prototype.smallestInAbsValue = function smallestInAbsValue(x1, x2, x3, x4) {
        var x = x1;
        var xabs = Math.abs(x);
        if (Math.abs(x2) < xabs) {
          x = x2;
          xabs = Math.abs(x2);
        }
        if (Math.abs(x3) < xabs) {
          x = x3;
          xabs = Math.abs(x3);
        }
        if (Math.abs(x4) < xabs) {
          x = x4;
        }
        return x;
      };
      RobustLineIntersector2.prototype.checkDD = function checkDD(p1, p2, q1, q2, intPt) {
        var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
        var isIn = this.isInSegmentEnvelopes(intPtDD);
        System.out.println("DD in env = " + isIn + "  --------------------- " + intPtDD);
        if (intPt.distance(intPtDD) > 1e-4) {
          System.out.println("Distance = " + intPt.distance(intPtDD));
        }
      };
      RobustLineIntersector2.prototype.intersectionWithNormalization = function intersectionWithNormalization(p1, p2, q1, q2) {
        var n1 = new Coordinate(p1);
        var n2 = new Coordinate(p2);
        var n3 = new Coordinate(q1);
        var n4 = new Coordinate(q2);
        var normPt = new Coordinate();
        this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
        var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
        intPt.x += normPt.x;
        intPt.y += normPt.y;
        return intPt;
      };
      RobustLineIntersector2.prototype.computeCollinearIntersection = function computeCollinearIntersection(p1, p2, q1, q2) {
        var p1q1p2 = Envelope.intersects(p1, p2, q1);
        var p1q2p2 = Envelope.intersects(p1, p2, q2);
        var q1p1q2 = Envelope.intersects(q1, q2, p1);
        var q1p2q2 = Envelope.intersects(q1, q2, p2);
        if (p1q1p2 && p1q2p2) {
          this._intPt[0] = q1;
          this._intPt[1] = q2;
          return LineIntersector$$1.COLLINEAR_INTERSECTION;
        }
        if (q1p1q2 && q1p2q2) {
          this._intPt[0] = p1;
          this._intPt[1] = p2;
          return LineIntersector$$1.COLLINEAR_INTERSECTION;
        }
        if (p1q1p2 && q1p1q2) {
          this._intPt[0] = q1;
          this._intPt[1] = p1;
          return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
        }
        if (p1q1p2 && q1p2q2) {
          this._intPt[0] = q1;
          this._intPt[1] = p2;
          return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
        }
        if (p1q2p2 && q1p1q2) {
          this._intPt[0] = q2;
          this._intPt[1] = p1;
          return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
        }
        if (p1q2p2 && q1p2q2) {
          this._intPt[0] = q2;
          this._intPt[1] = p2;
          return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
        }
        return LineIntersector$$1.NO_INTERSECTION;
      };
      RobustLineIntersector2.prototype.normalizeToEnvCentre = function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {
        var minX0 = n00.x < n01.x ? n00.x : n01.x;
        var minY0 = n00.y < n01.y ? n00.y : n01.y;
        var maxX0 = n00.x > n01.x ? n00.x : n01.x;
        var maxY0 = n00.y > n01.y ? n00.y : n01.y;
        var minX1 = n10.x < n11.x ? n10.x : n11.x;
        var minY1 = n10.y < n11.y ? n10.y : n11.y;
        var maxX1 = n10.x > n11.x ? n10.x : n11.x;
        var maxY1 = n10.y > n11.y ? n10.y : n11.y;
        var intMinX = minX0 > minX1 ? minX0 : minX1;
        var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
        var intMinY = minY0 > minY1 ? minY0 : minY1;
        var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
        var intMidX = (intMinX + intMaxX) / 2;
        var intMidY = (intMinY + intMaxY) / 2;
        normPt.x = intMidX;
        normPt.y = intMidY;
        n00.x -= normPt.x;
        n00.y -= normPt.y;
        n01.x -= normPt.x;
        n01.y -= normPt.y;
        n10.x -= normPt.x;
        n10.y -= normPt.y;
        n11.x -= normPt.x;
        n11.y -= normPt.y;
      };
      RobustLineIntersector2.prototype.computeIntersect = function computeIntersect(p1, p2, q1, q2) {
        this._isProper = false;
        if (!Envelope.intersects(p1, p2, q1, q2)) {
          return LineIntersector$$1.NO_INTERSECTION;
        }
        var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
        var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);
        if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {
          return LineIntersector$$1.NO_INTERSECTION;
        }
        var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
        var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);
        if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {
          return LineIntersector$$1.NO_INTERSECTION;
        }
        var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
        if (collinear) {
          return this.computeCollinearIntersection(p1, p2, q1, q2);
        }
        if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
          this._isProper = false;
          if (p1.equals2D(q1) || p1.equals2D(q2)) {
            this._intPt[0] = p1;
          } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
            this._intPt[0] = p2;
          } else if (Pq1 === 0) {
            this._intPt[0] = new Coordinate(q1);
          } else if (Pq2 === 0) {
            this._intPt[0] = new Coordinate(q2);
          } else if (Qp1 === 0) {
            this._intPt[0] = new Coordinate(p1);
          } else if (Qp2 === 0) {
            this._intPt[0] = new Coordinate(p2);
          }
        } else {
          this._isProper = true;
          this._intPt[0] = this.intersection(p1, p2, q1, q2);
        }
        return LineIntersector$$1.POINT_INTERSECTION;
      };
      RobustLineIntersector2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      RobustLineIntersector2.prototype.getClass = function getClass() {
        return RobustLineIntersector2;
      };
      RobustLineIntersector2.nearestEndpoint = function nearestEndpoint(p1, p2, q1, q2) {
        var nearestPt = p1;
        var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);
        var dist = CGAlgorithms.distancePointLine(p2, q1, q2);
        if (dist < minDist) {
          minDist = dist;
          nearestPt = p2;
        }
        dist = CGAlgorithms.distancePointLine(q1, p1, p2);
        if (dist < minDist) {
          minDist = dist;
          nearestPt = q1;
        }
        dist = CGAlgorithms.distancePointLine(q2, p1, p2);
        if (dist < minDist) {
          minDist = dist;
          nearestPt = q2;
        }
        return nearestPt;
      };
      return RobustLineIntersector2;
    }(LineIntersector);
    var RobustDeterminant = function RobustDeterminant2() {
    };
    RobustDeterminant.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    RobustDeterminant.prototype.getClass = function getClass() {
      return RobustDeterminant;
    };
    RobustDeterminant.orientationIndex = function orientationIndex(p1, p2, q) {
      var dx1 = p2.x - p1.x;
      var dy1 = p2.y - p1.y;
      var dx2 = q.x - p2.x;
      var dy2 = q.y - p2.y;
      return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
    };
    RobustDeterminant.signOfDet2x2 = function signOfDet2x2(x1, y1, x2, y2) {
      var sign = null;
      var swap = null;
      var k = null;
      sign = 1;
      if (x1 === 0 || y2 === 0) {
        if (y1 === 0 || x2 === 0) {
          return 0;
        } else if (y1 > 0) {
          if (x2 > 0) {
            return -sign;
          } else {
            return sign;
          }
        } else {
          if (x2 > 0) {
            return sign;
          } else {
            return -sign;
          }
        }
      }
      if (y1 === 0 || x2 === 0) {
        if (y2 > 0) {
          if (x1 > 0) {
            return sign;
          } else {
            return -sign;
          }
        } else {
          if (x1 > 0) {
            return -sign;
          } else {
            return sign;
          }
        }
      }
      if (y1 > 0) {
        if (y2 > 0) {
          if (y1 <= y2) {
          } else {
            sign = -sign;
            swap = x1;
            x1 = x2;
            x2 = swap;
            swap = y1;
            y1 = y2;
            y2 = swap;
          }
        } else {
          if (y1 <= -y2) {
            sign = -sign;
            x2 = -x2;
            y2 = -y2;
          } else {
            swap = x1;
            x1 = -x2;
            x2 = swap;
            swap = y1;
            y1 = -y2;
            y2 = swap;
          }
        }
      } else {
        if (y2 > 0) {
          if (-y1 <= y2) {
            sign = -sign;
            x1 = -x1;
            y1 = -y1;
          } else {
            swap = -x1;
            x1 = x2;
            x2 = swap;
            swap = -y1;
            y1 = y2;
            y2 = swap;
          }
        } else {
          if (y1 >= y2) {
            x1 = -x1;
            y1 = -y1;
            x2 = -x2;
            y2 = -y2;
          } else {
            sign = -sign;
            swap = -x1;
            x1 = -x2;
            x2 = swap;
            swap = -y1;
            y1 = -y2;
            y2 = swap;
          }
        }
      }
      if (x1 > 0) {
        if (x2 > 0) {
          if (x1 <= x2) {
          } else {
            return sign;
          }
        } else {
          return sign;
        }
      } else {
        if (x2 > 0) {
          return -sign;
        } else {
          if (x1 >= x2) {
            sign = -sign;
            x1 = -x1;
            x2 = -x2;
          } else {
            return -sign;
          }
        }
      }
      while (true) {
        k = Math.floor(x2 / x1);
        x2 = x2 - k * x1;
        y2 = y2 - k * y1;
        if (y2 < 0) {
          return -sign;
        }
        if (y2 > y1) {
          return sign;
        }
        if (x1 > x2 + x2) {
          if (y1 < y2 + y2) {
            return sign;
          }
        } else {
          if (y1 > y2 + y2) {
            return -sign;
          } else {
            x2 = x1 - x2;
            y2 = y1 - y2;
            sign = -sign;
          }
        }
        if (y2 === 0) {
          if (x2 === 0) {
            return 0;
          } else {
            return -sign;
          }
        }
        if (x2 === 0) {
          return sign;
        }
        k = Math.floor(x1 / x2);
        x1 = x1 - k * x2;
        y1 = y1 - k * y2;
        if (y1 < 0) {
          return sign;
        }
        if (y1 > y2) {
          return -sign;
        }
        if (x2 > x1 + x1) {
          if (y2 < y1 + y1) {
            return -sign;
          }
        } else {
          if (y2 > y1 + y1) {
            return sign;
          } else {
            x1 = x2 - x1;
            y1 = y2 - y1;
            sign = -sign;
          }
        }
        if (y1 === 0) {
          if (x1 === 0) {
            return 0;
          } else {
            return sign;
          }
        }
        if (x1 === 0) {
          return -sign;
        }
      }
    };
    var RayCrossingCounter = function RayCrossingCounter2() {
      this._p = null;
      this._crossingCount = 0;
      this._isPointOnSegment = false;
      var p = arguments[0];
      this._p = p;
    };
    RayCrossingCounter.prototype.countSegment = function countSegment(p1, p2) {
      if (p1.x < this._p.x && p2.x < this._p.x) {
        return null;
      }
      if (this._p.x === p2.x && this._p.y === p2.y) {
        this._isPointOnSegment = true;
        return null;
      }
      if (p1.y === this._p.y && p2.y === this._p.y) {
        var minx = p1.x;
        var maxx = p2.x;
        if (minx > maxx) {
          minx = p2.x;
          maxx = p1.x;
        }
        if (this._p.x >= minx && this._p.x <= maxx) {
          this._isPointOnSegment = true;
        }
        return null;
      }
      if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
        var x1 = p1.x - this._p.x;
        var y1 = p1.y - this._p.y;
        var x2 = p2.x - this._p.x;
        var y2 = p2.y - this._p.y;
        var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);
        if (xIntSign === 0) {
          this._isPointOnSegment = true;
          return null;
        }
        if (y2 < y1) {
          xIntSign = -xIntSign;
        }
        if (xIntSign > 0) {
          this._crossingCount++;
        }
      }
    };
    RayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon() {
      return this.getLocation() !== Location.EXTERIOR;
    };
    RayCrossingCounter.prototype.getLocation = function getLocation() {
      if (this._isPointOnSegment) {
        return Location.BOUNDARY;
      }
      if (this._crossingCount % 2 === 1) {
        return Location.INTERIOR;
      }
      return Location.EXTERIOR;
    };
    RayCrossingCounter.prototype.isOnSegment = function isOnSegment() {
      return this._isPointOnSegment;
    };
    RayCrossingCounter.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    RayCrossingCounter.prototype.getClass = function getClass() {
      return RayCrossingCounter;
    };
    RayCrossingCounter.locatePointInRing = function locatePointInRing() {
      if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
        var p = arguments[0];
        var ring = arguments[1];
        var counter = new RayCrossingCounter(p);
        var p1 = new Coordinate();
        var p2 = new Coordinate();
        for (var i = 1; i < ring.size(); i++) {
          ring.getCoordinate(i, p1);
          ring.getCoordinate(i - 1, p2);
          counter.countSegment(p1, p2);
          if (counter.isOnSegment()) {
            return counter.getLocation();
          }
        }
        return counter.getLocation();
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
        var p$1 = arguments[0];
        var ring$1 = arguments[1];
        var counter$1 = new RayCrossingCounter(p$1);
        for (var i$1 = 1; i$1 < ring$1.length; i$1++) {
          var p1$1 = ring$1[i$1];
          var p2$1 = ring$1[i$1 - 1];
          counter$1.countSegment(p1$1, p2$1);
          if (counter$1.isOnSegment()) {
            return counter$1.getLocation();
          }
        }
        return counter$1.getLocation();
      }
    };
    var CGAlgorithms = function CGAlgorithms2() {
    };
    var staticAccessors$3 = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
    CGAlgorithms.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CGAlgorithms.prototype.getClass = function getClass() {
      return CGAlgorithms;
    };
    CGAlgorithms.orientationIndex = function orientationIndex(p1, p2, q) {
      return CGAlgorithmsDD.orientationIndex(p1, p2, q);
    };
    CGAlgorithms.signedArea = function signedArea() {
      if (arguments[0] instanceof Array) {
        var ring = arguments[0];
        if (ring.length < 3) {
          return 0;
        }
        var sum = 0;
        var x0 = ring[0].x;
        for (var i = 1; i < ring.length - 1; i++) {
          var x = ring[i].x - x0;
          var y1 = ring[i + 1].y;
          var y2 = ring[i - 1].y;
          sum += x * (y2 - y1);
        }
        return sum / 2;
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        var ring$1 = arguments[0];
        var n = ring$1.size();
        if (n < 3) {
          return 0;
        }
        var p0 = new Coordinate();
        var p1 = new Coordinate();
        var p2 = new Coordinate();
        ring$1.getCoordinate(0, p1);
        ring$1.getCoordinate(1, p2);
        var x0$1 = p1.x;
        p2.x -= x0$1;
        var sum$1 = 0;
        for (var i$1 = 1; i$1 < n - 1; i$1++) {
          p0.y = p1.y;
          p1.x = p2.x;
          p1.y = p2.y;
          ring$1.getCoordinate(i$1 + 1, p2);
          p2.x -= x0$1;
          sum$1 += p1.x * (p0.y - p2.y);
        }
        return sum$1 / 2;
      }
    };
    CGAlgorithms.distanceLineLine = function distanceLineLine(A, B, C, D) {
      if (A.equals(B)) {
        return CGAlgorithms.distancePointLine(A, C, D);
      }
      if (C.equals(D)) {
        return CGAlgorithms.distancePointLine(D, A, B);
      }
      var noIntersection = false;
      if (!Envelope.intersects(A, B, C, D)) {
        noIntersection = true;
      } else {
        var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
        if (denom === 0) {
          noIntersection = true;
        } else {
          var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
          var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
          var s = sNum / denom;
          var r = rNumb / denom;
          if (r < 0 || r > 1 || s < 0 || s > 1) {
            noIntersection = true;
          }
        }
      }
      if (noIntersection) {
        return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));
      }
      return 0;
    };
    CGAlgorithms.isPointInRing = function isPointInRing(p, ring) {
      return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;
    };
    CGAlgorithms.computeLength = function computeLength(pts) {
      var n = pts.size();
      if (n <= 1) {
        return 0;
      }
      var len = 0;
      var p = new Coordinate();
      pts.getCoordinate(0, p);
      var x0 = p.x;
      var y0 = p.y;
      for (var i = 1; i < n; i++) {
        pts.getCoordinate(i, p);
        var x1 = p.x;
        var y1 = p.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        len += Math.sqrt(dx * dx + dy * dy);
        x0 = x1;
        y0 = y1;
      }
      return len;
    };
    CGAlgorithms.isCCW = function isCCW(ring) {
      var nPts = ring.length - 1;
      if (nPts < 3) {
        throw new IllegalArgumentException("Ring has fewer than 4 points, so orientation cannot be determined");
      }
      var hiPt = ring[0];
      var hiIndex = 0;
      for (var i = 1; i <= nPts; i++) {
        var p = ring[i];
        if (p.y > hiPt.y) {
          hiPt = p;
          hiIndex = i;
        }
      }
      var iPrev = hiIndex;
      do {
        iPrev = iPrev - 1;
        if (iPrev < 0) {
          iPrev = nPts;
        }
      } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
      var iNext = hiIndex;
      do {
        iNext = (iNext + 1) % nPts;
      } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
      var prev = ring[iPrev];
      var next = ring[iNext];
      if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) {
        return false;
      }
      var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);
      var isCCW2 = false;
      if (disc === 0) {
        isCCW2 = prev.x > next.x;
      } else {
        isCCW2 = disc > 0;
      }
      return isCCW2;
    };
    CGAlgorithms.locatePointInRing = function locatePointInRing(p, ring) {
      return RayCrossingCounter.locatePointInRing(p, ring);
    };
    CGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular(p, A, B) {
      var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
      var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
      return Math.abs(s) * Math.sqrt(len2);
    };
    CGAlgorithms.computeOrientation = function computeOrientation(p1, p2, q) {
      return CGAlgorithms.orientationIndex(p1, p2, q);
    };
    CGAlgorithms.distancePointLine = function distancePointLine() {
      if (arguments.length === 2) {
        var p = arguments[0];
        var line = arguments[1];
        if (line.length === 0) {
          throw new IllegalArgumentException("Line array must contain at least one vertex");
        }
        var minDistance = p.distance(line[0]);
        for (var i = 0; i < line.length - 1; i++) {
          var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
          if (dist < minDistance) {
            minDistance = dist;
          }
        }
        return minDistance;
      } else if (arguments.length === 3) {
        var p$1 = arguments[0];
        var A = arguments[1];
        var B = arguments[2];
        if (A.x === B.x && A.y === B.y) {
          return p$1.distance(A);
        }
        var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
        var r = ((p$1.x - A.x) * (B.x - A.x) + (p$1.y - A.y) * (B.y - A.y)) / len2;
        if (r <= 0) {
          return p$1.distance(A);
        }
        if (r >= 1) {
          return p$1.distance(B);
        }
        var s = ((A.y - p$1.y) * (B.x - A.x) - (A.x - p$1.x) * (B.y - A.y)) / len2;
        return Math.abs(s) * Math.sqrt(len2);
      }
    };
    CGAlgorithms.isOnLine = function isOnLine(p, pt) {
      var lineIntersector = new RobustLineIntersector();
      for (var i = 1; i < pt.length; i++) {
        var p0 = pt[i - 1];
        var p1 = pt[i];
        lineIntersector.computeIntersection(p, p0, p1);
        if (lineIntersector.hasIntersection()) {
          return true;
        }
      }
      return false;
    };
    staticAccessors$3.CLOCKWISE.get = function() {
      return -1;
    };
    staticAccessors$3.RIGHT.get = function() {
      return CGAlgorithms.CLOCKWISE;
    };
    staticAccessors$3.COUNTERCLOCKWISE.get = function() {
      return 1;
    };
    staticAccessors$3.LEFT.get = function() {
      return CGAlgorithms.COUNTERCLOCKWISE;
    };
    staticAccessors$3.COLLINEAR.get = function() {
      return 0;
    };
    staticAccessors$3.STRAIGHT.get = function() {
      return CGAlgorithms.COLLINEAR;
    };
    Object.defineProperties(CGAlgorithms, staticAccessors$3);
    var GeometryComponentFilter = function GeometryComponentFilter2() {
    };
    GeometryComponentFilter.prototype.filter = function filter(geom) {
    };
    GeometryComponentFilter.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryComponentFilter.prototype.getClass = function getClass() {
      return GeometryComponentFilter;
    };
    var Geometry = function Geometry2() {
      var factory = arguments[0];
      this._envelope = null;
      this._factory = null;
      this._SRID = null;
      this._userData = null;
      this._factory = factory;
      this._SRID = factory.getSRID();
    };
    var staticAccessors$11 = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
    Geometry.prototype.isGeometryCollection = function isGeometryCollection() {
      return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;
    };
    Geometry.prototype.getFactory = function getFactory() {
      return this._factory;
    };
    Geometry.prototype.getGeometryN = function getGeometryN(n) {
      return this;
    };
    Geometry.prototype.getArea = function getArea() {
      return 0;
    };
    Geometry.prototype.isRectangle = function isRectangle() {
      return false;
    };
    Geometry.prototype.equals = function equals() {
      if (arguments[0] instanceof Geometry) {
        var g$1 = arguments[0];
        if (g$1 === null) {
          return false;
        }
        return this.equalsTopo(g$1);
      } else if (arguments[0] instanceof Object) {
        var o = arguments[0];
        if (!(o instanceof Geometry)) {
          return false;
        }
        var g = o;
        return this.equalsExact(g);
      }
    };
    Geometry.prototype.equalsExact = function equalsExact(other) {
      return this === other || this.equalsExact(other, 0);
    };
    Geometry.prototype.geometryChanged = function geometryChanged() {
      this.apply(Geometry.geometryChangedFilter);
    };
    Geometry.prototype.geometryChangedAction = function geometryChangedAction() {
      this._envelope = null;
    };
    Geometry.prototype.equalsNorm = function equalsNorm(g) {
      if (g === null) {
        return false;
      }
      return this.norm().equalsExact(g.norm());
    };
    Geometry.prototype.getLength = function getLength() {
      return 0;
    };
    Geometry.prototype.getNumGeometries = function getNumGeometries() {
      return 1;
    };
    Geometry.prototype.compareTo = function compareTo() {
      if (arguments.length === 1) {
        var o = arguments[0];
        var other = o;
        if (this.getSortIndex() !== other.getSortIndex()) {
          return this.getSortIndex() - other.getSortIndex();
        }
        if (this.isEmpty() && other.isEmpty()) {
          return 0;
        }
        if (this.isEmpty()) {
          return -1;
        }
        if (other.isEmpty()) {
          return 1;
        }
        return this.compareToSameClass(o);
      } else if (arguments.length === 2) {
        var other$1 = arguments[0];
        var comp = arguments[1];
        if (this.getSortIndex() !== other$1.getSortIndex()) {
          return this.getSortIndex() - other$1.getSortIndex();
        }
        if (this.isEmpty() && other$1.isEmpty()) {
          return 0;
        }
        if (this.isEmpty()) {
          return -1;
        }
        if (other$1.isEmpty()) {
          return 1;
        }
        return this.compareToSameClass(other$1, comp);
      }
    };
    Geometry.prototype.getUserData = function getUserData() {
      return this._userData;
    };
    Geometry.prototype.getSRID = function getSRID() {
      return this._SRID;
    };
    Geometry.prototype.getEnvelope = function getEnvelope() {
      return this.getFactory().toGeometry(this.getEnvelopeInternal());
    };
    Geometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection(g) {
      if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
        throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
      }
    };
    Geometry.prototype.equal = function equal(a, b, tolerance) {
      if (tolerance === 0) {
        return a.equals(b);
      }
      return a.distance(b) <= tolerance;
    };
    Geometry.prototype.norm = function norm() {
      var copy = this.copy();
      copy.normalize();
      return copy;
    };
    Geometry.prototype.getPrecisionModel = function getPrecisionModel() {
      return this._factory.getPrecisionModel();
    };
    Geometry.prototype.getEnvelopeInternal = function getEnvelopeInternal() {
      if (this._envelope === null) {
        this._envelope = this.computeEnvelopeInternal();
      }
      return new Envelope(this._envelope);
    };
    Geometry.prototype.setSRID = function setSRID(SRID) {
      this._SRID = SRID;
    };
    Geometry.prototype.setUserData = function setUserData(userData) {
      this._userData = userData;
    };
    Geometry.prototype.compare = function compare(a, b) {
      var i = a.iterator();
      var j = b.iterator();
      while (i.hasNext() && j.hasNext()) {
        var aElement = i.next();
        var bElement = j.next();
        var comparison = aElement.compareTo(bElement);
        if (comparison !== 0) {
          return comparison;
        }
      }
      if (i.hasNext()) {
        return 1;
      }
      if (j.hasNext()) {
        return -1;
      }
      return 0;
    };
    Geometry.prototype.hashCode = function hashCode() {
      return this.getEnvelopeInternal().hashCode();
    };
    Geometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived() {
      if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
        return true;
      }
      return false;
    };
    Geometry.prototype.interfaces_ = function interfaces_() {
      return [Clonable, Comparable, Serializable];
    };
    Geometry.prototype.getClass = function getClass() {
      return Geometry;
    };
    Geometry.hasNonEmptyElements = function hasNonEmptyElements(geometries) {
      for (var i = 0; i < geometries.length; i++) {
        if (!geometries[i].isEmpty()) {
          return true;
        }
      }
      return false;
    };
    Geometry.hasNullElements = function hasNullElements(array) {
      for (var i = 0; i < array.length; i++) {
        if (array[i] === null) {
          return true;
        }
      }
      return false;
    };
    staticAccessors$11.serialVersionUID.get = function() {
      return 8763622679187377e3;
    };
    staticAccessors$11.SORTINDEX_POINT.get = function() {
      return 0;
    };
    staticAccessors$11.SORTINDEX_MULTIPOINT.get = function() {
      return 1;
    };
    staticAccessors$11.SORTINDEX_LINESTRING.get = function() {
      return 2;
    };
    staticAccessors$11.SORTINDEX_LINEARRING.get = function() {
      return 3;
    };
    staticAccessors$11.SORTINDEX_MULTILINESTRING.get = function() {
      return 4;
    };
    staticAccessors$11.SORTINDEX_POLYGON.get = function() {
      return 5;
    };
    staticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function() {
      return 6;
    };
    staticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
      return 7;
    };
    staticAccessors$11.geometryChangedFilter.get = function() {
      return geometryChangedFilter;
    };
    Object.defineProperties(Geometry, staticAccessors$11);
    var geometryChangedFilter = function geometryChangedFilter2() {
    };
    geometryChangedFilter.interfaces_ = function interfaces_() {
      return [GeometryComponentFilter];
    };
    geometryChangedFilter.filter = function filter(geom) {
      geom.geometryChangedAction();
    };
    var CoordinateFilter = function CoordinateFilter2() {
    };
    CoordinateFilter.prototype.filter = function filter(coord) {
    };
    CoordinateFilter.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CoordinateFilter.prototype.getClass = function getClass() {
      return CoordinateFilter;
    };
    var BoundaryNodeRule = function BoundaryNodeRule2() {
    };
    var staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
    BoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
    };
    BoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BoundaryNodeRule.prototype.getClass = function getClass() {
      return BoundaryNodeRule;
    };
    staticAccessors$12.Mod2BoundaryNodeRule.get = function() {
      return Mod2BoundaryNodeRule;
    };
    staticAccessors$12.EndPointBoundaryNodeRule.get = function() {
      return EndPointBoundaryNodeRule;
    };
    staticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function() {
      return MultiValentEndPointBoundaryNodeRule;
    };
    staticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function() {
      return MonoValentEndPointBoundaryNodeRule;
    };
    staticAccessors$12.MOD2_BOUNDARY_RULE.get = function() {
      return new Mod2BoundaryNodeRule();
    };
    staticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function() {
      return new EndPointBoundaryNodeRule();
    };
    staticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
      return new MultiValentEndPointBoundaryNodeRule();
    };
    staticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
      return new MonoValentEndPointBoundaryNodeRule();
    };
    staticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function() {
      return BoundaryNodeRule.MOD2_BOUNDARY_RULE;
    };
    Object.defineProperties(BoundaryNodeRule, staticAccessors$12);
    var Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule2() {
    };
    Mod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
      return boundaryCount % 2 === 1;
    };
    Mod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
      return [BoundaryNodeRule];
    };
    Mod2BoundaryNodeRule.prototype.getClass = function getClass() {
      return Mod2BoundaryNodeRule;
    };
    var EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule2() {
    };
    EndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
      return boundaryCount > 0;
    };
    EndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
      return [BoundaryNodeRule];
    };
    EndPointBoundaryNodeRule.prototype.getClass = function getClass() {
      return EndPointBoundaryNodeRule;
    };
    var MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule2() {
    };
    MultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
      return boundaryCount > 1;
    };
    MultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
      return [BoundaryNodeRule];
    };
    MultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass() {
      return MultiValentEndPointBoundaryNodeRule;
    };
    var MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule2() {
    };
    MonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
      return boundaryCount === 1;
    };
    MonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {
      return [BoundaryNodeRule];
    };
    MonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass() {
      return MonoValentEndPointBoundaryNodeRule;
    };
    var Collection = function Collection2() {
    };
    Collection.prototype.add = function add() {
    };
    Collection.prototype.addAll = function addAll() {
    };
    Collection.prototype.isEmpty = function isEmpty() {
    };
    Collection.prototype.iterator = function iterator() {
    };
    Collection.prototype.size = function size() {
    };
    Collection.prototype.toArray = function toArray() {
    };
    Collection.prototype.remove = function remove() {
    };
    function IndexOutOfBoundsException(message) {
      this.message = message || "";
    }
    IndexOutOfBoundsException.prototype = new Error();
    IndexOutOfBoundsException.prototype.name = "IndexOutOfBoundsException";
    var Iterator = function Iterator2() {
    };
    Iterator.prototype.hasNext = function hasNext() {
    };
    Iterator.prototype.next = function next() {
    };
    Iterator.prototype.remove = function remove() {
    };
    var List = function(Collection$$1) {
      function List2() {
        Collection$$1.apply(this, arguments);
      }
      if (Collection$$1) List2.__proto__ = Collection$$1;
      List2.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
      List2.prototype.constructor = List2;
      List2.prototype.get = function get2() {
      };
      List2.prototype.set = function set() {
      };
      List2.prototype.isEmpty = function isEmpty() {
      };
      return List2;
    }(Collection);
    function NoSuchElementException(message) {
      this.message = message || "";
    }
    NoSuchElementException.prototype = new Error();
    NoSuchElementException.prototype.name = "NoSuchElementException";
    var ArrayList = function(List$$1) {
      function ArrayList2() {
        List$$1.call(this);
        this.array_ = [];
        if (arguments[0] instanceof Collection) {
          this.addAll(arguments[0]);
        }
      }
      if (List$$1) ArrayList2.__proto__ = List$$1;
      ArrayList2.prototype = Object.create(List$$1 && List$$1.prototype);
      ArrayList2.prototype.constructor = ArrayList2;
      ArrayList2.prototype.ensureCapacity = function ensureCapacity() {
      };
      ArrayList2.prototype.interfaces_ = function interfaces_() {
        return [List$$1, Collection];
      };
      ArrayList2.prototype.add = function add(e) {
        if (arguments.length === 1) {
          this.array_.push(e);
        } else {
          this.array_.splice(arguments[0], arguments[1]);
        }
        return true;
      };
      ArrayList2.prototype.clear = function clear() {
        this.array_ = [];
      };
      ArrayList2.prototype.addAll = function addAll(c) {
        var this$1 = this;
        for (var i = c.iterator(); i.hasNext(); ) {
          this$1.add(i.next());
        }
        return true;
      };
      ArrayList2.prototype.set = function set(index, element) {
        var oldElement = this.array_[index];
        this.array_[index] = element;
        return oldElement;
      };
      ArrayList2.prototype.iterator = function iterator() {
        return new Iterator_(this);
      };
      ArrayList2.prototype.get = function get2(index) {
        if (index < 0 || index >= this.size()) {
          throw new IndexOutOfBoundsException();
        }
        return this.array_[index];
      };
      ArrayList2.prototype.isEmpty = function isEmpty() {
        return this.array_.length === 0;
      };
      ArrayList2.prototype.size = function size() {
        return this.array_.length;
      };
      ArrayList2.prototype.toArray = function toArray() {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = this.array_.length; i < len; i++) {
          array.push(this$1.array_[i]);
        }
        return array;
      };
      ArrayList2.prototype.remove = function remove(o) {
        var this$1 = this;
        var found = false;
        for (var i = 0, len = this.array_.length; i < len; i++) {
          if (this$1.array_[i] === o) {
            this$1.array_.splice(i, 1);
            found = true;
            break;
          }
        }
        return found;
      };
      return ArrayList2;
    }(List);
    var Iterator_ = function(Iterator$$1) {
      function Iterator_2(arrayList) {
        Iterator$$1.call(this);
        this.arrayList_ = arrayList;
        this.position_ = 0;
      }
      if (Iterator$$1) Iterator_2.__proto__ = Iterator$$1;
      Iterator_2.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
      Iterator_2.prototype.constructor = Iterator_2;
      Iterator_2.prototype.next = function next() {
        if (this.position_ === this.arrayList_.size()) {
          throw new NoSuchElementException();
        }
        return this.arrayList_.get(this.position_++);
      };
      Iterator_2.prototype.hasNext = function hasNext() {
        if (this.position_ < this.arrayList_.size()) {
          return true;
        } else {
          return false;
        }
      };
      Iterator_2.prototype.set = function set(element) {
        return this.arrayList_.set(this.position_ - 1, element);
      };
      Iterator_2.prototype.remove = function remove() {
        this.arrayList_.remove(this.arrayList_.get(this.position_));
      };
      return Iterator_2;
    }(Iterator);
    var CoordinateList = function(ArrayList$$1) {
      function CoordinateList2() {
        ArrayList$$1.call(this);
        if (arguments.length === 0) {
        } else if (arguments.length === 1) {
          var coord = arguments[0];
          this.ensureCapacity(coord.length);
          this.add(coord, true);
        } else if (arguments.length === 2) {
          var coord$1 = arguments[0];
          var allowRepeated = arguments[1];
          this.ensureCapacity(coord$1.length);
          this.add(coord$1, allowRepeated);
        }
      }
      if (ArrayList$$1) CoordinateList2.__proto__ = ArrayList$$1;
      CoordinateList2.prototype = Object.create(ArrayList$$1 && ArrayList$$1.prototype);
      CoordinateList2.prototype.constructor = CoordinateList2;
      var staticAccessors2 = { coordArrayType: { configurable: true } };
      staticAccessors2.coordArrayType.get = function() {
        return new Array(0).fill(null);
      };
      CoordinateList2.prototype.getCoordinate = function getCoordinate(i) {
        return this.get(i);
      };
      CoordinateList2.prototype.addAll = function addAll() {
        var this$1 = this;
        if (arguments.length === 2) {
          var coll = arguments[0];
          var allowRepeated = arguments[1];
          var isChanged = false;
          for (var i = coll.iterator(); i.hasNext(); ) {
            this$1.add(i.next(), allowRepeated);
            isChanged = true;
          }
          return isChanged;
        } else {
          return ArrayList$$1.prototype.addAll.apply(this, arguments);
        }
      };
      CoordinateList2.prototype.clone = function clone() {
        var this$1 = this;
        var clone2 = ArrayList$$1.prototype.clone.call(this);
        for (var i = 0; i < this.size(); i++) {
          clone2.add(i, this$1.get(i).copy());
        }
        return clone2;
      };
      CoordinateList2.prototype.toCoordinateArray = function toCoordinateArray() {
        return this.toArray(CoordinateList2.coordArrayType);
      };
      CoordinateList2.prototype.add = function add() {
        var this$1 = this;
        if (arguments.length === 1) {
          var coord = arguments[0];
          ArrayList$$1.prototype.add.call(this, coord);
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof Array && typeof arguments[1] === "boolean") {
            var coord$1 = arguments[0];
            var allowRepeated = arguments[1];
            this.add(coord$1, allowRepeated, true);
            return true;
          } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === "boolean") {
            var coord$2 = arguments[0];
            var allowRepeated$1 = arguments[1];
            if (!allowRepeated$1) {
              if (this.size() >= 1) {
                var last = this.get(this.size() - 1);
                if (last.equals2D(coord$2)) {
                  return null;
                }
              }
            }
            ArrayList$$1.prototype.add.call(this, coord$2);
          } else if (arguments[0] instanceof Object && typeof arguments[1] === "boolean") {
            var obj = arguments[0];
            var allowRepeated$2 = arguments[1];
            this.add(obj, allowRepeated$2);
            return true;
          }
        } else if (arguments.length === 3) {
          if (typeof arguments[2] === "boolean" && (arguments[0] instanceof Array && typeof arguments[1] === "boolean")) {
            var coord$3 = arguments[0];
            var allowRepeated$3 = arguments[1];
            var direction = arguments[2];
            if (direction) {
              for (var i$1 = 0; i$1 < coord$3.length; i$1++) {
                this$1.add(coord$3[i$1], allowRepeated$3);
              }
            } else {
              for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {
                this$1.add(coord$3[i$2], allowRepeated$3);
              }
            }
            return true;
          } else if (typeof arguments[2] === "boolean" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {
            var i$3 = arguments[0];
            var coord$4 = arguments[1];
            var allowRepeated$4 = arguments[2];
            if (!allowRepeated$4) {
              var size = this.size();
              if (size > 0) {
                if (i$3 > 0) {
                  var prev = this.get(i$3 - 1);
                  if (prev.equals2D(coord$4)) {
                    return null;
                  }
                }
                if (i$3 < size) {
                  var next = this.get(i$3);
                  if (next.equals2D(coord$4)) {
                    return null;
                  }
                }
              }
            }
            ArrayList$$1.prototype.add.call(this, i$3, coord$4);
          }
        } else if (arguments.length === 4) {
          var coord$5 = arguments[0];
          var allowRepeated$5 = arguments[1];
          var start = arguments[2];
          var end = arguments[3];
          var inc = 1;
          if (start > end) {
            inc = -1;
          }
          for (var i = start; i !== end; i += inc) {
            this$1.add(coord$5[i], allowRepeated$5);
          }
          return true;
        }
      };
      CoordinateList2.prototype.closeRing = function closeRing() {
        if (this.size() > 0) {
          this.add(new Coordinate(this.get(0)), false);
        }
      };
      CoordinateList2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      CoordinateList2.prototype.getClass = function getClass() {
        return CoordinateList2;
      };
      Object.defineProperties(CoordinateList2, staticAccessors2);
      return CoordinateList2;
    }(ArrayList);
    var CoordinateArrays = function CoordinateArrays2() {
    };
    var staticAccessors$13 = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
    staticAccessors$13.ForwardComparator.get = function() {
      return ForwardComparator;
    };
    staticAccessors$13.BidirectionalComparator.get = function() {
      return BidirectionalComparator;
    };
    staticAccessors$13.coordArrayType.get = function() {
      return new Array(0).fill(null);
    };
    CoordinateArrays.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CoordinateArrays.prototype.getClass = function getClass() {
      return CoordinateArrays;
    };
    CoordinateArrays.isRing = function isRing(pts) {
      if (pts.length < 4) {
        return false;
      }
      if (!pts[0].equals2D(pts[pts.length - 1])) {
        return false;
      }
      return true;
    };
    CoordinateArrays.ptNotInList = function ptNotInList(testPts, pts) {
      for (var i = 0; i < testPts.length; i++) {
        var testPt = testPts[i];
        if (CoordinateArrays.indexOf(testPt, pts) < 0) {
          return testPt;
        }
      }
      return null;
    };
    CoordinateArrays.scroll = function scroll(coordinates, firstCoordinate) {
      var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
      if (i < 0) {
        return null;
      }
      var newCoordinates = new Array(coordinates.length).fill(null);
      System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
      System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
      System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
    };
    CoordinateArrays.equals = function equals() {
      if (arguments.length === 2) {
        var coord1 = arguments[0];
        var coord2 = arguments[1];
        if (coord1 === coord2) {
          return true;
        }
        if (coord1 === null || coord2 === null) {
          return false;
        }
        if (coord1.length !== coord2.length) {
          return false;
        }
        for (var i = 0; i < coord1.length; i++) {
          if (!coord1[i].equals(coord2[i])) {
            return false;
          }
        }
        return true;
      } else if (arguments.length === 3) {
        var coord1$1 = arguments[0];
        var coord2$1 = arguments[1];
        var coordinateComparator = arguments[2];
        if (coord1$1 === coord2$1) {
          return true;
        }
        if (coord1$1 === null || coord2$1 === null) {
          return false;
        }
        if (coord1$1.length !== coord2$1.length) {
          return false;
        }
        for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {
          if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) {
            return false;
          }
        }
        return true;
      }
    };
    CoordinateArrays.intersection = function intersection(coordinates, env) {
      var coordList = new CoordinateList();
      for (var i = 0; i < coordinates.length; i++) {
        if (env.intersects(coordinates[i])) {
          coordList.add(coordinates[i], true);
        }
      }
      return coordList.toCoordinateArray();
    };
    CoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints(coord) {
      for (var i = 1; i < coord.length; i++) {
        if (coord[i - 1].equals(coord[i])) {
          return true;
        }
      }
      return false;
    };
    CoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints(coord) {
      if (!CoordinateArrays.hasRepeatedPoints(coord)) {
        return coord;
      }
      var coordList = new CoordinateList(coord, false);
      return coordList.toCoordinateArray();
    };
    CoordinateArrays.reverse = function reverse(coord) {
      var last = coord.length - 1;
      var mid = Math.trunc(last / 2);
      for (var i = 0; i <= mid; i++) {
        var tmp = coord[i];
        coord[i] = coord[last - i];
        coord[last - i] = tmp;
      }
    };
    CoordinateArrays.removeNull = function removeNull(coord) {
      var nonNull = 0;
      for (var i = 0; i < coord.length; i++) {
        if (coord[i] !== null) {
          nonNull++;
        }
      }
      var newCoord = new Array(nonNull).fill(null);
      if (nonNull === 0) {
        return newCoord;
      }
      var j = 0;
      for (var i$1 = 0; i$1 < coord.length; i$1++) {
        if (coord[i$1] !== null) {
          newCoord[j++] = coord[i$1];
        }
      }
      return newCoord;
    };
    CoordinateArrays.copyDeep = function copyDeep() {
      if (arguments.length === 1) {
        var coordinates = arguments[0];
        var copy = new Array(coordinates.length).fill(null);
        for (var i = 0; i < coordinates.length; i++) {
          copy[i] = new Coordinate(coordinates[i]);
        }
        return copy;
      } else if (arguments.length === 5) {
        var src = arguments[0];
        var srcStart = arguments[1];
        var dest = arguments[2];
        var destStart = arguments[3];
        var length = arguments[4];
        for (var i$1 = 0; i$1 < length; i$1++) {
          dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);
        }
      }
    };
    CoordinateArrays.isEqualReversed = function isEqualReversed(pts1, pts2) {
      for (var i = 0; i < pts1.length; i++) {
        var p1 = pts1[i];
        var p2 = pts2[pts1.length - i - 1];
        if (p1.compareTo(p2) !== 0) {
          return false;
        }
      }
      return true;
    };
    CoordinateArrays.envelope = function envelope(coordinates) {
      var env = new Envelope();
      for (var i = 0; i < coordinates.length; i++) {
        env.expandToInclude(coordinates[i]);
      }
      return env;
    };
    CoordinateArrays.toCoordinateArray = function toCoordinateArray(coordList) {
      return coordList.toArray(CoordinateArrays.coordArrayType);
    };
    CoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing(n, c) {
      return c.length >= n ? c : [];
    };
    CoordinateArrays.indexOf = function indexOf(coordinate, coordinates) {
      for (var i = 0; i < coordinates.length; i++) {
        if (coordinate.equals(coordinates[i])) {
          return i;
        }
      }
      return -1;
    };
    CoordinateArrays.increasingDirection = function increasingDirection(pts) {
      for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
        var j = pts.length - 1 - i;
        var comp = pts[i].compareTo(pts[j]);
        if (comp !== 0) {
          return comp;
        }
      }
      return 1;
    };
    CoordinateArrays.compare = function compare(pts1, pts2) {
      var i = 0;
      while (i < pts1.length && i < pts2.length) {
        var compare2 = pts1[i].compareTo(pts2[i]);
        if (compare2 !== 0) {
          return compare2;
        }
        i++;
      }
      if (i < pts2.length) {
        return -1;
      }
      if (i < pts1.length) {
        return 1;
      }
      return 0;
    };
    CoordinateArrays.minCoordinate = function minCoordinate(coordinates) {
      var minCoord = null;
      for (var i = 0; i < coordinates.length; i++) {
        if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
          minCoord = coordinates[i];
        }
      }
      return minCoord;
    };
    CoordinateArrays.extract = function extract2(pts, start, end) {
      start = MathUtil.clamp(start, 0, pts.length);
      end = MathUtil.clamp(end, -1, pts.length);
      var npts = end - start + 1;
      if (end < 0) {
        npts = 0;
      }
      if (start >= pts.length) {
        npts = 0;
      }
      if (end < start) {
        npts = 0;
      }
      var extractPts = new Array(npts).fill(null);
      if (npts === 0) {
        return extractPts;
      }
      var iPts = 0;
      for (var i = start; i <= end; i++) {
        extractPts[iPts++] = pts[i];
      }
      return extractPts;
    };
    Object.defineProperties(CoordinateArrays, staticAccessors$13);
    var ForwardComparator = function ForwardComparator2() {
    };
    ForwardComparator.prototype.compare = function compare(o1, o2) {
      var pts1 = o1;
      var pts2 = o2;
      return CoordinateArrays.compare(pts1, pts2);
    };
    ForwardComparator.prototype.interfaces_ = function interfaces_() {
      return [Comparator];
    };
    ForwardComparator.prototype.getClass = function getClass() {
      return ForwardComparator;
    };
    var BidirectionalComparator = function BidirectionalComparator2() {
    };
    BidirectionalComparator.prototype.compare = function compare(o1, o2) {
      var pts1 = o1;
      var pts2 = o2;
      if (pts1.length < pts2.length) {
        return -1;
      }
      if (pts1.length > pts2.length) {
        return 1;
      }
      if (pts1.length === 0) {
        return 0;
      }
      var forwardComp = CoordinateArrays.compare(pts1, pts2);
      var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
      if (isEqualRev) {
        return 0;
      }
      return forwardComp;
    };
    BidirectionalComparator.prototype.OLDcompare = function OLDcompare(o1, o2) {
      var pts1 = o1;
      var pts2 = o2;
      if (pts1.length < pts2.length) {
        return -1;
      }
      if (pts1.length > pts2.length) {
        return 1;
      }
      if (pts1.length === 0) {
        return 0;
      }
      var dir1 = CoordinateArrays.increasingDirection(pts1);
      var dir2 = CoordinateArrays.increasingDirection(pts2);
      var i1 = dir1 > 0 ? 0 : pts1.length - 1;
      var i2 = dir2 > 0 ? 0 : pts1.length - 1;
      for (var i = 0; i < pts1.length; i++) {
        var comparePt = pts1[i1].compareTo(pts2[i2]);
        if (comparePt !== 0) {
          return comparePt;
        }
        i1 += dir1;
        i2 += dir2;
      }
      return 0;
    };
    BidirectionalComparator.prototype.interfaces_ = function interfaces_() {
      return [Comparator];
    };
    BidirectionalComparator.prototype.getClass = function getClass() {
      return BidirectionalComparator;
    };
    var Map$1 = function Map2() {
    };
    Map$1.prototype.get = function get2() {
    };
    Map$1.prototype.put = function put() {
    };
    Map$1.prototype.size = function size() {
    };
    Map$1.prototype.values = function values() {
    };
    Map$1.prototype.entrySet = function entrySet() {
    };
    var SortedMap = function(Map2) {
      function SortedMap2() {
        Map2.apply(this, arguments);
      }
      if (Map2) SortedMap2.__proto__ = Map2;
      SortedMap2.prototype = Object.create(Map2 && Map2.prototype);
      SortedMap2.prototype.constructor = SortedMap2;
      return SortedMap2;
    }(Map$1);
    function OperationNotSupported(message) {
      this.message = message || "";
    }
    OperationNotSupported.prototype = new Error();
    OperationNotSupported.prototype.name = "OperationNotSupported";
    function Set2() {
    }
    Set2.prototype = new Collection();
    Set2.prototype.contains = function() {
    };
    var HashSet = function(Set$$1) {
      function HashSet2() {
        Set$$1.call(this);
        this.array_ = [];
        if (arguments[0] instanceof Collection) {
          this.addAll(arguments[0]);
        }
      }
      if (Set$$1) HashSet2.__proto__ = Set$$1;
      HashSet2.prototype = Object.create(Set$$1 && Set$$1.prototype);
      HashSet2.prototype.constructor = HashSet2;
      HashSet2.prototype.contains = function contains(o) {
        var this$1 = this;
        for (var i = 0, len = this.array_.length; i < len; i++) {
          var e = this$1.array_[i];
          if (e === o) {
            return true;
          }
        }
        return false;
      };
      HashSet2.prototype.add = function add(o) {
        if (this.contains(o)) {
          return false;
        }
        this.array_.push(o);
        return true;
      };
      HashSet2.prototype.addAll = function addAll(c) {
        var this$1 = this;
        for (var i = c.iterator(); i.hasNext(); ) {
          this$1.add(i.next());
        }
        return true;
      };
      HashSet2.prototype.remove = function remove(o) {
        throw new Error();
      };
      HashSet2.prototype.size = function size() {
        return this.array_.length;
      };
      HashSet2.prototype.isEmpty = function isEmpty() {
        return this.array_.length === 0;
      };
      HashSet2.prototype.toArray = function toArray() {
        var this$1 = this;
        var array = [];
        for (var i = 0, len = this.array_.length; i < len; i++) {
          array.push(this$1.array_[i]);
        }
        return array;
      };
      HashSet2.prototype.iterator = function iterator() {
        return new Iterator_$1(this);
      };
      return HashSet2;
    }(Set2);
    var Iterator_$1 = function(Iterator$$1) {
      function Iterator_2(hashSet) {
        Iterator$$1.call(this);
        this.hashSet_ = hashSet;
        this.position_ = 0;
      }
      if (Iterator$$1) Iterator_2.__proto__ = Iterator$$1;
      Iterator_2.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
      Iterator_2.prototype.constructor = Iterator_2;
      Iterator_2.prototype.next = function next() {
        if (this.position_ === this.hashSet_.size()) {
          throw new NoSuchElementException();
        }
        return this.hashSet_.array_[this.position_++];
      };
      Iterator_2.prototype.hasNext = function hasNext() {
        if (this.position_ < this.hashSet_.size()) {
          return true;
        } else {
          return false;
        }
      };
      Iterator_2.prototype.remove = function remove() {
        throw new OperationNotSupported();
      };
      return Iterator_2;
    }(Iterator);
    var BLACK = 0;
    var RED = 1;
    function colorOf(p) {
      return p === null ? BLACK : p.color;
    }
    function parentOf(p) {
      return p === null ? null : p.parent;
    }
    function setColor(p, c) {
      if (p !== null) {
        p.color = c;
      }
    }
    function leftOf(p) {
      return p === null ? null : p.left;
    }
    function rightOf(p) {
      return p === null ? null : p.right;
    }
    function TreeMap() {
      this.root_ = null;
      this.size_ = 0;
    }
    TreeMap.prototype = new SortedMap();
    TreeMap.prototype.get = function(key) {
      var p = this.root_;
      while (p !== null) {
        var cmp = key["compareTo"](p.key);
        if (cmp < 0) {
          p = p.left;
        } else if (cmp > 0) {
          p = p.right;
        } else {
          return p.value;
        }
      }
      return null;
    };
    TreeMap.prototype.put = function(key, value) {
      if (this.root_ === null) {
        this.root_ = {
          key,
          value,
          left: null,
          right: null,
          parent: null,
          color: BLACK,
          getValue: function getValue() {
            return this.value;
          },
          getKey: function getKey() {
            return this.key;
          }
        };
        this.size_ = 1;
        return null;
      }
      var t = this.root_;
      var parent;
      var cmp;
      do {
        parent = t;
        cmp = key["compareTo"](t.key);
        if (cmp < 0) {
          t = t.left;
        } else if (cmp > 0) {
          t = t.right;
        } else {
          var oldValue = t.value;
          t.value = value;
          return oldValue;
        }
      } while (t !== null);
      var e = {
        key,
        left: null,
        right: null,
        value,
        parent,
        color: BLACK,
        getValue: function getValue() {
          return this.value;
        },
        getKey: function getKey() {
          return this.key;
        }
      };
      if (cmp < 0) {
        parent.left = e;
      } else {
        parent.right = e;
      }
      this.fixAfterInsertion(e);
      this.size_++;
      return null;
    };
    TreeMap.prototype.fixAfterInsertion = function(x) {
      var this$1 = this;
      x.color = RED;
      while (x != null && x !== this.root_ && x.parent.color === RED) {
        if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
          var y = rightOf(parentOf(parentOf(x)));
          if (colorOf(y) === RED) {
            setColor(parentOf(x), BLACK);
            setColor(y, BLACK);
            setColor(parentOf(parentOf(x)), RED);
            x = parentOf(parentOf(x));
          } else {
            if (x === rightOf(parentOf(x))) {
              x = parentOf(x);
              this$1.rotateLeft(x);
            }
            setColor(parentOf(x), BLACK);
            setColor(parentOf(parentOf(x)), RED);
            this$1.rotateRight(parentOf(parentOf(x)));
          }
        } else {
          var y$1 = leftOf(parentOf(parentOf(x)));
          if (colorOf(y$1) === RED) {
            setColor(parentOf(x), BLACK);
            setColor(y$1, BLACK);
            setColor(parentOf(parentOf(x)), RED);
            x = parentOf(parentOf(x));
          } else {
            if (x === leftOf(parentOf(x))) {
              x = parentOf(x);
              this$1.rotateRight(x);
            }
            setColor(parentOf(x), BLACK);
            setColor(parentOf(parentOf(x)), RED);
            this$1.rotateLeft(parentOf(parentOf(x)));
          }
        }
      }
      this.root_.color = BLACK;
    };
    TreeMap.prototype.values = function() {
      var arrayList = new ArrayList();
      var p = this.getFirstEntry();
      if (p !== null) {
        arrayList.add(p.value);
        while ((p = TreeMap.successor(p)) !== null) {
          arrayList.add(p.value);
        }
      }
      return arrayList;
    };
    TreeMap.prototype.entrySet = function() {
      var hashSet = new HashSet();
      var p = this.getFirstEntry();
      if (p !== null) {
        hashSet.add(p);
        while ((p = TreeMap.successor(p)) !== null) {
          hashSet.add(p);
        }
      }
      return hashSet;
    };
    TreeMap.prototype.rotateLeft = function(p) {
      if (p != null) {
        var r = p.right;
        p.right = r.left;
        if (r.left != null) {
          r.left.parent = p;
        }
        r.parent = p.parent;
        if (p.parent === null) {
          this.root_ = r;
        } else if (p.parent.left === p) {
          p.parent.left = r;
        } else {
          p.parent.right = r;
        }
        r.left = p;
        p.parent = r;
      }
    };
    TreeMap.prototype.rotateRight = function(p) {
      if (p != null) {
        var l = p.left;
        p.left = l.right;
        if (l.right != null) {
          l.right.parent = p;
        }
        l.parent = p.parent;
        if (p.parent === null) {
          this.root_ = l;
        } else if (p.parent.right === p) {
          p.parent.right = l;
        } else {
          p.parent.left = l;
        }
        l.right = p;
        p.parent = l;
      }
    };
    TreeMap.prototype.getFirstEntry = function() {
      var p = this.root_;
      if (p != null) {
        while (p.left != null) {
          p = p.left;
        }
      }
      return p;
    };
    TreeMap.successor = function(t) {
      if (t === null) {
        return null;
      } else if (t.right !== null) {
        var p = t.right;
        while (p.left !== null) {
          p = p.left;
        }
        return p;
      } else {
        var p$1 = t.parent;
        var ch = t;
        while (p$1 !== null && ch === p$1.right) {
          ch = p$1;
          p$1 = p$1.parent;
        }
        return p$1;
      }
    };
    TreeMap.prototype.size = function() {
      return this.size_;
    };
    var Lineal = function Lineal2() {
    };
    Lineal.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Lineal.prototype.getClass = function getClass() {
      return Lineal;
    };
    function SortedSet() {
    }
    SortedSet.prototype = new Set2();
    function TreeSet() {
      this.array_ = [];
      if (arguments[0] instanceof Collection) {
        this.addAll(arguments[0]);
      }
    }
    TreeSet.prototype = new SortedSet();
    TreeSet.prototype.contains = function(o) {
      var this$1 = this;
      for (var i = 0, len = this.array_.length; i < len; i++) {
        var e = this$1.array_[i];
        if (e["compareTo"](o) === 0) {
          return true;
        }
      }
      return false;
    };
    TreeSet.prototype.add = function(o) {
      var this$1 = this;
      if (this.contains(o)) {
        return false;
      }
      for (var i = 0, len = this.array_.length; i < len; i++) {
        var e = this$1.array_[i];
        if (e["compareTo"](o) === 1) {
          this$1.array_.splice(i, 0, o);
          return true;
        }
      }
      this.array_.push(o);
      return true;
    };
    TreeSet.prototype.addAll = function(c) {
      var this$1 = this;
      for (var i = c.iterator(); i.hasNext(); ) {
        this$1.add(i.next());
      }
      return true;
    };
    TreeSet.prototype.remove = function(e) {
      throw new OperationNotSupported();
    };
    TreeSet.prototype.size = function() {
      return this.array_.length;
    };
    TreeSet.prototype.isEmpty = function() {
      return this.array_.length === 0;
    };
    TreeSet.prototype.toArray = function() {
      var this$1 = this;
      var array = [];
      for (var i = 0, len = this.array_.length; i < len; i++) {
        array.push(this$1.array_[i]);
      }
      return array;
    };
    TreeSet.prototype.iterator = function() {
      return new Iterator_$2(this);
    };
    var Iterator_$2 = function(treeSet) {
      this.treeSet_ = treeSet;
      this.position_ = 0;
    };
    Iterator_$2.prototype.next = function() {
      if (this.position_ === this.treeSet_.size()) {
        throw new NoSuchElementException();
      }
      return this.treeSet_.array_[this.position_++];
    };
    Iterator_$2.prototype.hasNext = function() {
      if (this.position_ < this.treeSet_.size()) {
        return true;
      } else {
        return false;
      }
    };
    Iterator_$2.prototype.remove = function() {
      throw new OperationNotSupported();
    };
    var Arrays = function Arrays2() {
    };
    Arrays.sort = function sort() {
      var a = arguments[0];
      var i;
      var t;
      var comparator;
      var compare;
      if (arguments.length === 1) {
        compare = function(a2, b) {
          return a2.compareTo(b);
        };
        a.sort(compare);
      } else if (arguments.length === 2) {
        comparator = arguments[1];
        compare = function(a2, b) {
          return comparator["compare"](a2, b);
        };
        a.sort(compare);
      } else if (arguments.length === 3) {
        t = a.slice(arguments[1], arguments[2]);
        t.sort();
        var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
        a.splice(0, a.length);
        for (i = 0; i < r.length; i++) {
          a.push(r[i]);
        }
      } else if (arguments.length === 4) {
        t = a.slice(arguments[1], arguments[2]);
        comparator = arguments[3];
        compare = function(a2, b) {
          return comparator["compare"](a2, b);
        };
        t.sort(compare);
        r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
        a.splice(0, a.length);
        for (i = 0; i < r.length; i++) {
          a.push(r[i]);
        }
      }
    };
    Arrays.asList = function asList(array) {
      var arrayList = new ArrayList();
      for (var i = 0, len = array.length; i < len; i++) {
        arrayList.add(array[i]);
      }
      return arrayList;
    };
    var Dimension = function Dimension2() {
    };
    var staticAccessors$14 = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
    staticAccessors$14.P.get = function() {
      return 0;
    };
    staticAccessors$14.L.get = function() {
      return 1;
    };
    staticAccessors$14.A.get = function() {
      return 2;
    };
    staticAccessors$14.FALSE.get = function() {
      return -1;
    };
    staticAccessors$14.TRUE.get = function() {
      return -2;
    };
    staticAccessors$14.DONTCARE.get = function() {
      return -3;
    };
    staticAccessors$14.SYM_FALSE.get = function() {
      return "F";
    };
    staticAccessors$14.SYM_TRUE.get = function() {
      return "T";
    };
    staticAccessors$14.SYM_DONTCARE.get = function() {
      return "*";
    };
    staticAccessors$14.SYM_P.get = function() {
      return "0";
    };
    staticAccessors$14.SYM_L.get = function() {
      return "1";
    };
    staticAccessors$14.SYM_A.get = function() {
      return "2";
    };
    Dimension.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Dimension.prototype.getClass = function getClass() {
      return Dimension;
    };
    Dimension.toDimensionSymbol = function toDimensionSymbol(dimensionValue) {
      switch (dimensionValue) {
        case Dimension.FALSE:
          return Dimension.SYM_FALSE;
        case Dimension.TRUE:
          return Dimension.SYM_TRUE;
        case Dimension.DONTCARE:
          return Dimension.SYM_DONTCARE;
        case Dimension.P:
          return Dimension.SYM_P;
        case Dimension.L:
          return Dimension.SYM_L;
        case Dimension.A:
          return Dimension.SYM_A;
        default:
      }
      throw new IllegalArgumentException("Unknown dimension value: " + dimensionValue);
    };
    Dimension.toDimensionValue = function toDimensionValue(dimensionSymbol) {
      switch (Character.toUpperCase(dimensionSymbol)) {
        case Dimension.SYM_FALSE:
          return Dimension.FALSE;
        case Dimension.SYM_TRUE:
          return Dimension.TRUE;
        case Dimension.SYM_DONTCARE:
          return Dimension.DONTCARE;
        case Dimension.SYM_P:
          return Dimension.P;
        case Dimension.SYM_L:
          return Dimension.L;
        case Dimension.SYM_A:
          return Dimension.A;
        default:
      }
      throw new IllegalArgumentException("Unknown dimension symbol: " + dimensionSymbol);
    };
    Object.defineProperties(Dimension, staticAccessors$14);
    var GeometryFilter = function GeometryFilter2() {
    };
    GeometryFilter.prototype.filter = function filter(geom) {
    };
    GeometryFilter.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryFilter.prototype.getClass = function getClass() {
      return GeometryFilter;
    };
    var CoordinateSequenceFilter = function CoordinateSequenceFilter2() {
    };
    CoordinateSequenceFilter.prototype.filter = function filter(seq, i) {
    };
    CoordinateSequenceFilter.prototype.isDone = function isDone() {
    };
    CoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged() {
    };
    CoordinateSequenceFilter.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CoordinateSequenceFilter.prototype.getClass = function getClass() {
      return CoordinateSequenceFilter;
    };
    var GeometryCollection = function(Geometry$$1) {
      function GeometryCollection2(geometries, factory) {
        Geometry$$1.call(this, factory);
        this._geometries = geometries || [];
        if (Geometry$$1.hasNullElements(this._geometries)) {
          throw new IllegalArgumentException("geometries must not contain null elements");
        }
      }
      if (Geometry$$1) GeometryCollection2.__proto__ = Geometry$$1;
      GeometryCollection2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
      GeometryCollection2.prototype.constructor = GeometryCollection2;
      var staticAccessors2 = { serialVersionUID: { configurable: true } };
      GeometryCollection2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
        var this$1 = this;
        var envelope = new Envelope();
        for (var i = 0; i < this._geometries.length; i++) {
          envelope.expandToInclude(this$1._geometries[i].getEnvelopeInternal());
        }
        return envelope;
      };
      GeometryCollection2.prototype.getGeometryN = function getGeometryN(n) {
        return this._geometries[n];
      };
      GeometryCollection2.prototype.getSortIndex = function getSortIndex() {
        return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION;
      };
      GeometryCollection2.prototype.getCoordinates = function getCoordinates() {
        var this$1 = this;
        var coordinates = new Array(this.getNumPoints()).fill(null);
        var k = -1;
        for (var i = 0; i < this._geometries.length; i++) {
          var childCoordinates = this$1._geometries[i].getCoordinates();
          for (var j = 0; j < childCoordinates.length; j++) {
            k++;
            coordinates[k] = childCoordinates[j];
          }
        }
        return coordinates;
      };
      GeometryCollection2.prototype.getArea = function getArea() {
        var this$1 = this;
        var area = 0;
        for (var i = 0; i < this._geometries.length; i++) {
          area += this$1._geometries[i].getArea();
        }
        return area;
      };
      GeometryCollection2.prototype.equalsExact = function equalsExact() {
        var this$1 = this;
        if (arguments.length === 2) {
          var other = arguments[0];
          var tolerance = arguments[1];
          if (!this.isEquivalentClass(other)) {
            return false;
          }
          var otherCollection = other;
          if (this._geometries.length !== otherCollection._geometries.length) {
            return false;
          }
          for (var i = 0; i < this._geometries.length; i++) {
            if (!this$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
              return false;
            }
          }
          return true;
        } else {
          return Geometry$$1.prototype.equalsExact.apply(this, arguments);
        }
      };
      GeometryCollection2.prototype.normalize = function normalize2() {
        var this$1 = this;
        for (var i = 0; i < this._geometries.length; i++) {
          this$1._geometries[i].normalize();
        }
        Arrays.sort(this._geometries);
      };
      GeometryCollection2.prototype.getCoordinate = function getCoordinate() {
        if (this.isEmpty()) {
          return null;
        }
        return this._geometries[0].getCoordinate();
      };
      GeometryCollection2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        var this$1 = this;
        var dimension = Dimension.FALSE;
        for (var i = 0; i < this._geometries.length; i++) {
          dimension = Math.max(dimension, this$1._geometries[i].getBoundaryDimension());
        }
        return dimension;
      };
      GeometryCollection2.prototype.getDimension = function getDimension() {
        var this$1 = this;
        var dimension = Dimension.FALSE;
        for (var i = 0; i < this._geometries.length; i++) {
          dimension = Math.max(dimension, this$1._geometries[i].getDimension());
        }
        return dimension;
      };
      GeometryCollection2.prototype.getLength = function getLength() {
        var this$1 = this;
        var sum = 0;
        for (var i = 0; i < this._geometries.length; i++) {
          sum += this$1._geometries[i].getLength();
        }
        return sum;
      };
      GeometryCollection2.prototype.getNumPoints = function getNumPoints() {
        var this$1 = this;
        var numPoints = 0;
        for (var i = 0; i < this._geometries.length; i++) {
          numPoints += this$1._geometries[i].getNumPoints();
        }
        return numPoints;
      };
      GeometryCollection2.prototype.getNumGeometries = function getNumGeometries() {
        return this._geometries.length;
      };
      GeometryCollection2.prototype.reverse = function reverse() {
        var this$1 = this;
        var n = this._geometries.length;
        var revGeoms = new Array(n).fill(null);
        for (var i = 0; i < this._geometries.length; i++) {
          revGeoms[i] = this$1._geometries[i].reverse();
        }
        return this.getFactory().createGeometryCollection(revGeoms);
      };
      GeometryCollection2.prototype.compareToSameClass = function compareToSameClass() {
        var this$1 = this;
        if (arguments.length === 1) {
          var o = arguments[0];
          var theseElements = new TreeSet(Arrays.asList(this._geometries));
          var otherElements = new TreeSet(Arrays.asList(o._geometries));
          return this.compare(theseElements, otherElements);
        } else if (arguments.length === 2) {
          var o$1 = arguments[0];
          var comp = arguments[1];
          var gc = o$1;
          var n1 = this.getNumGeometries();
          var n2 = gc.getNumGeometries();
          var i = 0;
          while (i < n1 && i < n2) {
            var thisGeom = this$1.getGeometryN(i);
            var otherGeom = gc.getGeometryN(i);
            var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
            if (holeComp !== 0) {
              return holeComp;
            }
            i++;
          }
          if (i < n1) {
            return 1;
          }
          if (i < n2) {
            return -1;
          }
          return 0;
        }
      };
      GeometryCollection2.prototype.apply = function apply() {
        var this$1 = this;
        if (hasInterface(arguments[0], CoordinateFilter)) {
          var filter = arguments[0];
          for (var i = 0; i < this._geometries.length; i++) {
            this$1._geometries[i].apply(filter);
          }
        } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
          var filter$1 = arguments[0];
          if (this._geometries.length === 0) {
            return null;
          }
          for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {
            this$1._geometries[i$1].apply(filter$1);
            if (filter$1.isDone()) {
              break;
            }
          }
          if (filter$1.isGeometryChanged()) {
            this.geometryChanged();
          }
        } else if (hasInterface(arguments[0], GeometryFilter)) {
          var filter$2 = arguments[0];
          filter$2.filter(this);
          for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {
            this$1._geometries[i$2].apply(filter$2);
          }
        } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
          var filter$3 = arguments[0];
          filter$3.filter(this);
          for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {
            this$1._geometries[i$3].apply(filter$3);
          }
        }
      };
      GeometryCollection2.prototype.getBoundary = function getBoundary() {
        this.checkNotGeometryCollection(this);
        Assert.shouldNeverReachHere();
        return null;
      };
      GeometryCollection2.prototype.clone = function clone() {
        var this$1 = this;
        var gc = Geometry$$1.prototype.clone.call(this);
        gc._geometries = new Array(this._geometries.length).fill(null);
        for (var i = 0; i < this._geometries.length; i++) {
          gc._geometries[i] = this$1._geometries[i].clone();
        }
        return gc;
      };
      GeometryCollection2.prototype.getGeometryType = function getGeometryType() {
        return "GeometryCollection";
      };
      GeometryCollection2.prototype.copy = function copy() {
        var this$1 = this;
        var geometries = new Array(this._geometries.length).fill(null);
        for (var i = 0; i < geometries.length; i++) {
          geometries[i] = this$1._geometries[i].copy();
        }
        return new GeometryCollection2(geometries, this._factory);
      };
      GeometryCollection2.prototype.isEmpty = function isEmpty() {
        var this$1 = this;
        for (var i = 0; i < this._geometries.length; i++) {
          if (!this$1._geometries[i].isEmpty()) {
            return false;
          }
        }
        return true;
      };
      GeometryCollection2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      GeometryCollection2.prototype.getClass = function getClass() {
        return GeometryCollection2;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return -5694727726395021e3;
      };
      Object.defineProperties(GeometryCollection2, staticAccessors2);
      return GeometryCollection2;
    }(Geometry);
    var MultiLineString = function(GeometryCollection$$1) {
      function MultiLineString2() {
        GeometryCollection$$1.apply(this, arguments);
      }
      if (GeometryCollection$$1) MultiLineString2.__proto__ = GeometryCollection$$1;
      MultiLineString2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
      MultiLineString2.prototype.constructor = MultiLineString2;
      var staticAccessors2 = { serialVersionUID: { configurable: true } };
      MultiLineString2.prototype.getSortIndex = function getSortIndex() {
        return Geometry.SORTINDEX_MULTILINESTRING;
      };
      MultiLineString2.prototype.equalsExact = function equalsExact() {
        if (arguments.length === 2) {
          var other = arguments[0];
          var tolerance = arguments[1];
          if (!this.isEquivalentClass(other)) {
            return false;
          }
          return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
        } else {
          return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
        }
      };
      MultiLineString2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        if (this.isClosed()) {
          return Dimension.FALSE;
        }
        return 0;
      };
      MultiLineString2.prototype.isClosed = function isClosed() {
        var this$1 = this;
        if (this.isEmpty()) {
          return false;
        }
        for (var i = 0; i < this._geometries.length; i++) {
          if (!this$1._geometries[i].isClosed()) {
            return false;
          }
        }
        return true;
      };
      MultiLineString2.prototype.getDimension = function getDimension() {
        return 1;
      };
      MultiLineString2.prototype.reverse = function reverse() {
        var this$1 = this;
        var nLines = this._geometries.length;
        var revLines = new Array(nLines).fill(null);
        for (var i = 0; i < this._geometries.length; i++) {
          revLines[nLines - 1 - i] = this$1._geometries[i].reverse();
        }
        return this.getFactory().createMultiLineString(revLines);
      };
      MultiLineString2.prototype.getBoundary = function getBoundary() {
        return new BoundaryOp(this).getBoundary();
      };
      MultiLineString2.prototype.getGeometryType = function getGeometryType() {
        return "MultiLineString";
      };
      MultiLineString2.prototype.copy = function copy() {
        var this$1 = this;
        var lineStrings = new Array(this._geometries.length).fill(null);
        for (var i = 0; i < lineStrings.length; i++) {
          lineStrings[i] = this$1._geometries[i].copy();
        }
        return new MultiLineString2(lineStrings, this._factory);
      };
      MultiLineString2.prototype.interfaces_ = function interfaces_() {
        return [Lineal];
      };
      MultiLineString2.prototype.getClass = function getClass() {
        return MultiLineString2;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return 8166665132445434e3;
      };
      Object.defineProperties(MultiLineString2, staticAccessors2);
      return MultiLineString2;
    }(GeometryCollection);
    var BoundaryOp = function BoundaryOp2() {
      this._geom = null;
      this._geomFact = null;
      this._bnRule = null;
      this._endpointMap = null;
      if (arguments.length === 1) {
        var geom = arguments[0];
        var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;
        this._geom = geom;
        this._geomFact = geom.getFactory();
        this._bnRule = bnRule;
      } else if (arguments.length === 2) {
        var geom$1 = arguments[0];
        var bnRule$1 = arguments[1];
        this._geom = geom$1;
        this._geomFact = geom$1.getFactory();
        this._bnRule = bnRule$1;
      }
    };
    BoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString(mLine) {
      if (this._geom.isEmpty()) {
        return this.getEmptyMultiPoint();
      }
      var bdyPts = this.computeBoundaryCoordinates(mLine);
      if (bdyPts.length === 1) {
        return this._geomFact.createPoint(bdyPts[0]);
      }
      return this._geomFact.createMultiPointFromCoords(bdyPts);
    };
    BoundaryOp.prototype.getBoundary = function getBoundary() {
      if (this._geom instanceof LineString) {
        return this.boundaryLineString(this._geom);
      }
      if (this._geom instanceof MultiLineString) {
        return this.boundaryMultiLineString(this._geom);
      }
      return this._geom.getBoundary();
    };
    BoundaryOp.prototype.boundaryLineString = function boundaryLineString(line) {
      if (this._geom.isEmpty()) {
        return this.getEmptyMultiPoint();
      }
      if (line.isClosed()) {
        var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
        if (closedEndpointOnBoundary) {
          return line.getStartPoint();
        } else {
          return this._geomFact.createMultiPoint();
        }
      }
      return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);
    };
    BoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint() {
      return this._geomFact.createMultiPoint();
    };
    BoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates(mLine) {
      var this$1 = this;
      var bdyPts = new ArrayList();
      this._endpointMap = new TreeMap();
      for (var i = 0; i < mLine.getNumGeometries(); i++) {
        var line = mLine.getGeometryN(i);
        if (line.getNumPoints() === 0) {
          continue;
        }
        this$1.addEndpoint(line.getCoordinateN(0));
        this$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
      }
      for (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {
        var entry = it.next();
        var counter = entry.getValue();
        var valence = counter.count;
        if (this$1._bnRule.isInBoundary(valence)) {
          bdyPts.add(entry.getKey());
        }
      }
      return CoordinateArrays.toCoordinateArray(bdyPts);
    };
    BoundaryOp.prototype.addEndpoint = function addEndpoint(pt) {
      var counter = this._endpointMap.get(pt);
      if (counter === null) {
        counter = new Counter();
        this._endpointMap.put(pt, counter);
      }
      counter.count++;
    };
    BoundaryOp.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BoundaryOp.prototype.getClass = function getClass() {
      return BoundaryOp;
    };
    BoundaryOp.getBoundary = function getBoundary() {
      if (arguments.length === 1) {
        var g = arguments[0];
        var bop = new BoundaryOp(g);
        return bop.getBoundary();
      } else if (arguments.length === 2) {
        var g$1 = arguments[0];
        var bnRule = arguments[1];
        var bop$1 = new BoundaryOp(g$1, bnRule);
        return bop$1.getBoundary();
      }
    };
    var Counter = function Counter2() {
      this.count = null;
    };
    Counter.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Counter.prototype.getClass = function getClass() {
      return Counter;
    };
    function PrintStream() {
    }
    function StringReader() {
    }
    var DecimalFormat = function DecimalFormat2() {
    };
    function ByteArrayOutputStream() {
    }
    function IOException() {
    }
    function LineNumberReader() {
    }
    var StringUtil = function StringUtil2() {
    };
    var staticAccessors$15 = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
    StringUtil.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    StringUtil.prototype.getClass = function getClass() {
      return StringUtil;
    };
    StringUtil.chars = function chars(c, n) {
      var ch = new Array(n).fill(null);
      for (var i = 0; i < n; i++) {
        ch[i] = c;
      }
      return String(ch);
    };
    StringUtil.getStackTrace = function getStackTrace() {
      if (arguments.length === 1) {
        var t = arguments[0];
        var os = new ByteArrayOutputStream();
        var ps = new PrintStream(os);
        t.printStackTrace(ps);
        return os.toString();
      } else if (arguments.length === 2) {
        var t$1 = arguments[0];
        var depth = arguments[1];
        var stackTrace = "";
        var stringReader = new StringReader(StringUtil.getStackTrace(t$1));
        var lineNumberReader = new LineNumberReader(stringReader);
        for (var i = 0; i < depth; i++) {
          try {
            stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
          } catch (e) {
            if (e instanceof IOException) {
              Assert.shouldNeverReachHere();
            } else {
              throw e;
            }
          } finally {
          }
        }
        return stackTrace;
      }
    };
    StringUtil.split = function split(s, separator) {
      var separatorlen = separator.length;
      var tokenList = new ArrayList();
      var tmpString = "" + s;
      var pos = tmpString.indexOf(separator);
      while (pos >= 0) {
        var token = tmpString.substring(0, pos);
        tokenList.add(token);
        tmpString = tmpString.substring(pos + separatorlen);
        pos = tmpString.indexOf(separator);
      }
      if (tmpString.length > 0) {
        tokenList.add(tmpString);
      }
      var res = new Array(tokenList.size()).fill(null);
      for (var i = 0; i < res.length; i++) {
        res[i] = tokenList.get(i);
      }
      return res;
    };
    StringUtil.toString = function toString() {
      if (arguments.length === 1) {
        var d = arguments[0];
        return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);
      }
    };
    StringUtil.spaces = function spaces(n) {
      return StringUtil.chars(" ", n);
    };
    staticAccessors$15.NEWLINE.get = function() {
      return System.getProperty("line.separator");
    };
    staticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function() {
      return new DecimalFormat("0.#");
    };
    Object.defineProperties(StringUtil, staticAccessors$15);
    var CoordinateSequences = function CoordinateSequences2() {
    };
    CoordinateSequences.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CoordinateSequences.prototype.getClass = function getClass() {
      return CoordinateSequences;
    };
    CoordinateSequences.copyCoord = function copyCoord(src, srcPos, dest, destPos) {
      var minDim = Math.min(src.getDimension(), dest.getDimension());
      for (var dim = 0; dim < minDim; dim++) {
        dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
      }
    };
    CoordinateSequences.isRing = function isRing(seq) {
      var n = seq.size();
      if (n === 0) {
        return true;
      }
      if (n <= 3) {
        return false;
      }
      return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
    };
    CoordinateSequences.isEqual = function isEqual(cs1, cs2) {
      var cs1Size = cs1.size();
      var cs2Size = cs2.size();
      if (cs1Size !== cs2Size) {
        return false;
      }
      var dim = Math.min(cs1.getDimension(), cs2.getDimension());
      for (var i = 0; i < cs1Size; i++) {
        for (var d = 0; d < dim; d++) {
          var v12 = cs1.getOrdinate(i, d);
          var v2 = cs2.getOrdinate(i, d);
          if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) {
            continue;
          }
          if (Double.isNaN(v12) && Double.isNaN(v2)) {
            continue;
          }
          return false;
        }
      }
      return true;
    };
    CoordinateSequences.extend = function extend(fact, seq, size) {
      var newseq = fact.create(size, seq.getDimension());
      var n = seq.size();
      CoordinateSequences.copy(seq, 0, newseq, 0, n);
      if (n > 0) {
        for (var i = n; i < size; i++) {
          CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
        }
      }
      return newseq;
    };
    CoordinateSequences.reverse = function reverse(seq) {
      var last = seq.size() - 1;
      var mid = Math.trunc(last / 2);
      for (var i = 0; i <= mid; i++) {
        CoordinateSequences.swap(seq, i, last - i);
      }
    };
    CoordinateSequences.swap = function swap(seq, i, j) {
      if (i === j) {
        return null;
      }
      for (var dim = 0; dim < seq.getDimension(); dim++) {
        var tmp = seq.getOrdinate(i, dim);
        seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
        seq.setOrdinate(j, dim, tmp);
      }
    };
    CoordinateSequences.copy = function copy(src, srcPos, dest, destPos, length) {
      for (var i = 0; i < length; i++) {
        CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
      }
    };
    CoordinateSequences.toString = function toString() {
      if (arguments.length === 1) {
        var cs = arguments[0];
        var size = cs.size();
        if (size === 0) {
          return "()";
        }
        var dim = cs.getDimension();
        var buf = new StringBuffer();
        buf.append("(");
        for (var i = 0; i < size; i++) {
          if (i > 0) {
            buf.append(" ");
          }
          for (var d = 0; d < dim; d++) {
            if (d > 0) {
              buf.append(",");
            }
            buf.append(StringUtil.toString(cs.getOrdinate(i, d)));
          }
        }
        buf.append(")");
        return buf.toString();
      }
    };
    CoordinateSequences.ensureValidRing = function ensureValidRing(fact, seq) {
      var n = seq.size();
      if (n === 0) {
        return seq;
      }
      if (n <= 3) {
        return CoordinateSequences.createClosedRing(fact, seq, 4);
      }
      var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
      if (isClosed) {
        return seq;
      }
      return CoordinateSequences.createClosedRing(fact, seq, n + 1);
    };
    CoordinateSequences.createClosedRing = function createClosedRing(fact, seq, size) {
      var newseq = fact.create(size, seq.getDimension());
      var n = seq.size();
      CoordinateSequences.copy(seq, 0, newseq, 0, n);
      for (var i = n; i < size; i++) {
        CoordinateSequences.copy(seq, 0, newseq, i, 1);
      }
      return newseq;
    };
    var LineString = function(Geometry$$1) {
      function LineString2(points, factory) {
        Geometry$$1.call(this, factory);
        this._points = null;
        this.init(points);
      }
      if (Geometry$$1) LineString2.__proto__ = Geometry$$1;
      LineString2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
      LineString2.prototype.constructor = LineString2;
      var staticAccessors2 = { serialVersionUID: { configurable: true } };
      LineString2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
        if (this.isEmpty()) {
          return new Envelope();
        }
        return this._points.expandEnvelope(new Envelope());
      };
      LineString2.prototype.isRing = function isRing() {
        return this.isClosed() && this.isSimple();
      };
      LineString2.prototype.getSortIndex = function getSortIndex() {
        return Geometry$$1.SORTINDEX_LINESTRING;
      };
      LineString2.prototype.getCoordinates = function getCoordinates() {
        return this._points.toCoordinateArray();
      };
      LineString2.prototype.equalsExact = function equalsExact() {
        var this$1 = this;
        if (arguments.length === 2) {
          var other = arguments[0];
          var tolerance = arguments[1];
          if (!this.isEquivalentClass(other)) {
            return false;
          }
          var otherLineString = other;
          if (this._points.size() !== otherLineString._points.size()) {
            return false;
          }
          for (var i = 0; i < this._points.size(); i++) {
            if (!this$1.equal(this$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
              return false;
            }
          }
          return true;
        } else {
          return Geometry$$1.prototype.equalsExact.apply(this, arguments);
        }
      };
      LineString2.prototype.normalize = function normalize2() {
        var this$1 = this;
        for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
          var j = this$1._points.size() - 1 - i;
          if (!this$1._points.getCoordinate(i).equals(this$1._points.getCoordinate(j))) {
            if (this$1._points.getCoordinate(i).compareTo(this$1._points.getCoordinate(j)) > 0) {
              CoordinateSequences.reverse(this$1._points);
            }
            return null;
          }
        }
      };
      LineString2.prototype.getCoordinate = function getCoordinate() {
        if (this.isEmpty()) {
          return null;
        }
        return this._points.getCoordinate(0);
      };
      LineString2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        if (this.isClosed()) {
          return Dimension.FALSE;
        }
        return 0;
      };
      LineString2.prototype.isClosed = function isClosed() {
        if (this.isEmpty()) {
          return false;
        }
        return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
      };
      LineString2.prototype.getEndPoint = function getEndPoint() {
        if (this.isEmpty()) {
          return null;
        }
        return this.getPointN(this.getNumPoints() - 1);
      };
      LineString2.prototype.getDimension = function getDimension() {
        return 1;
      };
      LineString2.prototype.getLength = function getLength() {
        return CGAlgorithms.computeLength(this._points);
      };
      LineString2.prototype.getNumPoints = function getNumPoints() {
        return this._points.size();
      };
      LineString2.prototype.reverse = function reverse() {
        var seq = this._points.copy();
        CoordinateSequences.reverse(seq);
        var revLine = this.getFactory().createLineString(seq);
        return revLine;
      };
      LineString2.prototype.compareToSameClass = function compareToSameClass() {
        var this$1 = this;
        if (arguments.length === 1) {
          var o = arguments[0];
          var line = o;
          var i = 0;
          var j = 0;
          while (i < this._points.size() && j < line._points.size()) {
            var comparison = this$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
            if (comparison !== 0) {
              return comparison;
            }
            i++;
            j++;
          }
          if (i < this._points.size()) {
            return 1;
          }
          if (j < line._points.size()) {
            return -1;
          }
          return 0;
        } else if (arguments.length === 2) {
          var o$1 = arguments[0];
          var comp = arguments[1];
          var line$1 = o$1;
          return comp.compare(this._points, line$1._points);
        }
      };
      LineString2.prototype.apply = function apply() {
        var this$1 = this;
        if (hasInterface(arguments[0], CoordinateFilter)) {
          var filter = arguments[0];
          for (var i = 0; i < this._points.size(); i++) {
            filter.filter(this$1._points.getCoordinate(i));
          }
        } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
          var filter$1 = arguments[0];
          if (this._points.size() === 0) {
            return null;
          }
          for (var i$1 = 0; i$1 < this._points.size(); i$1++) {
            filter$1.filter(this$1._points, i$1);
            if (filter$1.isDone()) {
              break;
            }
          }
          if (filter$1.isGeometryChanged()) {
            this.geometryChanged();
          }
        } else if (hasInterface(arguments[0], GeometryFilter)) {
          var filter$2 = arguments[0];
          filter$2.filter(this);
        } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
          var filter$3 = arguments[0];
          filter$3.filter(this);
        }
      };
      LineString2.prototype.getBoundary = function getBoundary() {
        return new BoundaryOp(this).getBoundary();
      };
      LineString2.prototype.isEquivalentClass = function isEquivalentClass(other) {
        return other instanceof LineString2;
      };
      LineString2.prototype.clone = function clone() {
        var ls = Geometry$$1.prototype.clone.call(this);
        ls._points = this._points.clone();
        return ls;
      };
      LineString2.prototype.getCoordinateN = function getCoordinateN(n) {
        return this._points.getCoordinate(n);
      };
      LineString2.prototype.getGeometryType = function getGeometryType() {
        return "LineString";
      };
      LineString2.prototype.copy = function copy() {
        return new LineString2(this._points.copy(), this._factory);
      };
      LineString2.prototype.getCoordinateSequence = function getCoordinateSequence() {
        return this._points;
      };
      LineString2.prototype.isEmpty = function isEmpty() {
        return this._points.size() === 0;
      };
      LineString2.prototype.init = function init(points) {
        if (points === null) {
          points = this.getFactory().getCoordinateSequenceFactory().create([]);
        }
        if (points.size() === 1) {
          throw new IllegalArgumentException("Invalid number of points in LineString (found " + points.size() + " - must be 0 or >= 2)");
        }
        this._points = points;
      };
      LineString2.prototype.isCoordinate = function isCoordinate(pt) {
        var this$1 = this;
        for (var i = 0; i < this._points.size(); i++) {
          if (this$1._points.getCoordinate(i).equals(pt)) {
            return true;
          }
        }
        return false;
      };
      LineString2.prototype.getStartPoint = function getStartPoint() {
        if (this.isEmpty()) {
          return null;
        }
        return this.getPointN(0);
      };
      LineString2.prototype.getPointN = function getPointN(n) {
        return this.getFactory().createPoint(this._points.getCoordinate(n));
      };
      LineString2.prototype.interfaces_ = function interfaces_() {
        return [Lineal];
      };
      LineString2.prototype.getClass = function getClass() {
        return LineString2;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return 3110669828065365500;
      };
      Object.defineProperties(LineString2, staticAccessors2);
      return LineString2;
    }(Geometry);
    var Puntal = function Puntal2() {
    };
    Puntal.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Puntal.prototype.getClass = function getClass() {
      return Puntal;
    };
    var Point = function(Geometry$$1) {
      function Point2(coordinates, factory) {
        Geometry$$1.call(this, factory);
        this._coordinates = coordinates || null;
        this.init(this._coordinates);
      }
      if (Geometry$$1) Point2.__proto__ = Geometry$$1;
      Point2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
      Point2.prototype.constructor = Point2;
      var staticAccessors2 = { serialVersionUID: { configurable: true } };
      Point2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
        if (this.isEmpty()) {
          return new Envelope();
        }
        var env = new Envelope();
        env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
        return env;
      };
      Point2.prototype.getSortIndex = function getSortIndex() {
        return Geometry$$1.SORTINDEX_POINT;
      };
      Point2.prototype.getCoordinates = function getCoordinates() {
        return this.isEmpty() ? [] : [this.getCoordinate()];
      };
      Point2.prototype.equalsExact = function equalsExact() {
        if (arguments.length === 2) {
          var other = arguments[0];
          var tolerance = arguments[1];
          if (!this.isEquivalentClass(other)) {
            return false;
          }
          if (this.isEmpty() && other.isEmpty()) {
            return true;
          }
          if (this.isEmpty() !== other.isEmpty()) {
            return false;
          }
          return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
        } else {
          return Geometry$$1.prototype.equalsExact.apply(this, arguments);
        }
      };
      Point2.prototype.normalize = function normalize2() {
      };
      Point2.prototype.getCoordinate = function getCoordinate() {
        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
      };
      Point2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        return Dimension.FALSE;
      };
      Point2.prototype.getDimension = function getDimension() {
        return 0;
      };
      Point2.prototype.getNumPoints = function getNumPoints() {
        return this.isEmpty() ? 0 : 1;
      };
      Point2.prototype.reverse = function reverse() {
        return this.copy();
      };
      Point2.prototype.getX = function getX() {
        if (this.getCoordinate() === null) {
          throw new Error("getX called on empty Point");
        }
        return this.getCoordinate().x;
      };
      Point2.prototype.compareToSameClass = function compareToSameClass() {
        if (arguments.length === 1) {
          var other = arguments[0];
          var point$1 = other;
          return this.getCoordinate().compareTo(point$1.getCoordinate());
        } else if (arguments.length === 2) {
          var other$1 = arguments[0];
          var comp = arguments[1];
          var point = other$1;
          return comp.compare(this._coordinates, point._coordinates);
        }
      };
      Point2.prototype.apply = function apply() {
        if (hasInterface(arguments[0], CoordinateFilter)) {
          var filter = arguments[0];
          if (this.isEmpty()) {
            return null;
          }
          filter.filter(this.getCoordinate());
        } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
          var filter$1 = arguments[0];
          if (this.isEmpty()) {
            return null;
          }
          filter$1.filter(this._coordinates, 0);
          if (filter$1.isGeometryChanged()) {
            this.geometryChanged();
          }
        } else if (hasInterface(arguments[0], GeometryFilter)) {
          var filter$2 = arguments[0];
          filter$2.filter(this);
        } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
          var filter$3 = arguments[0];
          filter$3.filter(this);
        }
      };
      Point2.prototype.getBoundary = function getBoundary() {
        return this.getFactory().createGeometryCollection(null);
      };
      Point2.prototype.clone = function clone() {
        var p = Geometry$$1.prototype.clone.call(this);
        p._coordinates = this._coordinates.clone();
        return p;
      };
      Point2.prototype.getGeometryType = function getGeometryType() {
        return "Point";
      };
      Point2.prototype.copy = function copy() {
        return new Point2(this._coordinates.copy(), this._factory);
      };
      Point2.prototype.getCoordinateSequence = function getCoordinateSequence() {
        return this._coordinates;
      };
      Point2.prototype.getY = function getY() {
        if (this.getCoordinate() === null) {
          throw new Error("getY called on empty Point");
        }
        return this.getCoordinate().y;
      };
      Point2.prototype.isEmpty = function isEmpty() {
        return this._coordinates.size() === 0;
      };
      Point2.prototype.init = function init(coordinates) {
        if (coordinates === null) {
          coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
        }
        Assert.isTrue(coordinates.size() <= 1);
        this._coordinates = coordinates;
      };
      Point2.prototype.isSimple = function isSimple() {
        return true;
      };
      Point2.prototype.interfaces_ = function interfaces_() {
        return [Puntal];
      };
      Point2.prototype.getClass = function getClass() {
        return Point2;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return 4902022702746615e3;
      };
      Object.defineProperties(Point2, staticAccessors2);
      return Point2;
    }(Geometry);
    var Polygonal = function Polygonal2() {
    };
    Polygonal.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Polygonal.prototype.getClass = function getClass() {
      return Polygonal;
    };
    var Polygon = function(Geometry$$1) {
      function Polygon2(shell, holes, factory) {
        Geometry$$1.call(this, factory);
        this._shell = null;
        this._holes = null;
        if (shell === null) {
          shell = this.getFactory().createLinearRing();
        }
        if (holes === null) {
          holes = [];
        }
        if (Geometry$$1.hasNullElements(holes)) {
          throw new IllegalArgumentException("holes must not contain null elements");
        }
        if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {
          throw new IllegalArgumentException("shell is empty but holes are not");
        }
        this._shell = shell;
        this._holes = holes;
      }
      if (Geometry$$1) Polygon2.__proto__ = Geometry$$1;
      Polygon2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
      Polygon2.prototype.constructor = Polygon2;
      var staticAccessors2 = { serialVersionUID: { configurable: true } };
      Polygon2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
        return this._shell.getEnvelopeInternal();
      };
      Polygon2.prototype.getSortIndex = function getSortIndex() {
        return Geometry$$1.SORTINDEX_POLYGON;
      };
      Polygon2.prototype.getCoordinates = function getCoordinates() {
        var this$1 = this;
        if (this.isEmpty()) {
          return [];
        }
        var coordinates = new Array(this.getNumPoints()).fill(null);
        var k = -1;
        var shellCoordinates = this._shell.getCoordinates();
        for (var x = 0; x < shellCoordinates.length; x++) {
          k++;
          coordinates[k] = shellCoordinates[x];
        }
        for (var i = 0; i < this._holes.length; i++) {
          var childCoordinates = this$1._holes[i].getCoordinates();
          for (var j = 0; j < childCoordinates.length; j++) {
            k++;
            coordinates[k] = childCoordinates[j];
          }
        }
        return coordinates;
      };
      Polygon2.prototype.getArea = function getArea() {
        var this$1 = this;
        var area = 0;
        area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));
        for (var i = 0; i < this._holes.length; i++) {
          area -= Math.abs(CGAlgorithms.signedArea(this$1._holes[i].getCoordinateSequence()));
        }
        return area;
      };
      Polygon2.prototype.isRectangle = function isRectangle() {
        if (this.getNumInteriorRing() !== 0) {
          return false;
        }
        if (this._shell === null) {
          return false;
        }
        if (this._shell.getNumPoints() !== 5) {
          return false;
        }
        var seq = this._shell.getCoordinateSequence();
        var env = this.getEnvelopeInternal();
        for (var i = 0; i < 5; i++) {
          var x = seq.getX(i);
          if (!(x === env.getMinX() || x === env.getMaxX())) {
            return false;
          }
          var y = seq.getY(i);
          if (!(y === env.getMinY() || y === env.getMaxY())) {
            return false;
          }
        }
        var prevX = seq.getX(0);
        var prevY = seq.getY(0);
        for (var i$1 = 1; i$1 <= 4; i$1++) {
          var x$1 = seq.getX(i$1);
          var y$1 = seq.getY(i$1);
          var xChanged = x$1 !== prevX;
          var yChanged = y$1 !== prevY;
          if (xChanged === yChanged) {
            return false;
          }
          prevX = x$1;
          prevY = y$1;
        }
        return true;
      };
      Polygon2.prototype.equalsExact = function equalsExact() {
        var this$1 = this;
        if (arguments.length === 2) {
          var other = arguments[0];
          var tolerance = arguments[1];
          if (!this.isEquivalentClass(other)) {
            return false;
          }
          var otherPolygon = other;
          var thisShell = this._shell;
          var otherPolygonShell = otherPolygon._shell;
          if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
            return false;
          }
          if (this._holes.length !== otherPolygon._holes.length) {
            return false;
          }
          for (var i = 0; i < this._holes.length; i++) {
            if (!this$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
              return false;
            }
          }
          return true;
        } else {
          return Geometry$$1.prototype.equalsExact.apply(this, arguments);
        }
      };
      Polygon2.prototype.normalize = function normalize2() {
        var this$1 = this;
        if (arguments.length === 0) {
          this.normalize(this._shell, true);
          for (var i = 0; i < this._holes.length; i++) {
            this$1.normalize(this$1._holes[i], false);
          }
          Arrays.sort(this._holes);
        } else if (arguments.length === 2) {
          var ring = arguments[0];
          var clockwise = arguments[1];
          if (ring.isEmpty()) {
            return null;
          }
          var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
          System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
          var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());
          CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
          System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
          ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
          if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {
            CoordinateArrays.reverse(ring.getCoordinates());
          }
        }
      };
      Polygon2.prototype.getCoordinate = function getCoordinate() {
        return this._shell.getCoordinate();
      };
      Polygon2.prototype.getNumInteriorRing = function getNumInteriorRing() {
        return this._holes.length;
      };
      Polygon2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        return 1;
      };
      Polygon2.prototype.getDimension = function getDimension() {
        return 2;
      };
      Polygon2.prototype.getLength = function getLength() {
        var this$1 = this;
        var len = 0;
        len += this._shell.getLength();
        for (var i = 0; i < this._holes.length; i++) {
          len += this$1._holes[i].getLength();
        }
        return len;
      };
      Polygon2.prototype.getNumPoints = function getNumPoints() {
        var this$1 = this;
        var numPoints = this._shell.getNumPoints();
        for (var i = 0; i < this._holes.length; i++) {
          numPoints += this$1._holes[i].getNumPoints();
        }
        return numPoints;
      };
      Polygon2.prototype.reverse = function reverse() {
        var this$1 = this;
        var poly = this.copy();
        poly._shell = this._shell.copy().reverse();
        poly._holes = new Array(this._holes.length).fill(null);
        for (var i = 0; i < this._holes.length; i++) {
          poly._holes[i] = this$1._holes[i].copy().reverse();
        }
        return poly;
      };
      Polygon2.prototype.convexHull = function convexHull() {
        return this.getExteriorRing().convexHull();
      };
      Polygon2.prototype.compareToSameClass = function compareToSameClass() {
        var this$1 = this;
        if (arguments.length === 1) {
          var o = arguments[0];
          var thisShell = this._shell;
          var otherShell = o._shell;
          return thisShell.compareToSameClass(otherShell);
        } else if (arguments.length === 2) {
          var o$1 = arguments[0];
          var comp = arguments[1];
          var poly = o$1;
          var thisShell$1 = this._shell;
          var otherShell$1 = poly._shell;
          var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);
          if (shellComp !== 0) {
            return shellComp;
          }
          var nHole1 = this.getNumInteriorRing();
          var nHole2 = poly.getNumInteriorRing();
          var i = 0;
          while (i < nHole1 && i < nHole2) {
            var thisHole = this$1.getInteriorRingN(i);
            var otherHole = poly.getInteriorRingN(i);
            var holeComp = thisHole.compareToSameClass(otherHole, comp);
            if (holeComp !== 0) {
              return holeComp;
            }
            i++;
          }
          if (i < nHole1) {
            return 1;
          }
          if (i < nHole2) {
            return -1;
          }
          return 0;
        }
      };
      Polygon2.prototype.apply = function apply(filter) {
        var this$1 = this;
        if (hasInterface(filter, CoordinateFilter)) {
          this._shell.apply(filter);
          for (var i$1 = 0; i$1 < this._holes.length; i$1++) {
            this$1._holes[i$1].apply(filter);
          }
        } else if (hasInterface(filter, CoordinateSequenceFilter)) {
          this._shell.apply(filter);
          if (!filter.isDone()) {
            for (var i$2 = 0; i$2 < this._holes.length; i$2++) {
              this$1._holes[i$2].apply(filter);
              if (filter.isDone()) {
                break;
              }
            }
          }
          if (filter.isGeometryChanged()) {
            this.geometryChanged();
          }
        } else if (hasInterface(filter, GeometryFilter)) {
          filter.filter(this);
        } else if (hasInterface(filter, GeometryComponentFilter)) {
          filter.filter(this);
          this._shell.apply(filter);
          for (var i = 0; i < this._holes.length; i++) {
            this$1._holes[i].apply(filter);
          }
        }
      };
      Polygon2.prototype.getBoundary = function getBoundary() {
        var this$1 = this;
        if (this.isEmpty()) {
          return this.getFactory().createMultiLineString();
        }
        var rings = new Array(this._holes.length + 1).fill(null);
        rings[0] = this._shell;
        for (var i = 0; i < this._holes.length; i++) {
          rings[i + 1] = this$1._holes[i];
        }
        if (rings.length <= 1) {
          return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
        }
        return this.getFactory().createMultiLineString(rings);
      };
      Polygon2.prototype.clone = function clone() {
        var this$1 = this;
        var poly = Geometry$$1.prototype.clone.call(this);
        poly._shell = this._shell.clone();
        poly._holes = new Array(this._holes.length).fill(null);
        for (var i = 0; i < this._holes.length; i++) {
          poly._holes[i] = this$1._holes[i].clone();
        }
        return poly;
      };
      Polygon2.prototype.getGeometryType = function getGeometryType() {
        return "Polygon";
      };
      Polygon2.prototype.copy = function copy() {
        var this$1 = this;
        var shell = this._shell.copy();
        var holes = new Array(this._holes.length).fill(null);
        for (var i = 0; i < holes.length; i++) {
          holes[i] = this$1._holes[i].copy();
        }
        return new Polygon2(shell, holes, this._factory);
      };
      Polygon2.prototype.getExteriorRing = function getExteriorRing() {
        return this._shell;
      };
      Polygon2.prototype.isEmpty = function isEmpty() {
        return this._shell.isEmpty();
      };
      Polygon2.prototype.getInteriorRingN = function getInteriorRingN(n) {
        return this._holes[n];
      };
      Polygon2.prototype.interfaces_ = function interfaces_() {
        return [Polygonal];
      };
      Polygon2.prototype.getClass = function getClass() {
        return Polygon2;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return -3494792200821764600;
      };
      Object.defineProperties(Polygon2, staticAccessors2);
      return Polygon2;
    }(Geometry);
    var MultiPoint = function(GeometryCollection$$1) {
      function MultiPoint2() {
        GeometryCollection$$1.apply(this, arguments);
      }
      if (GeometryCollection$$1) MultiPoint2.__proto__ = GeometryCollection$$1;
      MultiPoint2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
      MultiPoint2.prototype.constructor = MultiPoint2;
      var staticAccessors2 = { serialVersionUID: { configurable: true } };
      MultiPoint2.prototype.getSortIndex = function getSortIndex() {
        return Geometry.SORTINDEX_MULTIPOINT;
      };
      MultiPoint2.prototype.isValid = function isValid() {
        return true;
      };
      MultiPoint2.prototype.equalsExact = function equalsExact() {
        if (arguments.length === 2) {
          var other = arguments[0];
          var tolerance = arguments[1];
          if (!this.isEquivalentClass(other)) {
            return false;
          }
          return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
        } else {
          return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
        }
      };
      MultiPoint2.prototype.getCoordinate = function getCoordinate() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return this._geometries[n].getCoordinate();
        } else {
          return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments);
        }
      };
      MultiPoint2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        return Dimension.FALSE;
      };
      MultiPoint2.prototype.getDimension = function getDimension() {
        return 0;
      };
      MultiPoint2.prototype.getBoundary = function getBoundary() {
        return this.getFactory().createGeometryCollection(null);
      };
      MultiPoint2.prototype.getGeometryType = function getGeometryType() {
        return "MultiPoint";
      };
      MultiPoint2.prototype.copy = function copy() {
        var this$1 = this;
        var points = new Array(this._geometries.length).fill(null);
        for (var i = 0; i < points.length; i++) {
          points[i] = this$1._geometries[i].copy();
        }
        return new MultiPoint2(points, this._factory);
      };
      MultiPoint2.prototype.interfaces_ = function interfaces_() {
        return [Puntal];
      };
      MultiPoint2.prototype.getClass = function getClass() {
        return MultiPoint2;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return -8048474874175356e3;
      };
      Object.defineProperties(MultiPoint2, staticAccessors2);
      return MultiPoint2;
    }(GeometryCollection);
    var LinearRing = function(LineString$$1) {
      function LinearRing2(points, factory) {
        if (points instanceof Coordinate && factory instanceof GeometryFactory) {
          points = factory.getCoordinateSequenceFactory().create(points);
        }
        LineString$$1.call(this, points, factory);
        this.validateConstruction();
      }
      if (LineString$$1) LinearRing2.__proto__ = LineString$$1;
      LinearRing2.prototype = Object.create(LineString$$1 && LineString$$1.prototype);
      LinearRing2.prototype.constructor = LinearRing2;
      var staticAccessors2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
      LinearRing2.prototype.getSortIndex = function getSortIndex() {
        return Geometry.SORTINDEX_LINEARRING;
      };
      LinearRing2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        return Dimension.FALSE;
      };
      LinearRing2.prototype.isClosed = function isClosed() {
        if (this.isEmpty()) {
          return true;
        }
        return LineString$$1.prototype.isClosed.call(this);
      };
      LinearRing2.prototype.reverse = function reverse() {
        var seq = this._points.copy();
        CoordinateSequences.reverse(seq);
        var rev = this.getFactory().createLinearRing(seq);
        return rev;
      };
      LinearRing2.prototype.validateConstruction = function validateConstruction() {
        if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {
          throw new IllegalArgumentException("Points of LinearRing do not form a closed linestring");
        }
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing2.MINIMUM_VALID_SIZE) {
          throw new IllegalArgumentException("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        }
      };
      LinearRing2.prototype.getGeometryType = function getGeometryType() {
        return "LinearRing";
      };
      LinearRing2.prototype.copy = function copy() {
        return new LinearRing2(this._points.copy(), this._factory);
      };
      LinearRing2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      LinearRing2.prototype.getClass = function getClass() {
        return LinearRing2;
      };
      staticAccessors2.MINIMUM_VALID_SIZE.get = function() {
        return 4;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return -4261142084085851600;
      };
      Object.defineProperties(LinearRing2, staticAccessors2);
      return LinearRing2;
    }(LineString);
    var MultiPolygon = function(GeometryCollection$$1) {
      function MultiPolygon2() {
        GeometryCollection$$1.apply(this, arguments);
      }
      if (GeometryCollection$$1) MultiPolygon2.__proto__ = GeometryCollection$$1;
      MultiPolygon2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
      MultiPolygon2.prototype.constructor = MultiPolygon2;
      var staticAccessors2 = { serialVersionUID: { configurable: true } };
      MultiPolygon2.prototype.getSortIndex = function getSortIndex() {
        return Geometry.SORTINDEX_MULTIPOLYGON;
      };
      MultiPolygon2.prototype.equalsExact = function equalsExact() {
        if (arguments.length === 2) {
          var other = arguments[0];
          var tolerance = arguments[1];
          if (!this.isEquivalentClass(other)) {
            return false;
          }
          return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
        } else {
          return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
        }
      };
      MultiPolygon2.prototype.getBoundaryDimension = function getBoundaryDimension() {
        return 1;
      };
      MultiPolygon2.prototype.getDimension = function getDimension() {
        return 2;
      };
      MultiPolygon2.prototype.reverse = function reverse() {
        var this$1 = this;
        var n = this._geometries.length;
        var revGeoms = new Array(n).fill(null);
        for (var i = 0; i < this._geometries.length; i++) {
          revGeoms[i] = this$1._geometries[i].reverse();
        }
        return this.getFactory().createMultiPolygon(revGeoms);
      };
      MultiPolygon2.prototype.getBoundary = function getBoundary() {
        var this$1 = this;
        if (this.isEmpty()) {
          return this.getFactory().createMultiLineString();
        }
        var allRings = new ArrayList();
        for (var i = 0; i < this._geometries.length; i++) {
          var polygon = this$1._geometries[i];
          var rings = polygon.getBoundary();
          for (var j = 0; j < rings.getNumGeometries(); j++) {
            allRings.add(rings.getGeometryN(j));
          }
        }
        var allRingsArray = new Array(allRings.size()).fill(null);
        return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
      };
      MultiPolygon2.prototype.getGeometryType = function getGeometryType() {
        return "MultiPolygon";
      };
      MultiPolygon2.prototype.copy = function copy() {
        var this$1 = this;
        var polygons = new Array(this._geometries.length).fill(null);
        for (var i = 0; i < polygons.length; i++) {
          polygons[i] = this$1._geometries[i].copy();
        }
        return new MultiPolygon2(polygons, this._factory);
      };
      MultiPolygon2.prototype.interfaces_ = function interfaces_() {
        return [Polygonal];
      };
      MultiPolygon2.prototype.getClass = function getClass() {
        return MultiPolygon2;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return -551033529766975900;
      };
      Object.defineProperties(MultiPolygon2, staticAccessors2);
      return MultiPolygon2;
    }(GeometryCollection);
    var GeometryEditor = function GeometryEditor2(factory) {
      this._factory = factory || null;
      this._isUserDataCopied = false;
    };
    var staticAccessors$16 = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
    GeometryEditor.prototype.setCopyUserData = function setCopyUserData(isUserDataCopied) {
      this._isUserDataCopied = isUserDataCopied;
    };
    GeometryEditor.prototype.edit = function edit(geometry, operation) {
      if (geometry === null) {
        return null;
      }
      var result2 = this.editInternal(geometry, operation);
      if (this._isUserDataCopied) {
        result2.setUserData(geometry.getUserData());
      }
      return result2;
    };
    GeometryEditor.prototype.editInternal = function editInternal(geometry, operation) {
      if (this._factory === null) {
        this._factory = geometry.getFactory();
      }
      if (geometry instanceof GeometryCollection) {
        return this.editGeometryCollection(geometry, operation);
      }
      if (geometry instanceof Polygon) {
        return this.editPolygon(geometry, operation);
      }
      if (geometry instanceof Point) {
        return operation.edit(geometry, this._factory);
      }
      if (geometry instanceof LineString) {
        return operation.edit(geometry, this._factory);
      }
      Assert.shouldNeverReachHere("Unsupported Geometry class: " + geometry.getClass().getName());
      return null;
    };
    GeometryEditor.prototype.editGeometryCollection = function editGeometryCollection(collection, operation) {
      var this$1 = this;
      var collectionForType = operation.edit(collection, this._factory);
      var geometries = new ArrayList();
      for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
        var geometry = this$1.edit(collectionForType.getGeometryN(i), operation);
        if (geometry === null || geometry.isEmpty()) {
          continue;
        }
        geometries.add(geometry);
      }
      if (collectionForType.getClass() === MultiPoint) {
        return this._factory.createMultiPoint(geometries.toArray([]));
      }
      if (collectionForType.getClass() === MultiLineString) {
        return this._factory.createMultiLineString(geometries.toArray([]));
      }
      if (collectionForType.getClass() === MultiPolygon) {
        return this._factory.createMultiPolygon(geometries.toArray([]));
      }
      return this._factory.createGeometryCollection(geometries.toArray([]));
    };
    GeometryEditor.prototype.editPolygon = function editPolygon(polygon, operation) {
      var this$1 = this;
      var newPolygon = operation.edit(polygon, this._factory);
      if (newPolygon === null) {
        newPolygon = this._factory.createPolygon(null);
      }
      if (newPolygon.isEmpty()) {
        return newPolygon;
      }
      var shell = this.edit(newPolygon.getExteriorRing(), operation);
      if (shell === null || shell.isEmpty()) {
        return this._factory.createPolygon();
      }
      var holes = new ArrayList();
      for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
        var hole = this$1.edit(newPolygon.getInteriorRingN(i), operation);
        if (hole === null || hole.isEmpty()) {
          continue;
        }
        holes.add(hole);
      }
      return this._factory.createPolygon(shell, holes.toArray([]));
    };
    GeometryEditor.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryEditor.prototype.getClass = function getClass() {
      return GeometryEditor;
    };
    GeometryEditor.GeometryEditorOperation = function GeometryEditorOperation() {
    };
    staticAccessors$16.NoOpGeometryOperation.get = function() {
      return NoOpGeometryOperation;
    };
    staticAccessors$16.CoordinateOperation.get = function() {
      return CoordinateOperation;
    };
    staticAccessors$16.CoordinateSequenceOperation.get = function() {
      return CoordinateSequenceOperation;
    };
    Object.defineProperties(GeometryEditor, staticAccessors$16);
    var NoOpGeometryOperation = function NoOpGeometryOperation2() {
    };
    NoOpGeometryOperation.prototype.edit = function edit(geometry, factory) {
      return geometry;
    };
    NoOpGeometryOperation.prototype.interfaces_ = function interfaces_() {
      return [GeometryEditor.GeometryEditorOperation];
    };
    NoOpGeometryOperation.prototype.getClass = function getClass() {
      return NoOpGeometryOperation;
    };
    var CoordinateOperation = function CoordinateOperation2() {
    };
    CoordinateOperation.prototype.edit = function edit(geometry, factory) {
      var coords = this.editCoordinates(geometry.getCoordinates(), geometry);
      if (coords === null) {
        return geometry;
      }
      if (geometry instanceof LinearRing) {
        return factory.createLinearRing(coords);
      }
      if (geometry instanceof LineString) {
        return factory.createLineString(coords);
      }
      if (geometry instanceof Point) {
        if (coords.length > 0) {
          return factory.createPoint(coords[0]);
        } else {
          return factory.createPoint();
        }
      }
      return geometry;
    };
    CoordinateOperation.prototype.interfaces_ = function interfaces_() {
      return [GeometryEditor.GeometryEditorOperation];
    };
    CoordinateOperation.prototype.getClass = function getClass() {
      return CoordinateOperation;
    };
    var CoordinateSequenceOperation = function CoordinateSequenceOperation2() {
    };
    CoordinateSequenceOperation.prototype.edit = function edit(geometry, factory) {
      if (geometry instanceof LinearRing) {
        return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));
      }
      if (geometry instanceof LineString) {
        return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));
      }
      if (geometry instanceof Point) {
        return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));
      }
      return geometry;
    };
    CoordinateSequenceOperation.prototype.interfaces_ = function interfaces_() {
      return [GeometryEditor.GeometryEditorOperation];
    };
    CoordinateSequenceOperation.prototype.getClass = function getClass() {
      return CoordinateSequenceOperation;
    };
    var CoordinateArraySequence = function CoordinateArraySequence2() {
      var this$1 = this;
      this._dimension = 3;
      this._coordinates = null;
      if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          this._coordinates = arguments[0];
          this._dimension = 3;
        } else if (Number.isInteger(arguments[0])) {
          var size = arguments[0];
          this._coordinates = new Array(size).fill(null);
          for (var i = 0; i < size; i++) {
            this$1._coordinates[i] = new Coordinate();
          }
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordSeq = arguments[0];
          if (coordSeq === null) {
            this._coordinates = new Array(0).fill(null);
            return null;
          }
          this._dimension = coordSeq.getDimension();
          this._coordinates = new Array(coordSeq.size()).fill(null);
          for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {
            this$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);
          }
        }
      } else if (arguments.length === 2) {
        if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
          var coordinates = arguments[0];
          var dimension = arguments[1];
          this._coordinates = coordinates;
          this._dimension = dimension;
          if (coordinates === null) {
            this._coordinates = new Array(0).fill(null);
          }
        } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var size$1 = arguments[0];
          var dimension$1 = arguments[1];
          this._coordinates = new Array(size$1).fill(null);
          this._dimension = dimension$1;
          for (var i$2 = 0; i$2 < size$1; i$2++) {
            this$1._coordinates[i$2] = new Coordinate();
          }
        }
      }
    };
    var staticAccessors$18 = { serialVersionUID: { configurable: true } };
    CoordinateArraySequence.prototype.setOrdinate = function setOrdinate(index, ordinateIndex, value) {
      switch (ordinateIndex) {
        case CoordinateSequence.X:
          this._coordinates[index].x = value;
          break;
        case CoordinateSequence.Y:
          this._coordinates[index].y = value;
          break;
        case CoordinateSequence.Z:
          this._coordinates[index].z = value;
          break;
        default:
          throw new IllegalArgumentException("invalid ordinateIndex");
      }
    };
    CoordinateArraySequence.prototype.size = function size() {
      return this._coordinates.length;
    };
    CoordinateArraySequence.prototype.getOrdinate = function getOrdinate(index, ordinateIndex) {
      switch (ordinateIndex) {
        case CoordinateSequence.X:
          return this._coordinates[index].x;
        case CoordinateSequence.Y:
          return this._coordinates[index].y;
        case CoordinateSequence.Z:
          return this._coordinates[index].z;
        default:
      }
      return Double.NaN;
    };
    CoordinateArraySequence.prototype.getCoordinate = function getCoordinate() {
      if (arguments.length === 1) {
        var i = arguments[0];
        return this._coordinates[i];
      } else if (arguments.length === 2) {
        var index = arguments[0];
        var coord = arguments[1];
        coord.x = this._coordinates[index].x;
        coord.y = this._coordinates[index].y;
        coord.z = this._coordinates[index].z;
      }
    };
    CoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) {
      return new Coordinate(this._coordinates[i]);
    };
    CoordinateArraySequence.prototype.getDimension = function getDimension() {
      return this._dimension;
    };
    CoordinateArraySequence.prototype.getX = function getX(index) {
      return this._coordinates[index].x;
    };
    CoordinateArraySequence.prototype.clone = function clone() {
      var this$1 = this;
      var cloneCoordinates = new Array(this.size()).fill(null);
      for (var i = 0; i < this._coordinates.length; i++) {
        cloneCoordinates[i] = this$1._coordinates[i].clone();
      }
      return new CoordinateArraySequence(cloneCoordinates, this._dimension);
    };
    CoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope(env) {
      var this$1 = this;
      for (var i = 0; i < this._coordinates.length; i++) {
        env.expandToInclude(this$1._coordinates[i]);
      }
      return env;
    };
    CoordinateArraySequence.prototype.copy = function copy() {
      var this$1 = this;
      var cloneCoordinates = new Array(this.size()).fill(null);
      for (var i = 0; i < this._coordinates.length; i++) {
        cloneCoordinates[i] = this$1._coordinates[i].copy();
      }
      return new CoordinateArraySequence(cloneCoordinates, this._dimension);
    };
    CoordinateArraySequence.prototype.toString = function toString() {
      var this$1 = this;
      if (this._coordinates.length > 0) {
        var strBuf = new StringBuffer(17 * this._coordinates.length);
        strBuf.append("(");
        strBuf.append(this._coordinates[0]);
        for (var i = 1; i < this._coordinates.length; i++) {
          strBuf.append(", ");
          strBuf.append(this$1._coordinates[i]);
        }
        strBuf.append(")");
        return strBuf.toString();
      } else {
        return "()";
      }
    };
    CoordinateArraySequence.prototype.getY = function getY(index) {
      return this._coordinates[index].y;
    };
    CoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray() {
      return this._coordinates;
    };
    CoordinateArraySequence.prototype.interfaces_ = function interfaces_() {
      return [CoordinateSequence, Serializable];
    };
    CoordinateArraySequence.prototype.getClass = function getClass() {
      return CoordinateArraySequence;
    };
    staticAccessors$18.serialVersionUID.get = function() {
      return -915438501601840600;
    };
    Object.defineProperties(CoordinateArraySequence, staticAccessors$18);
    var CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory2() {
    };
    var staticAccessors$17 = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
    CoordinateArraySequenceFactory.prototype.readResolve = function readResolve() {
      return CoordinateArraySequenceFactory.instance();
    };
    CoordinateArraySequenceFactory.prototype.create = function create() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var coordinates = arguments[0];
          return new CoordinateArraySequence(coordinates);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordSeq = arguments[0];
          return new CoordinateArraySequence(coordSeq);
        }
      } else if (arguments.length === 2) {
        var size = arguments[0];
        var dimension = arguments[1];
        if (dimension > 3) {
          dimension = 3;
        }
        if (dimension < 2) {
          return new CoordinateArraySequence(size);
        }
        return new CoordinateArraySequence(size, dimension);
      }
    };
    CoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_() {
      return [CoordinateSequenceFactory, Serializable];
    };
    CoordinateArraySequenceFactory.prototype.getClass = function getClass() {
      return CoordinateArraySequenceFactory;
    };
    CoordinateArraySequenceFactory.instance = function instance() {
      return CoordinateArraySequenceFactory.instanceObject;
    };
    staticAccessors$17.serialVersionUID.get = function() {
      return -4099577099607551500;
    };
    staticAccessors$17.instanceObject.get = function() {
      return new CoordinateArraySequenceFactory();
    };
    Object.defineProperties(CoordinateArraySequenceFactory, staticAccessors$17);
    var HashMap = function(MapInterface) {
      function HashMap2() {
        MapInterface.call(this);
        this.map_ = /* @__PURE__ */ new Map();
      }
      if (MapInterface) HashMap2.__proto__ = MapInterface;
      HashMap2.prototype = Object.create(MapInterface && MapInterface.prototype);
      HashMap2.prototype.constructor = HashMap2;
      HashMap2.prototype.get = function get2(key) {
        return this.map_.get(key) || null;
      };
      HashMap2.prototype.put = function put(key, value) {
        this.map_.set(key, value);
        return value;
      };
      HashMap2.prototype.values = function values() {
        var arrayList = new ArrayList();
        var it = this.map_.values();
        var o = it.next();
        while (!o.done) {
          arrayList.add(o.value);
          o = it.next();
        }
        return arrayList;
      };
      HashMap2.prototype.entrySet = function entrySet() {
        var hashSet = new HashSet();
        this.map_.entries().forEach(function(entry) {
          return hashSet.add(entry);
        });
        return hashSet;
      };
      HashMap2.prototype.size = function size() {
        return this.map_.size();
      };
      return HashMap2;
    }(Map$1);
    var PrecisionModel = function PrecisionModel2() {
      this._modelType = null;
      this._scale = null;
      if (arguments.length === 0) {
        this._modelType = PrecisionModel2.FLOATING;
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Type) {
          var modelType = arguments[0];
          this._modelType = modelType;
          if (modelType === PrecisionModel2.FIXED) {
            this.setScale(1);
          }
        } else if (typeof arguments[0] === "number") {
          var scale = arguments[0];
          this._modelType = PrecisionModel2.FIXED;
          this.setScale(scale);
        } else if (arguments[0] instanceof PrecisionModel2) {
          var pm = arguments[0];
          this._modelType = pm._modelType;
          this._scale = pm._scale;
        }
      }
    };
    var staticAccessors$19 = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
    PrecisionModel.prototype.equals = function equals(other) {
      if (!(other instanceof PrecisionModel)) {
        return false;
      }
      var otherPrecisionModel = other;
      return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
    };
    PrecisionModel.prototype.compareTo = function compareTo(o) {
      var other = o;
      var sigDigits = this.getMaximumSignificantDigits();
      var otherSigDigits = other.getMaximumSignificantDigits();
      return new Integer(sigDigits).compareTo(new Integer(otherSigDigits));
    };
    PrecisionModel.prototype.getScale = function getScale() {
      return this._scale;
    };
    PrecisionModel.prototype.isFloating = function isFloating() {
      return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
    };
    PrecisionModel.prototype.getType = function getType() {
      return this._modelType;
    };
    PrecisionModel.prototype.toString = function toString() {
      var description = "UNKNOWN";
      if (this._modelType === PrecisionModel.FLOATING) {
        description = "Floating";
      } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
        description = "Floating-Single";
      } else if (this._modelType === PrecisionModel.FIXED) {
        description = "Fixed (Scale=" + this.getScale() + ")";
      }
      return description;
    };
    PrecisionModel.prototype.makePrecise = function makePrecise() {
      if (typeof arguments[0] === "number") {
        var val = arguments[0];
        if (Double.isNaN(val)) {
          return val;
        }
        if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
          var floatSingleVal = val;
          return floatSingleVal;
        }
        if (this._modelType === PrecisionModel.FIXED) {
          return Math.round(val * this._scale) / this._scale;
        }
        return val;
      } else if (arguments[0] instanceof Coordinate) {
        var coord = arguments[0];
        if (this._modelType === PrecisionModel.FLOATING) {
          return null;
        }
        coord.x = this.makePrecise(coord.x);
        coord.y = this.makePrecise(coord.y);
      }
    };
    PrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits() {
      var maxSigDigits = 16;
      if (this._modelType === PrecisionModel.FLOATING) {
        maxSigDigits = 16;
      } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
        maxSigDigits = 6;
      } else if (this._modelType === PrecisionModel.FIXED) {
        maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
      }
      return maxSigDigits;
    };
    PrecisionModel.prototype.setScale = function setScale(scale) {
      this._scale = Math.abs(scale);
    };
    PrecisionModel.prototype.interfaces_ = function interfaces_() {
      return [Serializable, Comparable];
    };
    PrecisionModel.prototype.getClass = function getClass() {
      return PrecisionModel;
    };
    PrecisionModel.mostPrecise = function mostPrecise(pm1, pm2) {
      if (pm1.compareTo(pm2) >= 0) {
        return pm1;
      }
      return pm2;
    };
    staticAccessors$19.serialVersionUID.get = function() {
      return 7777263578777804e3;
    };
    staticAccessors$19.maximumPreciseValue.get = function() {
      return 9007199254740992;
    };
    Object.defineProperties(PrecisionModel, staticAccessors$19);
    var Type = function Type2(name) {
      this._name = name || null;
      Type2.nameToTypeMap.put(name, this);
    };
    var staticAccessors$1$1 = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
    Type.prototype.readResolve = function readResolve() {
      return Type.nameToTypeMap.get(this._name);
    };
    Type.prototype.toString = function toString() {
      return this._name;
    };
    Type.prototype.interfaces_ = function interfaces_() {
      return [Serializable];
    };
    Type.prototype.getClass = function getClass() {
      return Type;
    };
    staticAccessors$1$1.serialVersionUID.get = function() {
      return -552860263173159e4;
    };
    staticAccessors$1$1.nameToTypeMap.get = function() {
      return new HashMap();
    };
    Object.defineProperties(Type, staticAccessors$1$1);
    PrecisionModel.Type = Type;
    PrecisionModel.FIXED = new Type("FIXED");
    PrecisionModel.FLOATING = new Type("FLOATING");
    PrecisionModel.FLOATING_SINGLE = new Type("FLOATING SINGLE");
    var GeometryFactory = function GeometryFactory2() {
      this._precisionModel = new PrecisionModel();
      this._SRID = 0;
      this._coordinateSequenceFactory = GeometryFactory2.getDefaultCoordinateSequenceFactory();
      if (arguments.length === 0) {
      } else if (arguments.length === 1) {
        if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
          this._coordinateSequenceFactory = arguments[0];
        } else if (arguments[0] instanceof PrecisionModel) {
          this._precisionModel = arguments[0];
        }
      } else if (arguments.length === 2) {
        this._precisionModel = arguments[0];
        this._SRID = arguments[1];
      } else if (arguments.length === 3) {
        this._precisionModel = arguments[0];
        this._SRID = arguments[1];
        this._coordinateSequenceFactory = arguments[2];
      }
    };
    var staticAccessors$2 = { serialVersionUID: { configurable: true } };
    GeometryFactory.prototype.toGeometry = function toGeometry(envelope) {
      if (envelope.isNull()) {
        return this.createPoint(null);
      }
      if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
        return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));
      }
      if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
        return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);
      }
      return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);
    };
    GeometryFactory.prototype.createLineString = function createLineString(coordinates) {
      if (!coordinates) {
        return new LineString(this.getCoordinateSequenceFactory().create([]), this);
      } else if (coordinates instanceof Array) {
        return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this);
      } else if (hasInterface(coordinates, CoordinateSequence)) {
        return new LineString(coordinates, this);
      }
    };
    GeometryFactory.prototype.createMultiLineString = function createMultiLineString() {
      if (arguments.length === 0) {
        return new MultiLineString(null, this);
      } else if (arguments.length === 1) {
        var lineStrings = arguments[0];
        return new MultiLineString(lineStrings, this);
      }
    };
    GeometryFactory.prototype.buildGeometry = function buildGeometry(geomList) {
      var geomClass = null;
      var isHeterogeneous = false;
      var hasGeometryCollection = false;
      for (var i = geomList.iterator(); i.hasNext(); ) {
        var geom = i.next();
        var partClass = geom.getClass();
        if (geomClass === null) {
          geomClass = partClass;
        }
        if (partClass !== geomClass) {
          isHeterogeneous = true;
        }
        if (geom.isGeometryCollectionOrDerived()) {
          hasGeometryCollection = true;
        }
      }
      if (geomClass === null) {
        return this.createGeometryCollection();
      }
      if (isHeterogeneous || hasGeometryCollection) {
        return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
      }
      var geom0 = geomList.iterator().next();
      var isCollection = geomList.size() > 1;
      if (isCollection) {
        if (geom0 instanceof Polygon) {
          return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
        } else if (geom0 instanceof LineString) {
          return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
        } else if (geom0 instanceof Point) {
          return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
        }
        Assert.shouldNeverReachHere("Unhandled class: " + geom0.getClass().getName());
      }
      return geom0;
    };
    GeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords(coordinates) {
      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    };
    GeometryFactory.prototype.createPoint = function createPoint() {
      if (arguments.length === 0) {
        return this.createPoint(this.getCoordinateSequenceFactory().create([]));
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var coordinate = arguments[0];
          return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordinates = arguments[0];
          return new Point(coordinates, this);
        }
      }
    };
    GeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory() {
      return this._coordinateSequenceFactory;
    };
    GeometryFactory.prototype.createPolygon = function createPolygon() {
      if (arguments.length === 0) {
        return new Polygon(null, null, this);
      } else if (arguments.length === 1) {
        if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordinates = arguments[0];
          return this.createPolygon(this.createLinearRing(coordinates));
        } else if (arguments[0] instanceof Array) {
          var coordinates$1 = arguments[0];
          return this.createPolygon(this.createLinearRing(coordinates$1));
        } else if (arguments[0] instanceof LinearRing) {
          var shell = arguments[0];
          return this.createPolygon(shell, null);
        }
      } else if (arguments.length === 2) {
        var shell$1 = arguments[0];
        var holes = arguments[1];
        return new Polygon(shell$1, holes, this);
      }
    };
    GeometryFactory.prototype.getSRID = function getSRID() {
      return this._SRID;
    };
    GeometryFactory.prototype.createGeometryCollection = function createGeometryCollection() {
      if (arguments.length === 0) {
        return new GeometryCollection(null, this);
      } else if (arguments.length === 1) {
        var geometries = arguments[0];
        return new GeometryCollection(geometries, this);
      }
    };
    GeometryFactory.prototype.createGeometry = function createGeometry(g) {
      var editor = new GeometryEditor(this);
      return editor.edit(g, {
        edit: function() {
          if (arguments.length === 2) {
            var coordSeq = arguments[0];
            return this._coordinateSequenceFactory.create(coordSeq);
          }
        }
      });
    };
    GeometryFactory.prototype.getPrecisionModel = function getPrecisionModel() {
      return this._precisionModel;
    };
    GeometryFactory.prototype.createLinearRing = function createLinearRing() {
      if (arguments.length === 0) {
        return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var coordinates = arguments[0];
          return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordinates$1 = arguments[0];
          return new LinearRing(coordinates$1, this);
        }
      }
    };
    GeometryFactory.prototype.createMultiPolygon = function createMultiPolygon() {
      if (arguments.length === 0) {
        return new MultiPolygon(null, this);
      } else if (arguments.length === 1) {
        var polygons = arguments[0];
        return new MultiPolygon(polygons, this);
      }
    };
    GeometryFactory.prototype.createMultiPoint = function createMultiPoint() {
      var this$1 = this;
      if (arguments.length === 0) {
        return new MultiPoint(null, this);
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var point = arguments[0];
          return new MultiPoint(point, this);
        } else if (arguments[0] instanceof Array) {
          var coordinates = arguments[0];
          return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordinates$1 = arguments[0];
          if (coordinates$1 === null) {
            return this.createMultiPoint(new Array(0).fill(null));
          }
          var points = new Array(coordinates$1.size()).fill(null);
          for (var i = 0; i < coordinates$1.size(); i++) {
            var ptSeq = this$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());
            CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);
            points[i] = this$1.createPoint(ptSeq);
          }
          return this.createMultiPoint(points);
        }
      }
    };
    GeometryFactory.prototype.interfaces_ = function interfaces_() {
      return [Serializable];
    };
    GeometryFactory.prototype.getClass = function getClass() {
      return GeometryFactory;
    };
    GeometryFactory.toMultiPolygonArray = function toMultiPolygonArray(multiPolygons) {
      var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
      return multiPolygons.toArray(multiPolygonArray);
    };
    GeometryFactory.toGeometryArray = function toGeometryArray(geometries) {
      if (geometries === null) {
        return null;
      }
      var geometryArray = new Array(geometries.size()).fill(null);
      return geometries.toArray(geometryArray);
    };
    GeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory() {
      return CoordinateArraySequenceFactory.instance();
    };
    GeometryFactory.toMultiLineStringArray = function toMultiLineStringArray(multiLineStrings) {
      var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
      return multiLineStrings.toArray(multiLineStringArray);
    };
    GeometryFactory.toLineStringArray = function toLineStringArray(lineStrings) {
      var lineStringArray = new Array(lineStrings.size()).fill(null);
      return lineStrings.toArray(lineStringArray);
    };
    GeometryFactory.toMultiPointArray = function toMultiPointArray(multiPoints) {
      var multiPointArray = new Array(multiPoints.size()).fill(null);
      return multiPoints.toArray(multiPointArray);
    };
    GeometryFactory.toLinearRingArray = function toLinearRingArray(linearRings) {
      var linearRingArray = new Array(linearRings.size()).fill(null);
      return linearRings.toArray(linearRingArray);
    };
    GeometryFactory.toPointArray = function toPointArray(points) {
      var pointArray = new Array(points.size()).fill(null);
      return points.toArray(pointArray);
    };
    GeometryFactory.toPolygonArray = function toPolygonArray(polygons) {
      var polygonArray = new Array(polygons.size()).fill(null);
      return polygons.toArray(polygonArray);
    };
    GeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord(coord, exemplar) {
      exemplar.getPrecisionModel().makePrecise(coord);
      return exemplar.getFactory().createPoint(coord);
    };
    staticAccessors$2.serialVersionUID.get = function() {
      return -6820524753094096e3;
    };
    Object.defineProperties(GeometryFactory, staticAccessors$2);
    var geometryTypes = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];
    var GeoJSONParser = function GeoJSONParser2(geometryFactory) {
      this.geometryFactory = geometryFactory || new GeometryFactory();
    };
    GeoJSONParser.prototype.read = function read(json) {
      var obj;
      if (typeof json === "string") {
        obj = JSON.parse(json);
      } else {
        obj = json;
      }
      var type = obj.type;
      if (!parse2[type]) {
        throw new Error("Unknown GeoJSON type: " + obj.type);
      }
      if (geometryTypes.indexOf(type) !== -1) {
        return parse2[type].apply(this, [obj.coordinates]);
      } else if (type === "GeometryCollection") {
        return parse2[type].apply(this, [obj.geometries]);
      }
      return parse2[type].apply(this, [obj]);
    };
    GeoJSONParser.prototype.write = function write(geometry) {
      var type = geometry.getGeometryType();
      if (!extract[type]) {
        throw new Error("Geometry is not supported");
      }
      return extract[type].apply(this, [geometry]);
    };
    var parse2 = {
      /**
       * Parse a GeoJSON Feature object
       *
       * @param {Object}
       *          obj Object to parse.
       *
       * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
       */
      Feature: function(obj) {
        var feature = {};
        for (var key in obj) {
          feature[key] = obj[key];
        }
        if (obj.geometry) {
          var type = obj.geometry.type;
          if (!parse2[type]) {
            throw new Error("Unknown GeoJSON type: " + obj.type);
          }
          feature.geometry = this.read(obj.geometry);
        }
        if (obj.bbox) {
          feature.bbox = parse2.bbox.apply(this, [obj.bbox]);
        }
        return feature;
      },
      /**
       * Parse a GeoJSON FeatureCollection object
       *
       * @param {Object}
       *          obj Object to parse.
       *
       * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
       */
      FeatureCollection: function(obj) {
        var this$1 = this;
        var featureCollection = {};
        if (obj.features) {
          featureCollection.features = [];
          for (var i = 0; i < obj.features.length; ++i) {
            featureCollection.features.push(this$1.read(obj.features[i]));
          }
        }
        if (obj.bbox) {
          featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);
        }
        return featureCollection;
      },
      /**
       * Convert the ordinates in an array to an array of Coordinates
       *
       * @param {Array}
       *          array Array with {Number}s.
       *
       * @return {Array} Array with Coordinates.
       */
      coordinates: function(array) {
        var coordinates = [];
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i];
          coordinates.push(new Coordinate(sub[0], sub[1]));
        }
        return coordinates;
      },
      /**
       * Convert the bbox to a LinearRing
       *
       * @param {Array}
       *          array Array with [xMin, yMin, xMax, yMax].
       *
       * @return {Array} Array with Coordinates.
       */
      bbox: function(array) {
        return this.geometryFactory.createLinearRing([
          new Coordinate(array[0], array[1]),
          new Coordinate(array[2], array[1]),
          new Coordinate(array[2], array[3]),
          new Coordinate(array[0], array[3]),
          new Coordinate(array[0], array[1])
        ]);
      },
      /**
       * Convert an Array with ordinates to a Point
       *
       * @param {Array}
       *          array Array with ordinates.
       *
       * @return {Point} Point.
       */
      Point: function(array) {
        var coordinate = new Coordinate(array[0], array[1]);
        return this.geometryFactory.createPoint(coordinate);
      },
      /**
       * Convert an Array with coordinates to a MultiPoint
       *
       * @param {Array}
       *          array Array with coordinates.
       *
       * @return {MultiPoint} MultiPoint.
       */
      MultiPoint: function(array) {
        var this$1 = this;
        var points = [];
        for (var i = 0; i < array.length; ++i) {
          points.push(parse2.Point.apply(this$1, [array[i]]));
        }
        return this.geometryFactory.createMultiPoint(points);
      },
      /**
       * Convert an Array with coordinates to a LineString
       *
       * @param {Array}
       *          array Array with coordinates.
       *
       * @return {LineString} LineString.
       */
      LineString: function(array) {
        var coordinates = parse2.coordinates.apply(this, [array]);
        return this.geometryFactory.createLineString(coordinates);
      },
      /**
       * Convert an Array with coordinates to a MultiLineString
       *
       * @param {Array}
       *          array Array with coordinates.
       *
       * @return {MultiLineString} MultiLineString.
       */
      MultiLineString: function(array) {
        var this$1 = this;
        var lineStrings = [];
        for (var i = 0; i < array.length; ++i) {
          lineStrings.push(parse2.LineString.apply(this$1, [array[i]]));
        }
        return this.geometryFactory.createMultiLineString(lineStrings);
      },
      /**
       * Convert an Array to a Polygon
       *
       * @param {Array}
       *          array Array with shell and holes.
       *
       * @return {Polygon} Polygon.
       */
      Polygon: function(array) {
        var this$1 = this;
        var shellCoordinates = parse2.coordinates.apply(this, [array[0]]);
        var shell = this.geometryFactory.createLinearRing(shellCoordinates);
        var holes = [];
        for (var i = 1; i < array.length; ++i) {
          var hole = array[i];
          var coordinates = parse2.coordinates.apply(this$1, [hole]);
          var linearRing = this$1.geometryFactory.createLinearRing(coordinates);
          holes.push(linearRing);
        }
        return this.geometryFactory.createPolygon(shell, holes);
      },
      /**
       * Convert an Array to a MultiPolygon
       *
       * @param {Array}
       *          array Array of arrays with shell and rings.
       *
       * @return {MultiPolygon} MultiPolygon.
       */
      MultiPolygon: function(array) {
        var this$1 = this;
        var polygons = [];
        for (var i = 0; i < array.length; ++i) {
          var polygon = array[i];
          polygons.push(parse2.Polygon.apply(this$1, [polygon]));
        }
        return this.geometryFactory.createMultiPolygon(polygons);
      },
      /**
       * Convert an Array to a GeometryCollection
       *
       * @param {Array}
       *          array Array of GeoJSON geometries.
       *
       * @return {GeometryCollection} GeometryCollection.
       */
      GeometryCollection: function(array) {
        var this$1 = this;
        var geometries = [];
        for (var i = 0; i < array.length; ++i) {
          var geometry = array[i];
          geometries.push(this$1.read(geometry));
        }
        return this.geometryFactory.createGeometryCollection(geometries);
      }
    };
    var extract = {
      /**
       * Convert a Coordinate to an Array
       *
       * @param {Coordinate}
       *          coordinate Coordinate to convert.
       *
       * @return {Array} Array of ordinates.
       */
      coordinate: function(coordinate) {
        return [coordinate.x, coordinate.y];
      },
      /**
       * Convert a Point to a GeoJSON object
       *
       * @param {Point}
       *          point Point to convert.
       *
       * @return {Array} Array of 2 ordinates (paired to a coordinate).
       */
      Point: function(point) {
        var array = extract.coordinate.apply(this, [point.getCoordinate()]);
        return {
          type: "Point",
          coordinates: array
        };
      },
      /**
       * Convert a MultiPoint to a GeoJSON object
       *
       * @param {MultiPoint}
       *          multipoint MultiPoint to convert.
       *
       * @return {Array} Array of coordinates.
       */
      MultiPoint: function(multipoint) {
        var this$1 = this;
        var array = [];
        for (var i = 0; i < multipoint._geometries.length; ++i) {
          var point = multipoint._geometries[i];
          var geoJson = extract.Point.apply(this$1, [point]);
          array.push(geoJson.coordinates);
        }
        return {
          type: "MultiPoint",
          coordinates: array
        };
      },
      /**
       * Convert a LineString to a GeoJSON object
       *
       * @param {LineString}
       *          linestring LineString to convert.
       *
       * @return {Array} Array of coordinates.
       */
      LineString: function(linestring) {
        var this$1 = this;
        var array = [];
        var coordinates = linestring.getCoordinates();
        for (var i = 0; i < coordinates.length; ++i) {
          var coordinate = coordinates[i];
          array.push(extract.coordinate.apply(this$1, [coordinate]));
        }
        return {
          type: "LineString",
          coordinates: array
        };
      },
      /**
       * Convert a MultiLineString to a GeoJSON object
       *
       * @param {MultiLineString}
       *          multilinestring MultiLineString to convert.
       *
       * @return {Array} Array of Array of coordinates.
       */
      MultiLineString: function(multilinestring) {
        var this$1 = this;
        var array = [];
        for (var i = 0; i < multilinestring._geometries.length; ++i) {
          var linestring = multilinestring._geometries[i];
          var geoJson = extract.LineString.apply(this$1, [linestring]);
          array.push(geoJson.coordinates);
        }
        return {
          type: "MultiLineString",
          coordinates: array
        };
      },
      /**
       * Convert a Polygon to a GeoJSON object
       *
       * @param {Polygon}
       *          polygon Polygon to convert.
       *
       * @return {Array} Array with shell, holes.
       */
      Polygon: function(polygon) {
        var this$1 = this;
        var array = [];
        var shellGeoJson = extract.LineString.apply(this, [polygon._shell]);
        array.push(shellGeoJson.coordinates);
        for (var i = 0; i < polygon._holes.length; ++i) {
          var hole = polygon._holes[i];
          var holeGeoJson = extract.LineString.apply(this$1, [hole]);
          array.push(holeGeoJson.coordinates);
        }
        return {
          type: "Polygon",
          coordinates: array
        };
      },
      /**
       * Convert a MultiPolygon to a GeoJSON object
       *
       * @param {MultiPolygon}
       *          multipolygon MultiPolygon to convert.
       *
       * @return {Array} Array of polygons.
       */
      MultiPolygon: function(multipolygon) {
        var this$1 = this;
        var array = [];
        for (var i = 0; i < multipolygon._geometries.length; ++i) {
          var polygon = multipolygon._geometries[i];
          var geoJson = extract.Polygon.apply(this$1, [polygon]);
          array.push(geoJson.coordinates);
        }
        return {
          type: "MultiPolygon",
          coordinates: array
        };
      },
      /**
       * Convert a GeometryCollection to a GeoJSON object
       *
       * @param {GeometryCollection}
       *          collection GeometryCollection to convert.
       *
       * @return {Array} Array of geometries.
       */
      GeometryCollection: function(collection) {
        var this$1 = this;
        var array = [];
        for (var i = 0; i < collection._geometries.length; ++i) {
          var geometry = collection._geometries[i];
          var type = geometry.getGeometryType();
          array.push(extract[type].apply(this$1, [geometry]));
        }
        return {
          type: "GeometryCollection",
          geometries: array
        };
      }
    };
    var GeoJSONReader = function GeoJSONReader2(geometryFactory) {
      this.geometryFactory = geometryFactory || new GeometryFactory();
      this.precisionModel = this.geometryFactory.getPrecisionModel();
      this.parser = new GeoJSONParser(this.geometryFactory);
    };
    GeoJSONReader.prototype.read = function read(geoJson) {
      var geometry = this.parser.read(geoJson);
      if (this.precisionModel.getType() === PrecisionModel.FIXED) {
        this.reducePrecision(geometry);
      }
      return geometry;
    };
    GeoJSONReader.prototype.reducePrecision = function reducePrecision(geometry) {
      var this$1 = this;
      var i, len;
      if (geometry.coordinate) {
        this.precisionModel.makePrecise(geometry.coordinate);
      } else if (geometry.points) {
        for (i = 0, len = geometry.points.length; i < len; i++) {
          this$1.precisionModel.makePrecise(geometry.points[i]);
        }
      } else if (geometry.geometries) {
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          this$1.reducePrecision(geometry.geometries[i]);
        }
      }
    };
    var GeoJSONWriter = function GeoJSONWriter2() {
      this.parser = new GeoJSONParser(this.geometryFactory);
    };
    GeoJSONWriter.prototype.write = function write(geometry) {
      return this.parser.write(geometry);
    };
    var Position = function Position2() {
    };
    var staticAccessors$20 = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
    Position.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Position.prototype.getClass = function getClass() {
      return Position;
    };
    Position.opposite = function opposite(position) {
      if (position === Position.LEFT) {
        return Position.RIGHT;
      }
      if (position === Position.RIGHT) {
        return Position.LEFT;
      }
      return position;
    };
    staticAccessors$20.ON.get = function() {
      return 0;
    };
    staticAccessors$20.LEFT.get = function() {
      return 1;
    };
    staticAccessors$20.RIGHT.get = function() {
      return 2;
    };
    Object.defineProperties(Position, staticAccessors$20);
    function EmptyStackException(message) {
      this.message = message || "";
    }
    EmptyStackException.prototype = new Error();
    EmptyStackException.prototype.name = "EmptyStackException";
    function Stack() {
      this.array_ = [];
    }
    Stack.prototype = new List();
    Stack.prototype.add = function(e) {
      this.array_.push(e);
      return true;
    };
    Stack.prototype.get = function(index) {
      if (index < 0 || index >= this.size()) {
        throw new Error();
      }
      return this.array_[index];
    };
    Stack.prototype.push = function(e) {
      this.array_.push(e);
      return e;
    };
    Stack.prototype.pop = function(e) {
      if (this.array_.length === 0) {
        throw new EmptyStackException();
      }
      return this.array_.pop();
    };
    Stack.prototype.peek = function() {
      if (this.array_.length === 0) {
        throw new EmptyStackException();
      }
      return this.array_[this.array_.length - 1];
    };
    Stack.prototype.empty = function() {
      if (this.array_.length === 0) {
        return true;
      } else {
        return false;
      }
    };
    Stack.prototype.isEmpty = function() {
      return this.empty();
    };
    Stack.prototype.search = function(o) {
      return this.array_.indexOf(o);
    };
    Stack.prototype.size = function() {
      return this.array_.length;
    };
    Stack.prototype.toArray = function() {
      var this$1 = this;
      var array = [];
      for (var i = 0, len = this.array_.length; i < len; i++) {
        array.push(this$1.array_[i]);
      }
      return array;
    };
    var RightmostEdgeFinder = function RightmostEdgeFinder2() {
      this._minIndex = -1;
      this._minCoord = null;
      this._minDe = null;
      this._orientedDe = null;
    };
    RightmostEdgeFinder.prototype.getCoordinate = function getCoordinate() {
      return this._minCoord;
    };
    RightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide(de, index) {
      var side = this.getRightmostSideOfSegment(de, index);
      if (side < 0) {
        side = this.getRightmostSideOfSegment(de, index - 1);
      }
      if (side < 0) {
        this._minCoord = null;
        this.checkForRightmostCoordinate(de);
      }
      return side;
    };
    RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex() {
      var pts = this._minDe.getEdge().getCoordinates();
      Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, "rightmost point expected to be interior vertex of edge");
      var pPrev = pts[this._minIndex - 1];
      var pNext = pts[this._minIndex + 1];
      var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);
      var usePrev = false;
      if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {
        usePrev = true;
      } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {
        usePrev = true;
      }
      if (usePrev) {
        this._minIndex = this._minIndex - 1;
      }
    };
    RightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment(de, i) {
      var e = de.getEdge();
      var coord = e.getCoordinates();
      if (i < 0 || i + 1 >= coord.length) {
        return -1;
      }
      if (coord[i].y === coord[i + 1].y) {
        return -1;
      }
      var pos = Position.LEFT;
      if (coord[i].y < coord[i + 1].y) {
        pos = Position.RIGHT;
      }
      return pos;
    };
    RightmostEdgeFinder.prototype.getEdge = function getEdge() {
      return this._orientedDe;
    };
    RightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate(de) {
      var this$1 = this;
      var coord = de.getEdge().getCoordinates();
      for (var i = 0; i < coord.length - 1; i++) {
        if (this$1._minCoord === null || coord[i].x > this$1._minCoord.x) {
          this$1._minDe = de;
          this$1._minIndex = i;
          this$1._minCoord = coord[i];
        }
      }
    };
    RightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode() {
      var node = this._minDe.getNode();
      var star = node.getEdges();
      this._minDe = star.getRightmostEdge();
      if (!this._minDe.isForward()) {
        this._minDe = this._minDe.getSym();
        this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
      }
    };
    RightmostEdgeFinder.prototype.findEdge = function findEdge(dirEdgeList) {
      var this$1 = this;
      for (var i = dirEdgeList.iterator(); i.hasNext(); ) {
        var de = i.next();
        if (!de.isForward()) {
          continue;
        }
        this$1.checkForRightmostCoordinate(de);
      }
      Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing");
      if (this._minIndex === 0) {
        this.findRightmostEdgeAtNode();
      } else {
        this.findRightmostEdgeAtVertex();
      }
      this._orientedDe = this._minDe;
      var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
      if (rightmostSide === Position.LEFT) {
        this._orientedDe = this._minDe.getSym();
      }
    };
    RightmostEdgeFinder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    RightmostEdgeFinder.prototype.getClass = function getClass() {
      return RightmostEdgeFinder;
    };
    var TopologyException = function(RuntimeException$$1) {
      function TopologyException2(msg, pt) {
        RuntimeException$$1.call(this, TopologyException2.msgWithCoord(msg, pt));
        this.pt = pt ? new Coordinate(pt) : null;
        this.name = "TopologyException";
      }
      if (RuntimeException$$1) TopologyException2.__proto__ = RuntimeException$$1;
      TopologyException2.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
      TopologyException2.prototype.constructor = TopologyException2;
      TopologyException2.prototype.getCoordinate = function getCoordinate() {
        return this.pt;
      };
      TopologyException2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      TopologyException2.prototype.getClass = function getClass() {
        return TopologyException2;
      };
      TopologyException2.msgWithCoord = function msgWithCoord(msg, pt) {
        if (!pt) {
          return msg + " [ " + pt + " ]";
        }
        return msg;
      };
      return TopologyException2;
    }(RuntimeException);
    var LinkedList = function LinkedList2() {
      this.array_ = [];
    };
    LinkedList.prototype.addLast = function addLast(e) {
      this.array_.push(e);
    };
    LinkedList.prototype.removeFirst = function removeFirst() {
      return this.array_.shift();
    };
    LinkedList.prototype.isEmpty = function isEmpty() {
      return this.array_.length === 0;
    };
    var BufferSubgraph = function BufferSubgraph2() {
      this._finder = null;
      this._dirEdgeList = new ArrayList();
      this._nodes = new ArrayList();
      this._rightMostCoord = null;
      this._env = null;
      this._finder = new RightmostEdgeFinder();
    };
    BufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges() {
      for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
        var de = it.next();
        de.setVisited(false);
      }
    };
    BufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate() {
      return this._rightMostCoord;
    };
    BufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth(n) {
      var this$1 = this;
      var startEdge = null;
      for (var i = n.getEdges().iterator(); i.hasNext(); ) {
        var de = i.next();
        if (de.isVisited() || de.getSym().isVisited()) {
          startEdge = de;
          break;
        }
      }
      if (startEdge === null) {
        throw new TopologyException("unable to find edge to compute depths at " + n.getCoordinate());
      }
      n.getEdges().computeDepths(startEdge);
      for (var i$1 = n.getEdges().iterator(); i$1.hasNext(); ) {
        var de$1 = i$1.next();
        de$1.setVisited(true);
        this$1.copySymDepths(de$1);
      }
    };
    BufferSubgraph.prototype.computeDepth = function computeDepth(outsideDepth) {
      this.clearVisitedEdges();
      var de = this._finder.getEdge();
      de.setEdgeDepths(Position.RIGHT, outsideDepth);
      this.copySymDepths(de);
      this.computeDepths(de);
    };
    BufferSubgraph.prototype.create = function create(node) {
      this.addReachable(node);
      this._finder.findEdge(this._dirEdgeList);
      this._rightMostCoord = this._finder.getCoordinate();
    };
    BufferSubgraph.prototype.findResultEdges = function findResultEdges() {
      for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
        var de = it.next();
        if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
          de.setInResult(true);
        }
      }
    };
    BufferSubgraph.prototype.computeDepths = function computeDepths(startEdge) {
      var this$1 = this;
      var nodesVisited = new HashSet();
      var nodeQueue = new LinkedList();
      var startNode = startEdge.getNode();
      nodeQueue.addLast(startNode);
      nodesVisited.add(startNode);
      startEdge.setVisited(true);
      while (!nodeQueue.isEmpty()) {
        var n = nodeQueue.removeFirst();
        nodesVisited.add(n);
        this$1.computeNodeDepth(n);
        for (var i = n.getEdges().iterator(); i.hasNext(); ) {
          var de = i.next();
          var sym = de.getSym();
          if (sym.isVisited()) {
            continue;
          }
          var adjNode = sym.getNode();
          if (!nodesVisited.contains(adjNode)) {
            nodeQueue.addLast(adjNode);
            nodesVisited.add(adjNode);
          }
        }
      }
    };
    BufferSubgraph.prototype.compareTo = function compareTo(o) {
      var graph = o;
      if (this._rightMostCoord.x < graph._rightMostCoord.x) {
        return -1;
      }
      if (this._rightMostCoord.x > graph._rightMostCoord.x) {
        return 1;
      }
      return 0;
    };
    BufferSubgraph.prototype.getEnvelope = function getEnvelope() {
      if (this._env === null) {
        var edgeEnv = new Envelope();
        for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
          var dirEdge = it.next();
          var pts = dirEdge.getEdge().getCoordinates();
          for (var i = 0; i < pts.length - 1; i++) {
            edgeEnv.expandToInclude(pts[i]);
          }
        }
        this._env = edgeEnv;
      }
      return this._env;
    };
    BufferSubgraph.prototype.addReachable = function addReachable(startNode) {
      var this$1 = this;
      var nodeStack = new Stack();
      nodeStack.add(startNode);
      while (!nodeStack.empty()) {
        var node = nodeStack.pop();
        this$1.add(node, nodeStack);
      }
    };
    BufferSubgraph.prototype.copySymDepths = function copySymDepths(de) {
      var sym = de.getSym();
      sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
      sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
    };
    BufferSubgraph.prototype.add = function add(node, nodeStack) {
      var this$1 = this;
      node.setVisited(true);
      this._nodes.add(node);
      for (var i = node.getEdges().iterator(); i.hasNext(); ) {
        var de = i.next();
        this$1._dirEdgeList.add(de);
        var sym = de.getSym();
        var symNode = sym.getNode();
        if (!symNode.isVisited()) {
          nodeStack.push(symNode);
        }
      }
    };
    BufferSubgraph.prototype.getNodes = function getNodes() {
      return this._nodes;
    };
    BufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges() {
      return this._dirEdgeList;
    };
    BufferSubgraph.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    BufferSubgraph.prototype.getClass = function getClass() {
      return BufferSubgraph;
    };
    var TopologyLocation = function TopologyLocation2() {
      var this$1 = this;
      this.location = null;
      if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var location = arguments[0];
          this.init(location.length);
        } else if (Number.isInteger(arguments[0])) {
          var on = arguments[0];
          this.init(1);
          this.location[Position.ON] = on;
        } else if (arguments[0] instanceof TopologyLocation2) {
          var gl = arguments[0];
          this.init(gl.location.length);
          if (gl !== null) {
            for (var i = 0; i < this.location.length; i++) {
              this$1.location[i] = gl.location[i];
            }
          }
        }
      } else if (arguments.length === 3) {
        var on$1 = arguments[0];
        var left = arguments[1];
        var right = arguments[2];
        this.init(3);
        this.location[Position.ON] = on$1;
        this.location[Position.LEFT] = left;
        this.location[Position.RIGHT] = right;
      }
    };
    TopologyLocation.prototype.setAllLocations = function setAllLocations(locValue) {
      var this$1 = this;
      for (var i = 0; i < this.location.length; i++) {
        this$1.location[i] = locValue;
      }
    };
    TopologyLocation.prototype.isNull = function isNull() {
      var this$1 = this;
      for (var i = 0; i < this.location.length; i++) {
        if (this$1.location[i] !== Location.NONE) {
          return false;
        }
      }
      return true;
    };
    TopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull(locValue) {
      var this$1 = this;
      for (var i = 0; i < this.location.length; i++) {
        if (this$1.location[i] === Location.NONE) {
          this$1.location[i] = locValue;
        }
      }
    };
    TopologyLocation.prototype.isLine = function isLine() {
      return this.location.length === 1;
    };
    TopologyLocation.prototype.merge = function merge(gl) {
      var this$1 = this;
      if (gl.location.length > this.location.length) {
        var newLoc = new Array(3).fill(null);
        newLoc[Position.ON] = this.location[Position.ON];
        newLoc[Position.LEFT] = Location.NONE;
        newLoc[Position.RIGHT] = Location.NONE;
        this.location = newLoc;
      }
      for (var i = 0; i < this.location.length; i++) {
        if (this$1.location[i] === Location.NONE && i < gl.location.length) {
          this$1.location[i] = gl.location[i];
        }
      }
    };
    TopologyLocation.prototype.getLocations = function getLocations() {
      return this.location;
    };
    TopologyLocation.prototype.flip = function flip() {
      if (this.location.length <= 1) {
        return null;
      }
      var temp = this.location[Position.LEFT];
      this.location[Position.LEFT] = this.location[Position.RIGHT];
      this.location[Position.RIGHT] = temp;
    };
    TopologyLocation.prototype.toString = function toString() {
      var buf = new StringBuffer();
      if (this.location.length > 1) {
        buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));
      }
      buf.append(Location.toLocationSymbol(this.location[Position.ON]));
      if (this.location.length > 1) {
        buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));
      }
      return buf.toString();
    };
    TopologyLocation.prototype.setLocations = function setLocations(on, left, right) {
      this.location[Position.ON] = on;
      this.location[Position.LEFT] = left;
      this.location[Position.RIGHT] = right;
    };
    TopologyLocation.prototype.get = function get2(posIndex) {
      if (posIndex < this.location.length) {
        return this.location[posIndex];
      }
      return Location.NONE;
    };
    TopologyLocation.prototype.isArea = function isArea() {
      return this.location.length > 1;
    };
    TopologyLocation.prototype.isAnyNull = function isAnyNull() {
      var this$1 = this;
      for (var i = 0; i < this.location.length; i++) {
        if (this$1.location[i] === Location.NONE) {
          return true;
        }
      }
      return false;
    };
    TopologyLocation.prototype.setLocation = function setLocation() {
      if (arguments.length === 1) {
        var locValue = arguments[0];
        this.setLocation(Position.ON, locValue);
      } else if (arguments.length === 2) {
        var locIndex = arguments[0];
        var locValue$1 = arguments[1];
        this.location[locIndex] = locValue$1;
      }
    };
    TopologyLocation.prototype.init = function init(size) {
      this.location = new Array(size).fill(null);
      this.setAllLocations(Location.NONE);
    };
    TopologyLocation.prototype.isEqualOnSide = function isEqualOnSide(le, locIndex) {
      return this.location[locIndex] === le.location[locIndex];
    };
    TopologyLocation.prototype.allPositionsEqual = function allPositionsEqual(loc) {
      var this$1 = this;
      for (var i = 0; i < this.location.length; i++) {
        if (this$1.location[i] !== loc) {
          return false;
        }
      }
      return true;
    };
    TopologyLocation.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    TopologyLocation.prototype.getClass = function getClass() {
      return TopologyLocation;
    };
    var Label = function Label2() {
      this.elt = new Array(2).fill(null);
      if (arguments.length === 1) {
        if (Number.isInteger(arguments[0])) {
          var onLoc = arguments[0];
          this.elt[0] = new TopologyLocation(onLoc);
          this.elt[1] = new TopologyLocation(onLoc);
        } else if (arguments[0] instanceof Label2) {
          var lbl = arguments[0];
          this.elt[0] = new TopologyLocation(lbl.elt[0]);
          this.elt[1] = new TopologyLocation(lbl.elt[1]);
        }
      } else if (arguments.length === 2) {
        var geomIndex = arguments[0];
        var onLoc$1 = arguments[1];
        this.elt[0] = new TopologyLocation(Location.NONE);
        this.elt[1] = new TopologyLocation(Location.NONE);
        this.elt[geomIndex].setLocation(onLoc$1);
      } else if (arguments.length === 3) {
        var onLoc$2 = arguments[0];
        var leftLoc = arguments[1];
        var rightLoc = arguments[2];
        this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
        this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
      } else if (arguments.length === 4) {
        var geomIndex$1 = arguments[0];
        var onLoc$3 = arguments[1];
        var leftLoc$1 = arguments[2];
        var rightLoc$1 = arguments[3];
        this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
        this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
        this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);
      }
    };
    Label.prototype.getGeometryCount = function getGeometryCount() {
      var count = 0;
      if (!this.elt[0].isNull()) {
        count++;
      }
      if (!this.elt[1].isNull()) {
        count++;
      }
      return count;
    };
    Label.prototype.setAllLocations = function setAllLocations(geomIndex, location) {
      this.elt[geomIndex].setAllLocations(location);
    };
    Label.prototype.isNull = function isNull(geomIndex) {
      return this.elt[geomIndex].isNull();
    };
    Label.prototype.setAllLocationsIfNull = function setAllLocationsIfNull() {
      if (arguments.length === 1) {
        var location = arguments[0];
        this.setAllLocationsIfNull(0, location);
        this.setAllLocationsIfNull(1, location);
      } else if (arguments.length === 2) {
        var geomIndex = arguments[0];
        var location$1 = arguments[1];
        this.elt[geomIndex].setAllLocationsIfNull(location$1);
      }
    };
    Label.prototype.isLine = function isLine(geomIndex) {
      return this.elt[geomIndex].isLine();
    };
    Label.prototype.merge = function merge(lbl) {
      var this$1 = this;
      for (var i = 0; i < 2; i++) {
        if (this$1.elt[i] === null && lbl.elt[i] !== null) {
          this$1.elt[i] = new TopologyLocation(lbl.elt[i]);
        } else {
          this$1.elt[i].merge(lbl.elt[i]);
        }
      }
    };
    Label.prototype.flip = function flip() {
      this.elt[0].flip();
      this.elt[1].flip();
    };
    Label.prototype.getLocation = function getLocation() {
      if (arguments.length === 1) {
        var geomIndex = arguments[0];
        return this.elt[geomIndex].get(Position.ON);
      } else if (arguments.length === 2) {
        var geomIndex$1 = arguments[0];
        var posIndex = arguments[1];
        return this.elt[geomIndex$1].get(posIndex);
      }
    };
    Label.prototype.toString = function toString() {
      var buf = new StringBuffer();
      if (this.elt[0] !== null) {
        buf.append("A:");
        buf.append(this.elt[0].toString());
      }
      if (this.elt[1] !== null) {
        buf.append(" B:");
        buf.append(this.elt[1].toString());
      }
      return buf.toString();
    };
    Label.prototype.isArea = function isArea() {
      if (arguments.length === 0) {
        return this.elt[0].isArea() || this.elt[1].isArea();
      } else if (arguments.length === 1) {
        var geomIndex = arguments[0];
        return this.elt[geomIndex].isArea();
      }
    };
    Label.prototype.isAnyNull = function isAnyNull(geomIndex) {
      return this.elt[geomIndex].isAnyNull();
    };
    Label.prototype.setLocation = function setLocation() {
      if (arguments.length === 2) {
        var geomIndex = arguments[0];
        var location = arguments[1];
        this.elt[geomIndex].setLocation(Position.ON, location);
      } else if (arguments.length === 3) {
        var geomIndex$1 = arguments[0];
        var posIndex = arguments[1];
        var location$1 = arguments[2];
        this.elt[geomIndex$1].setLocation(posIndex, location$1);
      }
    };
    Label.prototype.isEqualOnSide = function isEqualOnSide(lbl, side) {
      return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
    };
    Label.prototype.allPositionsEqual = function allPositionsEqual(geomIndex, loc) {
      return this.elt[geomIndex].allPositionsEqual(loc);
    };
    Label.prototype.toLine = function toLine(geomIndex) {
      if (this.elt[geomIndex].isArea()) {
        this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);
      }
    };
    Label.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Label.prototype.getClass = function getClass() {
      return Label;
    };
    Label.toLineLabel = function toLineLabel(label) {
      var lineLabel = new Label(Location.NONE);
      for (var i = 0; i < 2; i++) {
        lineLabel.setLocation(i, label.getLocation(i));
      }
      return lineLabel;
    };
    var EdgeRing = function EdgeRing2() {
      this._startDe = null;
      this._maxNodeDegree = -1;
      this._edges = new ArrayList();
      this._pts = new ArrayList();
      this._label = new Label(Location.NONE);
      this._ring = null;
      this._isHole = null;
      this._shell = null;
      this._holes = new ArrayList();
      this._geometryFactory = null;
      var start = arguments[0];
      var geometryFactory = arguments[1];
      this._geometryFactory = geometryFactory;
      this.computePoints(start);
      this.computeRing();
    };
    EdgeRing.prototype.computeRing = function computeRing() {
      var this$1 = this;
      if (this._ring !== null) {
        return null;
      }
      var coord = new Array(this._pts.size()).fill(null);
      for (var i = 0; i < this._pts.size(); i++) {
        coord[i] = this$1._pts.get(i);
      }
      this._ring = this._geometryFactory.createLinearRing(coord);
      this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());
    };
    EdgeRing.prototype.isIsolated = function isIsolated() {
      return this._label.getGeometryCount() === 1;
    };
    EdgeRing.prototype.computePoints = function computePoints(start) {
      var this$1 = this;
      this._startDe = start;
      var de = start;
      var isFirstEdge = true;
      do {
        if (de === null) {
          throw new TopologyException("Found null DirectedEdge");
        }
        if (de.getEdgeRing() === this$1) {
          throw new TopologyException("Directed Edge visited twice during ring-building at " + de.getCoordinate());
        }
        this$1._edges.add(de);
        var label = de.getLabel();
        Assert.isTrue(label.isArea());
        this$1.mergeLabel(label);
        this$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
        isFirstEdge = false;
        this$1.setEdgeRing(de, this$1);
        de = this$1.getNext(de);
      } while (de !== this._startDe);
    };
    EdgeRing.prototype.getLinearRing = function getLinearRing() {
      return this._ring;
    };
    EdgeRing.prototype.getCoordinate = function getCoordinate(i) {
      return this._pts.get(i);
    };
    EdgeRing.prototype.computeMaxNodeDegree = function computeMaxNodeDegree() {
      var this$1 = this;
      this._maxNodeDegree = 0;
      var de = this._startDe;
      do {
        var node = de.getNode();
        var degree = node.getEdges().getOutgoingDegree(this$1);
        if (degree > this$1._maxNodeDegree) {
          this$1._maxNodeDegree = degree;
        }
        de = this$1.getNext(de);
      } while (de !== this._startDe);
      this._maxNodeDegree *= 2;
    };
    EdgeRing.prototype.addPoints = function addPoints(edge, isForward, isFirstEdge) {
      var this$1 = this;
      var edgePts = edge.getCoordinates();
      if (isForward) {
        var startIndex = 1;
        if (isFirstEdge) {
          startIndex = 0;
        }
        for (var i = startIndex; i < edgePts.length; i++) {
          this$1._pts.add(edgePts[i]);
        }
      } else {
        var startIndex$1 = edgePts.length - 2;
        if (isFirstEdge) {
          startIndex$1 = edgePts.length - 1;
        }
        for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {
          this$1._pts.add(edgePts[i$1]);
        }
      }
    };
    EdgeRing.prototype.isHole = function isHole() {
      return this._isHole;
    };
    EdgeRing.prototype.setInResult = function setInResult() {
      var de = this._startDe;
      do {
        de.getEdge().setInResult(true);
        de = de.getNext();
      } while (de !== this._startDe);
    };
    EdgeRing.prototype.containsPoint = function containsPoint(p) {
      var shell = this.getLinearRing();
      var env = shell.getEnvelopeInternal();
      if (!env.contains(p)) {
        return false;
      }
      if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) {
        return false;
      }
      for (var i = this._holes.iterator(); i.hasNext(); ) {
        var hole = i.next();
        if (hole.containsPoint(p)) {
          return false;
        }
      }
      return true;
    };
    EdgeRing.prototype.addHole = function addHole(ring) {
      this._holes.add(ring);
    };
    EdgeRing.prototype.isShell = function isShell() {
      return this._shell === null;
    };
    EdgeRing.prototype.getLabel = function getLabel() {
      return this._label;
    };
    EdgeRing.prototype.getEdges = function getEdges() {
      return this._edges;
    };
    EdgeRing.prototype.getMaxNodeDegree = function getMaxNodeDegree() {
      if (this._maxNodeDegree < 0) {
        this.computeMaxNodeDegree();
      }
      return this._maxNodeDegree;
    };
    EdgeRing.prototype.getShell = function getShell() {
      return this._shell;
    };
    EdgeRing.prototype.mergeLabel = function mergeLabel() {
      if (arguments.length === 1) {
        var deLabel = arguments[0];
        this.mergeLabel(deLabel, 0);
        this.mergeLabel(deLabel, 1);
      } else if (arguments.length === 2) {
        var deLabel$1 = arguments[0];
        var geomIndex = arguments[1];
        var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);
        if (loc === Location.NONE) {
          return null;
        }
        if (this._label.getLocation(geomIndex) === Location.NONE) {
          this._label.setLocation(geomIndex, loc);
          return null;
        }
      }
    };
    EdgeRing.prototype.setShell = function setShell(shell) {
      this._shell = shell;
      if (shell !== null) {
        shell.addHole(this);
      }
    };
    EdgeRing.prototype.toPolygon = function toPolygon(geometryFactory) {
      var this$1 = this;
      var holeLR = new Array(this._holes.size()).fill(null);
      for (var i = 0; i < this._holes.size(); i++) {
        holeLR[i] = this$1._holes.get(i).getLinearRing();
      }
      var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
      return poly;
    };
    EdgeRing.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    EdgeRing.prototype.getClass = function getClass() {
      return EdgeRing;
    };
    var MinimalEdgeRing = function(EdgeRing$$1) {
      function MinimalEdgeRing2() {
        var start = arguments[0];
        var geometryFactory = arguments[1];
        EdgeRing$$1.call(this, start, geometryFactory);
      }
      if (EdgeRing$$1) MinimalEdgeRing2.__proto__ = EdgeRing$$1;
      MinimalEdgeRing2.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
      MinimalEdgeRing2.prototype.constructor = MinimalEdgeRing2;
      MinimalEdgeRing2.prototype.setEdgeRing = function setEdgeRing(de, er) {
        de.setMinEdgeRing(er);
      };
      MinimalEdgeRing2.prototype.getNext = function getNext(de) {
        return de.getNextMin();
      };
      MinimalEdgeRing2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      MinimalEdgeRing2.prototype.getClass = function getClass() {
        return MinimalEdgeRing2;
      };
      return MinimalEdgeRing2;
    }(EdgeRing);
    var MaximalEdgeRing = function(EdgeRing$$1) {
      function MaximalEdgeRing2() {
        var start = arguments[0];
        var geometryFactory = arguments[1];
        EdgeRing$$1.call(this, start, geometryFactory);
      }
      if (EdgeRing$$1) MaximalEdgeRing2.__proto__ = EdgeRing$$1;
      MaximalEdgeRing2.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
      MaximalEdgeRing2.prototype.constructor = MaximalEdgeRing2;
      MaximalEdgeRing2.prototype.buildMinimalRings = function buildMinimalRings() {
        var this$1 = this;
        var minEdgeRings = new ArrayList();
        var de = this._startDe;
        do {
          if (de.getMinEdgeRing() === null) {
            var minEr = new MinimalEdgeRing(de, this$1._geometryFactory);
            minEdgeRings.add(minEr);
          }
          de = de.getNext();
        } while (de !== this._startDe);
        return minEdgeRings;
      };
      MaximalEdgeRing2.prototype.setEdgeRing = function setEdgeRing(de, er) {
        de.setEdgeRing(er);
      };
      MaximalEdgeRing2.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings() {
        var this$1 = this;
        var de = this._startDe;
        do {
          var node = de.getNode();
          node.getEdges().linkMinimalDirectedEdges(this$1);
          de = de.getNext();
        } while (de !== this._startDe);
      };
      MaximalEdgeRing2.prototype.getNext = function getNext(de) {
        return de.getNext();
      };
      MaximalEdgeRing2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      MaximalEdgeRing2.prototype.getClass = function getClass() {
        return MaximalEdgeRing2;
      };
      return MaximalEdgeRing2;
    }(EdgeRing);
    var GraphComponent = function GraphComponent2() {
      this._label = null;
      this._isInResult = false;
      this._isCovered = false;
      this._isCoveredSet = false;
      this._isVisited = false;
      if (arguments.length === 0) {
      } else if (arguments.length === 1) {
        var label = arguments[0];
        this._label = label;
      }
    };
    GraphComponent.prototype.setVisited = function setVisited(isVisited) {
      this._isVisited = isVisited;
    };
    GraphComponent.prototype.setInResult = function setInResult(isInResult) {
      this._isInResult = isInResult;
    };
    GraphComponent.prototype.isCovered = function isCovered() {
      return this._isCovered;
    };
    GraphComponent.prototype.isCoveredSet = function isCoveredSet() {
      return this._isCoveredSet;
    };
    GraphComponent.prototype.setLabel = function setLabel(label) {
      this._label = label;
    };
    GraphComponent.prototype.getLabel = function getLabel() {
      return this._label;
    };
    GraphComponent.prototype.setCovered = function setCovered(isCovered) {
      this._isCovered = isCovered;
      this._isCoveredSet = true;
    };
    GraphComponent.prototype.updateIM = function updateIM(im) {
      Assert.isTrue(this._label.getGeometryCount() >= 2, "found partial label");
      this.computeIM(im);
    };
    GraphComponent.prototype.isInResult = function isInResult() {
      return this._isInResult;
    };
    GraphComponent.prototype.isVisited = function isVisited() {
      return this._isVisited;
    };
    GraphComponent.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GraphComponent.prototype.getClass = function getClass() {
      return GraphComponent;
    };
    var Node = function(GraphComponent$$1) {
      function Node2() {
        GraphComponent$$1.call(this);
        this._coord = null;
        this._edges = null;
        var coord = arguments[0];
        var edges = arguments[1];
        this._coord = coord;
        this._edges = edges;
        this._label = new Label(0, Location.NONE);
      }
      if (GraphComponent$$1) Node2.__proto__ = GraphComponent$$1;
      Node2.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
      Node2.prototype.constructor = Node2;
      Node2.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult() {
        for (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {
          var de = it.next();
          if (de.getEdge().isInResult()) {
            return true;
          }
        }
        return false;
      };
      Node2.prototype.isIsolated = function isIsolated() {
        return this._label.getGeometryCount() === 1;
      };
      Node2.prototype.getCoordinate = function getCoordinate() {
        return this._coord;
      };
      Node2.prototype.print = function print(out) {
        out.println("node " + this._coord + " lbl: " + this._label);
      };
      Node2.prototype.computeIM = function computeIM(im) {
      };
      Node2.prototype.computeMergedLocation = function computeMergedLocation(label2, eltIndex) {
        var loc = Location.NONE;
        loc = this._label.getLocation(eltIndex);
        if (!label2.isNull(eltIndex)) {
          var nLoc = label2.getLocation(eltIndex);
          if (loc !== Location.BOUNDARY) {
            loc = nLoc;
          }
        }
        return loc;
      };
      Node2.prototype.setLabel = function setLabel() {
        if (arguments.length === 2) {
          var argIndex = arguments[0];
          var onLocation = arguments[1];
          if (this._label === null) {
            this._label = new Label(argIndex, onLocation);
          } else {
            this._label.setLocation(argIndex, onLocation);
          }
        } else {
          return GraphComponent$$1.prototype.setLabel.apply(this, arguments);
        }
      };
      Node2.prototype.getEdges = function getEdges() {
        return this._edges;
      };
      Node2.prototype.mergeLabel = function mergeLabel() {
        var this$1 = this;
        if (arguments[0] instanceof Node2) {
          var n = arguments[0];
          this.mergeLabel(n._label);
        } else if (arguments[0] instanceof Label) {
          var label2 = arguments[0];
          for (var i = 0; i < 2; i++) {
            var loc = this$1.computeMergedLocation(label2, i);
            var thisLoc = this$1._label.getLocation(i);
            if (thisLoc === Location.NONE) {
              this$1._label.setLocation(i, loc);
            }
          }
        }
      };
      Node2.prototype.add = function add(e) {
        this._edges.insert(e);
        e.setNode(this);
      };
      Node2.prototype.setLabelBoundary = function setLabelBoundary(argIndex) {
        if (this._label === null) {
          return null;
        }
        var loc = Location.NONE;
        if (this._label !== null) {
          loc = this._label.getLocation(argIndex);
        }
        var newLoc = null;
        switch (loc) {
          case Location.BOUNDARY:
            newLoc = Location.INTERIOR;
            break;
          case Location.INTERIOR:
            newLoc = Location.BOUNDARY;
            break;
          default:
            newLoc = Location.BOUNDARY;
            break;
        }
        this._label.setLocation(argIndex, newLoc);
      };
      Node2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      Node2.prototype.getClass = function getClass() {
        return Node2;
      };
      return Node2;
    }(GraphComponent);
    var NodeMap = function NodeMap2() {
      this.nodeMap = new TreeMap();
      this.nodeFact = null;
      var nodeFact = arguments[0];
      this.nodeFact = nodeFact;
    };
    NodeMap.prototype.find = function find(coord) {
      return this.nodeMap.get(coord);
    };
    NodeMap.prototype.addNode = function addNode() {
      if (arguments[0] instanceof Coordinate) {
        var coord = arguments[0];
        var node = this.nodeMap.get(coord);
        if (node === null) {
          node = this.nodeFact.createNode(coord);
          this.nodeMap.put(coord, node);
        }
        return node;
      } else if (arguments[0] instanceof Node) {
        var n = arguments[0];
        var node$1 = this.nodeMap.get(n.getCoordinate());
        if (node$1 === null) {
          this.nodeMap.put(n.getCoordinate(), n);
          return n;
        }
        node$1.mergeLabel(n);
        return node$1;
      }
    };
    NodeMap.prototype.print = function print(out) {
      for (var it = this.iterator(); it.hasNext(); ) {
        var n = it.next();
        n.print(out);
      }
    };
    NodeMap.prototype.iterator = function iterator() {
      return this.nodeMap.values().iterator();
    };
    NodeMap.prototype.values = function values() {
      return this.nodeMap.values();
    };
    NodeMap.prototype.getBoundaryNodes = function getBoundaryNodes(geomIndex) {
      var bdyNodes = new ArrayList();
      for (var i = this.iterator(); i.hasNext(); ) {
        var node = i.next();
        if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) {
          bdyNodes.add(node);
        }
      }
      return bdyNodes;
    };
    NodeMap.prototype.add = function add(e) {
      var p = e.getCoordinate();
      var n = this.addNode(p);
      n.add(e);
    };
    NodeMap.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    NodeMap.prototype.getClass = function getClass() {
      return NodeMap;
    };
    var Quadrant = function Quadrant2() {
    };
    var staticAccessors$21 = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
    Quadrant.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Quadrant.prototype.getClass = function getClass() {
      return Quadrant;
    };
    Quadrant.isNorthern = function isNorthern(quad) {
      return quad === Quadrant.NE || quad === Quadrant.NW;
    };
    Quadrant.isOpposite = function isOpposite(quad1, quad2) {
      if (quad1 === quad2) {
        return false;
      }
      var diff = (quad1 - quad2 + 4) % 4;
      if (diff === 2) {
        return true;
      }
      return false;
    };
    Quadrant.commonHalfPlane = function commonHalfPlane(quad1, quad2) {
      if (quad1 === quad2) {
        return quad1;
      }
      var diff = (quad1 - quad2 + 4) % 4;
      if (diff === 2) {
        return -1;
      }
      var min = quad1 < quad2 ? quad1 : quad2;
      var max = quad1 > quad2 ? quad1 : quad2;
      if (min === 0 && max === 3) {
        return 3;
      }
      return min;
    };
    Quadrant.isInHalfPlane = function isInHalfPlane(quad, halfPlane) {
      if (halfPlane === Quadrant.SE) {
        return quad === Quadrant.SE || quad === Quadrant.SW;
      }
      return quad === halfPlane || quad === halfPlane + 1;
    };
    Quadrant.quadrant = function quadrant() {
      if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
        var dx = arguments[0];
        var dy = arguments[1];
        if (dx === 0 && dy === 0) {
          throw new IllegalArgumentException("Cannot compute the quadrant for point ( " + dx + ", " + dy + " )");
        }
        if (dx >= 0) {
          if (dy >= 0) {
            return Quadrant.NE;
          } else {
            return Quadrant.SE;
          }
        } else {
          if (dy >= 0) {
            return Quadrant.NW;
          } else {
            return Quadrant.SW;
          }
        }
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (p1.x === p0.x && p1.y === p0.y) {
          throw new IllegalArgumentException("Cannot compute the quadrant for two identical points " + p0);
        }
        if (p1.x >= p0.x) {
          if (p1.y >= p0.y) {
            return Quadrant.NE;
          } else {
            return Quadrant.SE;
          }
        } else {
          if (p1.y >= p0.y) {
            return Quadrant.NW;
          } else {
            return Quadrant.SW;
          }
        }
      }
    };
    staticAccessors$21.NE.get = function() {
      return 0;
    };
    staticAccessors$21.NW.get = function() {
      return 1;
    };
    staticAccessors$21.SW.get = function() {
      return 2;
    };
    staticAccessors$21.SE.get = function() {
      return 3;
    };
    Object.defineProperties(Quadrant, staticAccessors$21);
    var EdgeEnd = function EdgeEnd2() {
      this._edge = null;
      this._label = null;
      this._node = null;
      this._p0 = null;
      this._p1 = null;
      this._dx = null;
      this._dy = null;
      this._quadrant = null;
      if (arguments.length === 1) {
        var edge = arguments[0];
        this._edge = edge;
      } else if (arguments.length === 3) {
        var edge$1 = arguments[0];
        var p0 = arguments[1];
        var p1 = arguments[2];
        var label = null;
        this._edge = edge$1;
        this.init(p0, p1);
        this._label = label;
      } else if (arguments.length === 4) {
        var edge$2 = arguments[0];
        var p0$1 = arguments[1];
        var p1$1 = arguments[2];
        var label$1 = arguments[3];
        this._edge = edge$2;
        this.init(p0$1, p1$1);
        this._label = label$1;
      }
    };
    EdgeEnd.prototype.compareDirection = function compareDirection(e) {
      if (this._dx === e._dx && this._dy === e._dy) {
        return 0;
      }
      if (this._quadrant > e._quadrant) {
        return 1;
      }
      if (this._quadrant < e._quadrant) {
        return -1;
      }
      return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);
    };
    EdgeEnd.prototype.getDy = function getDy() {
      return this._dy;
    };
    EdgeEnd.prototype.getCoordinate = function getCoordinate() {
      return this._p0;
    };
    EdgeEnd.prototype.setNode = function setNode(node) {
      this._node = node;
    };
    EdgeEnd.prototype.print = function print(out) {
      var angle = Math.atan2(this._dy, this._dx);
      var className = this.getClass().getName();
      var lastDotPos = className.lastIndexOf(".");
      var name = className.substring(lastDotPos + 1);
      out.print("  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle + "   " + this._label);
    };
    EdgeEnd.prototype.compareTo = function compareTo(obj) {
      var e = obj;
      return this.compareDirection(e);
    };
    EdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate() {
      return this._p1;
    };
    EdgeEnd.prototype.getDx = function getDx() {
      return this._dx;
    };
    EdgeEnd.prototype.getLabel = function getLabel() {
      return this._label;
    };
    EdgeEnd.prototype.getEdge = function getEdge() {
      return this._edge;
    };
    EdgeEnd.prototype.getQuadrant = function getQuadrant() {
      return this._quadrant;
    };
    EdgeEnd.prototype.getNode = function getNode() {
      return this._node;
    };
    EdgeEnd.prototype.toString = function toString() {
      var angle = Math.atan2(this._dy, this._dx);
      var className = this.getClass().getName();
      var lastDotPos = className.lastIndexOf(".");
      var name = className.substring(lastDotPos + 1);
      return "  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle + "   " + this._label;
    };
    EdgeEnd.prototype.computeLabel = function computeLabel(boundaryNodeRule) {
    };
    EdgeEnd.prototype.init = function init(p0, p1) {
      this._p0 = p0;
      this._p1 = p1;
      this._dx = p1.x - p0.x;
      this._dy = p1.y - p0.y;
      this._quadrant = Quadrant.quadrant(this._dx, this._dy);
      Assert.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
    };
    EdgeEnd.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    EdgeEnd.prototype.getClass = function getClass() {
      return EdgeEnd;
    };
    var DirectedEdge = function(EdgeEnd$$1) {
      function DirectedEdge2() {
        var edge = arguments[0];
        var isForward = arguments[1];
        EdgeEnd$$1.call(this, edge);
        this._isForward = null;
        this._isInResult = false;
        this._isVisited = false;
        this._sym = null;
        this._next = null;
        this._nextMin = null;
        this._edgeRing = null;
        this._minEdgeRing = null;
        this._depth = [0, -999, -999];
        this._isForward = isForward;
        if (isForward) {
          this.init(edge.getCoordinate(0), edge.getCoordinate(1));
        } else {
          var n = edge.getNumPoints() - 1;
          this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
        }
        this.computeDirectedLabel();
      }
      if (EdgeEnd$$1) DirectedEdge2.__proto__ = EdgeEnd$$1;
      DirectedEdge2.prototype = Object.create(EdgeEnd$$1 && EdgeEnd$$1.prototype);
      DirectedEdge2.prototype.constructor = DirectedEdge2;
      DirectedEdge2.prototype.getNextMin = function getNextMin() {
        return this._nextMin;
      };
      DirectedEdge2.prototype.getDepth = function getDepth(position) {
        return this._depth[position];
      };
      DirectedEdge2.prototype.setVisited = function setVisited(isVisited) {
        this._isVisited = isVisited;
      };
      DirectedEdge2.prototype.computeDirectedLabel = function computeDirectedLabel() {
        this._label = new Label(this._edge.getLabel());
        if (!this._isForward) {
          this._label.flip();
        }
      };
      DirectedEdge2.prototype.getNext = function getNext() {
        return this._next;
      };
      DirectedEdge2.prototype.setDepth = function setDepth(position, depthVal) {
        if (this._depth[position] !== -999) {
          if (this._depth[position] !== depthVal) {
            throw new TopologyException("assigned depths do not match", this.getCoordinate());
          }
        }
        this._depth[position] = depthVal;
      };
      DirectedEdge2.prototype.isInteriorAreaEdge = function isInteriorAreaEdge() {
        var this$1 = this;
        var isInteriorAreaEdge2 = true;
        for (var i = 0; i < 2; i++) {
          if (!(this$1._label.isArea(i) && this$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
            isInteriorAreaEdge2 = false;
          }
        }
        return isInteriorAreaEdge2;
      };
      DirectedEdge2.prototype.setNextMin = function setNextMin(nextMin) {
        this._nextMin = nextMin;
      };
      DirectedEdge2.prototype.print = function print(out) {
        EdgeEnd$$1.prototype.print.call(this, out);
        out.print(" " + this._depth[Position.LEFT] + "/" + this._depth[Position.RIGHT]);
        out.print(" (" + this.getDepthDelta() + ")");
        if (this._isInResult) {
          out.print(" inResult");
        }
      };
      DirectedEdge2.prototype.setMinEdgeRing = function setMinEdgeRing(minEdgeRing) {
        this._minEdgeRing = minEdgeRing;
      };
      DirectedEdge2.prototype.isLineEdge = function isLineEdge() {
        var isLine = this._label.isLine(0) || this._label.isLine(1);
        var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
        var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
        return isLine && isExteriorIfArea0 && isExteriorIfArea1;
      };
      DirectedEdge2.prototype.setEdgeRing = function setEdgeRing(edgeRing) {
        this._edgeRing = edgeRing;
      };
      DirectedEdge2.prototype.getMinEdgeRing = function getMinEdgeRing() {
        return this._minEdgeRing;
      };
      DirectedEdge2.prototype.getDepthDelta = function getDepthDelta() {
        var depthDelta = this._edge.getDepthDelta();
        if (!this._isForward) {
          depthDelta = -depthDelta;
        }
        return depthDelta;
      };
      DirectedEdge2.prototype.setInResult = function setInResult(isInResult) {
        this._isInResult = isInResult;
      };
      DirectedEdge2.prototype.getSym = function getSym() {
        return this._sym;
      };
      DirectedEdge2.prototype.isForward = function isForward() {
        return this._isForward;
      };
      DirectedEdge2.prototype.getEdge = function getEdge() {
        return this._edge;
      };
      DirectedEdge2.prototype.printEdge = function printEdge(out) {
        this.print(out);
        out.print(" ");
        if (this._isForward) {
          this._edge.print(out);
        } else {
          this._edge.printReverse(out);
        }
      };
      DirectedEdge2.prototype.setSym = function setSym(de) {
        this._sym = de;
      };
      DirectedEdge2.prototype.setVisitedEdge = function setVisitedEdge(isVisited) {
        this.setVisited(isVisited);
        this._sym.setVisited(isVisited);
      };
      DirectedEdge2.prototype.setEdgeDepths = function setEdgeDepths(position, depth) {
        var depthDelta = this.getEdge().getDepthDelta();
        if (!this._isForward) {
          depthDelta = -depthDelta;
        }
        var directionFactor = 1;
        if (position === Position.LEFT) {
          directionFactor = -1;
        }
        var oppositePos = Position.opposite(position);
        var delta = depthDelta * directionFactor;
        var oppositeDepth = depth + delta;
        this.setDepth(position, depth);
        this.setDepth(oppositePos, oppositeDepth);
      };
      DirectedEdge2.prototype.getEdgeRing = function getEdgeRing() {
        return this._edgeRing;
      };
      DirectedEdge2.prototype.isInResult = function isInResult() {
        return this._isInResult;
      };
      DirectedEdge2.prototype.setNext = function setNext(next) {
        this._next = next;
      };
      DirectedEdge2.prototype.isVisited = function isVisited() {
        return this._isVisited;
      };
      DirectedEdge2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      DirectedEdge2.prototype.getClass = function getClass() {
        return DirectedEdge2;
      };
      DirectedEdge2.depthFactor = function depthFactor(currLocation, nextLocation) {
        if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) {
          return 1;
        } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) {
          return -1;
        }
        return 0;
      };
      return DirectedEdge2;
    }(EdgeEnd);
    var NodeFactory = function NodeFactory2() {
    };
    NodeFactory.prototype.createNode = function createNode(coord) {
      return new Node(coord, null);
    };
    NodeFactory.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    NodeFactory.prototype.getClass = function getClass() {
      return NodeFactory;
    };
    var PlanarGraph = function PlanarGraph2() {
      this._edges = new ArrayList();
      this._nodes = null;
      this._edgeEndList = new ArrayList();
      if (arguments.length === 0) {
        this._nodes = new NodeMap(new NodeFactory());
      } else if (arguments.length === 1) {
        var nodeFact = arguments[0];
        this._nodes = new NodeMap(nodeFact);
      }
    };
    PlanarGraph.prototype.printEdges = function printEdges(out) {
      var this$1 = this;
      out.println("Edges:");
      for (var i = 0; i < this._edges.size(); i++) {
        out.println("edge " + i + ":");
        var e = this$1._edges.get(i);
        e.print(out);
        e.eiList.print(out);
      }
    };
    PlanarGraph.prototype.find = function find(coord) {
      return this._nodes.find(coord);
    };
    PlanarGraph.prototype.addNode = function addNode() {
      if (arguments[0] instanceof Node) {
        var node = arguments[0];
        return this._nodes.addNode(node);
      } else if (arguments[0] instanceof Coordinate) {
        var coord = arguments[0];
        return this._nodes.addNode(coord);
      }
    };
    PlanarGraph.prototype.getNodeIterator = function getNodeIterator() {
      return this._nodes.iterator();
    };
    PlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {
      for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
        var node = nodeit.next();
        node.getEdges().linkResultDirectedEdges();
      }
    };
    PlanarGraph.prototype.debugPrintln = function debugPrintln(o) {
      System.out.println(o);
    };
    PlanarGraph.prototype.isBoundaryNode = function isBoundaryNode(geomIndex, coord) {
      var node = this._nodes.find(coord);
      if (node === null) {
        return false;
      }
      var label = node.getLabel();
      if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) {
        return true;
      }
      return false;
    };
    PlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {
      for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
        var node = nodeit.next();
        node.getEdges().linkAllDirectedEdges();
      }
    };
    PlanarGraph.prototype.matchInSameDirection = function matchInSameDirection(p0, p1, ep0, ep1) {
      if (!p0.equals(ep0)) {
        return false;
      }
      if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) {
        return true;
      }
      return false;
    };
    PlanarGraph.prototype.getEdgeEnds = function getEdgeEnds() {
      return this._edgeEndList;
    };
    PlanarGraph.prototype.debugPrint = function debugPrint(o) {
      System.out.print(o);
    };
    PlanarGraph.prototype.getEdgeIterator = function getEdgeIterator() {
      return this._edges.iterator();
    };
    PlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection(p0, p1) {
      var this$1 = this;
      for (var i = 0; i < this._edges.size(); i++) {
        var e = this$1._edges.get(i);
        var eCoord = e.getCoordinates();
        if (this$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) {
          return e;
        }
        if (this$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) {
          return e;
        }
      }
      return null;
    };
    PlanarGraph.prototype.insertEdge = function insertEdge(e) {
      this._edges.add(e);
    };
    PlanarGraph.prototype.findEdgeEnd = function findEdgeEnd(e) {
      for (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {
        var ee = i.next();
        if (ee.getEdge() === e) {
          return ee;
        }
      }
      return null;
    };
    PlanarGraph.prototype.addEdges = function addEdges(edgesToAdd) {
      var this$1 = this;
      for (var it = edgesToAdd.iterator(); it.hasNext(); ) {
        var e = it.next();
        this$1._edges.add(e);
        var de1 = new DirectedEdge(e, true);
        var de2 = new DirectedEdge(e, false);
        de1.setSym(de2);
        de2.setSym(de1);
        this$1.add(de1);
        this$1.add(de2);
      }
    };
    PlanarGraph.prototype.add = function add(e) {
      this._nodes.add(e);
      this._edgeEndList.add(e);
    };
    PlanarGraph.prototype.getNodes = function getNodes() {
      return this._nodes.values();
    };
    PlanarGraph.prototype.findEdge = function findEdge(p0, p1) {
      var this$1 = this;
      for (var i = 0; i < this._edges.size(); i++) {
        var e = this$1._edges.get(i);
        var eCoord = e.getCoordinates();
        if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) {
          return e;
        }
      }
      return null;
    };
    PlanarGraph.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PlanarGraph.prototype.getClass = function getClass() {
      return PlanarGraph;
    };
    PlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges(nodes) {
      for (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {
        var node = nodeit.next();
        node.getEdges().linkResultDirectedEdges();
      }
    };
    var PolygonBuilder = function PolygonBuilder2() {
      this._geometryFactory = null;
      this._shellList = new ArrayList();
      var geometryFactory = arguments[0];
      this._geometryFactory = geometryFactory;
    };
    PolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
      for (var it = edgeRings.iterator(); it.hasNext(); ) {
        var er = it.next();
        if (er.isHole()) {
          freeHoleList.add(er);
        } else {
          shellList.add(er);
        }
      }
    };
    PolygonBuilder.prototype.computePolygons = function computePolygons(shellList) {
      var this$1 = this;
      var resultPolyList = new ArrayList();
      for (var it = shellList.iterator(); it.hasNext(); ) {
        var er = it.next();
        var poly = er.toPolygon(this$1._geometryFactory);
        resultPolyList.add(poly);
      }
      return resultPolyList;
    };
    PolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles(shellList, freeHoleList) {
      var this$1 = this;
      for (var it = freeHoleList.iterator(); it.hasNext(); ) {
        var hole = it.next();
        if (hole.getShell() === null) {
          var shell = this$1.findEdgeRingContaining(hole, shellList);
          if (shell === null) {
            throw new TopologyException("unable to assign hole to a shell", hole.getCoordinate(0));
          }
          hole.setShell(shell);
        }
      }
    };
    PolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
      var this$1 = this;
      var edgeRings = new ArrayList();
      for (var it = maxEdgeRings.iterator(); it.hasNext(); ) {
        var er = it.next();
        if (er.getMaxNodeDegree() > 2) {
          er.linkDirectedEdgesForMinimalEdgeRings();
          var minEdgeRings = er.buildMinimalRings();
          var shell = this$1.findShell(minEdgeRings);
          if (shell !== null) {
            this$1.placePolygonHoles(shell, minEdgeRings);
            shellList.add(shell);
          } else {
            freeHoleList.addAll(minEdgeRings);
          }
        } else {
          edgeRings.add(er);
        }
      }
      return edgeRings;
    };
    PolygonBuilder.prototype.containsPoint = function containsPoint(p) {
      for (var it = this._shellList.iterator(); it.hasNext(); ) {
        var er = it.next();
        if (er.containsPoint(p)) {
          return true;
        }
      }
      return false;
    };
    PolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings(dirEdges) {
      var this$1 = this;
      var maxEdgeRings = new ArrayList();
      for (var it = dirEdges.iterator(); it.hasNext(); ) {
        var de = it.next();
        if (de.isInResult() && de.getLabel().isArea()) {
          if (de.getEdgeRing() === null) {
            var er = new MaximalEdgeRing(de, this$1._geometryFactory);
            maxEdgeRings.add(er);
            er.setInResult();
          }
        }
      }
      return maxEdgeRings;
    };
    PolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles(shell, minEdgeRings) {
      for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
        var er = it.next();
        if (er.isHole()) {
          er.setShell(shell);
        }
      }
    };
    PolygonBuilder.prototype.getPolygons = function getPolygons() {
      var resultPolyList = this.computePolygons(this._shellList);
      return resultPolyList;
    };
    PolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining(testEr, shellList) {
      var testRing = testEr.getLinearRing();
      var testEnv = testRing.getEnvelopeInternal();
      var testPt = testRing.getCoordinateN(0);
      var minShell = null;
      var minEnv = null;
      for (var it = shellList.iterator(); it.hasNext(); ) {
        var tryShell = it.next();
        var tryRing = tryShell.getLinearRing();
        var tryEnv = tryRing.getEnvelopeInternal();
        if (minShell !== null) {
          minEnv = minShell.getLinearRing().getEnvelopeInternal();
        }
        var isContained = false;
        if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) {
          isContained = true;
        }
        if (isContained) {
          if (minShell === null || minEnv.contains(tryEnv)) {
            minShell = tryShell;
          }
        }
      }
      return minShell;
    };
    PolygonBuilder.prototype.findShell = function findShell(minEdgeRings) {
      var shellCount = 0;
      var shell = null;
      for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
        var er = it.next();
        if (!er.isHole()) {
          shell = er;
          shellCount++;
        }
      }
      Assert.isTrue(shellCount <= 1, "found two shells in MinimalEdgeRing list");
      return shell;
    };
    PolygonBuilder.prototype.add = function add() {
      if (arguments.length === 1) {
        var graph = arguments[0];
        this.add(graph.getEdgeEnds(), graph.getNodes());
      } else if (arguments.length === 2) {
        var dirEdges = arguments[0];
        var nodes = arguments[1];
        PlanarGraph.linkResultDirectedEdges(nodes);
        var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
        var freeHoleList = new ArrayList();
        var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
        this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
        this.placeFreeHoles(this._shellList, freeHoleList);
      }
    };
    PolygonBuilder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PolygonBuilder.prototype.getClass = function getClass() {
      return PolygonBuilder;
    };
    var Boundable = function Boundable2() {
    };
    Boundable.prototype.getBounds = function getBounds() {
    };
    Boundable.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Boundable.prototype.getClass = function getClass() {
      return Boundable;
    };
    var ItemBoundable = function ItemBoundable2() {
      this._bounds = null;
      this._item = null;
      var bounds = arguments[0];
      var item = arguments[1];
      this._bounds = bounds;
      this._item = item;
    };
    ItemBoundable.prototype.getItem = function getItem() {
      return this._item;
    };
    ItemBoundable.prototype.getBounds = function getBounds() {
      return this._bounds;
    };
    ItemBoundable.prototype.interfaces_ = function interfaces_() {
      return [Boundable, Serializable];
    };
    ItemBoundable.prototype.getClass = function getClass() {
      return ItemBoundable;
    };
    var PriorityQueue = function PriorityQueue2() {
      this._size = null;
      this._items = null;
      this._size = 0;
      this._items = new ArrayList();
      this._items.add(null);
    };
    PriorityQueue.prototype.poll = function poll() {
      if (this.isEmpty()) {
        return null;
      }
      var minItem = this._items.get(1);
      this._items.set(1, this._items.get(this._size));
      this._size -= 1;
      this.reorder(1);
      return minItem;
    };
    PriorityQueue.prototype.size = function size() {
      return this._size;
    };
    PriorityQueue.prototype.reorder = function reorder(hole) {
      var this$1 = this;
      var child = null;
      var tmp = this._items.get(hole);
      for (; hole * 2 <= this._size; hole = child) {
        child = hole * 2;
        if (child !== this$1._size && this$1._items.get(child + 1).compareTo(this$1._items.get(child)) < 0) {
          child++;
        }
        if (this$1._items.get(child).compareTo(tmp) < 0) {
          this$1._items.set(hole, this$1._items.get(child));
        } else {
          break;
        }
      }
      this._items.set(hole, tmp);
    };
    PriorityQueue.prototype.clear = function clear() {
      this._size = 0;
      this._items.clear();
    };
    PriorityQueue.prototype.isEmpty = function isEmpty() {
      return this._size === 0;
    };
    PriorityQueue.prototype.add = function add(x) {
      var this$1 = this;
      this._items.add(null);
      this._size += 1;
      var hole = this._size;
      this._items.set(0, x);
      for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
        this$1._items.set(hole, this$1._items.get(Math.trunc(hole / 2)));
      }
      this._items.set(hole, x);
    };
    PriorityQueue.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PriorityQueue.prototype.getClass = function getClass() {
      return PriorityQueue;
    };
    var ItemVisitor = function ItemVisitor2() {
    };
    ItemVisitor.prototype.visitItem = function visitItem(item) {
    };
    ItemVisitor.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    ItemVisitor.prototype.getClass = function getClass() {
      return ItemVisitor;
    };
    var SpatialIndex = function SpatialIndex2() {
    };
    SpatialIndex.prototype.insert = function insert(itemEnv, item) {
    };
    SpatialIndex.prototype.remove = function remove(itemEnv, item) {
    };
    SpatialIndex.prototype.query = function query() {
    };
    SpatialIndex.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SpatialIndex.prototype.getClass = function getClass() {
      return SpatialIndex;
    };
    var AbstractNode = function AbstractNode2() {
      this._childBoundables = new ArrayList();
      this._bounds = null;
      this._level = null;
      if (arguments.length === 0) {
      } else if (arguments.length === 1) {
        var level = arguments[0];
        this._level = level;
      }
    };
    var staticAccessors$22 = { serialVersionUID: { configurable: true } };
    AbstractNode.prototype.getLevel = function getLevel() {
      return this._level;
    };
    AbstractNode.prototype.size = function size() {
      return this._childBoundables.size();
    };
    AbstractNode.prototype.getChildBoundables = function getChildBoundables() {
      return this._childBoundables;
    };
    AbstractNode.prototype.addChildBoundable = function addChildBoundable(childBoundable) {
      Assert.isTrue(this._bounds === null);
      this._childBoundables.add(childBoundable);
    };
    AbstractNode.prototype.isEmpty = function isEmpty() {
      return this._childBoundables.isEmpty();
    };
    AbstractNode.prototype.getBounds = function getBounds() {
      if (this._bounds === null) {
        this._bounds = this.computeBounds();
      }
      return this._bounds;
    };
    AbstractNode.prototype.interfaces_ = function interfaces_() {
      return [Boundable, Serializable];
    };
    AbstractNode.prototype.getClass = function getClass() {
      return AbstractNode;
    };
    staticAccessors$22.serialVersionUID.get = function() {
      return 6493722185909574e3;
    };
    Object.defineProperties(AbstractNode, staticAccessors$22);
    var Collections = function Collections2() {
    };
    Collections.reverseOrder = function reverseOrder() {
      return {
        compare: function compare(a, b) {
          return b.compareTo(a);
        }
      };
    };
    Collections.min = function min(l) {
      Collections.sort(l);
      return l.get(0);
    };
    Collections.sort = function sort(l, c) {
      var a = l.toArray();
      if (c) {
        Arrays.sort(a, c);
      } else {
        Arrays.sort(a);
      }
      var i = l.iterator();
      for (var pos = 0, alen = a.length; pos < alen; pos++) {
        i.next();
        i.set(a[pos]);
      }
    };
    Collections.singletonList = function singletonList(o) {
      var arrayList = new ArrayList();
      arrayList.add(o);
      return arrayList;
    };
    var BoundablePair = function BoundablePair2() {
      this._boundable1 = null;
      this._boundable2 = null;
      this._distance = null;
      this._itemDistance = null;
      var boundable1 = arguments[0];
      var boundable2 = arguments[1];
      var itemDistance = arguments[2];
      this._boundable1 = boundable1;
      this._boundable2 = boundable2;
      this._itemDistance = itemDistance;
      this._distance = this.distance();
    };
    BoundablePair.prototype.expandToQueue = function expandToQueue(priQ, minDistance) {
      var isComp1 = BoundablePair.isComposite(this._boundable1);
      var isComp2 = BoundablePair.isComposite(this._boundable2);
      if (isComp1 && isComp2) {
        if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
          this.expand(this._boundable1, this._boundable2, priQ, minDistance);
          return null;
        } else {
          this.expand(this._boundable2, this._boundable1, priQ, minDistance);
          return null;
        }
      } else if (isComp1) {
        this.expand(this._boundable1, this._boundable2, priQ, minDistance);
        return null;
      } else if (isComp2) {
        this.expand(this._boundable2, this._boundable1, priQ, minDistance);
        return null;
      }
      throw new IllegalArgumentException("neither boundable is composite");
    };
    BoundablePair.prototype.isLeaves = function isLeaves() {
      return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
    };
    BoundablePair.prototype.compareTo = function compareTo(o) {
      var nd = o;
      if (this._distance < nd._distance) {
        return -1;
      }
      if (this._distance > nd._distance) {
        return 1;
      }
      return 0;
    };
    BoundablePair.prototype.expand = function expand(bndComposite, bndOther, priQ, minDistance) {
      var this$1 = this;
      var children2 = bndComposite.getChildBoundables();
      for (var i = children2.iterator(); i.hasNext(); ) {
        var child = i.next();
        var bp = new BoundablePair(child, bndOther, this$1._itemDistance);
        if (bp.getDistance() < minDistance) {
          priQ.add(bp);
        }
      }
    };
    BoundablePair.prototype.getBoundable = function getBoundable(i) {
      if (i === 0) {
        return this._boundable1;
      }
      return this._boundable2;
    };
    BoundablePair.prototype.getDistance = function getDistance() {
      return this._distance;
    };
    BoundablePair.prototype.distance = function distance() {
      if (this.isLeaves()) {
        return this._itemDistance.distance(this._boundable1, this._boundable2);
      }
      return this._boundable1.getBounds().distance(this._boundable2.getBounds());
    };
    BoundablePair.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    BoundablePair.prototype.getClass = function getClass() {
      return BoundablePair;
    };
    BoundablePair.area = function area(b) {
      return b.getBounds().getArea();
    };
    BoundablePair.isComposite = function isComposite(item) {
      return item instanceof AbstractNode;
    };
    var AbstractSTRtree = function AbstractSTRtree2() {
      this._root = null;
      this._built = false;
      this._itemBoundables = new ArrayList();
      this._nodeCapacity = null;
      if (arguments.length === 0) {
        var nodeCapacity = AbstractSTRtree2.DEFAULT_NODE_CAPACITY;
        this._nodeCapacity = nodeCapacity;
      } else if (arguments.length === 1) {
        var nodeCapacity$1 = arguments[0];
        Assert.isTrue(nodeCapacity$1 > 1, "Node capacity must be greater than 1");
        this._nodeCapacity = nodeCapacity$1;
      }
    };
    var staticAccessors$23 = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
    AbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity() {
      return this._nodeCapacity;
    };
    AbstractSTRtree.prototype.lastNode = function lastNode(nodes) {
      return nodes.get(nodes.size() - 1);
    };
    AbstractSTRtree.prototype.size = function size() {
      var this$1 = this;
      if (arguments.length === 0) {
        if (this.isEmpty()) {
          return 0;
        }
        this.build();
        return this.size(this._root);
      } else if (arguments.length === 1) {
        var node = arguments[0];
        var size2 = 0;
        for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
          var childBoundable = i.next();
          if (childBoundable instanceof AbstractNode) {
            size2 += this$1.size(childBoundable);
          } else if (childBoundable instanceof ItemBoundable) {
            size2 += 1;
          }
        }
        return size2;
      }
    };
    AbstractSTRtree.prototype.removeItem = function removeItem(node, item) {
      var childToRemove = null;
      for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
        var childBoundable = i.next();
        if (childBoundable instanceof ItemBoundable) {
          if (childBoundable.getItem() === item) {
            childToRemove = childBoundable;
          }
        }
      }
      if (childToRemove !== null) {
        node.getChildBoundables().remove(childToRemove);
        return true;
      }
      return false;
    };
    AbstractSTRtree.prototype.itemsTree = function itemsTree() {
      var this$1 = this;
      if (arguments.length === 0) {
        this.build();
        var valuesTree = this.itemsTree(this._root);
        if (valuesTree === null) {
          return new ArrayList();
        }
        return valuesTree;
      } else if (arguments.length === 1) {
        var node = arguments[0];
        var valuesTreeForNode = new ArrayList();
        for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
          var childBoundable = i.next();
          if (childBoundable instanceof AbstractNode) {
            var valuesTreeForChild = this$1.itemsTree(childBoundable);
            if (valuesTreeForChild !== null) {
              valuesTreeForNode.add(valuesTreeForChild);
            }
          } else if (childBoundable instanceof ItemBoundable) {
            valuesTreeForNode.add(childBoundable.getItem());
          } else {
            Assert.shouldNeverReachHere();
          }
        }
        if (valuesTreeForNode.size() <= 0) {
          return null;
        }
        return valuesTreeForNode;
      }
    };
    AbstractSTRtree.prototype.insert = function insert(bounds, item) {
      Assert.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built.");
      this._itemBoundables.add(new ItemBoundable(bounds, item));
    };
    AbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel() {
      var this$1 = this;
      if (arguments.length === 1) {
        var level = arguments[0];
        var boundables = new ArrayList();
        this.boundablesAtLevel(level, this._root, boundables);
        return boundables;
      } else if (arguments.length === 3) {
        var level$1 = arguments[0];
        var top = arguments[1];
        var boundables$1 = arguments[2];
        Assert.isTrue(level$1 > -2);
        if (top.getLevel() === level$1) {
          boundables$1.add(top);
          return null;
        }
        for (var i = top.getChildBoundables().iterator(); i.hasNext(); ) {
          var boundable = i.next();
          if (boundable instanceof AbstractNode) {
            this$1.boundablesAtLevel(level$1, boundable, boundables$1);
          } else {
            Assert.isTrue(boundable instanceof ItemBoundable);
            if (level$1 === -1) {
              boundables$1.add(boundable);
            }
          }
        }
        return null;
      }
    };
    AbstractSTRtree.prototype.query = function query() {
      var this$1 = this;
      if (arguments.length === 1) {
        var searchBounds = arguments[0];
        this.build();
        var matches = new ArrayList();
        if (this.isEmpty()) {
          return matches;
        }
        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
          this.query(searchBounds, this._root, matches);
        }
        return matches;
      } else if (arguments.length === 2) {
        var searchBounds$1 = arguments[0];
        var visitor = arguments[1];
        this.build();
        if (this.isEmpty()) {
          return null;
        }
        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {
          this.query(searchBounds$1, this._root, visitor);
        }
      } else if (arguments.length === 3) {
        if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
          var searchBounds$2 = arguments[0];
          var node = arguments[1];
          var visitor$1 = arguments[2];
          var childBoundables = node.getChildBoundables();
          for (var i = 0; i < childBoundables.size(); i++) {
            var childBoundable = childBoundables.get(i);
            if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {
              continue;
            }
            if (childBoundable instanceof AbstractNode) {
              this$1.query(searchBounds$2, childBoundable, visitor$1);
            } else if (childBoundable instanceof ItemBoundable) {
              visitor$1.visitItem(childBoundable.getItem());
            } else {
              Assert.shouldNeverReachHere();
            }
          }
        } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
          var searchBounds$3 = arguments[0];
          var node$1 = arguments[1];
          var matches$1 = arguments[2];
          var childBoundables$1 = node$1.getChildBoundables();
          for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {
            var childBoundable$1 = childBoundables$1.get(i$1);
            if (!this$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {
              continue;
            }
            if (childBoundable$1 instanceof AbstractNode) {
              this$1.query(searchBounds$3, childBoundable$1, matches$1);
            } else if (childBoundable$1 instanceof ItemBoundable) {
              matches$1.add(childBoundable$1.getItem());
            } else {
              Assert.shouldNeverReachHere();
            }
          }
        }
      }
    };
    AbstractSTRtree.prototype.build = function build() {
      if (this._built) {
        return null;
      }
      this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
      this._itemBoundables = null;
      this._built = true;
    };
    AbstractSTRtree.prototype.getRoot = function getRoot() {
      this.build();
      return this._root;
    };
    AbstractSTRtree.prototype.remove = function remove() {
      var this$1 = this;
      if (arguments.length === 2) {
        var searchBounds = arguments[0];
        var item = arguments[1];
        this.build();
        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
          return this.remove(searchBounds, this._root, item);
        }
        return false;
      } else if (arguments.length === 3) {
        var searchBounds$1 = arguments[0];
        var node = arguments[1];
        var item$1 = arguments[2];
        var found = this.removeItem(node, item$1);
        if (found) {
          return true;
        }
        var childToPrune = null;
        for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
          var childBoundable = i.next();
          if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {
            continue;
          }
          if (childBoundable instanceof AbstractNode) {
            found = this$1.remove(searchBounds$1, childBoundable, item$1);
            if (found) {
              childToPrune = childBoundable;
              break;
            }
          }
        }
        if (childToPrune !== null) {
          if (childToPrune.getChildBoundables().isEmpty()) {
            node.getChildBoundables().remove(childToPrune);
          }
        }
        return found;
      }
    };
    AbstractSTRtree.prototype.createHigherLevels = function createHigherLevels(boundablesOfALevel, level) {
      Assert.isTrue(!boundablesOfALevel.isEmpty());
      var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
      if (parentBoundables.size() === 1) {
        return parentBoundables.get(0);
      }
      return this.createHigherLevels(parentBoundables, level + 1);
    };
    AbstractSTRtree.prototype.depth = function depth() {
      var this$1 = this;
      if (arguments.length === 0) {
        if (this.isEmpty()) {
          return 0;
        }
        this.build();
        return this.depth(this._root);
      } else if (arguments.length === 1) {
        var node = arguments[0];
        var maxChildDepth = 0;
        for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
          var childBoundable = i.next();
          if (childBoundable instanceof AbstractNode) {
            var childDepth = this$1.depth(childBoundable);
            if (childDepth > maxChildDepth) {
              maxChildDepth = childDepth;
            }
          }
        }
        return maxChildDepth + 1;
      }
    };
    AbstractSTRtree.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {
      var this$1 = this;
      Assert.isTrue(!childBoundables.isEmpty());
      var parentBoundables = new ArrayList();
      parentBoundables.add(this.createNode(newLevel));
      var sortedChildBoundables = new ArrayList(childBoundables);
      Collections.sort(sortedChildBoundables, this.getComparator());
      for (var i = sortedChildBoundables.iterator(); i.hasNext(); ) {
        var childBoundable = i.next();
        if (this$1.lastNode(parentBoundables).getChildBoundables().size() === this$1.getNodeCapacity()) {
          parentBoundables.add(this$1.createNode(newLevel));
        }
        this$1.lastNode(parentBoundables).addChildBoundable(childBoundable);
      }
      return parentBoundables;
    };
    AbstractSTRtree.prototype.isEmpty = function isEmpty() {
      if (!this._built) {
        return this._itemBoundables.isEmpty();
      }
      return this._root.isEmpty();
    };
    AbstractSTRtree.prototype.interfaces_ = function interfaces_() {
      return [Serializable];
    };
    AbstractSTRtree.prototype.getClass = function getClass() {
      return AbstractSTRtree;
    };
    AbstractSTRtree.compareDoubles = function compareDoubles(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    };
    staticAccessors$23.IntersectsOp.get = function() {
      return IntersectsOp;
    };
    staticAccessors$23.serialVersionUID.get = function() {
      return -3886435814360241e3;
    };
    staticAccessors$23.DEFAULT_NODE_CAPACITY.get = function() {
      return 10;
    };
    Object.defineProperties(AbstractSTRtree, staticAccessors$23);
    var IntersectsOp = function IntersectsOp2() {
    };
    var ItemDistance = function ItemDistance2() {
    };
    ItemDistance.prototype.distance = function distance(item1, item2) {
    };
    ItemDistance.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    ItemDistance.prototype.getClass = function getClass() {
      return ItemDistance;
    };
    var STRtree = function(AbstractSTRtree$$1) {
      function STRtree2(nodeCapacity) {
        nodeCapacity = nodeCapacity || STRtree2.DEFAULT_NODE_CAPACITY;
        AbstractSTRtree$$1.call(this, nodeCapacity);
      }
      if (AbstractSTRtree$$1) STRtree2.__proto__ = AbstractSTRtree$$1;
      STRtree2.prototype = Object.create(AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype);
      STRtree2.prototype.constructor = STRtree2;
      var staticAccessors2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
      STRtree2.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
        var this$1 = this;
        Assert.isTrue(verticalSlices.length > 0);
        var parentBoundables = new ArrayList();
        for (var i = 0; i < verticalSlices.length; i++) {
          parentBoundables.addAll(this$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
        }
        return parentBoundables;
      };
      STRtree2.prototype.createNode = function createNode(level) {
        return new STRtreeNode(level);
      };
      STRtree2.prototype.size = function size() {
        if (arguments.length === 0) {
          return AbstractSTRtree$$1.prototype.size.call(this);
        } else {
          return AbstractSTRtree$$1.prototype.size.apply(this, arguments);
        }
      };
      STRtree2.prototype.insert = function insert() {
        if (arguments.length === 2) {
          var itemEnv = arguments[0];
          var item = arguments[1];
          if (itemEnv.isNull()) {
            return null;
          }
          AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);
        } else {
          return AbstractSTRtree$$1.prototype.insert.apply(this, arguments);
        }
      };
      STRtree2.prototype.getIntersectsOp = function getIntersectsOp() {
        return STRtree2.intersectsOp;
      };
      STRtree2.prototype.verticalSlices = function verticalSlices(childBoundables, sliceCount) {
        var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
        var slices = new Array(sliceCount).fill(null);
        var i = childBoundables.iterator();
        for (var j = 0; j < sliceCount; j++) {
          slices[j] = new ArrayList();
          var boundablesAddedToSlice = 0;
          while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
            var childBoundable = i.next();
            slices[j].add(childBoundable);
            boundablesAddedToSlice++;
          }
        }
        return slices;
      };
      STRtree2.prototype.query = function query() {
        if (arguments.length === 1) {
          var searchEnv = arguments[0];
          return AbstractSTRtree$$1.prototype.query.call(this, searchEnv);
        } else if (arguments.length === 2) {
          var searchEnv$1 = arguments[0];
          var visitor = arguments[1];
          AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);
        } else if (arguments.length === 3) {
          if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
            var searchBounds = arguments[0];
            var node = arguments[1];
            var visitor$1 = arguments[2];
            AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);
          } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
            var searchBounds$1 = arguments[0];
            var node$1 = arguments[1];
            var matches = arguments[2];
            AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);
          }
        }
      };
      STRtree2.prototype.getComparator = function getComparator() {
        return STRtree2.yComparator;
      };
      STRtree2.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
        return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel);
      };
      STRtree2.prototype.remove = function remove() {
        if (arguments.length === 2) {
          var itemEnv = arguments[0];
          var item = arguments[1];
          return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item);
        } else {
          return AbstractSTRtree$$1.prototype.remove.apply(this, arguments);
        }
      };
      STRtree2.prototype.depth = function depth() {
        if (arguments.length === 0) {
          return AbstractSTRtree$$1.prototype.depth.call(this);
        } else {
          return AbstractSTRtree$$1.prototype.depth.apply(this, arguments);
        }
      };
      STRtree2.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {
        Assert.isTrue(!childBoundables.isEmpty());
        var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
        var sortedChildBoundables = new ArrayList(childBoundables);
        Collections.sort(sortedChildBoundables, STRtree2.xComparator);
        var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
        return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
      };
      STRtree2.prototype.nearestNeighbour = function nearestNeighbour() {
        if (arguments.length === 1) {
          if (hasInterface(arguments[0], ItemDistance)) {
            var itemDist = arguments[0];
            var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
            return this.nearestNeighbour(bp);
          } else if (arguments[0] instanceof BoundablePair) {
            var initBndPair = arguments[0];
            return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);
          }
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof STRtree2 && hasInterface(arguments[1], ItemDistance)) {
            var tree = arguments[0];
            var itemDist$1 = arguments[1];
            var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);
            return this.nearestNeighbour(bp$1);
          } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === "number") {
            var initBndPair$1 = arguments[0];
            var maxDistance = arguments[1];
            var distanceLowerBound = maxDistance;
            var minPair = null;
            var priQ = new PriorityQueue();
            priQ.add(initBndPair$1);
            while (!priQ.isEmpty() && distanceLowerBound > 0) {
              var bndPair = priQ.poll();
              var currentDistance = bndPair.getDistance();
              if (currentDistance >= distanceLowerBound) {
                break;
              }
              if (bndPair.isLeaves()) {
                distanceLowerBound = currentDistance;
                minPair = bndPair;
              } else {
                bndPair.expandToQueue(priQ, distanceLowerBound);
              }
            }
            return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];
          }
        } else if (arguments.length === 3) {
          var env = arguments[0];
          var item = arguments[1];
          var itemDist$2 = arguments[2];
          var bnd = new ItemBoundable(env, item);
          var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);
          return this.nearestNeighbour(bp$2)[0];
        }
      };
      STRtree2.prototype.interfaces_ = function interfaces_() {
        return [SpatialIndex, Serializable];
      };
      STRtree2.prototype.getClass = function getClass() {
        return STRtree2;
      };
      STRtree2.centreX = function centreX(e) {
        return STRtree2.avg(e.getMinX(), e.getMaxX());
      };
      STRtree2.avg = function avg(a, b) {
        return (a + b) / 2;
      };
      STRtree2.centreY = function centreY(e) {
        return STRtree2.avg(e.getMinY(), e.getMaxY());
      };
      staticAccessors2.STRtreeNode.get = function() {
        return STRtreeNode;
      };
      staticAccessors2.serialVersionUID.get = function() {
        return 259274702368956900;
      };
      staticAccessors2.xComparator.get = function() {
        return {
          interfaces_: function() {
            return [Comparator];
          },
          compare: function(o1, o2) {
            return AbstractSTRtree$$1.compareDoubles(STRtree2.centreX(o1.getBounds()), STRtree2.centreX(o2.getBounds()));
          }
        };
      };
      staticAccessors2.yComparator.get = function() {
        return {
          interfaces_: function() {
            return [Comparator];
          },
          compare: function(o1, o2) {
            return AbstractSTRtree$$1.compareDoubles(STRtree2.centreY(o1.getBounds()), STRtree2.centreY(o2.getBounds()));
          }
        };
      };
      staticAccessors2.intersectsOp.get = function() {
        return {
          interfaces_: function() {
            return [AbstractSTRtree$$1.IntersectsOp];
          },
          intersects: function(aBounds, bBounds) {
            return aBounds.intersects(bBounds);
          }
        };
      };
      staticAccessors2.DEFAULT_NODE_CAPACITY.get = function() {
        return 10;
      };
      Object.defineProperties(STRtree2, staticAccessors2);
      return STRtree2;
    }(AbstractSTRtree);
    var STRtreeNode = function(AbstractNode$$1) {
      function STRtreeNode2() {
        var level = arguments[0];
        AbstractNode$$1.call(this, level);
      }
      if (AbstractNode$$1) STRtreeNode2.__proto__ = AbstractNode$$1;
      STRtreeNode2.prototype = Object.create(AbstractNode$$1 && AbstractNode$$1.prototype);
      STRtreeNode2.prototype.constructor = STRtreeNode2;
      STRtreeNode2.prototype.computeBounds = function computeBounds() {
        var bounds = null;
        for (var i = this.getChildBoundables().iterator(); i.hasNext(); ) {
          var childBoundable = i.next();
          if (bounds === null) {
            bounds = new Envelope(childBoundable.getBounds());
          } else {
            bounds.expandToInclude(childBoundable.getBounds());
          }
        }
        return bounds;
      };
      STRtreeNode2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      STRtreeNode2.prototype.getClass = function getClass() {
        return STRtreeNode2;
      };
      return STRtreeNode2;
    }(AbstractNode);
    var SegmentPointComparator = function SegmentPointComparator2() {
    };
    SegmentPointComparator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SegmentPointComparator.prototype.getClass = function getClass() {
      return SegmentPointComparator;
    };
    SegmentPointComparator.relativeSign = function relativeSign(x0, x1) {
      if (x0 < x1) {
        return -1;
      }
      if (x0 > x1) {
        return 1;
      }
      return 0;
    };
    SegmentPointComparator.compare = function compare(octant, p0, p1) {
      if (p0.equals2D(p1)) {
        return 0;
      }
      var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
      var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
      switch (octant) {
        case 0:
          return SegmentPointComparator.compareValue(xSign, ySign);
        case 1:
          return SegmentPointComparator.compareValue(ySign, xSign);
        case 2:
          return SegmentPointComparator.compareValue(ySign, -xSign);
        case 3:
          return SegmentPointComparator.compareValue(-xSign, ySign);
        case 4:
          return SegmentPointComparator.compareValue(-xSign, -ySign);
        case 5:
          return SegmentPointComparator.compareValue(-ySign, -xSign);
        case 6:
          return SegmentPointComparator.compareValue(-ySign, xSign);
        case 7:
          return SegmentPointComparator.compareValue(xSign, -ySign);
        default:
      }
      Assert.shouldNeverReachHere("invalid octant value");
      return 0;
    };
    SegmentPointComparator.compareValue = function compareValue(compareSign0, compareSign1) {
      if (compareSign0 < 0) {
        return -1;
      }
      if (compareSign0 > 0) {
        return 1;
      }
      if (compareSign1 < 0) {
        return -1;
      }
      if (compareSign1 > 0) {
        return 1;
      }
      return 0;
    };
    var SegmentNode = function SegmentNode2() {
      this._segString = null;
      this.coord = null;
      this.segmentIndex = null;
      this._segmentOctant = null;
      this._isInterior = null;
      var segString = arguments[0];
      var coord = arguments[1];
      var segmentIndex = arguments[2];
      var segmentOctant = arguments[3];
      this._segString = segString;
      this.coord = new Coordinate(coord);
      this.segmentIndex = segmentIndex;
      this._segmentOctant = segmentOctant;
      this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
    };
    SegmentNode.prototype.getCoordinate = function getCoordinate() {
      return this.coord;
    };
    SegmentNode.prototype.print = function print(out) {
      out.print(this.coord);
      out.print(" seg # = " + this.segmentIndex);
    };
    SegmentNode.prototype.compareTo = function compareTo(obj) {
      var other = obj;
      if (this.segmentIndex < other.segmentIndex) {
        return -1;
      }
      if (this.segmentIndex > other.segmentIndex) {
        return 1;
      }
      if (this.coord.equals2D(other.coord)) {
        return 0;
      }
      return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);
    };
    SegmentNode.prototype.isEndPoint = function isEndPoint(maxSegmentIndex) {
      if (this.segmentIndex === 0 && !this._isInterior) {
        return true;
      }
      if (this.segmentIndex === maxSegmentIndex) {
        return true;
      }
      return false;
    };
    SegmentNode.prototype.isInterior = function isInterior() {
      return this._isInterior;
    };
    SegmentNode.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    SegmentNode.prototype.getClass = function getClass() {
      return SegmentNode;
    };
    var SegmentNodeList = function SegmentNodeList2() {
      this._nodeMap = new TreeMap();
      this._edge = null;
      var edge = arguments[0];
      this._edge = edge;
    };
    SegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates() {
      var this$1 = this;
      var coordList = new CoordinateList();
      this.addEndpoints();
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        this$1.addEdgeCoordinates(eiPrev, ei, coordList);
        eiPrev = ei;
      }
      return coordList.toCoordinateArray();
    };
    SegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes() {
      var this$1 = this;
      var collapsedVertexIndexes = new ArrayList();
      this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
      this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
      for (var it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {
        var vertexIndex = it.next().intValue();
        this$1.add(this$1._edge.getCoordinate(vertexIndex), vertexIndex);
      }
    };
    SegmentNodeList.prototype.print = function print(out) {
      out.println("Intersections:");
      for (var it = this.iterator(); it.hasNext(); ) {
        var ei = it.next();
        ei.print(out);
      }
    };
    SegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices(collapsedVertexIndexes) {
      var this$1 = this;
      for (var i = 0; i < this._edge.size() - 2; i++) {
        var p0 = this$1._edge.getCoordinate(i);
        var p2 = this$1._edge.getCoordinate(i + 2);
        if (p0.equals2D(p2)) {
          collapsedVertexIndexes.add(new Integer(i + 1));
        }
      }
    };
    SegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates(ei0, ei1, coordList) {
      var this$1 = this;
      var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
      var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
      coordList.add(new Coordinate(ei0.coord), false);
      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
        coordList.add(this$1._edge.getCoordinate(i));
      }
      if (useIntPt1) {
        coordList.add(new Coordinate(ei1.coord));
      }
    };
    SegmentNodeList.prototype.iterator = function iterator() {
      return this._nodeMap.values().iterator();
    };
    SegmentNodeList.prototype.addSplitEdges = function addSplitEdges(edgeList) {
      var this$1 = this;
      this.addEndpoints();
      this.addCollapsedNodes();
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        var newEdge = this$1.createSplitEdge(eiPrev, ei);
        edgeList.add(newEdge);
        eiPrev = ei;
      }
    };
    SegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
      if (!ei0.coord.equals2D(ei1.coord)) {
        return false;
      }
      var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
      if (!ei1.isInterior()) {
        numVerticesBetween--;
      }
      if (numVerticesBetween === 1) {
        collapsedVertexIndex[0] = ei0.segmentIndex + 1;
        return true;
      }
      return false;
    };
    SegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
      var this$1 = this;
      var collapsedVertexIndex = new Array(1).fill(null);
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        var isCollapsed = this$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
        if (isCollapsed) {
          collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));
        }
        eiPrev = ei;
      }
    };
    SegmentNodeList.prototype.getEdge = function getEdge() {
      return this._edge;
    };
    SegmentNodeList.prototype.addEndpoints = function addEndpoints() {
      var maxSegIndex = this._edge.size() - 1;
      this.add(this._edge.getCoordinate(0), 0);
      this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
    };
    SegmentNodeList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {
      var this$1 = this;
      var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
      var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
      var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
      if (!useIntPt1) {
        npts--;
      }
      var pts = new Array(npts).fill(null);
      var ipt = 0;
      pts[ipt++] = new Coordinate(ei0.coord);
      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
        pts[ipt++] = this$1._edge.getCoordinate(i);
      }
      if (useIntPt1) {
        pts[ipt] = new Coordinate(ei1.coord);
      }
      return new NodedSegmentString(pts, this._edge.getData());
    };
    SegmentNodeList.prototype.add = function add(intPt, segmentIndex) {
      var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
      var ei = this._nodeMap.get(eiNew);
      if (ei !== null) {
        Assert.isTrue(ei.coord.equals2D(intPt), "Found equal nodes with different coordinates");
        return ei;
      }
      this._nodeMap.put(eiNew, eiNew);
      return eiNew;
    };
    SegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness(splitEdges) {
      var edgePts = this._edge.getCoordinates();
      var split0 = splitEdges.get(0);
      var pt0 = split0.getCoordinate(0);
      if (!pt0.equals2D(edgePts[0])) {
        throw new RuntimeException("bad split edge start point at " + pt0);
      }
      var splitn = splitEdges.get(splitEdges.size() - 1);
      var splitnPts = splitn.getCoordinates();
      var ptn = splitnPts[splitnPts.length - 1];
      if (!ptn.equals2D(edgePts[edgePts.length - 1])) {
        throw new RuntimeException("bad split edge end point at " + ptn);
      }
    };
    SegmentNodeList.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SegmentNodeList.prototype.getClass = function getClass() {
      return SegmentNodeList;
    };
    var Octant = function Octant2() {
    };
    Octant.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Octant.prototype.getClass = function getClass() {
      return Octant;
    };
    Octant.octant = function octant() {
      if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
        var dx = arguments[0];
        var dy = arguments[1];
        if (dx === 0 && dy === 0) {
          throw new IllegalArgumentException("Cannot compute the octant for point ( " + dx + ", " + dy + " )");
        }
        var adx = Math.abs(dx);
        var ady = Math.abs(dy);
        if (dx >= 0) {
          if (dy >= 0) {
            if (adx >= ady) {
              return 0;
            } else {
              return 1;
            }
          } else {
            if (adx >= ady) {
              return 7;
            } else {
              return 6;
            }
          }
        } else {
          if (dy >= 0) {
            if (adx >= ady) {
              return 3;
            } else {
              return 2;
            }
          } else {
            if (adx >= ady) {
              return 4;
            } else {
              return 5;
            }
          }
        }
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        var dx$1 = p1.x - p0.x;
        var dy$1 = p1.y - p0.y;
        if (dx$1 === 0 && dy$1 === 0) {
          throw new IllegalArgumentException("Cannot compute the octant for two identical points " + p0);
        }
        return Octant.octant(dx$1, dy$1);
      }
    };
    var SegmentString = function SegmentString2() {
    };
    SegmentString.prototype.getCoordinates = function getCoordinates() {
    };
    SegmentString.prototype.size = function size() {
    };
    SegmentString.prototype.getCoordinate = function getCoordinate(i) {
    };
    SegmentString.prototype.isClosed = function isClosed() {
    };
    SegmentString.prototype.setData = function setData(data) {
    };
    SegmentString.prototype.getData = function getData() {
    };
    SegmentString.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SegmentString.prototype.getClass = function getClass() {
      return SegmentString;
    };
    var NodableSegmentString = function NodableSegmentString2() {
    };
    NodableSegmentString.prototype.addIntersection = function addIntersection(intPt, segmentIndex) {
    };
    NodableSegmentString.prototype.interfaces_ = function interfaces_() {
      return [SegmentString];
    };
    NodableSegmentString.prototype.getClass = function getClass() {
      return NodableSegmentString;
    };
    var NodedSegmentString = function NodedSegmentString2() {
      this._nodeList = new SegmentNodeList(this);
      this._pts = null;
      this._data = null;
      var pts = arguments[0];
      var data = arguments[1];
      this._pts = pts;
      this._data = data;
    };
    NodedSegmentString.prototype.getCoordinates = function getCoordinates() {
      return this._pts;
    };
    NodedSegmentString.prototype.size = function size() {
      return this._pts.length;
    };
    NodedSegmentString.prototype.getCoordinate = function getCoordinate(i) {
      return this._pts[i];
    };
    NodedSegmentString.prototype.isClosed = function isClosed() {
      return this._pts[0].equals(this._pts[this._pts.length - 1]);
    };
    NodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index) {
      if (index === this._pts.length - 1) {
        return -1;
      }
      return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));
    };
    NodedSegmentString.prototype.setData = function setData(data) {
      this._data = data;
    };
    NodedSegmentString.prototype.safeOctant = function safeOctant(p0, p1) {
      if (p0.equals2D(p1)) {
        return 0;
      }
      return Octant.octant(p0, p1);
    };
    NodedSegmentString.prototype.getData = function getData() {
      return this._data;
    };
    NodedSegmentString.prototype.addIntersection = function addIntersection() {
      if (arguments.length === 2) {
        var intPt$1 = arguments[0];
        var segmentIndex = arguments[1];
        this.addIntersectionNode(intPt$1, segmentIndex);
      } else if (arguments.length === 4) {
        var li = arguments[0];
        var segmentIndex$1 = arguments[1];
        var intIndex = arguments[3];
        var intPt = new Coordinate(li.getIntersection(intIndex));
        this.addIntersection(intPt, segmentIndex$1);
      }
    };
    NodedSegmentString.prototype.toString = function toString() {
      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
    };
    NodedSegmentString.prototype.getNodeList = function getNodeList() {
      return this._nodeList;
    };
    NodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode(intPt, segmentIndex) {
      var normalizedSegmentIndex = segmentIndex;
      var nextSegIndex = normalizedSegmentIndex + 1;
      if (nextSegIndex < this._pts.length) {
        var nextPt = this._pts[nextSegIndex];
        if (intPt.equals2D(nextPt)) {
          normalizedSegmentIndex = nextSegIndex;
        }
      }
      var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
      return ei;
    };
    NodedSegmentString.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {
      var this$1 = this;
      for (var i = 0; i < li.getIntersectionNum(); i++) {
        this$1.addIntersection(li, segmentIndex, geomIndex, i);
      }
    };
    NodedSegmentString.prototype.interfaces_ = function interfaces_() {
      return [NodableSegmentString];
    };
    NodedSegmentString.prototype.getClass = function getClass() {
      return NodedSegmentString;
    };
    NodedSegmentString.getNodedSubstrings = function getNodedSubstrings() {
      if (arguments.length === 1) {
        var segStrings = arguments[0];
        var resultEdgelist = new ArrayList();
        NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
        return resultEdgelist;
      } else if (arguments.length === 2) {
        var segStrings$1 = arguments[0];
        var resultEdgelist$1 = arguments[1];
        for (var i = segStrings$1.iterator(); i.hasNext(); ) {
          var ss = i.next();
          ss.getNodeList().addSplitEdges(resultEdgelist$1);
        }
      }
    };
    var LineSegment = function LineSegment2() {
      this.p0 = null;
      this.p1 = null;
      if (arguments.length === 0) {
        this.p0 = new Coordinate();
        this.p1 = new Coordinate();
      } else if (arguments.length === 1) {
        var ls = arguments[0];
        this.p0 = new Coordinate(ls.p0);
        this.p1 = new Coordinate(ls.p1);
      } else if (arguments.length === 2) {
        this.p0 = arguments[0];
        this.p1 = arguments[1];
      } else if (arguments.length === 4) {
        var x0 = arguments[0];
        var y0 = arguments[1];
        var x1 = arguments[2];
        var y1 = arguments[3];
        this.p0 = new Coordinate(x0, y0);
        this.p1 = new Coordinate(x1, y1);
      }
    };
    var staticAccessors$24 = { serialVersionUID: { configurable: true } };
    LineSegment.prototype.minX = function minX() {
      return Math.min(this.p0.x, this.p1.x);
    };
    LineSegment.prototype.orientationIndex = function orientationIndex() {
      if (arguments[0] instanceof LineSegment) {
        var seg = arguments[0];
        var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
        var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
        if (orient0 >= 0 && orient1 >= 0) {
          return Math.max(orient0, orient1);
        }
        if (orient0 <= 0 && orient1 <= 0) {
          return Math.max(orient0, orient1);
        }
        return 0;
      } else if (arguments[0] instanceof Coordinate) {
        var p = arguments[0];
        return CGAlgorithms.orientationIndex(this.p0, this.p1, p);
      }
    };
    LineSegment.prototype.toGeometry = function toGeometry(geomFactory) {
      return geomFactory.createLineString([this.p0, this.p1]);
    };
    LineSegment.prototype.isVertical = function isVertical() {
      return this.p0.x === this.p1.x;
    };
    LineSegment.prototype.equals = function equals(o) {
      if (!(o instanceof LineSegment)) {
        return false;
      }
      var other = o;
      return this.p0.equals(other.p0) && this.p1.equals(other.p1);
    };
    LineSegment.prototype.intersection = function intersection(line) {
      var li = new RobustLineIntersector();
      li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
      if (li.hasIntersection()) {
        return li.getIntersection(0);
      }
      return null;
    };
    LineSegment.prototype.project = function project() {
      if (arguments[0] instanceof Coordinate) {
        var p = arguments[0];
        if (p.equals(this.p0) || p.equals(this.p1)) {
          return new Coordinate(p);
        }
        var r = this.projectionFactor(p);
        var coord = new Coordinate();
        coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
        coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
        return coord;
      } else if (arguments[0] instanceof LineSegment) {
        var seg = arguments[0];
        var pf0 = this.projectionFactor(seg.p0);
        var pf1 = this.projectionFactor(seg.p1);
        if (pf0 >= 1 && pf1 >= 1) {
          return null;
        }
        if (pf0 <= 0 && pf1 <= 0) {
          return null;
        }
        var newp0 = this.project(seg.p0);
        if (pf0 < 0) {
          newp0 = this.p0;
        }
        if (pf0 > 1) {
          newp0 = this.p1;
        }
        var newp1 = this.project(seg.p1);
        if (pf1 < 0) {
          newp1 = this.p0;
        }
        if (pf1 > 1) {
          newp1 = this.p1;
        }
        return new LineSegment(newp0, newp1);
      }
    };
    LineSegment.prototype.normalize = function normalize2() {
      if (this.p1.compareTo(this.p0) < 0) {
        this.reverse();
      }
    };
    LineSegment.prototype.angle = function angle() {
      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
    };
    LineSegment.prototype.getCoordinate = function getCoordinate(i) {
      if (i === 0) {
        return this.p0;
      }
      return this.p1;
    };
    LineSegment.prototype.distancePerpendicular = function distancePerpendicular(p) {
      return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);
    };
    LineSegment.prototype.minY = function minY() {
      return Math.min(this.p0.y, this.p1.y);
    };
    LineSegment.prototype.midPoint = function midPoint() {
      return LineSegment.midPoint(this.p0, this.p1);
    };
    LineSegment.prototype.projectionFactor = function projectionFactor(p) {
      if (p.equals(this.p0)) {
        return 0;
      }
      if (p.equals(this.p1)) {
        return 1;
      }
      var dx = this.p1.x - this.p0.x;
      var dy = this.p1.y - this.p0.y;
      var len = dx * dx + dy * dy;
      if (len <= 0) {
        return Double.NaN;
      }
      var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
      return r;
    };
    LineSegment.prototype.closestPoints = function closestPoints(line) {
      var intPt = this.intersection(line);
      if (intPt !== null) {
        return [intPt, intPt];
      }
      var closestPt = new Array(2).fill(null);
      var minDistance = Double.MAX_VALUE;
      var dist = null;
      var close00 = this.closestPoint(line.p0);
      minDistance = close00.distance(line.p0);
      closestPt[0] = close00;
      closestPt[1] = line.p0;
      var close01 = this.closestPoint(line.p1);
      dist = close01.distance(line.p1);
      if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = close01;
        closestPt[1] = line.p1;
      }
      var close10 = line.closestPoint(this.p0);
      dist = close10.distance(this.p0);
      if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = this.p0;
        closestPt[1] = close10;
      }
      var close11 = line.closestPoint(this.p1);
      dist = close11.distance(this.p1);
      if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = this.p1;
        closestPt[1] = close11;
      }
      return closestPt;
    };
    LineSegment.prototype.closestPoint = function closestPoint(p) {
      var factor = this.projectionFactor(p);
      if (factor > 0 && factor < 1) {
        return this.project(p);
      }
      var dist0 = this.p0.distance(p);
      var dist1 = this.p1.distance(p);
      if (dist0 < dist1) {
        return this.p0;
      }
      return this.p1;
    };
    LineSegment.prototype.maxX = function maxX() {
      return Math.max(this.p0.x, this.p1.x);
    };
    LineSegment.prototype.getLength = function getLength() {
      return this.p0.distance(this.p1);
    };
    LineSegment.prototype.compareTo = function compareTo(o) {
      var other = o;
      var comp0 = this.p0.compareTo(other.p0);
      if (comp0 !== 0) {
        return comp0;
      }
      return this.p1.compareTo(other.p1);
    };
    LineSegment.prototype.reverse = function reverse() {
      var temp = this.p0;
      this.p0 = this.p1;
      this.p1 = temp;
    };
    LineSegment.prototype.equalsTopo = function equalsTopo(other) {
      return this.p0.equals(other.p0) && (this.p1.equals(other.p1) || this.p0.equals(other.p1)) && this.p1.equals(other.p0);
    };
    LineSegment.prototype.lineIntersection = function lineIntersection(line) {
      try {
        var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
        return intPt;
      } catch (ex) {
        if (ex instanceof NotRepresentableException) {
        } else {
          throw ex;
        }
      } finally {
      }
      return null;
    };
    LineSegment.prototype.maxY = function maxY() {
      return Math.max(this.p0.y, this.p1.y);
    };
    LineSegment.prototype.pointAlongOffset = function pointAlongOffset(segmentLengthFraction, offsetDistance) {
      var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
      var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
      var dx = this.p1.x - this.p0.x;
      var dy = this.p1.y - this.p0.y;
      var len = Math.sqrt(dx * dx + dy * dy);
      var ux = 0;
      var uy = 0;
      if (offsetDistance !== 0) {
        if (len <= 0) {
          throw new Error("Cannot compute offset from zero-length line segment");
        }
        ux = offsetDistance * dx / len;
        uy = offsetDistance * dy / len;
      }
      var offsetx = segx - uy;
      var offsety = segy + ux;
      var coord = new Coordinate(offsetx, offsety);
      return coord;
    };
    LineSegment.prototype.setCoordinates = function setCoordinates() {
      if (arguments.length === 1) {
        var ls = arguments[0];
        this.setCoordinates(ls.p0, ls.p1);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        this.p0.x = p0.x;
        this.p0.y = p0.y;
        this.p1.x = p1.x;
        this.p1.y = p1.y;
      }
    };
    LineSegment.prototype.segmentFraction = function segmentFraction(inputPt) {
      var segFrac = this.projectionFactor(inputPt);
      if (segFrac < 0) {
        segFrac = 0;
      } else if (segFrac > 1 || Double.isNaN(segFrac)) {
        segFrac = 1;
      }
      return segFrac;
    };
    LineSegment.prototype.toString = function toString() {
      return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
    };
    LineSegment.prototype.isHorizontal = function isHorizontal() {
      return this.p0.y === this.p1.y;
    };
    LineSegment.prototype.distance = function distance() {
      if (arguments[0] instanceof LineSegment) {
        var ls = arguments[0];
        return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);
      } else if (arguments[0] instanceof Coordinate) {
        var p = arguments[0];
        return CGAlgorithms.distancePointLine(p, this.p0, this.p1);
      }
    };
    LineSegment.prototype.pointAlong = function pointAlong(segmentLengthFraction) {
      var coord = new Coordinate();
      coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
      coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
      return coord;
    };
    LineSegment.prototype.hashCode = function hashCode() {
      var bits0 = Double.doubleToLongBits(this.p0.x);
      bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;
      var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
      var bits1 = Double.doubleToLongBits(this.p1.x);
      bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;
      var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
      return hash0 ^ hash1;
    };
    LineSegment.prototype.interfaces_ = function interfaces_() {
      return [Comparable, Serializable];
    };
    LineSegment.prototype.getClass = function getClass() {
      return LineSegment;
    };
    LineSegment.midPoint = function midPoint(p0, p1) {
      return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
    };
    staticAccessors$24.serialVersionUID.get = function() {
      return 3252005833466256400;
    };
    Object.defineProperties(LineSegment, staticAccessors$24);
    var MonotoneChainOverlapAction = function MonotoneChainOverlapAction2() {
      this.tempEnv1 = new Envelope();
      this.tempEnv2 = new Envelope();
      this._overlapSeg1 = new LineSegment();
      this._overlapSeg2 = new LineSegment();
    };
    MonotoneChainOverlapAction.prototype.overlap = function overlap() {
      if (arguments.length === 2) {
      } else if (arguments.length === 4) {
        var mc1 = arguments[0];
        var start1 = arguments[1];
        var mc2 = arguments[2];
        var start2 = arguments[3];
        mc1.getLineSegment(start1, this._overlapSeg1);
        mc2.getLineSegment(start2, this._overlapSeg2);
        this.overlap(this._overlapSeg1, this._overlapSeg2);
      }
    };
    MonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MonotoneChainOverlapAction.prototype.getClass = function getClass() {
      return MonotoneChainOverlapAction;
    };
    var MonotoneChain = function MonotoneChain2() {
      this._pts = null;
      this._start = null;
      this._end = null;
      this._env = null;
      this._context = null;
      this._id = null;
      var pts = arguments[0];
      var start = arguments[1];
      var end = arguments[2];
      var context = arguments[3];
      this._pts = pts;
      this._start = start;
      this._end = end;
      this._context = context;
    };
    MonotoneChain.prototype.getLineSegment = function getLineSegment(index, ls) {
      ls.p0 = this._pts[index];
      ls.p1 = this._pts[index + 1];
    };
    MonotoneChain.prototype.computeSelect = function computeSelect(searchEnv, start0, end0, mcs) {
      var p0 = this._pts[start0];
      var p1 = this._pts[end0];
      mcs.tempEnv1.init(p0, p1);
      if (end0 - start0 === 1) {
        mcs.select(this, start0);
        return null;
      }
      if (!searchEnv.intersects(mcs.tempEnv1)) {
        return null;
      }
      var mid = Math.trunc((start0 + end0) / 2);
      if (start0 < mid) {
        this.computeSelect(searchEnv, start0, mid, mcs);
      }
      if (mid < end0) {
        this.computeSelect(searchEnv, mid, end0, mcs);
      }
    };
    MonotoneChain.prototype.getCoordinates = function getCoordinates() {
      var this$1 = this;
      var coord = new Array(this._end - this._start + 1).fill(null);
      var index = 0;
      for (var i = this._start; i <= this._end; i++) {
        coord[index++] = this$1._pts[i];
      }
      return coord;
    };
    MonotoneChain.prototype.computeOverlaps = function computeOverlaps(mc, mco) {
      this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
    };
    MonotoneChain.prototype.setId = function setId(id) {
      this._id = id;
    };
    MonotoneChain.prototype.select = function select(searchEnv, mcs) {
      this.computeSelect(searchEnv, this._start, this._end, mcs);
    };
    MonotoneChain.prototype.getEnvelope = function getEnvelope() {
      if (this._env === null) {
        var p0 = this._pts[this._start];
        var p1 = this._pts[this._end];
        this._env = new Envelope(p0, p1);
      }
      return this._env;
    };
    MonotoneChain.prototype.getEndIndex = function getEndIndex() {
      return this._end;
    };
    MonotoneChain.prototype.getStartIndex = function getStartIndex() {
      return this._start;
    };
    MonotoneChain.prototype.getContext = function getContext() {
      return this._context;
    };
    MonotoneChain.prototype.getId = function getId() {
      return this._id;
    };
    MonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {
      var p00 = this._pts[start0];
      var p01 = this._pts[end0];
      var p10 = mc._pts[start1];
      var p11 = mc._pts[end1];
      if (end0 - start0 === 1 && end1 - start1 === 1) {
        mco.overlap(this, start0, mc, start1);
        return null;
      }
      mco.tempEnv1.init(p00, p01);
      mco.tempEnv2.init(p10, p11);
      if (!mco.tempEnv1.intersects(mco.tempEnv2)) {
        return null;
      }
      var mid0 = Math.trunc((start0 + end0) / 2);
      var mid1 = Math.trunc((start1 + end1) / 2);
      if (start0 < mid0) {
        if (start1 < mid1) {
          this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);
        }
        if (mid1 < end1) {
          this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);
        }
      }
      if (mid0 < end0) {
        if (start1 < mid1) {
          this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);
        }
        if (mid1 < end1) {
          this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);
        }
      }
    };
    MonotoneChain.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MonotoneChain.prototype.getClass = function getClass() {
      return MonotoneChain;
    };
    var MonotoneChainBuilder = function MonotoneChainBuilder2() {
    };
    MonotoneChainBuilder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MonotoneChainBuilder.prototype.getClass = function getClass() {
      return MonotoneChainBuilder;
    };
    MonotoneChainBuilder.getChainStartIndices = function getChainStartIndices(pts) {
      var start = 0;
      var startIndexList = new ArrayList();
      startIndexList.add(new Integer(start));
      do {
        var last = MonotoneChainBuilder.findChainEnd(pts, start);
        startIndexList.add(new Integer(last));
        start = last;
      } while (start < pts.length - 1);
      var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
      return startIndex;
    };
    MonotoneChainBuilder.findChainEnd = function findChainEnd(pts, start) {
      var safeStart = start;
      while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
        safeStart++;
      }
      if (safeStart >= pts.length - 1) {
        return pts.length - 1;
      }
      var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
      var last = start + 1;
      while (last < pts.length) {
        if (!pts[last - 1].equals2D(pts[last])) {
          var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
          if (quad !== chainQuad) {
            break;
          }
        }
        last++;
      }
      return last - 1;
    };
    MonotoneChainBuilder.getChains = function getChains() {
      if (arguments.length === 1) {
        var pts = arguments[0];
        return MonotoneChainBuilder.getChains(pts, null);
      } else if (arguments.length === 2) {
        var pts$1 = arguments[0];
        var context = arguments[1];
        var mcList = new ArrayList();
        var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);
        for (var i = 0; i < startIndex.length - 1; i++) {
          var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);
          mcList.add(mc);
        }
        return mcList;
      }
    };
    MonotoneChainBuilder.toIntArray = function toIntArray(list) {
      var array = new Array(list.size()).fill(null);
      for (var i = 0; i < array.length; i++) {
        array[i] = list.get(i).intValue();
      }
      return array;
    };
    var Noder = function Noder2() {
    };
    Noder.prototype.computeNodes = function computeNodes(segStrings) {
    };
    Noder.prototype.getNodedSubstrings = function getNodedSubstrings() {
    };
    Noder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Noder.prototype.getClass = function getClass() {
      return Noder;
    };
    var SinglePassNoder = function SinglePassNoder2() {
      this._segInt = null;
      if (arguments.length === 0) {
      } else if (arguments.length === 1) {
        var segInt = arguments[0];
        this.setSegmentIntersector(segInt);
      }
    };
    SinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector(segInt) {
      this._segInt = segInt;
    };
    SinglePassNoder.prototype.interfaces_ = function interfaces_() {
      return [Noder];
    };
    SinglePassNoder.prototype.getClass = function getClass() {
      return SinglePassNoder;
    };
    var MCIndexNoder = function(SinglePassNoder$$1) {
      function MCIndexNoder2(si) {
        if (si) {
          SinglePassNoder$$1.call(this, si);
        } else {
          SinglePassNoder$$1.call(this);
        }
        this._monoChains = new ArrayList();
        this._index = new STRtree();
        this._idCounter = 0;
        this._nodedSegStrings = null;
        this._nOverlaps = 0;
      }
      if (SinglePassNoder$$1) MCIndexNoder2.__proto__ = SinglePassNoder$$1;
      MCIndexNoder2.prototype = Object.create(SinglePassNoder$$1 && SinglePassNoder$$1.prototype);
      MCIndexNoder2.prototype.constructor = MCIndexNoder2;
      var staticAccessors2 = { SegmentOverlapAction: { configurable: true } };
      MCIndexNoder2.prototype.getMonotoneChains = function getMonotoneChains() {
        return this._monoChains;
      };
      MCIndexNoder2.prototype.getNodedSubstrings = function getNodedSubstrings() {
        return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
      };
      MCIndexNoder2.prototype.getIndex = function getIndex() {
        return this._index;
      };
      MCIndexNoder2.prototype.add = function add(segStr) {
        var this$1 = this;
        var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
        for (var i = segChains.iterator(); i.hasNext(); ) {
          var mc = i.next();
          mc.setId(this$1._idCounter++);
          this$1._index.insert(mc.getEnvelope(), mc);
          this$1._monoChains.add(mc);
        }
      };
      MCIndexNoder2.prototype.computeNodes = function computeNodes(inputSegStrings) {
        var this$1 = this;
        this._nodedSegStrings = inputSegStrings;
        for (var i = inputSegStrings.iterator(); i.hasNext(); ) {
          this$1.add(i.next());
        }
        this.intersectChains();
      };
      MCIndexNoder2.prototype.intersectChains = function intersectChains() {
        var this$1 = this;
        var overlapAction = new SegmentOverlapAction(this._segInt);
        for (var i = this._monoChains.iterator(); i.hasNext(); ) {
          var queryChain = i.next();
          var overlapChains = this$1._index.query(queryChain.getEnvelope());
          for (var j = overlapChains.iterator(); j.hasNext(); ) {
            var testChain = j.next();
            if (testChain.getId() > queryChain.getId()) {
              queryChain.computeOverlaps(testChain, overlapAction);
              this$1._nOverlaps++;
            }
            if (this$1._segInt.isDone()) {
              return null;
            }
          }
        }
      };
      MCIndexNoder2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      MCIndexNoder2.prototype.getClass = function getClass() {
        return MCIndexNoder2;
      };
      staticAccessors2.SegmentOverlapAction.get = function() {
        return SegmentOverlapAction;
      };
      Object.defineProperties(MCIndexNoder2, staticAccessors2);
      return MCIndexNoder2;
    }(SinglePassNoder);
    var SegmentOverlapAction = function(MonotoneChainOverlapAction$$1) {
      function SegmentOverlapAction2() {
        MonotoneChainOverlapAction$$1.call(this);
        this._si = null;
        var si = arguments[0];
        this._si = si;
      }
      if (MonotoneChainOverlapAction$$1) SegmentOverlapAction2.__proto__ = MonotoneChainOverlapAction$$1;
      SegmentOverlapAction2.prototype = Object.create(MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype);
      SegmentOverlapAction2.prototype.constructor = SegmentOverlapAction2;
      SegmentOverlapAction2.prototype.overlap = function overlap() {
        if (arguments.length === 4) {
          var mc1 = arguments[0];
          var start1 = arguments[1];
          var mc2 = arguments[2];
          var start2 = arguments[3];
          var ss1 = mc1.getContext();
          var ss2 = mc2.getContext();
          this._si.processIntersections(ss1, start1, ss2, start2);
        } else {
          return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments);
        }
      };
      SegmentOverlapAction2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      SegmentOverlapAction2.prototype.getClass = function getClass() {
        return SegmentOverlapAction2;
      };
      return SegmentOverlapAction2;
    }(MonotoneChainOverlapAction);
    var BufferParameters = function BufferParameters2() {
      this._quadrantSegments = BufferParameters2.DEFAULT_QUADRANT_SEGMENTS;
      this._endCapStyle = BufferParameters2.CAP_ROUND;
      this._joinStyle = BufferParameters2.JOIN_ROUND;
      this._mitreLimit = BufferParameters2.DEFAULT_MITRE_LIMIT;
      this._isSingleSided = false;
      this._simplifyFactor = BufferParameters2.DEFAULT_SIMPLIFY_FACTOR;
      if (arguments.length === 0) {
      } else if (arguments.length === 1) {
        var quadrantSegments = arguments[0];
        this.setQuadrantSegments(quadrantSegments);
      } else if (arguments.length === 2) {
        var quadrantSegments$1 = arguments[0];
        var endCapStyle = arguments[1];
        this.setQuadrantSegments(quadrantSegments$1);
        this.setEndCapStyle(endCapStyle);
      } else if (arguments.length === 4) {
        var quadrantSegments$2 = arguments[0];
        var endCapStyle$1 = arguments[1];
        var joinStyle = arguments[2];
        var mitreLimit = arguments[3];
        this.setQuadrantSegments(quadrantSegments$2);
        this.setEndCapStyle(endCapStyle$1);
        this.setJoinStyle(joinStyle);
        this.setMitreLimit(mitreLimit);
      }
    };
    var staticAccessors$25 = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
    BufferParameters.prototype.getEndCapStyle = function getEndCapStyle() {
      return this._endCapStyle;
    };
    BufferParameters.prototype.isSingleSided = function isSingleSided() {
      return this._isSingleSided;
    };
    BufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments(quadSegs) {
      this._quadrantSegments = quadSegs;
      if (this._quadrantSegments === 0) {
        this._joinStyle = BufferParameters.JOIN_BEVEL;
      }
      if (this._quadrantSegments < 0) {
        this._joinStyle = BufferParameters.JOIN_MITRE;
        this._mitreLimit = Math.abs(this._quadrantSegments);
      }
      if (quadSegs <= 0) {
        this._quadrantSegments = 1;
      }
      if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
        this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
      }
    };
    BufferParameters.prototype.getJoinStyle = function getJoinStyle() {
      return this._joinStyle;
    };
    BufferParameters.prototype.setJoinStyle = function setJoinStyle(joinStyle) {
      this._joinStyle = joinStyle;
    };
    BufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor(simplifyFactor) {
      this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
    };
    BufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor() {
      return this._simplifyFactor;
    };
    BufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments() {
      return this._quadrantSegments;
    };
    BufferParameters.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {
      this._endCapStyle = endCapStyle;
    };
    BufferParameters.prototype.getMitreLimit = function getMitreLimit() {
      return this._mitreLimit;
    };
    BufferParameters.prototype.setMitreLimit = function setMitreLimit(mitreLimit) {
      this._mitreLimit = mitreLimit;
    };
    BufferParameters.prototype.setSingleSided = function setSingleSided(isSingleSided) {
      this._isSingleSided = isSingleSided;
    };
    BufferParameters.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BufferParameters.prototype.getClass = function getClass() {
      return BufferParameters;
    };
    BufferParameters.bufferDistanceError = function bufferDistanceError(quadSegs) {
      var alpha = Math.PI / 2 / quadSegs;
      return 1 - Math.cos(alpha / 2);
    };
    staticAccessors$25.CAP_ROUND.get = function() {
      return 1;
    };
    staticAccessors$25.CAP_FLAT.get = function() {
      return 2;
    };
    staticAccessors$25.CAP_SQUARE.get = function() {
      return 3;
    };
    staticAccessors$25.JOIN_ROUND.get = function() {
      return 1;
    };
    staticAccessors$25.JOIN_MITRE.get = function() {
      return 2;
    };
    staticAccessors$25.JOIN_BEVEL.get = function() {
      return 3;
    };
    staticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function() {
      return 8;
    };
    staticAccessors$25.DEFAULT_MITRE_LIMIT.get = function() {
      return 5;
    };
    staticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function() {
      return 0.01;
    };
    Object.defineProperties(BufferParameters, staticAccessors$25);
    var BufferInputLineSimplifier = function BufferInputLineSimplifier2(inputLine) {
      this._distanceTol = null;
      this._isDeleted = null;
      this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;
      this._inputLine = inputLine || null;
    };
    var staticAccessors$26 = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
    BufferInputLineSimplifier.prototype.isDeletable = function isDeletable(i0, i1, i2, distanceTol) {
      var p0 = this._inputLine[i0];
      var p1 = this._inputLine[i1];
      var p2 = this._inputLine[i2];
      if (!this.isConcave(p0, p1, p2)) {
        return false;
      }
      if (!this.isShallow(p0, p1, p2, distanceTol)) {
        return false;
      }
      return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
    };
    BufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities() {
      var this$1 = this;
      var index = 1;
      var midIndex = this.findNextNonDeletedIndex(index);
      var lastIndex = this.findNextNonDeletedIndex(midIndex);
      var isChanged = false;
      while (lastIndex < this._inputLine.length) {
        var isMiddleVertexDeleted = false;
        if (this$1.isDeletable(index, midIndex, lastIndex, this$1._distanceTol)) {
          this$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
          isMiddleVertexDeleted = true;
          isChanged = true;
        }
        if (isMiddleVertexDeleted) {
          index = lastIndex;
        } else {
          index = midIndex;
        }
        midIndex = this$1.findNextNonDeletedIndex(index);
        lastIndex = this$1.findNextNonDeletedIndex(midIndex);
      }
      return isChanged;
    };
    BufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity(p0, p1, p2, distanceTol) {
      var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
      var isAngleToSimplify = orientation === this._angleOrientation;
      if (!isAngleToSimplify) {
        return false;
      }
      var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
      return dist < distanceTol;
    };
    BufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled(p0, p2, i0, i2, distanceTol) {
      var this$1 = this;
      var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
      if (inc <= 0) {
        inc = 1;
      }
      for (var i = i0; i < i2; i += inc) {
        if (!this$1.isShallow(p0, p2, this$1._inputLine[i], distanceTol)) {
          return false;
        }
      }
      return true;
    };
    BufferInputLineSimplifier.prototype.isConcave = function isConcave(p0, p1, p2) {
      var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
      var isConcave2 = orientation === this._angleOrientation;
      return isConcave2;
    };
    BufferInputLineSimplifier.prototype.simplify = function simplify(distanceTol) {
      var this$1 = this;
      this._distanceTol = Math.abs(distanceTol);
      if (distanceTol < 0) {
        this._angleOrientation = CGAlgorithms.CLOCKWISE;
      }
      this._isDeleted = new Array(this._inputLine.length).fill(null);
      var isChanged = false;
      do {
        isChanged = this$1.deleteShallowConcavities();
      } while (isChanged);
      return this.collapseLine();
    };
    BufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex(index) {
      var next = index + 1;
      while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) {
        next++;
      }
      return next;
    };
    BufferInputLineSimplifier.prototype.isShallow = function isShallow(p0, p1, p2, distanceTol) {
      var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
      return dist < distanceTol;
    };
    BufferInputLineSimplifier.prototype.collapseLine = function collapseLine() {
      var this$1 = this;
      var coordList = new CoordinateList();
      for (var i = 0; i < this._inputLine.length; i++) {
        if (this$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) {
          coordList.add(this$1._inputLine[i]);
        }
      }
      return coordList.toCoordinateArray();
    };
    BufferInputLineSimplifier.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BufferInputLineSimplifier.prototype.getClass = function getClass() {
      return BufferInputLineSimplifier;
    };
    BufferInputLineSimplifier.simplify = function simplify(inputLine, distanceTol) {
      var simp = new BufferInputLineSimplifier(inputLine);
      return simp.simplify(distanceTol);
    };
    staticAccessors$26.INIT.get = function() {
      return 0;
    };
    staticAccessors$26.DELETE.get = function() {
      return 1;
    };
    staticAccessors$26.KEEP.get = function() {
      return 1;
    };
    staticAccessors$26.NUM_PTS_TO_CHECK.get = function() {
      return 10;
    };
    Object.defineProperties(BufferInputLineSimplifier, staticAccessors$26);
    var OffsetSegmentString = function OffsetSegmentString2() {
      this._ptList = null;
      this._precisionModel = null;
      this._minimimVertexDistance = 0;
      this._ptList = new ArrayList();
    };
    var staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };
    OffsetSegmentString.prototype.getCoordinates = function getCoordinates() {
      var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
      return coord;
    };
    OffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {
      this._precisionModel = precisionModel;
    };
    OffsetSegmentString.prototype.addPt = function addPt(pt) {
      var bufPt = new Coordinate(pt);
      this._precisionModel.makePrecise(bufPt);
      if (this.isRedundant(bufPt)) {
        return null;
      }
      this._ptList.add(bufPt);
    };
    OffsetSegmentString.prototype.revere = function revere() {
    };
    OffsetSegmentString.prototype.addPts = function addPts(pt, isForward) {
      var this$1 = this;
      if (isForward) {
        for (var i = 0; i < pt.length; i++) {
          this$1.addPt(pt[i]);
        }
      } else {
        for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {
          this$1.addPt(pt[i$1]);
        }
      }
    };
    OffsetSegmentString.prototype.isRedundant = function isRedundant(pt) {
      if (this._ptList.size() < 1) {
        return false;
      }
      var lastPt = this._ptList.get(this._ptList.size() - 1);
      var ptDist = pt.distance(lastPt);
      if (ptDist < this._minimimVertexDistance) {
        return true;
      }
      return false;
    };
    OffsetSegmentString.prototype.toString = function toString() {
      var fact = new GeometryFactory();
      var line = fact.createLineString(this.getCoordinates());
      return line.toString();
    };
    OffsetSegmentString.prototype.closeRing = function closeRing() {
      if (this._ptList.size() < 1) {
        return null;
      }
      var startPt = new Coordinate(this._ptList.get(0));
      var lastPt = this._ptList.get(this._ptList.size() - 1);
      if (startPt.equals(lastPt)) {
        return null;
      }
      this._ptList.add(startPt);
    };
    OffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance(minimimVertexDistance) {
      this._minimimVertexDistance = minimimVertexDistance;
    };
    OffsetSegmentString.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    OffsetSegmentString.prototype.getClass = function getClass() {
      return OffsetSegmentString;
    };
    staticAccessors$28.COORDINATE_ARRAY_TYPE.get = function() {
      return new Array(0).fill(null);
    };
    Object.defineProperties(OffsetSegmentString, staticAccessors$28);
    var Angle = function Angle2() {
    };
    var staticAccessors$29 = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
    Angle.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Angle.prototype.getClass = function getClass() {
      return Angle;
    };
    Angle.toDegrees = function toDegrees(radians) {
      return radians * 180 / Math.PI;
    };
    Angle.normalize = function normalize2(angle) {
      while (angle > Math.PI) {
        angle -= Angle.PI_TIMES_2;
      }
      while (angle <= -Math.PI) {
        angle += Angle.PI_TIMES_2;
      }
      return angle;
    };
    Angle.angle = function angle() {
      if (arguments.length === 1) {
        var p = arguments[0];
        return Math.atan2(p.y, p.x);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        return Math.atan2(dy, dx);
      }
    };
    Angle.isAcute = function isAcute(p0, p1, p2) {
      var dx0 = p0.x - p1.x;
      var dy0 = p0.y - p1.y;
      var dx1 = p2.x - p1.x;
      var dy1 = p2.y - p1.y;
      var dotprod = dx0 * dx1 + dy0 * dy1;
      return dotprod > 0;
    };
    Angle.isObtuse = function isObtuse(p0, p1, p2) {
      var dx0 = p0.x - p1.x;
      var dy0 = p0.y - p1.y;
      var dx1 = p2.x - p1.x;
      var dy1 = p2.y - p1.y;
      var dotprod = dx0 * dx1 + dy0 * dy1;
      return dotprod < 0;
    };
    Angle.interiorAngle = function interiorAngle(p0, p1, p2) {
      var anglePrev = Angle.angle(p1, p0);
      var angleNext = Angle.angle(p1, p2);
      return Math.abs(angleNext - anglePrev);
    };
    Angle.normalizePositive = function normalizePositive(angle) {
      if (angle < 0) {
        while (angle < 0) {
          angle += Angle.PI_TIMES_2;
        }
        if (angle >= Angle.PI_TIMES_2) {
          angle = 0;
        }
      } else {
        while (angle >= Angle.PI_TIMES_2) {
          angle -= Angle.PI_TIMES_2;
        }
        if (angle < 0) {
          angle = 0;
        }
      }
      return angle;
    };
    Angle.angleBetween = function angleBetween(tip1, tail, tip2) {
      var a1 = Angle.angle(tail, tip1);
      var a2 = Angle.angle(tail, tip2);
      return Angle.diff(a1, a2);
    };
    Angle.diff = function diff(ang1, ang2) {
      var delAngle = null;
      if (ang1 < ang2) {
        delAngle = ang2 - ang1;
      } else {
        delAngle = ang1 - ang2;
      }
      if (delAngle > Math.PI) {
        delAngle = 2 * Math.PI - delAngle;
      }
      return delAngle;
    };
    Angle.toRadians = function toRadians(angleDegrees) {
      return angleDegrees * Math.PI / 180;
    };
    Angle.getTurn = function getTurn(ang1, ang2) {
      var crossproduct = Math.sin(ang2 - ang1);
      if (crossproduct > 0) {
        return Angle.COUNTERCLOCKWISE;
      }
      if (crossproduct < 0) {
        return Angle.CLOCKWISE;
      }
      return Angle.NONE;
    };
    Angle.angleBetweenOriented = function angleBetweenOriented(tip1, tail, tip2) {
      var a1 = Angle.angle(tail, tip1);
      var a2 = Angle.angle(tail, tip2);
      var angDel = a2 - a1;
      if (angDel <= -Math.PI) {
        return angDel + Angle.PI_TIMES_2;
      }
      if (angDel > Math.PI) {
        return angDel - Angle.PI_TIMES_2;
      }
      return angDel;
    };
    staticAccessors$29.PI_TIMES_2.get = function() {
      return 2 * Math.PI;
    };
    staticAccessors$29.PI_OVER_2.get = function() {
      return Math.PI / 2;
    };
    staticAccessors$29.PI_OVER_4.get = function() {
      return Math.PI / 4;
    };
    staticAccessors$29.COUNTERCLOCKWISE.get = function() {
      return CGAlgorithms.COUNTERCLOCKWISE;
    };
    staticAccessors$29.CLOCKWISE.get = function() {
      return CGAlgorithms.CLOCKWISE;
    };
    staticAccessors$29.NONE.get = function() {
      return CGAlgorithms.COLLINEAR;
    };
    Object.defineProperties(Angle, staticAccessors$29);
    var OffsetSegmentGenerator = function OffsetSegmentGenerator2() {
      this._maxCurveSegmentError = 0;
      this._filletAngleQuantum = null;
      this._closingSegLengthFactor = 1;
      this._segList = null;
      this._distance = 0;
      this._precisionModel = null;
      this._bufParams = null;
      this._li = null;
      this._s0 = null;
      this._s1 = null;
      this._s2 = null;
      this._seg0 = new LineSegment();
      this._seg1 = new LineSegment();
      this._offset0 = new LineSegment();
      this._offset1 = new LineSegment();
      this._side = 0;
      this._hasNarrowConcaveAngle = false;
      var precisionModel = arguments[0];
      var bufParams = arguments[1];
      var distance = arguments[2];
      this._precisionModel = precisionModel;
      this._bufParams = bufParams;
      this._li = new RobustLineIntersector();
      this._filletAngleQuantum = Math.PI / 2 / bufParams.getQuadrantSegments();
      if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) {
        this._closingSegLengthFactor = OffsetSegmentGenerator2.MAX_CLOSING_SEG_LEN_FACTOR;
      }
      this.init(distance);
    };
    var staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
    OffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment(p, addStartPoint) {
      this._s0 = this._s1;
      this._s1 = this._s2;
      this._s2 = p;
      this._seg0.setCoordinates(this._s0, this._s1);
      this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
      this._seg1.setCoordinates(this._s1, this._s2);
      this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
      if (this._s1.equals(this._s2)) {
        return null;
      }
      var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);
      var outsideTurn = orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;
      if (orientation === 0) {
        this.addCollinear(addStartPoint);
      } else if (outsideTurn) {
        this.addOutsideTurn(orientation, addStartPoint);
      } else {
        this.addInsideTurn(orientation, addStartPoint);
      }
    };
    OffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap(p0, p1) {
      var seg = new LineSegment(p0, p1);
      var offsetL = new LineSegment();
      this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
      var offsetR = new LineSegment();
      this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;
      var angle = Math.atan2(dy, dx);
      switch (this._bufParams.getEndCapStyle()) {
        case BufferParameters.CAP_ROUND:
          this._segList.addPt(offsetL.p1);
          this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);
          this._segList.addPt(offsetR.p1);
          break;
        case BufferParameters.CAP_FLAT:
          this._segList.addPt(offsetL.p1);
          this._segList.addPt(offsetR.p1);
          break;
        case BufferParameters.CAP_SQUARE:
          var squareCapSideOffset = new Coordinate();
          squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
          squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
          var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
          var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
          this._segList.addPt(squareCapLOffset);
          this._segList.addPt(squareCapROffset);
          break;
        default:
      }
    };
    OffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates() {
      var pts = this._segList.getCoordinates();
      return pts;
    };
    OffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin(p, offset0, offset1, distance) {
      var isMitreWithinLimit = true;
      var intPt = null;
      try {
        intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
        var mitreRatio = distance <= 0 ? 1 : intPt.distance(p) / Math.abs(distance);
        if (mitreRatio > this._bufParams.getMitreLimit()) {
          isMitreWithinLimit = false;
        }
      } catch (ex) {
        if (ex instanceof NotRepresentableException) {
          intPt = new Coordinate(0, 0);
          isMitreWithinLimit = false;
        } else {
          throw ex;
        }
      } finally {
      }
      if (isMitreWithinLimit) {
        this._segList.addPt(intPt);
      } else {
        this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
      }
    };
    OffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner(p, p0, p1, direction, radius) {
      var dx0 = p0.x - p.x;
      var dy0 = p0.y - p.y;
      var startAngle = Math.atan2(dy0, dx0);
      var dx1 = p1.x - p.x;
      var dy1 = p1.y - p.y;
      var endAngle = Math.atan2(dy1, dx1);
      if (direction === CGAlgorithms.CLOCKWISE) {
        if (startAngle <= endAngle) {
          startAngle += 2 * Math.PI;
        }
      } else {
        if (startAngle >= endAngle) {
          startAngle -= 2 * Math.PI;
        }
      }
      this._segList.addPt(p0);
      this.addFilletArc(p, startAngle, endAngle, direction, radius);
      this._segList.addPt(p1);
    };
    OffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn(orientation, addStartPoint) {
      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
        this._segList.addPt(this._offset0.p1);
        return null;
      }
      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
        this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
      } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
        this.addBevelJoin(this._offset0, this._offset1);
      } else {
        if (addStartPoint) {
          this._segList.addPt(this._offset0.p1);
        }
        this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
        this._segList.addPt(this._offset1.p0);
      }
    };
    OffsetSegmentGenerator.prototype.createSquare = function createSquare(p) {
      this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
      this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
      this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
      this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
      this._segList.closeRing();
    };
    OffsetSegmentGenerator.prototype.addSegments = function addSegments(pt, isForward) {
      this._segList.addPts(pt, isForward);
    };
    OffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment() {
      this._segList.addPt(this._offset1.p0);
    };
    OffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment() {
      this._segList.addPt(this._offset1.p1);
    };
    OffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments(s1, s2, side) {
      this._s1 = s1;
      this._s2 = s2;
      this._side = side;
      this._seg1.setCoordinates(s1, s2);
      this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
    };
    OffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {
      var basePt = this._seg0.p1;
      var ang0 = Angle.angle(basePt, this._seg0.p0);
      var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
      var angDiffHalf = angDiff / 2;
      var midAng = Angle.normalize(ang0 + angDiffHalf);
      var mitreMidAng = Angle.normalize(midAng + Math.PI);
      var mitreDist = mitreLimit * distance;
      var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
      var bevelHalfLen = distance - bevelDelta;
      var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
      var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
      var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
      var mitreMidLine = new LineSegment(basePt, bevelMidPt);
      var bevelEndLeft = mitreMidLine.pointAlongOffset(1, bevelHalfLen);
      var bevelEndRight = mitreMidLine.pointAlongOffset(1, -bevelHalfLen);
      if (this._side === Position.LEFT) {
        this._segList.addPt(bevelEndLeft);
        this._segList.addPt(bevelEndRight);
      } else {
        this._segList.addPt(bevelEndRight);
        this._segList.addPt(bevelEndLeft);
      }
    };
    OffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment(seg, side, distance, offset) {
      var sideSign = side === Position.LEFT ? 1 : -1;
      var dx = seg.p1.x - seg.p0.x;
      var dy = seg.p1.y - seg.p0.y;
      var len = Math.sqrt(dx * dx + dy * dy);
      var ux = sideSign * distance * dx / len;
      var uy = sideSign * distance * dy / len;
      offset.p0.x = seg.p0.x - uy;
      offset.p0.y = seg.p0.y + ux;
      offset.p1.x = seg.p1.x - uy;
      offset.p1.y = seg.p1.y + ux;
    };
    OffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc(p, startAngle, endAngle, direction, radius) {
      var this$1 = this;
      var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;
      var totalAngle = Math.abs(startAngle - endAngle);
      var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
      if (nSegs < 1) {
        return null;
      }
      var initAngle = 0;
      var currAngleInc = totalAngle / nSegs;
      var currAngle = initAngle;
      var pt = new Coordinate();
      while (currAngle < totalAngle) {
        var angle = startAngle + directionFactor * currAngle;
        pt.x = p.x + radius * Math.cos(angle);
        pt.y = p.y + radius * Math.sin(angle);
        this$1._segList.addPt(pt);
        currAngle += currAngleInc;
      }
    };
    OffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn(orientation, addStartPoint) {
      this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
      if (this._li.hasIntersection()) {
        this._segList.addPt(this._li.getIntersection(0));
      } else {
        this._hasNarrowConcaveAngle = true;
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
          this._segList.addPt(this._offset0.p1);
        } else {
          this._segList.addPt(this._offset0.p1);
          if (this._closingSegLengthFactor > 0) {
            var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(mid0);
            var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(mid1);
          } else {
            this._segList.addPt(this._s1);
          }
          this._segList.addPt(this._offset1.p0);
        }
      }
    };
    OffsetSegmentGenerator.prototype.createCircle = function createCircle(p) {
      var pt = new Coordinate(p.x + this._distance, p.y);
      this._segList.addPt(pt);
      this.addFilletArc(p, 0, 2 * Math.PI, -1, this._distance);
      this._segList.closeRing();
    };
    OffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin(offset0, offset1) {
      this._segList.addPt(offset0.p1);
      this._segList.addPt(offset1.p0);
    };
    OffsetSegmentGenerator.prototype.init = function init(distance) {
      this._distance = distance;
      this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2));
      this._segList = new OffsetSegmentString();
      this._segList.setPrecisionModel(this._precisionModel);
      this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
    };
    OffsetSegmentGenerator.prototype.addCollinear = function addCollinear(addStartPoint) {
      this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
      var numInt = this._li.getIntersectionNum();
      if (numInt >= 2) {
        if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
          if (addStartPoint) {
            this._segList.addPt(this._offset0.p1);
          }
          this._segList.addPt(this._offset1.p0);
        } else {
          this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);
        }
      }
    };
    OffsetSegmentGenerator.prototype.closeRing = function closeRing() {
      this._segList.closeRing();
    };
    OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle() {
      return this._hasNarrowConcaveAngle;
    };
    OffsetSegmentGenerator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    OffsetSegmentGenerator.prototype.getClass = function getClass() {
      return OffsetSegmentGenerator;
    };
    staticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
      return 1e-3;
    };
    staticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
      return 1e-3;
    };
    staticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
      return 1e-6;
    };
    staticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
      return 80;
    };
    Object.defineProperties(OffsetSegmentGenerator, staticAccessors$27);
    var OffsetCurveBuilder = function OffsetCurveBuilder2() {
      this._distance = 0;
      this._precisionModel = null;
      this._bufParams = null;
      var precisionModel = arguments[0];
      var bufParams = arguments[1];
      this._precisionModel = precisionModel;
      this._bufParams = bufParams;
    };
    OffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve(inputPts, distance) {
      this._distance = distance;
      if (distance === 0) {
        return null;
      }
      var isRightSide = distance < 0;
      var posDistance = Math.abs(distance);
      var segGen = this.getSegGen(posDistance);
      if (inputPts.length <= 1) {
        this.computePointCurve(inputPts[0], segGen);
      } else {
        this.computeOffsetCurve(inputPts, isRightSide, segGen);
      }
      var curvePts = segGen.getCoordinates();
      if (isRightSide) {
        CoordinateArrays.reverse(curvePts);
      }
      return curvePts;
    };
    OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      if (isRightSide) {
        segGen.addSegments(inputPts, true);
        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
        var n2 = simp2.length - 1;
        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
        segGen.addFirstSegment();
        for (var i = n2 - 2; i >= 0; i--) {
          segGen.addNextSegment(simp2[i], true);
        }
      } else {
        segGen.addSegments(inputPts, false);
        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
        var n1 = simp1.length - 1;
        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
        segGen.addFirstSegment();
        for (var i$1 = 2; i$1 <= n1; i$1++) {
          segGen.addNextSegment(simp1[i$1], true);
        }
      }
      segGen.addLastSegment();
      segGen.closeRing();
    };
    OffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve(inputPts, side, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      if (side === Position.RIGHT) {
        distTol = -distTol;
      }
      var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
      var n = simp.length - 1;
      segGen.initSideSegments(simp[n - 1], simp[0], side);
      for (var i = 1; i <= n; i++) {
        var addStartPoint = i !== 1;
        segGen.addNextSegment(simp[i], addStartPoint);
      }
      segGen.closeRing();
    };
    OffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve(inputPts, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
      var n1 = simp1.length - 1;
      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
      for (var i = 2; i <= n1; i++) {
        segGen.addNextSegment(simp1[i], true);
      }
      segGen.addLastSegment();
      segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
      var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
      var n2 = simp2.length - 1;
      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
      for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {
        segGen.addNextSegment(simp2[i$1], true);
      }
      segGen.addLastSegment();
      segGen.addLineEndCap(simp2[1], simp2[0]);
      segGen.closeRing();
    };
    OffsetCurveBuilder.prototype.computePointCurve = function computePointCurve(pt, segGen) {
      switch (this._bufParams.getEndCapStyle()) {
        case BufferParameters.CAP_ROUND:
          segGen.createCircle(pt);
          break;
        case BufferParameters.CAP_SQUARE:
          segGen.createSquare(pt);
          break;
        default:
      }
    };
    OffsetCurveBuilder.prototype.getLineCurve = function getLineCurve(inputPts, distance) {
      this._distance = distance;
      if (distance < 0 && !this._bufParams.isSingleSided()) {
        return null;
      }
      if (distance === 0) {
        return null;
      }
      var posDistance = Math.abs(distance);
      var segGen = this.getSegGen(posDistance);
      if (inputPts.length <= 1) {
        this.computePointCurve(inputPts[0], segGen);
      } else {
        if (this._bufParams.isSingleSided()) {
          var isRightSide = distance < 0;
          this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
        } else {
          this.computeLineBufferCurve(inputPts, segGen);
        }
      }
      var lineCoord = segGen.getCoordinates();
      return lineCoord;
    };
    OffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters() {
      return this._bufParams;
    };
    OffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance(bufDistance) {
      return bufDistance * this._bufParams.getSimplifyFactor();
    };
    OffsetCurveBuilder.prototype.getRingCurve = function getRingCurve(inputPts, side, distance) {
      this._distance = distance;
      if (inputPts.length <= 2) {
        return this.getLineCurve(inputPts, distance);
      }
      if (distance === 0) {
        return OffsetCurveBuilder.copyCoordinates(inputPts);
      }
      var segGen = this.getSegGen(distance);
      this.computeRingBufferCurve(inputPts, side, segGen);
      return segGen.getCoordinates();
    };
    OffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve(inputPts, isRightSide, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      if (isRightSide) {
        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
        var n2 = simp2.length - 1;
        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
        segGen.addFirstSegment();
        for (var i = n2 - 2; i >= 0; i--) {
          segGen.addNextSegment(simp2[i], true);
        }
      } else {
        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
        var n1 = simp1.length - 1;
        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
        segGen.addFirstSegment();
        for (var i$1 = 2; i$1 <= n1; i$1++) {
          segGen.addNextSegment(simp1[i$1], true);
        }
      }
      segGen.addLastSegment();
    };
    OffsetCurveBuilder.prototype.getSegGen = function getSegGen(distance) {
      return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);
    };
    OffsetCurveBuilder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    OffsetCurveBuilder.prototype.getClass = function getClass() {
      return OffsetCurveBuilder;
    };
    OffsetCurveBuilder.copyCoordinates = function copyCoordinates(pts) {
      var copy = new Array(pts.length).fill(null);
      for (var i = 0; i < copy.length; i++) {
        copy[i] = new Coordinate(pts[i]);
      }
      return copy;
    };
    var SubgraphDepthLocater = function SubgraphDepthLocater2() {
      this._subgraphs = null;
      this._seg = new LineSegment();
      this._cga = new CGAlgorithms();
      var subgraphs = arguments[0];
      this._subgraphs = subgraphs;
    };
    var staticAccessors$30 = { DepthSegment: { configurable: true } };
    SubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments() {
      var this$1 = this;
      if (arguments.length === 1) {
        var stabbingRayLeftPt = arguments[0];
        var stabbedSegments = new ArrayList();
        for (var i = this._subgraphs.iterator(); i.hasNext(); ) {
          var bsg = i.next();
          var env = bsg.getEnvelope();
          if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) {
            continue;
          }
          this$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
        }
        return stabbedSegments;
      } else if (arguments.length === 3) {
        if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {
          var stabbingRayLeftPt$1 = arguments[0];
          var dirEdge = arguments[1];
          var stabbedSegments$1 = arguments[2];
          var pts = dirEdge.getEdge().getCoordinates();
          for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {
            this$1._seg.p0 = pts[i$1];
            this$1._seg.p1 = pts[i$1 + 1];
            if (this$1._seg.p0.y > this$1._seg.p1.y) {
              this$1._seg.reverse();
            }
            var maxx = Math.max(this$1._seg.p0.x, this$1._seg.p1.x);
            if (maxx < stabbingRayLeftPt$1.x) {
              continue;
            }
            if (this$1._seg.isHorizontal()) {
              continue;
            }
            if (stabbingRayLeftPt$1.y < this$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1._seg.p1.y) {
              continue;
            }
            if (CGAlgorithms.computeOrientation(this$1._seg.p0, this$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) {
              continue;
            }
            var depth = dirEdge.getDepth(Position.LEFT);
            if (!this$1._seg.p0.equals(pts[i$1])) {
              depth = dirEdge.getDepth(Position.RIGHT);
            }
            var ds = new DepthSegment(this$1._seg, depth);
            stabbedSegments$1.add(ds);
          }
        } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {
          var stabbingRayLeftPt$2 = arguments[0];
          var dirEdges = arguments[1];
          var stabbedSegments$2 = arguments[2];
          for (var i$2 = dirEdges.iterator(); i$2.hasNext(); ) {
            var de = i$2.next();
            if (!de.isForward()) {
              continue;
            }
            this$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);
          }
        }
      }
    };
    SubgraphDepthLocater.prototype.getDepth = function getDepth(p) {
      var stabbedSegments = this.findStabbedSegments(p);
      if (stabbedSegments.size() === 0) {
        return 0;
      }
      var ds = Collections.min(stabbedSegments);
      return ds._leftDepth;
    };
    SubgraphDepthLocater.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SubgraphDepthLocater.prototype.getClass = function getClass() {
      return SubgraphDepthLocater;
    };
    staticAccessors$30.DepthSegment.get = function() {
      return DepthSegment;
    };
    Object.defineProperties(SubgraphDepthLocater, staticAccessors$30);
    var DepthSegment = function DepthSegment2() {
      this._upwardSeg = null;
      this._leftDepth = null;
      var seg = arguments[0];
      var depth = arguments[1];
      this._upwardSeg = new LineSegment(seg);
      this._leftDepth = depth;
    };
    DepthSegment.prototype.compareTo = function compareTo(obj) {
      var other = obj;
      if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) {
        return 1;
      }
      if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) {
        return -1;
      }
      var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
      if (orientIndex !== 0) {
        return orientIndex;
      }
      orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
      if (orientIndex !== 0) {
        return orientIndex;
      }
      return this._upwardSeg.compareTo(other._upwardSeg);
    };
    DepthSegment.prototype.compareX = function compareX(seg0, seg1) {
      var compare0 = seg0.p0.compareTo(seg1.p0);
      if (compare0 !== 0) {
        return compare0;
      }
      return seg0.p1.compareTo(seg1.p1);
    };
    DepthSegment.prototype.toString = function toString() {
      return this._upwardSeg.toString();
    };
    DepthSegment.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    DepthSegment.prototype.getClass = function getClass() {
      return DepthSegment;
    };
    var Triangle = function Triangle2(p0, p1, p2) {
      this.p0 = p0 || null;
      this.p1 = p1 || null;
      this.p2 = p2 || null;
    };
    Triangle.prototype.area = function area() {
      return Triangle.area(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.signedArea = function signedArea() {
      return Triangle.signedArea(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.interpolateZ = function interpolateZ(p) {
      if (p === null) {
        throw new IllegalArgumentException("Supplied point is null.");
      }
      return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);
    };
    Triangle.prototype.longestSideLength = function longestSideLength() {
      return Triangle.longestSideLength(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.isAcute = function isAcute() {
      return Triangle.isAcute(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.circumcentre = function circumcentre() {
      return Triangle.circumcentre(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.area3D = function area3D() {
      return Triangle.area3D(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.centroid = function centroid() {
      return Triangle.centroid(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.inCentre = function inCentre() {
      return Triangle.inCentre(this.p0, this.p1, this.p2);
    };
    Triangle.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Triangle.prototype.getClass = function getClass() {
      return Triangle;
    };
    Triangle.area = function area(a, b, c) {
      return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
    };
    Triangle.signedArea = function signedArea(a, b, c) {
      return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
    };
    Triangle.det = function det(m00, m01, m10, m11) {
      return m00 * m11 - m01 * m10;
    };
    Triangle.interpolateZ = function interpolateZ(p, v0, v12, v2) {
      var x0 = v0.x;
      var y0 = v0.y;
      var a = v12.x - x0;
      var b = v2.x - x0;
      var c = v12.y - y0;
      var d = v2.y - y0;
      var det = a * d - b * c;
      var dx = p.x - x0;
      var dy = p.y - y0;
      var t = (d * dx - b * dy) / det;
      var u = (-c * dx + a * dy) / det;
      var z = v0.z + t * (v12.z - v0.z) + u * (v2.z - v0.z);
      return z;
    };
    Triangle.longestSideLength = function longestSideLength(a, b, c) {
      var lenAB = a.distance(b);
      var lenBC = b.distance(c);
      var lenCA = c.distance(a);
      var maxLen = lenAB;
      if (lenBC > maxLen) {
        maxLen = lenBC;
      }
      if (lenCA > maxLen) {
        maxLen = lenCA;
      }
      return maxLen;
    };
    Triangle.isAcute = function isAcute(a, b, c) {
      if (!Angle.isAcute(a, b, c)) {
        return false;
      }
      if (!Angle.isAcute(b, c, a)) {
        return false;
      }
      if (!Angle.isAcute(c, a, b)) {
        return false;
      }
      return true;
    };
    Triangle.circumcentre = function circumcentre(a, b, c) {
      var cx = c.x;
      var cy = c.y;
      var ax = a.x - cx;
      var ay = a.y - cy;
      var bx = b.x - cx;
      var by = b.y - cy;
      var denom = 2 * Triangle.det(ax, ay, bx, by);
      var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
      var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
      var ccx = cx - numx / denom;
      var ccy = cy + numy / denom;
      return new Coordinate(ccx, ccy);
    };
    Triangle.perpendicularBisector = function perpendicularBisector(a, b) {
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      var l1 = new HCoordinate(a.x + dx / 2, a.y + dy / 2, 1);
      var l2 = new HCoordinate(a.x - dy + dx / 2, a.y + dx + dy / 2, 1);
      return new HCoordinate(l1, l2);
    };
    Triangle.angleBisector = function angleBisector(a, b, c) {
      var len0 = b.distance(a);
      var len2 = b.distance(c);
      var frac = len0 / (len0 + len2);
      var dx = c.x - a.x;
      var dy = c.y - a.y;
      var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
      return splitPt;
    };
    Triangle.area3D = function area3D(a, b, c) {
      var ux = b.x - a.x;
      var uy = b.y - a.y;
      var uz = b.z - a.z;
      var vx = c.x - a.x;
      var vy = c.y - a.y;
      var vz = c.z - a.z;
      var crossx = uy * vz - uz * vy;
      var crossy = uz * vx - ux * vz;
      var crossz = ux * vy - uy * vx;
      var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
      var area3D2 = Math.sqrt(absSq) / 2;
      return area3D2;
    };
    Triangle.centroid = function centroid(a, b, c) {
      var x = (a.x + b.x + c.x) / 3;
      var y = (a.y + b.y + c.y) / 3;
      return new Coordinate(x, y);
    };
    Triangle.inCentre = function inCentre(a, b, c) {
      var len0 = b.distance(c);
      var len1 = a.distance(c);
      var len2 = a.distance(b);
      var circum = len0 + len1 + len2;
      var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
      var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
      return new Coordinate(inCentreX, inCentreY);
    };
    var OffsetCurveSetBuilder = function OffsetCurveSetBuilder2() {
      this._inputGeom = null;
      this._distance = null;
      this._curveBuilder = null;
      this._curveList = new ArrayList();
      var inputGeom = arguments[0];
      var distance = arguments[1];
      var curveBuilder = arguments[2];
      this._inputGeom = inputGeom;
      this._distance = distance;
      this._curveBuilder = curveBuilder;
    };
    OffsetCurveSetBuilder.prototype.addPoint = function addPoint(p) {
      if (this._distance <= 0) {
        return null;
      }
      var coord = p.getCoordinates();
      var curve = this._curveBuilder.getLineCurve(coord, this._distance);
      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
    };
    OffsetCurveSetBuilder.prototype.addPolygon = function addPolygon(p) {
      var this$1 = this;
      var offsetDistance = this._distance;
      var offsetSide = Position.LEFT;
      if (this._distance < 0) {
        offsetDistance = -this._distance;
        offsetSide = Position.RIGHT;
      }
      var shell = p.getExteriorRing();
      var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
      if (this._distance < 0 && this.isErodedCompletely(shell, this._distance)) {
        return null;
      }
      if (this._distance <= 0 && shellCoord.length < 3) {
        return null;
      }
      this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
      for (var i = 0; i < p.getNumInteriorRing(); i++) {
        var hole = p.getInteriorRingN(i);
        var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
        if (this$1._distance > 0 && this$1.isErodedCompletely(hole, -this$1._distance)) {
          continue;
        }
        this$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
      }
    };
    OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely(triangleCoord, bufferDistance) {
      var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
      var inCentre = tri.inCentre();
      var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);
      return distToCentre < Math.abs(bufferDistance);
    };
    OffsetCurveSetBuilder.prototype.addLineString = function addLineString(line) {
      if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) {
        return null;
      }
      var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
      var curve = this._curveBuilder.getLineCurve(coord, this._distance);
      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
    };
    OffsetCurveSetBuilder.prototype.addCurve = function addCurve(coord, leftLoc, rightLoc) {
      if (coord === null || coord.length < 2) {
        return null;
      }
      var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
      this._curveList.add(e);
    };
    OffsetCurveSetBuilder.prototype.getCurves = function getCurves() {
      this.add(this._inputGeom);
      return this._curveList;
    };
    OffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
      if (offsetDistance === 0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) {
        return null;
      }
      var leftLoc = cwLeftLoc;
      var rightLoc = cwRightLoc;
      if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {
        leftLoc = cwRightLoc;
        rightLoc = cwLeftLoc;
        side = Position.opposite(side);
      }
      var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
      this.addCurve(curve, leftLoc, rightLoc);
    };
    OffsetCurveSetBuilder.prototype.add = function add(g) {
      if (g.isEmpty()) {
        return null;
      }
      if (g instanceof Polygon) {
        this.addPolygon(g);
      } else if (g instanceof LineString) {
        this.addLineString(g);
      } else if (g instanceof Point) {
        this.addPoint(g);
      } else if (g instanceof MultiPoint) {
        this.addCollection(g);
      } else if (g instanceof MultiLineString) {
        this.addCollection(g);
      } else if (g instanceof MultiPolygon) {
        this.addCollection(g);
      } else if (g instanceof GeometryCollection) {
        this.addCollection(g);
      }
    };
    OffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely(ring, bufferDistance) {
      var ringCoord = ring.getCoordinates();
      if (ringCoord.length < 4) {
        return bufferDistance < 0;
      }
      if (ringCoord.length === 4) {
        return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
      }
      var env = ring.getEnvelopeInternal();
      var envMinDimension = Math.min(env.getHeight(), env.getWidth());
      if (bufferDistance < 0 && 2 * Math.abs(bufferDistance) > envMinDimension) {
        return true;
      }
      return false;
    };
    OffsetCurveSetBuilder.prototype.addCollection = function addCollection(gc) {
      var this$1 = this;
      for (var i = 0; i < gc.getNumGeometries(); i++) {
        var g = gc.getGeometryN(i);
        this$1.add(g);
      }
    };
    OffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    OffsetCurveSetBuilder.prototype.getClass = function getClass() {
      return OffsetCurveSetBuilder;
    };
    var PointOnGeometryLocator = function PointOnGeometryLocator2() {
    };
    PointOnGeometryLocator.prototype.locate = function locate(p) {
    };
    PointOnGeometryLocator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PointOnGeometryLocator.prototype.getClass = function getClass() {
      return PointOnGeometryLocator;
    };
    var GeometryCollectionIterator = function GeometryCollectionIterator2() {
      this._parent = null;
      this._atStart = null;
      this._max = null;
      this._index = null;
      this._subcollectionIterator = null;
      var parent = arguments[0];
      this._parent = parent;
      this._atStart = true;
      this._index = 0;
      this._max = parent.getNumGeometries();
    };
    GeometryCollectionIterator.prototype.next = function next() {
      if (this._atStart) {
        this._atStart = false;
        if (GeometryCollectionIterator.isAtomic(this._parent)) {
          this._index++;
        }
        return this._parent;
      }
      if (this._subcollectionIterator !== null) {
        if (this._subcollectionIterator.hasNext()) {
          return this._subcollectionIterator.next();
        } else {
          this._subcollectionIterator = null;
        }
      }
      if (this._index >= this._max) {
        throw new NoSuchElementException();
      }
      var obj = this._parent.getGeometryN(this._index++);
      if (obj instanceof GeometryCollection) {
        this._subcollectionIterator = new GeometryCollectionIterator(obj);
        return this._subcollectionIterator.next();
      }
      return obj;
    };
    GeometryCollectionIterator.prototype.remove = function remove() {
      throw new Error(this.getClass().getName());
    };
    GeometryCollectionIterator.prototype.hasNext = function hasNext() {
      if (this._atStart) {
        return true;
      }
      if (this._subcollectionIterator !== null) {
        if (this._subcollectionIterator.hasNext()) {
          return true;
        }
        this._subcollectionIterator = null;
      }
      if (this._index >= this._max) {
        return false;
      }
      return true;
    };
    GeometryCollectionIterator.prototype.interfaces_ = function interfaces_() {
      return [Iterator];
    };
    GeometryCollectionIterator.prototype.getClass = function getClass() {
      return GeometryCollectionIterator;
    };
    GeometryCollectionIterator.isAtomic = function isAtomic(geom) {
      return !(geom instanceof GeometryCollection);
    };
    var SimplePointInAreaLocator = function SimplePointInAreaLocator2() {
      this._geom = null;
      var geom = arguments[0];
      this._geom = geom;
    };
    SimplePointInAreaLocator.prototype.locate = function locate(p) {
      return SimplePointInAreaLocator.locate(p, this._geom);
    };
    SimplePointInAreaLocator.prototype.interfaces_ = function interfaces_() {
      return [PointOnGeometryLocator];
    };
    SimplePointInAreaLocator.prototype.getClass = function getClass() {
      return SimplePointInAreaLocator;
    };
    SimplePointInAreaLocator.isPointInRing = function isPointInRing(p, ring) {
      if (!ring.getEnvelopeInternal().intersects(p)) {
        return false;
      }
      return CGAlgorithms.isPointInRing(p, ring.getCoordinates());
    };
    SimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon(p, poly) {
      if (poly.isEmpty()) {
        return false;
      }
      var shell = poly.getExteriorRing();
      if (!SimplePointInAreaLocator.isPointInRing(p, shell)) {
        return false;
      }
      for (var i = 0; i < poly.getNumInteriorRing(); i++) {
        var hole = poly.getInteriorRingN(i);
        if (SimplePointInAreaLocator.isPointInRing(p, hole)) {
          return false;
        }
      }
      return true;
    };
    SimplePointInAreaLocator.containsPoint = function containsPoint(p, geom) {
      if (geom instanceof Polygon) {
        return SimplePointInAreaLocator.containsPointInPolygon(p, geom);
      } else if (geom instanceof GeometryCollection) {
        var geomi = new GeometryCollectionIterator(geom);
        while (geomi.hasNext()) {
          var g2 = geomi.next();
          if (g2 !== geom) {
            if (SimplePointInAreaLocator.containsPoint(p, g2)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    SimplePointInAreaLocator.locate = function locate(p, geom) {
      if (geom.isEmpty()) {
        return Location.EXTERIOR;
      }
      if (SimplePointInAreaLocator.containsPoint(p, geom)) {
        return Location.INTERIOR;
      }
      return Location.EXTERIOR;
    };
    var EdgeEndStar = function EdgeEndStar2() {
      this._edgeMap = new TreeMap();
      this._edgeList = null;
      this._ptInAreaLocation = [Location.NONE, Location.NONE];
    };
    EdgeEndStar.prototype.getNextCW = function getNextCW(ee) {
      this.getEdges();
      var i = this._edgeList.indexOf(ee);
      var iNextCW = i - 1;
      if (i === 0) {
        iNextCW = this._edgeList.size() - 1;
      }
      return this._edgeList.get(iNextCW);
    };
    EdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels(geomIndex) {
      var startLoc = Location.NONE;
      for (var it = this.iterator(); it.hasNext(); ) {
        var e = it.next();
        var label = e.getLabel();
        if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) {
          startLoc = label.getLocation(geomIndex, Position.LEFT);
        }
      }
      if (startLoc === Location.NONE) {
        return null;
      }
      var currLoc = startLoc;
      for (var it$1 = this.iterator(); it$1.hasNext(); ) {
        var e$1 = it$1.next();
        var label$1 = e$1.getLabel();
        if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) {
          label$1.setLocation(geomIndex, Position.ON, currLoc);
        }
        if (label$1.isArea(geomIndex)) {
          var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);
          var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);
          if (rightLoc !== Location.NONE) {
            if (rightLoc !== currLoc) {
              throw new TopologyException("side location conflict", e$1.getCoordinate());
            }
            if (leftLoc === Location.NONE) {
              Assert.shouldNeverReachHere("found single null side (at " + e$1.getCoordinate() + ")");
            }
            currLoc = leftLoc;
          } else {
            Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, "found single null side");
            label$1.setLocation(geomIndex, Position.RIGHT, currLoc);
            label$1.setLocation(geomIndex, Position.LEFT, currLoc);
          }
        }
      }
    };
    EdgeEndStar.prototype.getCoordinate = function getCoordinate() {
      var it = this.iterator();
      if (!it.hasNext()) {
        return null;
      }
      var e = it.next();
      return e.getCoordinate();
    };
    EdgeEndStar.prototype.print = function print(out) {
      System.out.println("EdgeEndStar:   " + this.getCoordinate());
      for (var it = this.iterator(); it.hasNext(); ) {
        var e = it.next();
        e.print(out);
      }
    };
    EdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent(geomGraph) {
      this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
      return this.checkAreaLabelsConsistent(0);
    };
    EdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent(geomIndex) {
      var edges = this.getEdges();
      if (edges.size() <= 0) {
        return true;
      }
      var lastEdgeIndex = edges.size() - 1;
      var startLabel = edges.get(lastEdgeIndex).getLabel();
      var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
      Assert.isTrue(startLoc !== Location.NONE, "Found unlabelled area edge");
      var currLoc = startLoc;
      for (var it = this.iterator(); it.hasNext(); ) {
        var e = it.next();
        var label = e.getLabel();
        Assert.isTrue(label.isArea(geomIndex), "Found non-area edge");
        var leftLoc = label.getLocation(geomIndex, Position.LEFT);
        var rightLoc = label.getLocation(geomIndex, Position.RIGHT);
        if (leftLoc === rightLoc) {
          return false;
        }
        if (rightLoc !== currLoc) {
          return false;
        }
        currLoc = leftLoc;
      }
      return true;
    };
    EdgeEndStar.prototype.findIndex = function findIndex(eSearch) {
      var this$1 = this;
      this.iterator();
      for (var i = 0; i < this._edgeList.size(); i++) {
        var e = this$1._edgeList.get(i);
        if (e === eSearch) {
          return i;
        }
      }
      return -1;
    };
    EdgeEndStar.prototype.iterator = function iterator() {
      return this.getEdges().iterator();
    };
    EdgeEndStar.prototype.getEdges = function getEdges() {
      if (this._edgeList === null) {
        this._edgeList = new ArrayList(this._edgeMap.values());
      }
      return this._edgeList;
    };
    EdgeEndStar.prototype.getLocation = function getLocation(geomIndex, p, geom) {
      if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
        this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
      }
      return this._ptInAreaLocation[geomIndex];
    };
    EdgeEndStar.prototype.toString = function toString() {
      var buf = new StringBuffer();
      buf.append("EdgeEndStar:   " + this.getCoordinate());
      buf.append("\n");
      for (var it = this.iterator(); it.hasNext(); ) {
        var e = it.next();
        buf.append(e);
        buf.append("\n");
      }
      return buf.toString();
    };
    EdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels(boundaryNodeRule) {
      for (var it = this.iterator(); it.hasNext(); ) {
        var ee = it.next();
        ee.computeLabel(boundaryNodeRule);
      }
    };
    EdgeEndStar.prototype.computeLabelling = function computeLabelling(geomGraph) {
      var this$1 = this;
      this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
      this.propagateSideLabels(0);
      this.propagateSideLabels(1);
      var hasDimensionalCollapseEdge = [false, false];
      for (var it = this.iterator(); it.hasNext(); ) {
        var e = it.next();
        var label = e.getLabel();
        for (var geomi = 0; geomi < 2; geomi++) {
          if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) {
            hasDimensionalCollapseEdge[geomi] = true;
          }
        }
      }
      for (var it$1 = this.iterator(); it$1.hasNext(); ) {
        var e$1 = it$1.next();
        var label$1 = e$1.getLabel();
        for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {
          if (label$1.isAnyNull(geomi$1)) {
            var loc = Location.NONE;
            if (hasDimensionalCollapseEdge[geomi$1]) {
              loc = Location.EXTERIOR;
            } else {
              var p = e$1.getCoordinate();
              loc = this$1.getLocation(geomi$1, p, geomGraph);
            }
            label$1.setAllLocationsIfNull(geomi$1, loc);
          }
        }
      }
    };
    EdgeEndStar.prototype.getDegree = function getDegree() {
      return this._edgeMap.size();
    };
    EdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd(e, obj) {
      this._edgeMap.put(e, obj);
      this._edgeList = null;
    };
    EdgeEndStar.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    EdgeEndStar.prototype.getClass = function getClass() {
      return EdgeEndStar;
    };
    var DirectedEdgeStar = function(EdgeEndStar$$1) {
      function DirectedEdgeStar2() {
        EdgeEndStar$$1.call(this);
        this._resultAreaEdgeList = null;
        this._label = null;
        this._SCANNING_FOR_INCOMING = 1;
        this._LINKING_TO_OUTGOING = 2;
      }
      if (EdgeEndStar$$1) DirectedEdgeStar2.__proto__ = EdgeEndStar$$1;
      DirectedEdgeStar2.prototype = Object.create(EdgeEndStar$$1 && EdgeEndStar$$1.prototype);
      DirectedEdgeStar2.prototype.constructor = DirectedEdgeStar2;
      DirectedEdgeStar2.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {
        var this$1 = this;
        this.getResultAreaEdges();
        var firstOut = null;
        var incoming = null;
        var state = this._SCANNING_FOR_INCOMING;
        for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
          var nextOut = this$1._resultAreaEdgeList.get(i);
          var nextIn = nextOut.getSym();
          if (!nextOut.getLabel().isArea()) {
            continue;
          }
          if (firstOut === null && nextOut.isInResult()) {
            firstOut = nextOut;
          }
          switch (state) {
            case this$1._SCANNING_FOR_INCOMING:
              if (!nextIn.isInResult()) {
                continue;
              }
              incoming = nextIn;
              state = this$1._LINKING_TO_OUTGOING;
              break;
            case this$1._LINKING_TO_OUTGOING:
              if (!nextOut.isInResult()) {
                continue;
              }
              incoming.setNext(nextOut);
              state = this$1._SCANNING_FOR_INCOMING;
              break;
            default:
          }
        }
        if (state === this._LINKING_TO_OUTGOING) {
          if (firstOut === null) {
            throw new TopologyException("no outgoing dirEdge found", this.getCoordinate());
          }
          Assert.isTrue(firstOut.isInResult(), "unable to link last incoming dirEdge");
          incoming.setNext(firstOut);
        }
      };
      DirectedEdgeStar2.prototype.insert = function insert(ee) {
        var de = ee;
        this.insertEdgeEnd(de, de);
      };
      DirectedEdgeStar2.prototype.getRightmostEdge = function getRightmostEdge() {
        var edges = this.getEdges();
        var size = edges.size();
        if (size < 1) {
          return null;
        }
        var de0 = edges.get(0);
        if (size === 1) {
          return de0;
        }
        var deLast = edges.get(size - 1);
        var quad0 = de0.getQuadrant();
        var quad1 = deLast.getQuadrant();
        if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) {
          return de0;
        } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) {
          return deLast;
        } else {
          if (de0.getDy() !== 0) {
            return de0;
          } else if (deLast.getDy() !== 0) {
            return deLast;
          }
        }
        Assert.shouldNeverReachHere("found two horizontal edges incident on node");
        return null;
      };
      DirectedEdgeStar2.prototype.print = function print(out) {
        System.out.println("DirectedEdgeStar: " + this.getCoordinate());
        for (var it = this.iterator(); it.hasNext(); ) {
          var de = it.next();
          out.print("out ");
          de.print(out);
          out.println();
          out.print("in ");
          de.getSym().print(out);
          out.println();
        }
      };
      DirectedEdgeStar2.prototype.getResultAreaEdges = function getResultAreaEdges() {
        var this$1 = this;
        if (this._resultAreaEdgeList !== null) {
          return this._resultAreaEdgeList;
        }
        this._resultAreaEdgeList = new ArrayList();
        for (var it = this.iterator(); it.hasNext(); ) {
          var de = it.next();
          if (de.isInResult() || de.getSym().isInResult()) {
            this$1._resultAreaEdgeList.add(de);
          }
        }
        return this._resultAreaEdgeList;
      };
      DirectedEdgeStar2.prototype.updateLabelling = function updateLabelling(nodeLabel) {
        for (var it = this.iterator(); it.hasNext(); ) {
          var de = it.next();
          var label = de.getLabel();
          label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
          label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
        }
      };
      DirectedEdgeStar2.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {
        var this$1 = this;
        this.getEdges();
        var prevOut = null;
        var firstIn = null;
        for (var i = this._edgeList.size() - 1; i >= 0; i--) {
          var nextOut = this$1._edgeList.get(i);
          var nextIn = nextOut.getSym();
          if (firstIn === null) {
            firstIn = nextIn;
          }
          if (prevOut !== null) {
            nextIn.setNext(prevOut);
          }
          prevOut = nextOut;
        }
        firstIn.setNext(prevOut);
      };
      DirectedEdgeStar2.prototype.computeDepths = function computeDepths() {
        var this$1 = this;
        if (arguments.length === 1) {
          var de = arguments[0];
          var edgeIndex = this.findIndex(de);
          var startDepth = de.getDepth(Position.LEFT);
          var targetLastDepth = de.getDepth(Position.RIGHT);
          var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
          var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
          if (lastDepth !== targetLastDepth) {
            throw new TopologyException("depth mismatch at " + de.getCoordinate());
          }
        } else if (arguments.length === 3) {
          var startIndex = arguments[0];
          var endIndex = arguments[1];
          var startDepth$1 = arguments[2];
          var currDepth = startDepth$1;
          for (var i = startIndex; i < endIndex; i++) {
            var nextDe = this$1._edgeList.get(i);
            nextDe.setEdgeDepths(Position.RIGHT, currDepth);
            currDepth = nextDe.getDepth(Position.LEFT);
          }
          return currDepth;
        }
      };
      DirectedEdgeStar2.prototype.mergeSymLabels = function mergeSymLabels() {
        for (var it = this.iterator(); it.hasNext(); ) {
          var de = it.next();
          var label = de.getLabel();
          label.merge(de.getSym().getLabel());
        }
      };
      DirectedEdgeStar2.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges(er) {
        var this$1 = this;
        var firstOut = null;
        var incoming = null;
        var state = this._SCANNING_FOR_INCOMING;
        for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
          var nextOut = this$1._resultAreaEdgeList.get(i);
          var nextIn = nextOut.getSym();
          if (firstOut === null && nextOut.getEdgeRing() === er) {
            firstOut = nextOut;
          }
          switch (state) {
            case this$1._SCANNING_FOR_INCOMING:
              if (nextIn.getEdgeRing() !== er) {
                continue;
              }
              incoming = nextIn;
              state = this$1._LINKING_TO_OUTGOING;
              break;
            case this$1._LINKING_TO_OUTGOING:
              if (nextOut.getEdgeRing() !== er) {
                continue;
              }
              incoming.setNextMin(nextOut);
              state = this$1._SCANNING_FOR_INCOMING;
              break;
            default:
          }
        }
        if (state === this._LINKING_TO_OUTGOING) {
          Assert.isTrue(firstOut !== null, "found null for first outgoing dirEdge");
          Assert.isTrue(firstOut.getEdgeRing() === er, "unable to link last incoming dirEdge");
          incoming.setNextMin(firstOut);
        }
      };
      DirectedEdgeStar2.prototype.getOutgoingDegree = function getOutgoingDegree() {
        if (arguments.length === 0) {
          var degree = 0;
          for (var it = this.iterator(); it.hasNext(); ) {
            var de = it.next();
            if (de.isInResult()) {
              degree++;
            }
          }
          return degree;
        } else if (arguments.length === 1) {
          var er = arguments[0];
          var degree$1 = 0;
          for (var it$1 = this.iterator(); it$1.hasNext(); ) {
            var de$1 = it$1.next();
            if (de$1.getEdgeRing() === er) {
              degree$1++;
            }
          }
          return degree$1;
        }
      };
      DirectedEdgeStar2.prototype.getLabel = function getLabel() {
        return this._label;
      };
      DirectedEdgeStar2.prototype.findCoveredLineEdges = function findCoveredLineEdges() {
        var startLoc = Location.NONE;
        for (var it = this.iterator(); it.hasNext(); ) {
          var nextOut = it.next();
          var nextIn = nextOut.getSym();
          if (!nextOut.isLineEdge()) {
            if (nextOut.isInResult()) {
              startLoc = Location.INTERIOR;
              break;
            }
            if (nextIn.isInResult()) {
              startLoc = Location.EXTERIOR;
              break;
            }
          }
        }
        if (startLoc === Location.NONE) {
          return null;
        }
        var currLoc = startLoc;
        for (var it$1 = this.iterator(); it$1.hasNext(); ) {
          var nextOut$1 = it$1.next();
          var nextIn$1 = nextOut$1.getSym();
          if (nextOut$1.isLineEdge()) {
            nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);
          } else {
            if (nextOut$1.isInResult()) {
              currLoc = Location.EXTERIOR;
            }
            if (nextIn$1.isInResult()) {
              currLoc = Location.INTERIOR;
            }
          }
        }
      };
      DirectedEdgeStar2.prototype.computeLabelling = function computeLabelling(geom) {
        var this$1 = this;
        EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);
        this._label = new Label(Location.NONE);
        for (var it = this.iterator(); it.hasNext(); ) {
          var ee = it.next();
          var e = ee.getEdge();
          var eLabel = e.getLabel();
          for (var i = 0; i < 2; i++) {
            var eLoc = eLabel.getLocation(i);
            if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) {
              this$1._label.setLocation(i, Location.INTERIOR);
            }
          }
        }
      };
      DirectedEdgeStar2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      DirectedEdgeStar2.prototype.getClass = function getClass() {
        return DirectedEdgeStar2;
      };
      return DirectedEdgeStar2;
    }(EdgeEndStar);
    var OverlayNodeFactory = function(NodeFactory$$1) {
      function OverlayNodeFactory2() {
        NodeFactory$$1.apply(this, arguments);
      }
      if (NodeFactory$$1) OverlayNodeFactory2.__proto__ = NodeFactory$$1;
      OverlayNodeFactory2.prototype = Object.create(NodeFactory$$1 && NodeFactory$$1.prototype);
      OverlayNodeFactory2.prototype.constructor = OverlayNodeFactory2;
      OverlayNodeFactory2.prototype.createNode = function createNode(coord) {
        return new Node(coord, new DirectedEdgeStar());
      };
      OverlayNodeFactory2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      OverlayNodeFactory2.prototype.getClass = function getClass() {
        return OverlayNodeFactory2;
      };
      return OverlayNodeFactory2;
    }(NodeFactory);
    var OrientedCoordinateArray = function OrientedCoordinateArray2() {
      this._pts = null;
      this._orientation = null;
      var pts = arguments[0];
      this._pts = pts;
      this._orientation = OrientedCoordinateArray2.orientation(pts);
    };
    OrientedCoordinateArray.prototype.compareTo = function compareTo(o1) {
      var oca = o1;
      var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
      return comp;
    };
    OrientedCoordinateArray.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    OrientedCoordinateArray.prototype.getClass = function getClass() {
      return OrientedCoordinateArray;
    };
    OrientedCoordinateArray.orientation = function orientation(pts) {
      return CoordinateArrays.increasingDirection(pts) === 1;
    };
    OrientedCoordinateArray.compareOriented = function compareOriented(pts1, orientation1, pts2, orientation2) {
      var dir1 = orientation1 ? 1 : -1;
      var dir2 = orientation2 ? 1 : -1;
      var limit1 = orientation1 ? pts1.length : -1;
      var limit2 = orientation2 ? pts2.length : -1;
      var i1 = orientation1 ? 0 : pts1.length - 1;
      var i2 = orientation2 ? 0 : pts2.length - 1;
      while (true) {
        var compPt = pts1[i1].compareTo(pts2[i2]);
        if (compPt !== 0) {
          return compPt;
        }
        i1 += dir1;
        i2 += dir2;
        var done1 = i1 === limit1;
        var done2 = i2 === limit2;
        if (done1 && !done2) {
          return -1;
        }
        if (!done1 && done2) {
          return 1;
        }
        if (done1 && done2) {
          return 0;
        }
      }
    };
    var EdgeList = function EdgeList2() {
      this._edges = new ArrayList();
      this._ocaMap = new TreeMap();
    };
    EdgeList.prototype.print = function print(out) {
      var this$1 = this;
      out.print("MULTILINESTRING ( ");
      for (var j = 0; j < this._edges.size(); j++) {
        var e = this$1._edges.get(j);
        if (j > 0) {
          out.print(",");
        }
        out.print("(");
        var pts = e.getCoordinates();
        for (var i = 0; i < pts.length; i++) {
          if (i > 0) {
            out.print(",");
          }
          out.print(pts[i].x + " " + pts[i].y);
        }
        out.println(")");
      }
      out.print(")  ");
    };
    EdgeList.prototype.addAll = function addAll(edgeColl) {
      var this$1 = this;
      for (var i = edgeColl.iterator(); i.hasNext(); ) {
        this$1.add(i.next());
      }
    };
    EdgeList.prototype.findEdgeIndex = function findEdgeIndex(e) {
      var this$1 = this;
      for (var i = 0; i < this._edges.size(); i++) {
        if (this$1._edges.get(i).equals(e)) {
          return i;
        }
      }
      return -1;
    };
    EdgeList.prototype.iterator = function iterator() {
      return this._edges.iterator();
    };
    EdgeList.prototype.getEdges = function getEdges() {
      return this._edges;
    };
    EdgeList.prototype.get = function get2(i) {
      return this._edges.get(i);
    };
    EdgeList.prototype.findEqualEdge = function findEqualEdge(e) {
      var oca = new OrientedCoordinateArray(e.getCoordinates());
      var matchEdge = this._ocaMap.get(oca);
      return matchEdge;
    };
    EdgeList.prototype.add = function add(e) {
      this._edges.add(e);
      var oca = new OrientedCoordinateArray(e.getCoordinates());
      this._ocaMap.put(oca, e);
    };
    EdgeList.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    EdgeList.prototype.getClass = function getClass() {
      return EdgeList;
    };
    var SegmentIntersector = function SegmentIntersector2() {
    };
    SegmentIntersector.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
    };
    SegmentIntersector.prototype.isDone = function isDone() {
    };
    SegmentIntersector.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SegmentIntersector.prototype.getClass = function getClass() {
      return SegmentIntersector;
    };
    var IntersectionAdder = function IntersectionAdder2() {
      this._hasIntersection = false;
      this._hasProper = false;
      this._hasProperInterior = false;
      this._hasInterior = false;
      this._properIntersectionPoint = null;
      this._li = null;
      this._isSelfIntersection = null;
      this.numIntersections = 0;
      this.numInteriorIntersections = 0;
      this.numProperIntersections = 0;
      this.numTests = 0;
      var li = arguments[0];
      this._li = li;
    };
    IntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1) {
        if (this._li.getIntersectionNum() === 1) {
          if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) {
            return true;
          }
          if (e0.isClosed()) {
            var maxSegIndex = e0.size() - 1;
            if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
              return true;
            }
          }
        }
      }
      return false;
    };
    IntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {
      return this._properIntersectionPoint;
    };
    IntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {
      return this._hasProperInterior;
    };
    IntersectionAdder.prototype.getLineIntersector = function getLineIntersector() {
      return this._li;
    };
    IntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection() {
      return this._hasProper;
    };
    IntersectionAdder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1 && segIndex0 === segIndex1) {
        return null;
      }
      this.numTests++;
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        this.numIntersections++;
        if (this._li.isInteriorIntersection()) {
          this.numInteriorIntersections++;
          this._hasInterior = true;
        }
        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
          this._hasIntersection = true;
          e0.addIntersections(this._li, segIndex0, 0);
          e1.addIntersections(this._li, segIndex1, 1);
          if (this._li.isProper()) {
            this.numProperIntersections++;
            this._hasProper = true;
            this._hasProperInterior = true;
          }
        }
      }
    };
    IntersectionAdder.prototype.hasIntersection = function hasIntersection() {
      return this._hasIntersection;
    };
    IntersectionAdder.prototype.isDone = function isDone() {
      return false;
    };
    IntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection() {
      return this._hasInterior;
    };
    IntersectionAdder.prototype.interfaces_ = function interfaces_() {
      return [SegmentIntersector];
    };
    IntersectionAdder.prototype.getClass = function getClass() {
      return IntersectionAdder;
    };
    IntersectionAdder.isAdjacentSegments = function isAdjacentSegments(i1, i2) {
      return Math.abs(i1 - i2) === 1;
    };
    var EdgeIntersection = function EdgeIntersection2() {
      this.coord = null;
      this.segmentIndex = null;
      this.dist = null;
      var coord = arguments[0];
      var segmentIndex = arguments[1];
      var dist = arguments[2];
      this.coord = new Coordinate(coord);
      this.segmentIndex = segmentIndex;
      this.dist = dist;
    };
    EdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex() {
      return this.segmentIndex;
    };
    EdgeIntersection.prototype.getCoordinate = function getCoordinate() {
      return this.coord;
    };
    EdgeIntersection.prototype.print = function print(out) {
      out.print(this.coord);
      out.print(" seg # = " + this.segmentIndex);
      out.println(" dist = " + this.dist);
    };
    EdgeIntersection.prototype.compareTo = function compareTo(obj) {
      var other = obj;
      return this.compare(other.segmentIndex, other.dist);
    };
    EdgeIntersection.prototype.isEndPoint = function isEndPoint(maxSegmentIndex) {
      if (this.segmentIndex === 0 && this.dist === 0) {
        return true;
      }
      if (this.segmentIndex === maxSegmentIndex) {
        return true;
      }
      return false;
    };
    EdgeIntersection.prototype.toString = function toString() {
      return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
    };
    EdgeIntersection.prototype.getDistance = function getDistance() {
      return this.dist;
    };
    EdgeIntersection.prototype.compare = function compare(segmentIndex, dist) {
      if (this.segmentIndex < segmentIndex) {
        return -1;
      }
      if (this.segmentIndex > segmentIndex) {
        return 1;
      }
      if (this.dist < dist) {
        return -1;
      }
      if (this.dist > dist) {
        return 1;
      }
      return 0;
    };
    EdgeIntersection.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    EdgeIntersection.prototype.getClass = function getClass() {
      return EdgeIntersection;
    };
    var EdgeIntersectionList = function EdgeIntersectionList2() {
      this._nodeMap = new TreeMap();
      this.edge = null;
      var edge = arguments[0];
      this.edge = edge;
    };
    EdgeIntersectionList.prototype.print = function print(out) {
      out.println("Intersections:");
      for (var it = this.iterator(); it.hasNext(); ) {
        var ei = it.next();
        ei.print(out);
      }
    };
    EdgeIntersectionList.prototype.iterator = function iterator() {
      return this._nodeMap.values().iterator();
    };
    EdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges(edgeList) {
      var this$1 = this;
      this.addEndpoints();
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        var newEdge = this$1.createSplitEdge(eiPrev, ei);
        edgeList.add(newEdge);
        eiPrev = ei;
      }
    };
    EdgeIntersectionList.prototype.addEndpoints = function addEndpoints() {
      var maxSegIndex = this.edge.pts.length - 1;
      this.add(this.edge.pts[0], 0, 0);
      this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0);
    };
    EdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {
      var this$1 = this;
      var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
      var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
      var useIntPt1 = ei1.dist > 0 || !ei1.coord.equals2D(lastSegStartPt);
      if (!useIntPt1) {
        npts--;
      }
      var pts = new Array(npts).fill(null);
      var ipt = 0;
      pts[ipt++] = new Coordinate(ei0.coord);
      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
        pts[ipt++] = this$1.edge.pts[i];
      }
      if (useIntPt1) {
        pts[ipt] = ei1.coord;
      }
      return new Edge(pts, new Label(this.edge._label));
    };
    EdgeIntersectionList.prototype.add = function add(intPt, segmentIndex, dist) {
      var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
      var ei = this._nodeMap.get(eiNew);
      if (ei !== null) {
        return ei;
      }
      this._nodeMap.put(eiNew, eiNew);
      return eiNew;
    };
    EdgeIntersectionList.prototype.isIntersection = function isIntersection(pt) {
      for (var it = this.iterator(); it.hasNext(); ) {
        var ei = it.next();
        if (ei.coord.equals(pt)) {
          return true;
        }
      }
      return false;
    };
    EdgeIntersectionList.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    EdgeIntersectionList.prototype.getClass = function getClass() {
      return EdgeIntersectionList;
    };
    var MonotoneChainIndexer = function MonotoneChainIndexer2() {
    };
    MonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices(pts) {
      var this$1 = this;
      var start = 0;
      var startIndexList = new ArrayList();
      startIndexList.add(new Integer(start));
      do {
        var last = this$1.findChainEnd(pts, start);
        startIndexList.add(new Integer(last));
        start = last;
      } while (start < pts.length - 1);
      var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
      return startIndex;
    };
    MonotoneChainIndexer.prototype.findChainEnd = function findChainEnd(pts, start) {
      var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
      var last = start + 1;
      while (last < pts.length) {
        var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
        if (quad !== chainQuad) {
          break;
        }
        last++;
      }
      return last - 1;
    };
    MonotoneChainIndexer.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MonotoneChainIndexer.prototype.getClass = function getClass() {
      return MonotoneChainIndexer;
    };
    MonotoneChainIndexer.toIntArray = function toIntArray(list) {
      var array = new Array(list.size()).fill(null);
      for (var i = 0; i < array.length; i++) {
        array[i] = list.get(i).intValue();
      }
      return array;
    };
    var MonotoneChainEdge = function MonotoneChainEdge2() {
      this.e = null;
      this.pts = null;
      this.startIndex = null;
      this.env1 = new Envelope();
      this.env2 = new Envelope();
      var e = arguments[0];
      this.e = e;
      this.pts = e.getCoordinates();
      var mcb = new MonotoneChainIndexer();
      this.startIndex = mcb.getChainStartIndices(this.pts);
    };
    MonotoneChainEdge.prototype.getCoordinates = function getCoordinates() {
      return this.pts;
    };
    MonotoneChainEdge.prototype.getMaxX = function getMaxX(chainIndex) {
      var x1 = this.pts[this.startIndex[chainIndex]].x;
      var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
      return x1 > x2 ? x1 : x2;
    };
    MonotoneChainEdge.prototype.getMinX = function getMinX(chainIndex) {
      var x1 = this.pts[this.startIndex[chainIndex]].x;
      var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
      return x1 < x2 ? x1 : x2;
    };
    MonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain() {
      if (arguments.length === 4) {
        var chainIndex0 = arguments[0];
        var mce = arguments[1];
        var chainIndex1 = arguments[2];
        var si = arguments[3];
        this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
      } else if (arguments.length === 6) {
        var start0 = arguments[0];
        var end0 = arguments[1];
        var mce$1 = arguments[2];
        var start1 = arguments[3];
        var end1 = arguments[4];
        var ei = arguments[5];
        var p00 = this.pts[start0];
        var p01 = this.pts[end0];
        var p10 = mce$1.pts[start1];
        var p11 = mce$1.pts[end1];
        if (end0 - start0 === 1 && end1 - start1 === 1) {
          ei.addIntersections(this.e, start0, mce$1.e, start1);
          return null;
        }
        this.env1.init(p00, p01);
        this.env2.init(p10, p11);
        if (!this.env1.intersects(this.env2)) {
          return null;
        }
        var mid0 = Math.trunc((start0 + end0) / 2);
        var mid1 = Math.trunc((start1 + end1) / 2);
        if (start0 < mid0) {
          if (start1 < mid1) {
            this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei);
          }
          if (mid1 < end1) {
            this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei);
          }
        }
        if (mid0 < end0) {
          if (start1 < mid1) {
            this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei);
          }
          if (mid1 < end1) {
            this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei);
          }
        }
      }
    };
    MonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes() {
      return this.startIndex;
    };
    MonotoneChainEdge.prototype.computeIntersects = function computeIntersects(mce, si) {
      var this$1 = this;
      for (var i = 0; i < this.startIndex.length - 1; i++) {
        for (var j = 0; j < mce.startIndex.length - 1; j++) {
          this$1.computeIntersectsForChain(i, mce, j, si);
        }
      }
    };
    MonotoneChainEdge.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MonotoneChainEdge.prototype.getClass = function getClass() {
      return MonotoneChainEdge;
    };
    var Depth = function Depth2() {
      var this$1 = this;
      this._depth = Array(2).fill().map(function() {
        return Array(3);
      });
      for (var i = 0; i < 2; i++) {
        for (var j = 0; j < 3; j++) {
          this$1._depth[i][j] = Depth2.NULL_VALUE;
        }
      }
    };
    var staticAccessors$31 = { NULL_VALUE: { configurable: true } };
    Depth.prototype.getDepth = function getDepth(geomIndex, posIndex) {
      return this._depth[geomIndex][posIndex];
    };
    Depth.prototype.setDepth = function setDepth(geomIndex, posIndex, depthValue) {
      this._depth[geomIndex][posIndex] = depthValue;
    };
    Depth.prototype.isNull = function isNull() {
      var this$1 = this;
      if (arguments.length === 0) {
        for (var i = 0; i < 2; i++) {
          for (var j = 0; j < 3; j++) {
            if (this$1._depth[i][j] !== Depth.NULL_VALUE) {
              return false;
            }
          }
        }
        return true;
      } else if (arguments.length === 1) {
        var geomIndex = arguments[0];
        return this._depth[geomIndex][1] === Depth.NULL_VALUE;
      } else if (arguments.length === 2) {
        var geomIndex$1 = arguments[0];
        var posIndex = arguments[1];
        return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE;
      }
    };
    Depth.prototype.normalize = function normalize2() {
      var this$1 = this;
      for (var i = 0; i < 2; i++) {
        if (!this$1.isNull(i)) {
          var minDepth = this$1._depth[i][1];
          if (this$1._depth[i][2] < minDepth) {
            minDepth = this$1._depth[i][2];
          }
          if (minDepth < 0) {
            minDepth = 0;
          }
          for (var j = 1; j < 3; j++) {
            var newValue = 0;
            if (this$1._depth[i][j] > minDepth) {
              newValue = 1;
            }
            this$1._depth[i][j] = newValue;
          }
        }
      }
    };
    Depth.prototype.getDelta = function getDelta(geomIndex) {
      return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];
    };
    Depth.prototype.getLocation = function getLocation(geomIndex, posIndex) {
      if (this._depth[geomIndex][posIndex] <= 0) {
        return Location.EXTERIOR;
      }
      return Location.INTERIOR;
    };
    Depth.prototype.toString = function toString() {
      return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
    };
    Depth.prototype.add = function add() {
      var this$1 = this;
      if (arguments.length === 1) {
        var lbl = arguments[0];
        for (var i = 0; i < 2; i++) {
          for (var j = 1; j < 3; j++) {
            var loc = lbl.getLocation(i, j);
            if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
              if (this$1.isNull(i, j)) {
                this$1._depth[i][j] = Depth.depthAtLocation(loc);
              } else {
                this$1._depth[i][j] += Depth.depthAtLocation(loc);
              }
            }
          }
        }
      } else if (arguments.length === 3) {
        var geomIndex = arguments[0];
        var posIndex = arguments[1];
        var location = arguments[2];
        if (location === Location.INTERIOR) {
          this._depth[geomIndex][posIndex]++;
        }
      }
    };
    Depth.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    Depth.prototype.getClass = function getClass() {
      return Depth;
    };
    Depth.depthAtLocation = function depthAtLocation(location) {
      if (location === Location.EXTERIOR) {
        return 0;
      }
      if (location === Location.INTERIOR) {
        return 1;
      }
      return Depth.NULL_VALUE;
    };
    staticAccessors$31.NULL_VALUE.get = function() {
      return -1;
    };
    Object.defineProperties(Depth, staticAccessors$31);
    var Edge = function(GraphComponent$$1) {
      function Edge2() {
        GraphComponent$$1.call(this);
        this.pts = null;
        this._env = null;
        this.eiList = new EdgeIntersectionList(this);
        this._name = null;
        this._mce = null;
        this._isIsolated = true;
        this._depth = new Depth();
        this._depthDelta = 0;
        if (arguments.length === 1) {
          var pts = arguments[0];
          Edge2.call(this, pts, null);
        } else if (arguments.length === 2) {
          var pts$1 = arguments[0];
          var label = arguments[1];
          this.pts = pts$1;
          this._label = label;
        }
      }
      if (GraphComponent$$1) Edge2.__proto__ = GraphComponent$$1;
      Edge2.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
      Edge2.prototype.constructor = Edge2;
      Edge2.prototype.getDepth = function getDepth() {
        return this._depth;
      };
      Edge2.prototype.getCollapsedEdge = function getCollapsedEdge() {
        var newPts = new Array(2).fill(null);
        newPts[0] = this.pts[0];
        newPts[1] = this.pts[1];
        var newe = new Edge2(newPts, Label.toLineLabel(this._label));
        return newe;
      };
      Edge2.prototype.isIsolated = function isIsolated() {
        return this._isIsolated;
      };
      Edge2.prototype.getCoordinates = function getCoordinates() {
        return this.pts;
      };
      Edge2.prototype.setIsolated = function setIsolated(isIsolated) {
        this._isIsolated = isIsolated;
      };
      Edge2.prototype.setName = function setName(name) {
        this._name = name;
      };
      Edge2.prototype.equals = function equals(o) {
        var this$1 = this;
        if (!(o instanceof Edge2)) {
          return false;
        }
        var e = o;
        if (this.pts.length !== e.pts.length) {
          return false;
        }
        var isEqualForward = true;
        var isEqualReverse = true;
        var iRev = this.pts.length;
        for (var i = 0; i < this.pts.length; i++) {
          if (!this$1.pts[i].equals2D(e.pts[i])) {
            isEqualForward = false;
          }
          if (!this$1.pts[i].equals2D(e.pts[--iRev])) {
            isEqualReverse = false;
          }
          if (!isEqualForward && !isEqualReverse) {
            return false;
          }
        }
        return true;
      };
      Edge2.prototype.getCoordinate = function getCoordinate() {
        if (arguments.length === 0) {
          if (this.pts.length > 0) {
            return this.pts[0];
          }
          return null;
        } else if (arguments.length === 1) {
          var i = arguments[0];
          return this.pts[i];
        }
      };
      Edge2.prototype.print = function print(out) {
        var this$1 = this;
        out.print("edge " + this._name + ": ");
        out.print("LINESTRING (");
        for (var i = 0; i < this.pts.length; i++) {
          if (i > 0) {
            out.print(",");
          }
          out.print(this$1.pts[i].x + " " + this$1.pts[i].y);
        }
        out.print(")  " + this._label + " " + this._depthDelta);
      };
      Edge2.prototype.computeIM = function computeIM(im) {
        Edge2.updateIM(this._label, im);
      };
      Edge2.prototype.isCollapsed = function isCollapsed() {
        if (!this._label.isArea()) {
          return false;
        }
        if (this.pts.length !== 3) {
          return false;
        }
        if (this.pts[0].equals(this.pts[2])) {
          return true;
        }
        return false;
      };
      Edge2.prototype.isClosed = function isClosed() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      };
      Edge2.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex() {
        return this.pts.length - 1;
      };
      Edge2.prototype.getDepthDelta = function getDepthDelta() {
        return this._depthDelta;
      };
      Edge2.prototype.getNumPoints = function getNumPoints() {
        return this.pts.length;
      };
      Edge2.prototype.printReverse = function printReverse(out) {
        var this$1 = this;
        out.print("edge " + this._name + ": ");
        for (var i = this.pts.length - 1; i >= 0; i--) {
          out.print(this$1.pts[i] + " ");
        }
        out.println("");
      };
      Edge2.prototype.getMonotoneChainEdge = function getMonotoneChainEdge() {
        if (this._mce === null) {
          this._mce = new MonotoneChainEdge(this);
        }
        return this._mce;
      };
      Edge2.prototype.getEnvelope = function getEnvelope() {
        var this$1 = this;
        if (this._env === null) {
          this._env = new Envelope();
          for (var i = 0; i < this.pts.length; i++) {
            this$1._env.expandToInclude(this$1.pts[i]);
          }
        }
        return this._env;
      };
      Edge2.prototype.addIntersection = function addIntersection(li, segmentIndex, geomIndex, intIndex) {
        var intPt = new Coordinate(li.getIntersection(intIndex));
        var normalizedSegmentIndex = segmentIndex;
        var dist = li.getEdgeDistance(geomIndex, intIndex);
        var nextSegIndex = normalizedSegmentIndex + 1;
        if (nextSegIndex < this.pts.length) {
          var nextPt = this.pts[nextSegIndex];
          if (intPt.equals2D(nextPt)) {
            normalizedSegmentIndex = nextSegIndex;
            dist = 0;
          }
        }
        this.eiList.add(intPt, normalizedSegmentIndex, dist);
      };
      Edge2.prototype.toString = function toString() {
        var this$1 = this;
        var buf = new StringBuffer();
        buf.append("edge " + this._name + ": ");
        buf.append("LINESTRING (");
        for (var i = 0; i < this.pts.length; i++) {
          if (i > 0) {
            buf.append(",");
          }
          buf.append(this$1.pts[i].x + " " + this$1.pts[i].y);
        }
        buf.append(")  " + this._label + " " + this._depthDelta);
        return buf.toString();
      };
      Edge2.prototype.isPointwiseEqual = function isPointwiseEqual(e) {
        var this$1 = this;
        if (this.pts.length !== e.pts.length) {
          return false;
        }
        for (var i = 0; i < this.pts.length; i++) {
          if (!this$1.pts[i].equals2D(e.pts[i])) {
            return false;
          }
        }
        return true;
      };
      Edge2.prototype.setDepthDelta = function setDepthDelta(depthDelta) {
        this._depthDelta = depthDelta;
      };
      Edge2.prototype.getEdgeIntersectionList = function getEdgeIntersectionList() {
        return this.eiList;
      };
      Edge2.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {
        var this$1 = this;
        for (var i = 0; i < li.getIntersectionNum(); i++) {
          this$1.addIntersection(li, segmentIndex, geomIndex, i);
        }
      };
      Edge2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      Edge2.prototype.getClass = function getClass() {
        return Edge2;
      };
      Edge2.updateIM = function updateIM() {
        if (arguments.length === 2) {
          var label = arguments[0];
          var im = arguments[1];
          im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
          if (label.isArea()) {
            im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
            im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
          }
        } else {
          return GraphComponent$$1.prototype.updateIM.apply(this, arguments);
        }
      };
      return Edge2;
    }(GraphComponent);
    var BufferBuilder = function BufferBuilder2(bufParams) {
      this._workingPrecisionModel = null;
      this._workingNoder = null;
      this._geomFact = null;
      this._graph = null;
      this._edgeList = new EdgeList();
      this._bufParams = bufParams || null;
    };
    BufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel(pm) {
      this._workingPrecisionModel = pm;
    };
    BufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge(e) {
      var existingEdge = this._edgeList.findEqualEdge(e);
      if (existingEdge !== null) {
        var existingLabel = existingEdge.getLabel();
        var labelToMerge = e.getLabel();
        if (!existingEdge.isPointwiseEqual(e)) {
          labelToMerge = new Label(e.getLabel());
          labelToMerge.flip();
        }
        existingLabel.merge(labelToMerge);
        var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
        var existingDelta = existingEdge.getDepthDelta();
        var newDelta = existingDelta + mergeDelta;
        existingEdge.setDepthDelta(newDelta);
      } else {
        this._edgeList.add(e);
        e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
      }
    };
    BufferBuilder.prototype.buildSubgraphs = function buildSubgraphs(subgraphList, polyBuilder) {
      var processedGraphs = new ArrayList();
      for (var i = subgraphList.iterator(); i.hasNext(); ) {
        var subgraph = i.next();
        var p = subgraph.getRightmostCoordinate();
        var locater = new SubgraphDepthLocater(processedGraphs);
        var outsideDepth = locater.getDepth(p);
        subgraph.computeDepth(outsideDepth);
        subgraph.findResultEdges();
        processedGraphs.add(subgraph);
        polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
      }
    };
    BufferBuilder.prototype.createSubgraphs = function createSubgraphs(graph) {
      var subgraphList = new ArrayList();
      for (var i = graph.getNodes().iterator(); i.hasNext(); ) {
        var node = i.next();
        if (!node.isVisited()) {
          var subgraph = new BufferSubgraph();
          subgraph.create(node);
          subgraphList.add(subgraph);
        }
      }
      Collections.sort(subgraphList, Collections.reverseOrder());
      return subgraphList;
    };
    BufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry() {
      var emptyGeom = this._geomFact.createPolygon();
      return emptyGeom;
    };
    BufferBuilder.prototype.getNoder = function getNoder(precisionModel) {
      if (this._workingNoder !== null) {
        return this._workingNoder;
      }
      var noder = new MCIndexNoder();
      var li = new RobustLineIntersector();
      li.setPrecisionModel(precisionModel);
      noder.setSegmentIntersector(new IntersectionAdder(li));
      return noder;
    };
    BufferBuilder.prototype.buffer = function buffer(g, distance) {
      var precisionModel = this._workingPrecisionModel;
      if (precisionModel === null) {
        precisionModel = g.getPrecisionModel();
      }
      this._geomFact = g.getFactory();
      var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
      var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);
      var bufferSegStrList = curveSetBuilder.getCurves();
      if (bufferSegStrList.size() <= 0) {
        return this.createEmptyResultGeometry();
      }
      this.computeNodedEdges(bufferSegStrList, precisionModel);
      this._graph = new PlanarGraph(new OverlayNodeFactory());
      this._graph.addEdges(this._edgeList.getEdges());
      var subgraphList = this.createSubgraphs(this._graph);
      var polyBuilder = new PolygonBuilder(this._geomFact);
      this.buildSubgraphs(subgraphList, polyBuilder);
      var resultPolyList = polyBuilder.getPolygons();
      if (resultPolyList.size() <= 0) {
        return this.createEmptyResultGeometry();
      }
      var resultGeom = this._geomFact.buildGeometry(resultPolyList);
      return resultGeom;
    };
    BufferBuilder.prototype.computeNodedEdges = function computeNodedEdges(bufferSegStrList, precisionModel) {
      var this$1 = this;
      var noder = this.getNoder(precisionModel);
      noder.computeNodes(bufferSegStrList);
      var nodedSegStrings = noder.getNodedSubstrings();
      for (var i = nodedSegStrings.iterator(); i.hasNext(); ) {
        var segStr = i.next();
        var pts = segStr.getCoordinates();
        if (pts.length === 2 && pts[0].equals2D(pts[1])) {
          continue;
        }
        var oldLabel = segStr.getData();
        var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));
        this$1.insertUniqueEdge(edge);
      }
    };
    BufferBuilder.prototype.setNoder = function setNoder(noder) {
      this._workingNoder = noder;
    };
    BufferBuilder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BufferBuilder.prototype.getClass = function getClass() {
      return BufferBuilder;
    };
    BufferBuilder.depthDelta = function depthDelta(label) {
      var lLoc = label.getLocation(0, Position.LEFT);
      var rLoc = label.getLocation(0, Position.RIGHT);
      if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) {
        return 1;
      } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) {
        return -1;
      }
      return 0;
    };
    BufferBuilder.convertSegStrings = function convertSegStrings(it) {
      var fact = new GeometryFactory();
      var lines = new ArrayList();
      while (it.hasNext()) {
        var ss = it.next();
        var line = fact.createLineString(ss.getCoordinates());
        lines.add(line);
      }
      return fact.buildGeometry(lines);
    };
    var ScaledNoder = function ScaledNoder2() {
      this._noder = null;
      this._scaleFactor = null;
      this._offsetX = null;
      this._offsetY = null;
      this._isScaled = false;
      if (arguments.length === 2) {
        var noder = arguments[0];
        var scaleFactor = arguments[1];
        this._noder = noder;
        this._scaleFactor = scaleFactor;
        this._offsetX = 0;
        this._offsetY = 0;
        this._isScaled = !this.isIntegerPrecision();
      } else if (arguments.length === 4) {
        var noder$1 = arguments[0];
        var scaleFactor$1 = arguments[1];
        var offsetX = arguments[2];
        var offsetY = arguments[3];
        this._noder = noder$1;
        this._scaleFactor = scaleFactor$1;
        this._offsetX = offsetX;
        this._offsetY = offsetY;
        this._isScaled = !this.isIntegerPrecision();
      }
    };
    ScaledNoder.prototype.rescale = function rescale() {
      var this$1 = this;
      if (hasInterface(arguments[0], Collection)) {
        var segStrings = arguments[0];
        for (var i = segStrings.iterator(); i.hasNext(); ) {
          var ss = i.next();
          this$1.rescale(ss.getCoordinates());
        }
      } else if (arguments[0] instanceof Array) {
        var pts = arguments[0];
        for (var i$1 = 0; i$1 < pts.length; i$1++) {
          pts[i$1].x = pts[i$1].x / this$1._scaleFactor + this$1._offsetX;
          pts[i$1].y = pts[i$1].y / this$1._scaleFactor + this$1._offsetY;
        }
        if (pts.length === 2 && pts[0].equals2D(pts[1])) {
          System.out.println(pts);
        }
      }
    };
    ScaledNoder.prototype.scale = function scale() {
      var this$1 = this;
      if (hasInterface(arguments[0], Collection)) {
        var segStrings = arguments[0];
        var nodedSegmentStrings = new ArrayList();
        for (var i = segStrings.iterator(); i.hasNext(); ) {
          var ss = i.next();
          nodedSegmentStrings.add(new NodedSegmentString(this$1.scale(ss.getCoordinates()), ss.getData()));
        }
        return nodedSegmentStrings;
      } else if (arguments[0] instanceof Array) {
        var pts = arguments[0];
        var roundPts = new Array(pts.length).fill(null);
        for (var i$1 = 0; i$1 < pts.length; i$1++) {
          roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1._offsetX) * this$1._scaleFactor), Math.round((pts[i$1].y - this$1._offsetY) * this$1._scaleFactor), pts[i$1].z);
        }
        var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
        return roundPtsNoDup;
      }
    };
    ScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision() {
      return this._scaleFactor === 1;
    };
    ScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings() {
      var splitSS = this._noder.getNodedSubstrings();
      if (this._isScaled) {
        this.rescale(splitSS);
      }
      return splitSS;
    };
    ScaledNoder.prototype.computeNodes = function computeNodes(inputSegStrings) {
      var intSegStrings = inputSegStrings;
      if (this._isScaled) {
        intSegStrings = this.scale(inputSegStrings);
      }
      this._noder.computeNodes(intSegStrings);
    };
    ScaledNoder.prototype.interfaces_ = function interfaces_() {
      return [Noder];
    };
    ScaledNoder.prototype.getClass = function getClass() {
      return ScaledNoder;
    };
    var NodingValidator = function NodingValidator2() {
      this._li = new RobustLineIntersector();
      this._segStrings = null;
      var segStrings = arguments[0];
      this._segStrings = segStrings;
    };
    var staticAccessors$33 = { fact: { configurable: true } };
    NodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections() {
      var this$1 = this;
      if (arguments.length === 0) {
        for (var i = this._segStrings.iterator(); i.hasNext(); ) {
          var ss = i.next();
          var pts = ss.getCoordinates();
          this$1.checkEndPtVertexIntersections(pts[0], this$1._segStrings);
          this$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1._segStrings);
        }
      } else if (arguments.length === 2) {
        var testPt = arguments[0];
        var segStrings = arguments[1];
        for (var i$1 = segStrings.iterator(); i$1.hasNext(); ) {
          var ss$1 = i$1.next();
          var pts$1 = ss$1.getCoordinates();
          for (var j = 1; j < pts$1.length - 1; j++) {
            if (pts$1[j].equals(testPt)) {
              throw new RuntimeException("found endpt/interior pt intersection at index " + j + " :pt " + testPt);
            }
          }
        }
      }
    };
    NodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {
      var this$1 = this;
      if (arguments.length === 0) {
        for (var i = this._segStrings.iterator(); i.hasNext(); ) {
          var ss0 = i.next();
          for (var j = this._segStrings.iterator(); j.hasNext(); ) {
            var ss1 = j.next();
            this$1.checkInteriorIntersections(ss0, ss1);
          }
        }
      } else if (arguments.length === 2) {
        var ss0$1 = arguments[0];
        var ss1$1 = arguments[1];
        var pts0 = ss0$1.getCoordinates();
        var pts1 = ss1$1.getCoordinates();
        for (var i0 = 0; i0 < pts0.length - 1; i0++) {
          for (var i1 = 0; i1 < pts1.length - 1; i1++) {
            this$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);
          }
        }
      } else if (arguments.length === 4) {
        var e0 = arguments[0];
        var segIndex0 = arguments[1];
        var e1 = arguments[2];
        var segIndex1 = arguments[3];
        if (e0 === e1 && segIndex0 === segIndex1) {
          return null;
        }
        var p00 = e0.getCoordinates()[segIndex0];
        var p01 = e0.getCoordinates()[segIndex0 + 1];
        var p10 = e1.getCoordinates()[segIndex1];
        var p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
          if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
            throw new RuntimeException("found non-noded intersection at " + p00 + "-" + p01 + " and " + p10 + "-" + p11);
          }
        }
      }
    };
    NodingValidator.prototype.checkValid = function checkValid() {
      this.checkEndPtVertexIntersections();
      this.checkInteriorIntersections();
      this.checkCollapses();
    };
    NodingValidator.prototype.checkCollapses = function checkCollapses() {
      var this$1 = this;
      if (arguments.length === 0) {
        for (var i = this._segStrings.iterator(); i.hasNext(); ) {
          var ss = i.next();
          this$1.checkCollapses(ss);
        }
      } else if (arguments.length === 1) {
        var ss$1 = arguments[0];
        var pts = ss$1.getCoordinates();
        for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {
          this$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);
        }
      }
    };
    NodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection(li, p0, p1) {
      for (var i = 0; i < li.getIntersectionNum(); i++) {
        var intPt = li.getIntersection(i);
        if (!(intPt.equals(p0) || intPt.equals(p1))) {
          return true;
        }
      }
      return false;
    };
    NodingValidator.prototype.checkCollapse = function checkCollapse(p0, p1, p2) {
      if (p0.equals(p2)) {
        throw new RuntimeException("found non-noded collapse at " + NodingValidator.fact.createLineString([p0, p1, p2]));
      }
    };
    NodingValidator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    NodingValidator.prototype.getClass = function getClass() {
      return NodingValidator;
    };
    staticAccessors$33.fact.get = function() {
      return new GeometryFactory();
    };
    Object.defineProperties(NodingValidator, staticAccessors$33);
    var HotPixel = function HotPixel2() {
      this._li = null;
      this._pt = null;
      this._originalPt = null;
      this._ptScaled = null;
      this._p0Scaled = null;
      this._p1Scaled = null;
      this._scaleFactor = null;
      this._minx = null;
      this._maxx = null;
      this._miny = null;
      this._maxy = null;
      this._corner = new Array(4).fill(null);
      this._safeEnv = null;
      var pt = arguments[0];
      var scaleFactor = arguments[1];
      var li = arguments[2];
      this._originalPt = pt;
      this._pt = pt;
      this._scaleFactor = scaleFactor;
      this._li = li;
      if (scaleFactor <= 0) {
        throw new IllegalArgumentException("Scale factor must be non-zero");
      }
      if (scaleFactor !== 1) {
        this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
        this._p0Scaled = new Coordinate();
        this._p1Scaled = new Coordinate();
      }
      this.initCorners(this._pt);
    };
    var staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
    HotPixel.prototype.intersectsScaled = function intersectsScaled(p0, p1) {
      var segMinx = Math.min(p0.x, p1.x);
      var segMaxx = Math.max(p0.x, p1.x);
      var segMiny = Math.min(p0.y, p1.y);
      var segMaxy = Math.max(p0.y, p1.y);
      var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
      if (isOutsidePixelEnv) {
        return false;
      }
      var intersects = this.intersectsToleranceSquare(p0, p1);
      Assert.isTrue(!(isOutsidePixelEnv && intersects), "Found bad envelope test");
      return intersects;
    };
    HotPixel.prototype.initCorners = function initCorners(pt) {
      var tolerance = 0.5;
      this._minx = pt.x - tolerance;
      this._maxx = pt.x + tolerance;
      this._miny = pt.y - tolerance;
      this._maxy = pt.y + tolerance;
      this._corner[0] = new Coordinate(this._maxx, this._maxy);
      this._corner[1] = new Coordinate(this._minx, this._maxy);
      this._corner[2] = new Coordinate(this._minx, this._miny);
      this._corner[3] = new Coordinate(this._maxx, this._miny);
    };
    HotPixel.prototype.intersects = function intersects(p0, p1) {
      if (this._scaleFactor === 1) {
        return this.intersectsScaled(p0, p1);
      }
      this.copyScaled(p0, this._p0Scaled);
      this.copyScaled(p1, this._p1Scaled);
      return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
    };
    HotPixel.prototype.scale = function scale(val) {
      return Math.round(val * this._scaleFactor);
    };
    HotPixel.prototype.getCoordinate = function getCoordinate() {
      return this._originalPt;
    };
    HotPixel.prototype.copyScaled = function copyScaled(p, pScaled) {
      pScaled.x = this.scale(p.x);
      pScaled.y = this.scale(p.y);
    };
    HotPixel.prototype.getSafeEnvelope = function getSafeEnvelope() {
      if (this._safeEnv === null) {
        var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
        this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
      }
      return this._safeEnv;
    };
    HotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure(p0, p1) {
      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
      if (this._li.hasIntersection()) {
        return true;
      }
      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
      if (this._li.hasIntersection()) {
        return true;
      }
      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
      if (this._li.hasIntersection()) {
        return true;
      }
      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
      if (this._li.hasIntersection()) {
        return true;
      }
      return false;
    };
    HotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare(p0, p1) {
      var intersectsLeft = false;
      var intersectsBottom = false;
      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
      if (this._li.isProper()) {
        return true;
      }
      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
      if (this._li.isProper()) {
        return true;
      }
      if (this._li.hasIntersection()) {
        intersectsLeft = true;
      }
      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
      if (this._li.isProper()) {
        return true;
      }
      if (this._li.hasIntersection()) {
        intersectsBottom = true;
      }
      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
      if (this._li.isProper()) {
        return true;
      }
      if (intersectsLeft && intersectsBottom) {
        return true;
      }
      if (p0.equals(this._pt)) {
        return true;
      }
      if (p1.equals(this._pt)) {
        return true;
      }
      return false;
    };
    HotPixel.prototype.addSnappedNode = function addSnappedNode(segStr, segIndex) {
      var p0 = segStr.getCoordinate(segIndex);
      var p1 = segStr.getCoordinate(segIndex + 1);
      if (this.intersects(p0, p1)) {
        segStr.addIntersection(this.getCoordinate(), segIndex);
        return true;
      }
      return false;
    };
    HotPixel.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    HotPixel.prototype.getClass = function getClass() {
      return HotPixel;
    };
    staticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function() {
      return 0.75;
    };
    Object.defineProperties(HotPixel, staticAccessors$34);
    var MonotoneChainSelectAction = function MonotoneChainSelectAction2() {
      this.tempEnv1 = new Envelope();
      this.selectedSegment = new LineSegment();
    };
    MonotoneChainSelectAction.prototype.select = function select() {
      if (arguments.length === 1) {
      } else if (arguments.length === 2) {
        var mc = arguments[0];
        var startIndex = arguments[1];
        mc.getLineSegment(startIndex, this.selectedSegment);
        this.select(this.selectedSegment);
      }
    };
    MonotoneChainSelectAction.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MonotoneChainSelectAction.prototype.getClass = function getClass() {
      return MonotoneChainSelectAction;
    };
    var MCIndexPointSnapper = function MCIndexPointSnapper2() {
      this._index = null;
      var index = arguments[0];
      this._index = index;
    };
    var staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };
    MCIndexPointSnapper.prototype.snap = function snap() {
      if (arguments.length === 1) {
        var hotPixel = arguments[0];
        return this.snap(hotPixel, null, -1);
      } else if (arguments.length === 3) {
        var hotPixel$1 = arguments[0];
        var parentEdge = arguments[1];
        var hotPixelVertexIndex = arguments[2];
        var pixelEnv = hotPixel$1.getSafeEnvelope();
        var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);
        this._index.query(pixelEnv, {
          interfaces_: function() {
            return [ItemVisitor];
          },
          visitItem: function(item) {
            var testChain = item;
            testChain.select(pixelEnv, hotPixelSnapAction);
          }
        });
        return hotPixelSnapAction.isNodeAdded();
      }
    };
    MCIndexPointSnapper.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MCIndexPointSnapper.prototype.getClass = function getClass() {
      return MCIndexPointSnapper;
    };
    staticAccessors$35.HotPixelSnapAction.get = function() {
      return HotPixelSnapAction;
    };
    Object.defineProperties(MCIndexPointSnapper, staticAccessors$35);
    var HotPixelSnapAction = function(MonotoneChainSelectAction$$1) {
      function HotPixelSnapAction2() {
        MonotoneChainSelectAction$$1.call(this);
        this._hotPixel = null;
        this._parentEdge = null;
        this._hotPixelVertexIndex = null;
        this._isNodeAdded = false;
        var hotPixel = arguments[0];
        var parentEdge = arguments[1];
        var hotPixelVertexIndex = arguments[2];
        this._hotPixel = hotPixel;
        this._parentEdge = parentEdge;
        this._hotPixelVertexIndex = hotPixelVertexIndex;
      }
      if (MonotoneChainSelectAction$$1) HotPixelSnapAction2.__proto__ = MonotoneChainSelectAction$$1;
      HotPixelSnapAction2.prototype = Object.create(MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype);
      HotPixelSnapAction2.prototype.constructor = HotPixelSnapAction2;
      HotPixelSnapAction2.prototype.isNodeAdded = function isNodeAdded() {
        return this._isNodeAdded;
      };
      HotPixelSnapAction2.prototype.select = function select() {
        if (arguments.length === 2) {
          var mc = arguments[0];
          var startIndex = arguments[1];
          var ss = mc.getContext();
          if (this._parentEdge !== null) {
            if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) {
              return null;
            }
          }
          this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
        } else {
          return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments);
        }
      };
      HotPixelSnapAction2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      HotPixelSnapAction2.prototype.getClass = function getClass() {
        return HotPixelSnapAction2;
      };
      return HotPixelSnapAction2;
    }(MonotoneChainSelectAction);
    var InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder2() {
      this._li = null;
      this._interiorIntersections = null;
      var li = arguments[0];
      this._li = li;
      this._interiorIntersections = new ArrayList();
    };
    InteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
      var this$1 = this;
      if (e0 === e1 && segIndex0 === segIndex1) {
        return null;
      }
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._li.isInteriorIntersection()) {
          for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
            this$1._interiorIntersections.add(this$1._li.getIntersection(intIndex));
          }
          e0.addIntersections(this._li, segIndex0, 0);
          e1.addIntersections(this._li, segIndex1, 1);
        }
      }
    };
    InteriorIntersectionFinderAdder.prototype.isDone = function isDone() {
      return false;
    };
    InteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections() {
      return this._interiorIntersections;
    };
    InteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_() {
      return [SegmentIntersector];
    };
    InteriorIntersectionFinderAdder.prototype.getClass = function getClass() {
      return InteriorIntersectionFinderAdder;
    };
    var MCIndexSnapRounder = function MCIndexSnapRounder2() {
      this._pm = null;
      this._li = null;
      this._scaleFactor = null;
      this._noder = null;
      this._pointSnapper = null;
      this._nodedSegStrings = null;
      var pm = arguments[0];
      this._pm = pm;
      this._li = new RobustLineIntersector();
      this._li.setPrecisionModel(pm);
      this._scaleFactor = pm.getScale();
    };
    MCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness(inputSegmentStrings) {
      var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
      var nv = new NodingValidator(resultSegStrings);
      try {
        nv.checkValid();
      } catch (ex) {
        if (ex instanceof Exception) {
          ex.printStackTrace();
        } else {
          throw ex;
        }
      } finally {
      }
    };
    MCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings() {
      return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
    };
    MCIndexSnapRounder.prototype.snapRound = function snapRound(segStrings, li) {
      var intersections = this.findInteriorIntersections(segStrings, li);
      this.computeIntersectionSnaps(intersections);
      this.computeVertexSnaps(segStrings);
    };
    MCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections(segStrings, li) {
      var intFinderAdder = new InteriorIntersectionFinderAdder(li);
      this._noder.setSegmentIntersector(intFinderAdder);
      this._noder.computeNodes(segStrings);
      return intFinderAdder.getInteriorIntersections();
    };
    MCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps() {
      var this$1 = this;
      if (hasInterface(arguments[0], Collection)) {
        var edges = arguments[0];
        for (var i0 = edges.iterator(); i0.hasNext(); ) {
          var edge0 = i0.next();
          this$1.computeVertexSnaps(edge0);
        }
      } else if (arguments[0] instanceof NodedSegmentString) {
        var e = arguments[0];
        var pts0 = e.getCoordinates();
        for (var i = 0; i < pts0.length; i++) {
          var hotPixel = new HotPixel(pts0[i], this$1._scaleFactor, this$1._li);
          var isNodeAdded = this$1._pointSnapper.snap(hotPixel, e, i);
          if (isNodeAdded) {
            e.addIntersection(pts0[i], i);
          }
        }
      }
    };
    MCIndexSnapRounder.prototype.computeNodes = function computeNodes(inputSegmentStrings) {
      this._nodedSegStrings = inputSegmentStrings;
      this._noder = new MCIndexNoder();
      this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
      this.snapRound(inputSegmentStrings, this._li);
    };
    MCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps(snapPts) {
      var this$1 = this;
      for (var it = snapPts.iterator(); it.hasNext(); ) {
        var snapPt = it.next();
        var hotPixel = new HotPixel(snapPt, this$1._scaleFactor, this$1._li);
        this$1._pointSnapper.snap(hotPixel);
      }
    };
    MCIndexSnapRounder.prototype.interfaces_ = function interfaces_() {
      return [Noder];
    };
    MCIndexSnapRounder.prototype.getClass = function getClass() {
      return MCIndexSnapRounder;
    };
    var BufferOp = function BufferOp2() {
      this._argGeom = null;
      this._distance = null;
      this._bufParams = new BufferParameters();
      this._resultGeometry = null;
      this._saveException = null;
      if (arguments.length === 1) {
        var g = arguments[0];
        this._argGeom = g;
      } else if (arguments.length === 2) {
        var g$1 = arguments[0];
        var bufParams = arguments[1];
        this._argGeom = g$1;
        this._bufParams = bufParams;
      }
    };
    var staticAccessors$32 = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
    BufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision(fixedPM) {
      var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1)), fixedPM.getScale());
      var bufBuilder = new BufferBuilder(this._bufParams);
      bufBuilder.setWorkingPrecisionModel(fixedPM);
      bufBuilder.setNoder(noder);
      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
    };
    BufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision() {
      var this$1 = this;
      if (arguments.length === 0) {
        for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
          try {
            this$1.bufferReducedPrecision(precDigits);
          } catch (ex) {
            if (ex instanceof TopologyException) {
              this$1._saveException = ex;
            } else {
              throw ex;
            }
          } finally {
          }
          if (this$1._resultGeometry !== null) {
            return null;
          }
        }
        throw this._saveException;
      } else if (arguments.length === 1) {
        var precisionDigits = arguments[0];
        var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
        var fixedPM = new PrecisionModel(sizeBasedScaleFactor);
        this.bufferFixedPrecision(fixedPM);
      }
    };
    BufferOp.prototype.computeGeometry = function computeGeometry() {
      this.bufferOriginalPrecision();
      if (this._resultGeometry !== null) {
        return null;
      }
      var argPM = this._argGeom.getFactory().getPrecisionModel();
      if (argPM.getType() === PrecisionModel.FIXED) {
        this.bufferFixedPrecision(argPM);
      } else {
        this.bufferReducedPrecision();
      }
    };
    BufferOp.prototype.setQuadrantSegments = function setQuadrantSegments(quadrantSegments) {
      this._bufParams.setQuadrantSegments(quadrantSegments);
    };
    BufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision() {
      try {
        var bufBuilder = new BufferBuilder(this._bufParams);
        this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
      } catch (ex) {
        if (ex instanceof RuntimeException) {
          this._saveException = ex;
        } else {
          throw ex;
        }
      } finally {
      }
    };
    BufferOp.prototype.getResultGeometry = function getResultGeometry(distance) {
      this._distance = distance;
      this.computeGeometry();
      return this._resultGeometry;
    };
    BufferOp.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {
      this._bufParams.setEndCapStyle(endCapStyle);
    };
    BufferOp.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BufferOp.prototype.getClass = function getClass() {
      return BufferOp;
    };
    BufferOp.bufferOp = function bufferOp() {
      if (arguments.length === 2) {
        var g = arguments[0];
        var distance = arguments[1];
        var gBuf = new BufferOp(g);
        var geomBuf = gBuf.getResultGeometry(distance);
        return geomBuf;
      } else if (arguments.length === 3) {
        if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === "number")) {
          var g$1 = arguments[0];
          var distance$1 = arguments[1];
          var quadrantSegments = arguments[2];
          var bufOp = new BufferOp(g$1);
          bufOp.setQuadrantSegments(quadrantSegments);
          var geomBuf$1 = bufOp.getResultGeometry(distance$1);
          return geomBuf$1;
        } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === "number")) {
          var g$2 = arguments[0];
          var distance$2 = arguments[1];
          var params = arguments[2];
          var bufOp$1 = new BufferOp(g$2, params);
          var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);
          return geomBuf$2;
        }
      } else if (arguments.length === 4) {
        var g$3 = arguments[0];
        var distance$3 = arguments[1];
        var quadrantSegments$1 = arguments[2];
        var endCapStyle = arguments[3];
        var bufOp$2 = new BufferOp(g$3);
        bufOp$2.setQuadrantSegments(quadrantSegments$1);
        bufOp$2.setEndCapStyle(endCapStyle);
        var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);
        return geomBuf$3;
      }
    };
    BufferOp.precisionScaleFactor = function precisionScaleFactor(g, distance, maxPrecisionDigits) {
      var env = g.getEnvelopeInternal();
      var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
      var expandByDistance = distance > 0 ? distance : 0;
      var bufEnvMax = envMax + 2 * expandByDistance;
      var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1);
      var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
      var scaleFactor = Math.pow(10, minUnitLog10);
      return scaleFactor;
    };
    staticAccessors$32.CAP_ROUND.get = function() {
      return BufferParameters.CAP_ROUND;
    };
    staticAccessors$32.CAP_BUTT.get = function() {
      return BufferParameters.CAP_FLAT;
    };
    staticAccessors$32.CAP_FLAT.get = function() {
      return BufferParameters.CAP_FLAT;
    };
    staticAccessors$32.CAP_SQUARE.get = function() {
      return BufferParameters.CAP_SQUARE;
    };
    staticAccessors$32.MAX_PRECISION_DIGITS.get = function() {
      return 12;
    };
    Object.defineProperties(BufferOp, staticAccessors$32);
    var PointPairDistance = function PointPairDistance2() {
      this._pt = [new Coordinate(), new Coordinate()];
      this._distance = Double.NaN;
      this._isNull = true;
    };
    PointPairDistance.prototype.getCoordinates = function getCoordinates() {
      return this._pt;
    };
    PointPairDistance.prototype.getCoordinate = function getCoordinate(i) {
      return this._pt[i];
    };
    PointPairDistance.prototype.setMinimum = function setMinimum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist < this._distance) {
          this.initialize(p0, p1, dist);
        }
      }
    };
    PointPairDistance.prototype.initialize = function initialize() {
      if (arguments.length === 0) {
        this._isNull = true;
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        this._pt[0].setCoordinate(p0);
        this._pt[1].setCoordinate(p1);
        this._distance = p0.distance(p1);
        this._isNull = false;
      } else if (arguments.length === 3) {
        var p0$1 = arguments[0];
        var p1$1 = arguments[1];
        var distance = arguments[2];
        this._pt[0].setCoordinate(p0$1);
        this._pt[1].setCoordinate(p1$1);
        this._distance = distance;
        this._isNull = false;
      }
    };
    PointPairDistance.prototype.getDistance = function getDistance() {
      return this._distance;
    };
    PointPairDistance.prototype.setMaximum = function setMaximum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist > this._distance) {
          this.initialize(p0, p1, dist);
        }
      }
    };
    PointPairDistance.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PointPairDistance.prototype.getClass = function getClass() {
      return PointPairDistance;
    };
    var DistanceToPointFinder = function DistanceToPointFinder2() {
    };
    DistanceToPointFinder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    DistanceToPointFinder.prototype.getClass = function getClass() {
      return DistanceToPointFinder;
    };
    DistanceToPointFinder.computeDistance = function computeDistance() {
      if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {
        var line = arguments[0];
        var pt = arguments[1];
        var ptDist = arguments[2];
        var coords = line.getCoordinates();
        var tempSegment = new LineSegment();
        for (var i = 0; i < coords.length - 1; i++) {
          tempSegment.setCoordinates(coords[i], coords[i + 1]);
          var closestPt = tempSegment.closestPoint(pt);
          ptDist.setMinimum(closestPt, pt);
        }
      } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
        var poly = arguments[0];
        var pt$1 = arguments[1];
        var ptDist$1 = arguments[2];
        DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
        for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
          DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
        }
      } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
        var geom = arguments[0];
        var pt$2 = arguments[1];
        var ptDist$2 = arguments[2];
        if (geom instanceof LineString) {
          DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
        } else if (geom instanceof Polygon) {
          DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
        } else if (geom instanceof GeometryCollection) {
          var gc = geom;
          for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
            var g = gc.getGeometryN(i$2);
            DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);
          }
        } else {
          ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
        }
      } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
        var segment = arguments[0];
        var pt$3 = arguments[1];
        var ptDist$3 = arguments[2];
        var closestPt$1 = segment.closestPoint(pt$3);
        ptDist$3.setMinimum(closestPt$1, pt$3);
      }
    };
    var BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder2(inputGeom) {
      this._maxPtDist = new PointPairDistance();
      this._inputGeom = inputGeom || null;
    };
    var staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
    BufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance(curve) {
      var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);
      curve.apply(distFilter);
      this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
    };
    BufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance(curve) {
      var distFilter = new MaxPointDistanceFilter(this._inputGeom);
      curve.apply(distFilter);
      this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
    };
    BufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance(bufferCurve) {
      this.computeMaxVertexDistance(bufferCurve);
      this.computeMaxMidpointDistance(bufferCurve);
      return this._maxPtDist.getDistance();
    };
    BufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints() {
      return this._maxPtDist;
    };
    BufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BufferCurveMaximumDistanceFinder.prototype.getClass = function getClass() {
      return BufferCurveMaximumDistanceFinder;
    };
    staticAccessors$36.MaxPointDistanceFilter.get = function() {
      return MaxPointDistanceFilter;
    };
    staticAccessors$36.MaxMidpointDistanceFilter.get = function() {
      return MaxMidpointDistanceFilter;
    };
    Object.defineProperties(BufferCurveMaximumDistanceFinder, staticAccessors$36);
    var MaxPointDistanceFilter = function MaxPointDistanceFilter2(geom) {
      this._maxPtDist = new PointPairDistance();
      this._minPtDist = new PointPairDistance();
      this._geom = geom || null;
    };
    MaxPointDistanceFilter.prototype.filter = function filter(pt) {
      this._minPtDist.initialize();
      DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);
      this._maxPtDist.setMaximum(this._minPtDist);
    };
    MaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
      return this._maxPtDist;
    };
    MaxPointDistanceFilter.prototype.interfaces_ = function interfaces_() {
      return [CoordinateFilter];
    };
    MaxPointDistanceFilter.prototype.getClass = function getClass() {
      return MaxPointDistanceFilter;
    };
    var MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter2(geom) {
      this._maxPtDist = new PointPairDistance();
      this._minPtDist = new PointPairDistance();
      this._geom = geom || null;
    };
    MaxMidpointDistanceFilter.prototype.filter = function filter(seq, index) {
      if (index === 0) {
        return null;
      }
      var p0 = seq.getCoordinate(index - 1);
      var p1 = seq.getCoordinate(index);
      var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
      this._minPtDist.initialize();
      DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);
      this._maxPtDist.setMaximum(this._minPtDist);
    };
    MaxMidpointDistanceFilter.prototype.isDone = function isDone() {
      return false;
    };
    MaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged() {
      return false;
    };
    MaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
      return this._maxPtDist;
    };
    MaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_() {
      return [CoordinateSequenceFilter];
    };
    MaxMidpointDistanceFilter.prototype.getClass = function getClass() {
      return MaxMidpointDistanceFilter;
    };
    var PolygonExtracter = function PolygonExtracter2(comps) {
      this._comps = comps || null;
    };
    PolygonExtracter.prototype.filter = function filter(geom) {
      if (geom instanceof Polygon) {
        this._comps.add(geom);
      }
    };
    PolygonExtracter.prototype.interfaces_ = function interfaces_() {
      return [GeometryFilter];
    };
    PolygonExtracter.prototype.getClass = function getClass() {
      return PolygonExtracter;
    };
    PolygonExtracter.getPolygons = function getPolygons() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        return PolygonExtracter.getPolygons(geom, new ArrayList());
      } else if (arguments.length === 2) {
        var geom$1 = arguments[0];
        var list = arguments[1];
        if (geom$1 instanceof Polygon) {
          list.add(geom$1);
        } else if (geom$1 instanceof GeometryCollection) {
          geom$1.apply(new PolygonExtracter(list));
        }
        return list;
      }
    };
    var LinearComponentExtracter = function LinearComponentExtracter2() {
      this._lines = null;
      this._isForcedToLineString = false;
      if (arguments.length === 1) {
        var lines = arguments[0];
        this._lines = lines;
      } else if (arguments.length === 2) {
        var lines$1 = arguments[0];
        var isForcedToLineString = arguments[1];
        this._lines = lines$1;
        this._isForcedToLineString = isForcedToLineString;
      }
    };
    LinearComponentExtracter.prototype.filter = function filter(geom) {
      if (this._isForcedToLineString && geom instanceof LinearRing) {
        var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
        this._lines.add(line);
        return null;
      }
      if (geom instanceof LineString) {
        this._lines.add(geom);
      }
    };
    LinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString(isForcedToLineString) {
      this._isForcedToLineString = isForcedToLineString;
    };
    LinearComponentExtracter.prototype.interfaces_ = function interfaces_() {
      return [GeometryComponentFilter];
    };
    LinearComponentExtracter.prototype.getClass = function getClass() {
      return LinearComponentExtracter;
    };
    LinearComponentExtracter.getGeometry = function getGeometry() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
      } else if (arguments.length === 2) {
        var geom$1 = arguments[0];
        var forceToLineString = arguments[1];
        return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString));
      }
    };
    LinearComponentExtracter.getLines = function getLines() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        return LinearComponentExtracter.getLines(geom, false);
      } else if (arguments.length === 2) {
        if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
          var geoms = arguments[0];
          var lines$1 = arguments[1];
          for (var i = geoms.iterator(); i.hasNext(); ) {
            var g = i.next();
            LinearComponentExtracter.getLines(g, lines$1);
          }
          return lines$1;
        } else if (arguments[0] instanceof Geometry && typeof arguments[1] === "boolean") {
          var geom$1 = arguments[0];
          var forceToLineString = arguments[1];
          var lines = new ArrayList();
          geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));
          return lines;
        } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
          var geom$2 = arguments[0];
          var lines$2 = arguments[1];
          if (geom$2 instanceof LineString) {
            lines$2.add(geom$2);
          } else {
            geom$2.apply(new LinearComponentExtracter(lines$2));
          }
          return lines$2;
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[2] === "boolean" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {
          var geoms$1 = arguments[0];
          var lines$3 = arguments[1];
          var forceToLineString$1 = arguments[2];
          for (var i$1 = geoms$1.iterator(); i$1.hasNext(); ) {
            var g$1 = i$1.next();
            LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);
          }
          return lines$3;
        } else if (typeof arguments[2] === "boolean" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {
          var geom$3 = arguments[0];
          var lines$4 = arguments[1];
          var forceToLineString$2 = arguments[2];
          geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));
          return lines$4;
        }
      }
    };
    var PointLocator = function PointLocator2() {
      this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
      this._isIn = null;
      this._numBoundaries = null;
      if (arguments.length === 0) {
      } else if (arguments.length === 1) {
        var boundaryRule = arguments[0];
        if (boundaryRule === null) {
          throw new IllegalArgumentException("Rule must be non-null");
        }
        this._boundaryRule = boundaryRule;
      }
    };
    PointLocator.prototype.locateInternal = function locateInternal() {
      var this$1 = this;
      if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {
        var p = arguments[0];
        var poly = arguments[1];
        if (poly.isEmpty()) {
          return Location.EXTERIOR;
        }
        var shell = poly.getExteriorRing();
        var shellLoc = this.locateInPolygonRing(p, shell);
        if (shellLoc === Location.EXTERIOR) {
          return Location.EXTERIOR;
        }
        if (shellLoc === Location.BOUNDARY) {
          return Location.BOUNDARY;
        }
        for (var i = 0; i < poly.getNumInteriorRing(); i++) {
          var hole = poly.getInteriorRingN(i);
          var holeLoc = this$1.locateInPolygonRing(p, hole);
          if (holeLoc === Location.INTERIOR) {
            return Location.EXTERIOR;
          }
          if (holeLoc === Location.BOUNDARY) {
            return Location.BOUNDARY;
          }
        }
        return Location.INTERIOR;
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {
        var p$1 = arguments[0];
        var l = arguments[1];
        if (!l.getEnvelopeInternal().intersects(p$1)) {
          return Location.EXTERIOR;
        }
        var pt = l.getCoordinates();
        if (!l.isClosed()) {
          if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {
            return Location.BOUNDARY;
          }
        }
        if (CGAlgorithms.isOnLine(p$1, pt)) {
          return Location.INTERIOR;
        }
        return Location.EXTERIOR;
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {
        var p$2 = arguments[0];
        var pt$1 = arguments[1];
        var ptCoord = pt$1.getCoordinate();
        if (ptCoord.equals2D(p$2)) {
          return Location.INTERIOR;
        }
        return Location.EXTERIOR;
      }
    };
    PointLocator.prototype.locateInPolygonRing = function locateInPolygonRing(p, ring) {
      if (!ring.getEnvelopeInternal().intersects(p)) {
        return Location.EXTERIOR;
      }
      return CGAlgorithms.locatePointInRing(p, ring.getCoordinates());
    };
    PointLocator.prototype.intersects = function intersects(p, geom) {
      return this.locate(p, geom) !== Location.EXTERIOR;
    };
    PointLocator.prototype.updateLocationInfo = function updateLocationInfo(loc) {
      if (loc === Location.INTERIOR) {
        this._isIn = true;
      }
      if (loc === Location.BOUNDARY) {
        this._numBoundaries++;
      }
    };
    PointLocator.prototype.computeLocation = function computeLocation(p, geom) {
      var this$1 = this;
      if (geom instanceof Point) {
        this.updateLocationInfo(this.locateInternal(p, geom));
      }
      if (geom instanceof LineString) {
        this.updateLocationInfo(this.locateInternal(p, geom));
      } else if (geom instanceof Polygon) {
        this.updateLocationInfo(this.locateInternal(p, geom));
      } else if (geom instanceof MultiLineString) {
        var ml = geom;
        for (var i = 0; i < ml.getNumGeometries(); i++) {
          var l = ml.getGeometryN(i);
          this$1.updateLocationInfo(this$1.locateInternal(p, l));
        }
      } else if (geom instanceof MultiPolygon) {
        var mpoly = geom;
        for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {
          var poly = mpoly.getGeometryN(i$1);
          this$1.updateLocationInfo(this$1.locateInternal(p, poly));
        }
      } else if (geom instanceof GeometryCollection) {
        var geomi = new GeometryCollectionIterator(geom);
        while (geomi.hasNext()) {
          var g2 = geomi.next();
          if (g2 !== geom) {
            this$1.computeLocation(p, g2);
          }
        }
      }
    };
    PointLocator.prototype.locate = function locate(p, geom) {
      if (geom.isEmpty()) {
        return Location.EXTERIOR;
      }
      if (geom instanceof LineString) {
        return this.locateInternal(p, geom);
      } else if (geom instanceof Polygon) {
        return this.locateInternal(p, geom);
      }
      this._isIn = false;
      this._numBoundaries = 0;
      this.computeLocation(p, geom);
      if (this._boundaryRule.isInBoundary(this._numBoundaries)) {
        return Location.BOUNDARY;
      }
      if (this._numBoundaries > 0 || this._isIn) {
        return Location.INTERIOR;
      }
      return Location.EXTERIOR;
    };
    PointLocator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PointLocator.prototype.getClass = function getClass() {
      return PointLocator;
    };
    var GeometryLocation = function GeometryLocation2() {
      this._component = null;
      this._segIndex = null;
      this._pt = null;
      if (arguments.length === 2) {
        var component = arguments[0];
        var pt = arguments[1];
        GeometryLocation2.call(this, component, GeometryLocation2.INSIDE_AREA, pt);
      } else if (arguments.length === 3) {
        var component$1 = arguments[0];
        var segIndex = arguments[1];
        var pt$1 = arguments[2];
        this._component = component$1;
        this._segIndex = segIndex;
        this._pt = pt$1;
      }
    };
    var staticAccessors$38 = { INSIDE_AREA: { configurable: true } };
    GeometryLocation.prototype.isInsideArea = function isInsideArea() {
      return this._segIndex === GeometryLocation.INSIDE_AREA;
    };
    GeometryLocation.prototype.getCoordinate = function getCoordinate() {
      return this._pt;
    };
    GeometryLocation.prototype.getGeometryComponent = function getGeometryComponent() {
      return this._component;
    };
    GeometryLocation.prototype.getSegmentIndex = function getSegmentIndex() {
      return this._segIndex;
    };
    GeometryLocation.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryLocation.prototype.getClass = function getClass() {
      return GeometryLocation;
    };
    staticAccessors$38.INSIDE_AREA.get = function() {
      return -1;
    };
    Object.defineProperties(GeometryLocation, staticAccessors$38);
    var PointExtracter = function PointExtracter2(pts) {
      this._pts = pts || null;
    };
    PointExtracter.prototype.filter = function filter(geom) {
      if (geom instanceof Point) {
        this._pts.add(geom);
      }
    };
    PointExtracter.prototype.interfaces_ = function interfaces_() {
      return [GeometryFilter];
    };
    PointExtracter.prototype.getClass = function getClass() {
      return PointExtracter;
    };
    PointExtracter.getPoints = function getPoints() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        if (geom instanceof Point) {
          return Collections.singletonList(geom);
        }
        return PointExtracter.getPoints(geom, new ArrayList());
      } else if (arguments.length === 2) {
        var geom$1 = arguments[0];
        var list = arguments[1];
        if (geom$1 instanceof Point) {
          list.add(geom$1);
        } else if (geom$1 instanceof GeometryCollection) {
          geom$1.apply(new PointExtracter(list));
        }
        return list;
      }
    };
    var ConnectedElementLocationFilter = function ConnectedElementLocationFilter2() {
      this._locations = null;
      var locations = arguments[0];
      this._locations = locations;
    };
    ConnectedElementLocationFilter.prototype.filter = function filter(geom) {
      if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) {
        this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));
      }
    };
    ConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_() {
      return [GeometryFilter];
    };
    ConnectedElementLocationFilter.prototype.getClass = function getClass() {
      return ConnectedElementLocationFilter;
    };
    ConnectedElementLocationFilter.getLocations = function getLocations(geom) {
      var locations = new ArrayList();
      geom.apply(new ConnectedElementLocationFilter(locations));
      return locations;
    };
    var DistanceOp = function DistanceOp2() {
      this._geom = null;
      this._terminateDistance = 0;
      this._ptLocator = new PointLocator();
      this._minDistanceLocation = null;
      this._minDistance = Double.MAX_VALUE;
      if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        this._geom = [g0, g1];
        this._terminateDistance = 0;
      } else if (arguments.length === 3) {
        var g0$1 = arguments[0];
        var g1$1 = arguments[1];
        var terminateDistance = arguments[2];
        this._geom = new Array(2).fill(null);
        this._geom[0] = g0$1;
        this._geom[1] = g1$1;
        this._terminateDistance = terminateDistance;
      }
    };
    DistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance() {
      var this$1 = this;
      if (arguments.length === 0) {
        var locPtPoly = new Array(2).fill(null);
        this.computeContainmentDistance(0, locPtPoly);
        if (this._minDistance <= this._terminateDistance) {
          return null;
        }
        this.computeContainmentDistance(1, locPtPoly);
      } else if (arguments.length === 2) {
        var polyGeomIndex = arguments[0];
        var locPtPoly$1 = arguments[1];
        var locationsIndex = 1 - polyGeomIndex;
        var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);
        if (polys.size() > 0) {
          var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);
          this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);
          if (this._minDistance <= this._terminateDistance) {
            this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];
            this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];
            return null;
          }
        }
      } else if (arguments.length === 3) {
        if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
          var locs = arguments[0];
          var polys$1 = arguments[1];
          var locPtPoly$2 = arguments[2];
          for (var i = 0; i < locs.size(); i++) {
            var loc = locs.get(i);
            for (var j = 0; j < polys$1.size(); j++) {
              this$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);
              if (this$1._minDistance <= this$1._terminateDistance) {
                return null;
              }
            }
          }
        } else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {
          var ptLoc = arguments[0];
          var poly = arguments[1];
          var locPtPoly$3 = arguments[2];
          var pt = ptLoc.getCoordinate();
          if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {
            this._minDistance = 0;
            locPtPoly$3[0] = ptLoc;
            locPtPoly$3[1] = new GeometryLocation(poly, pt);
            return null;
          }
        }
      }
    };
    DistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints(lines, points, locGeom) {
      var this$1 = this;
      for (var i = 0; i < lines.size(); i++) {
        var line = lines.get(i);
        for (var j = 0; j < points.size(); j++) {
          var pt = points.get(j);
          this$1.computeMinDistance(line, pt, locGeom);
          if (this$1._minDistance <= this$1._terminateDistance) {
            return null;
          }
        }
      }
    };
    DistanceOp.prototype.computeFacetDistance = function computeFacetDistance() {
      var locGeom = new Array(2).fill(null);
      var lines0 = LinearComponentExtracter.getLines(this._geom[0]);
      var lines1 = LinearComponentExtracter.getLines(this._geom[1]);
      var pts0 = PointExtracter.getPoints(this._geom[0]);
      var pts1 = PointExtracter.getPoints(this._geom[1]);
      this.computeMinDistanceLines(lines0, lines1, locGeom);
      this.updateMinDistance(locGeom, false);
      if (this._minDistance <= this._terminateDistance) {
        return null;
      }
      locGeom[0] = null;
      locGeom[1] = null;
      this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
      this.updateMinDistance(locGeom, false);
      if (this._minDistance <= this._terminateDistance) {
        return null;
      }
      locGeom[0] = null;
      locGeom[1] = null;
      this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
      this.updateMinDistance(locGeom, true);
      if (this._minDistance <= this._terminateDistance) {
        return null;
      }
      locGeom[0] = null;
      locGeom[1] = null;
      this.computeMinDistancePoints(pts0, pts1, locGeom);
      this.updateMinDistance(locGeom, false);
    };
    DistanceOp.prototype.nearestLocations = function nearestLocations() {
      this.computeMinDistance();
      return this._minDistanceLocation;
    };
    DistanceOp.prototype.updateMinDistance = function updateMinDistance(locGeom, flip) {
      if (locGeom[0] === null) {
        return null;
      }
      if (flip) {
        this._minDistanceLocation[0] = locGeom[1];
        this._minDistanceLocation[1] = locGeom[0];
      } else {
        this._minDistanceLocation[0] = locGeom[0];
        this._minDistanceLocation[1] = locGeom[1];
      }
    };
    DistanceOp.prototype.nearestPoints = function nearestPoints() {
      this.computeMinDistance();
      var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
      return nearestPts;
    };
    DistanceOp.prototype.computeMinDistance = function computeMinDistance() {
      var this$1 = this;
      if (arguments.length === 0) {
        if (this._minDistanceLocation !== null) {
          return null;
        }
        this._minDistanceLocation = new Array(2).fill(null);
        this.computeContainmentDistance();
        if (this._minDistance <= this._terminateDistance) {
          return null;
        }
        this.computeFacetDistance();
      } else if (arguments.length === 3) {
        if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof Point)) {
          var line = arguments[0];
          var pt = arguments[1];
          var locGeom = arguments[2];
          if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) {
            return null;
          }
          var coord0 = line.getCoordinates();
          var coord = pt.getCoordinate();
          for (var i = 0; i < coord0.length - 1; i++) {
            var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
            if (dist < this$1._minDistance) {
              this$1._minDistance = dist;
              var seg = new LineSegment(coord0[i], coord0[i + 1]);
              var segClosestPoint = seg.closestPoint(coord);
              locGeom[0] = new GeometryLocation(line, i, segClosestPoint);
              locGeom[1] = new GeometryLocation(pt, 0, coord);
            }
            if (this$1._minDistance <= this$1._terminateDistance) {
              return null;
            }
          }
        } else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof LineString)) {
          var line0 = arguments[0];
          var line1 = arguments[1];
          var locGeom$1 = arguments[2];
          if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) {
            return null;
          }
          var coord0$1 = line0.getCoordinates();
          var coord1 = line1.getCoordinates();
          for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {
            for (var j = 0; j < coord1.length - 1; j++) {
              var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);
              if (dist$1 < this$1._minDistance) {
                this$1._minDistance = dist$1;
                var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);
                var seg1 = new LineSegment(coord1[j], coord1[j + 1]);
                var closestPt = seg0.closestPoints(seg1);
                locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);
                locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);
              }
              if (this$1._minDistance <= this$1._terminateDistance) {
                return null;
              }
            }
          }
        }
      }
    };
    DistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints(points0, points1, locGeom) {
      var this$1 = this;
      for (var i = 0; i < points0.size(); i++) {
        var pt0 = points0.get(i);
        for (var j = 0; j < points1.size(); j++) {
          var pt1 = points1.get(j);
          var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
          if (dist < this$1._minDistance) {
            this$1._minDistance = dist;
            locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());
            locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());
          }
          if (this$1._minDistance <= this$1._terminateDistance) {
            return null;
          }
        }
      }
    };
    DistanceOp.prototype.distance = function distance() {
      if (this._geom[0] === null || this._geom[1] === null) {
        throw new IllegalArgumentException("null geometries are not supported");
      }
      if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) {
        return 0;
      }
      this.computeMinDistance();
      return this._minDistance;
    };
    DistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines(lines0, lines1, locGeom) {
      var this$1 = this;
      for (var i = 0; i < lines0.size(); i++) {
        var line0 = lines0.get(i);
        for (var j = 0; j < lines1.size(); j++) {
          var line1 = lines1.get(j);
          this$1.computeMinDistance(line0, line1, locGeom);
          if (this$1._minDistance <= this$1._terminateDistance) {
            return null;
          }
        }
      }
    };
    DistanceOp.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    DistanceOp.prototype.getClass = function getClass() {
      return DistanceOp;
    };
    DistanceOp.distance = function distance(g0, g1) {
      var distOp = new DistanceOp(g0, g1);
      return distOp.distance();
    };
    DistanceOp.isWithinDistance = function isWithinDistance(g0, g1, distance) {
      var distOp = new DistanceOp(g0, g1, distance);
      return distOp.distance() <= distance;
    };
    DistanceOp.nearestPoints = function nearestPoints(g0, g1) {
      var distOp = new DistanceOp(g0, g1);
      return distOp.nearestPoints();
    };
    var PointPairDistance$2 = function PointPairDistance2() {
      this._pt = [new Coordinate(), new Coordinate()];
      this._distance = Double.NaN;
      this._isNull = true;
    };
    PointPairDistance$2.prototype.getCoordinates = function getCoordinates() {
      return this._pt;
    };
    PointPairDistance$2.prototype.getCoordinate = function getCoordinate(i) {
      return this._pt[i];
    };
    PointPairDistance$2.prototype.setMinimum = function setMinimum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist < this._distance) {
          this.initialize(p0, p1, dist);
        }
      }
    };
    PointPairDistance$2.prototype.initialize = function initialize() {
      if (arguments.length === 0) {
        this._isNull = true;
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        this._pt[0].setCoordinate(p0);
        this._pt[1].setCoordinate(p1);
        this._distance = p0.distance(p1);
        this._isNull = false;
      } else if (arguments.length === 3) {
        var p0$1 = arguments[0];
        var p1$1 = arguments[1];
        var distance = arguments[2];
        this._pt[0].setCoordinate(p0$1);
        this._pt[1].setCoordinate(p1$1);
        this._distance = distance;
        this._isNull = false;
      }
    };
    PointPairDistance$2.prototype.toString = function toString() {
      return WKTWriter.toLineString(this._pt[0], this._pt[1]);
    };
    PointPairDistance$2.prototype.getDistance = function getDistance() {
      return this._distance;
    };
    PointPairDistance$2.prototype.setMaximum = function setMaximum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist > this._distance) {
          this.initialize(p0, p1, dist);
        }
      }
    };
    PointPairDistance$2.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PointPairDistance$2.prototype.getClass = function getClass() {
      return PointPairDistance$2;
    };
    var DistanceToPoint = function DistanceToPoint2() {
    };
    DistanceToPoint.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    DistanceToPoint.prototype.getClass = function getClass() {
      return DistanceToPoint;
    };
    DistanceToPoint.computeDistance = function computeDistance() {
      if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {
        var line = arguments[0];
        var pt = arguments[1];
        var ptDist = arguments[2];
        var tempSegment = new LineSegment();
        var coords = line.getCoordinates();
        for (var i = 0; i < coords.length - 1; i++) {
          tempSegment.setCoordinates(coords[i], coords[i + 1]);
          var closestPt = tempSegment.closestPoint(pt);
          ptDist.setMinimum(closestPt, pt);
        }
      } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
        var poly = arguments[0];
        var pt$1 = arguments[1];
        var ptDist$1 = arguments[2];
        DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
        for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
          DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
        }
      } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
        var geom = arguments[0];
        var pt$2 = arguments[1];
        var ptDist$2 = arguments[2];
        if (geom instanceof LineString) {
          DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
        } else if (geom instanceof Polygon) {
          DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
        } else if (geom instanceof GeometryCollection) {
          var gc = geom;
          for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
            var g = gc.getGeometryN(i$2);
            DistanceToPoint.computeDistance(g, pt$2, ptDist$2);
          }
        } else {
          ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
        }
      } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
        var segment = arguments[0];
        var pt$3 = arguments[1];
        var ptDist$3 = arguments[2];
        var closestPt$1 = segment.closestPoint(pt$3);
        ptDist$3.setMinimum(closestPt$1, pt$3);
      }
    };
    var DiscreteHausdorffDistance = function DiscreteHausdorffDistance2() {
      this._g0 = null;
      this._g1 = null;
      this._ptDist = new PointPairDistance$2();
      this._densifyFrac = 0;
      var g0 = arguments[0];
      var g1 = arguments[1];
      this._g0 = g0;
      this._g1 = g1;
    };
    var staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
    DiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates() {
      return this._ptDist.getCoordinates();
    };
    DiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction(densifyFrac) {
      if (densifyFrac > 1 || densifyFrac <= 0) {
        throw new IllegalArgumentException("Fraction is not in range (0.0 - 1.0]");
      }
      this._densifyFrac = densifyFrac;
    };
    DiscreteHausdorffDistance.prototype.compute = function compute(g0, g1) {
      this.computeOrientedDistance(g0, g1, this._ptDist);
      this.computeOrientedDistance(g1, g0, this._ptDist);
    };
    DiscreteHausdorffDistance.prototype.distance = function distance() {
      this.compute(this._g0, this._g1);
      return this._ptDist.getDistance();
    };
    DiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance(discreteGeom, geom, ptDist) {
      var distFilter = new MaxPointDistanceFilter$1(geom);
      discreteGeom.apply(distFilter);
      ptDist.setMaximum(distFilter.getMaxPointDistance());
      if (this._densifyFrac > 0) {
        var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);
        discreteGeom.apply(fracFilter);
        ptDist.setMaximum(fracFilter.getMaxPointDistance());
      }
    };
    DiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance() {
      this.computeOrientedDistance(this._g0, this._g1, this._ptDist);
      return this._ptDist.getDistance();
    };
    DiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    DiscreteHausdorffDistance.prototype.getClass = function getClass() {
      return DiscreteHausdorffDistance;
    };
    DiscreteHausdorffDistance.distance = function distance() {
      if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        var dist = new DiscreteHausdorffDistance(g0, g1);
        return dist.distance();
      } else if (arguments.length === 3) {
        var g0$1 = arguments[0];
        var g1$1 = arguments[1];
        var densifyFrac = arguments[2];
        var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);
        dist$1.setDensifyFraction(densifyFrac);
        return dist$1.distance();
      }
    };
    staticAccessors$39.MaxPointDistanceFilter.get = function() {
      return MaxPointDistanceFilter$1;
    };
    staticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function() {
      return MaxDensifiedByFractionDistanceFilter;
    };
    Object.defineProperties(DiscreteHausdorffDistance, staticAccessors$39);
    var MaxPointDistanceFilter$1 = function MaxPointDistanceFilter2() {
      this._maxPtDist = new PointPairDistance$2();
      this._minPtDist = new PointPairDistance$2();
      this._euclideanDist = new DistanceToPoint();
      this._geom = null;
      var geom = arguments[0];
      this._geom = geom;
    };
    MaxPointDistanceFilter$1.prototype.filter = function filter(pt) {
      this._minPtDist.initialize();
      DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
      this._maxPtDist.setMaximum(this._minPtDist);
    };
    MaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance() {
      return this._maxPtDist;
    };
    MaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_() {
      return [CoordinateFilter];
    };
    MaxPointDistanceFilter$1.prototype.getClass = function getClass() {
      return MaxPointDistanceFilter$1;
    };
    var MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter2() {
      this._maxPtDist = new PointPairDistance$2();
      this._minPtDist = new PointPairDistance$2();
      this._geom = null;
      this._numSubSegs = 0;
      var geom = arguments[0];
      var fraction = arguments[1];
      this._geom = geom;
      this._numSubSegs = Math.trunc(Math.round(1 / fraction));
    };
    MaxDensifiedByFractionDistanceFilter.prototype.filter = function filter(seq, index) {
      var this$1 = this;
      if (index === 0) {
        return null;
      }
      var p0 = seq.getCoordinate(index - 1);
      var p1 = seq.getCoordinate(index);
      var delx = (p1.x - p0.x) / this._numSubSegs;
      var dely = (p1.y - p0.y) / this._numSubSegs;
      for (var i = 0; i < this._numSubSegs; i++) {
        var x = p0.x + i * delx;
        var y = p0.y + i * dely;
        var pt = new Coordinate(x, y);
        this$1._minPtDist.initialize();
        DistanceToPoint.computeDistance(this$1._geom, pt, this$1._minPtDist);
        this$1._maxPtDist.setMaximum(this$1._minPtDist);
      }
    };
    MaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone() {
      return false;
    };
    MaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged() {
      return false;
    };
    MaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
      return this._maxPtDist;
    };
    MaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_() {
      return [CoordinateSequenceFilter];
    };
    MaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass() {
      return MaxDensifiedByFractionDistanceFilter;
    };
    var BufferDistanceValidator = function BufferDistanceValidator2(input, bufDistance, result2) {
      this._minValidDistance = null;
      this._maxValidDistance = null;
      this._minDistanceFound = null;
      this._maxDistanceFound = null;
      this._isValid = true;
      this._errMsg = null;
      this._errorLocation = null;
      this._errorIndicator = null;
      this._input = input || null;
      this._bufDistance = bufDistance || null;
      this._result = result2 || null;
    };
    var staticAccessors$37 = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
    BufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance(input, bufCurve, maxDist) {
      var haus = new DiscreteHausdorffDistance(bufCurve, input);
      haus.setDensifyFraction(0.25);
      this._maxDistanceFound = haus.orientedDistance();
      if (this._maxDistanceFound > maxDist) {
        this._isValid = false;
        var pts = haus.getCoordinates();
        this._errorLocation = pts[1];
        this._errorIndicator = input.getFactory().createLineString(pts);
        this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + WKTWriter.toLineString(pts[0], pts[1]) + ")";
      }
    };
    BufferDistanceValidator.prototype.isValid = function isValid() {
      var posDistance = Math.abs(this._bufDistance);
      var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;
      this._minValidDistance = posDistance - distDelta;
      this._maxValidDistance = posDistance + distDelta;
      if (this._input.isEmpty() || this._result.isEmpty()) {
        return true;
      }
      if (this._bufDistance > 0) {
        this.checkPositiveValid();
      } else {
        this.checkNegativeValid();
      }
      if (BufferDistanceValidator.VERBOSE) {
        System.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1));
      }
      return this._isValid;
    };
    BufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid() {
      if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {
        return null;
      }
      var inputCurve = this.getPolygonLines(this._input);
      this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);
      if (!this._isValid) {
        return null;
      }
      this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);
    };
    BufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator() {
      return this._errorIndicator;
    };
    BufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance(g1, g2, minDist) {
      var distOp = new DistanceOp(g1, g2, minDist);
      this._minDistanceFound = distOp.distance();
      if (this._minDistanceFound < minDist) {
        this._isValid = false;
        var pts = distOp.nearestPoints();
        this._errorLocation = distOp.nearestPoints()[1];
        this._errorIndicator = g1.getFactory().createLineString(pts);
        this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + WKTWriter.toLineString(pts[0], pts[1]) + " )";
      }
    };
    BufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid() {
      var bufCurve = this._result.getBoundary();
      this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);
      if (!this._isValid) {
        return null;
      }
      this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);
    };
    BufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation() {
      return this._errorLocation;
    };
    BufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines(g) {
      var lines = new ArrayList();
      var lineExtracter = new LinearComponentExtracter(lines);
      var polys = PolygonExtracter.getPolygons(g);
      for (var i = polys.iterator(); i.hasNext(); ) {
        var poly = i.next();
        poly.apply(lineExtracter);
      }
      return g.getFactory().buildGeometry(lines);
    };
    BufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage() {
      return this._errMsg;
    };
    BufferDistanceValidator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BufferDistanceValidator.prototype.getClass = function getClass() {
      return BufferDistanceValidator;
    };
    staticAccessors$37.VERBOSE.get = function() {
      return false;
    };
    staticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function() {
      return 0.012;
    };
    Object.defineProperties(BufferDistanceValidator, staticAccessors$37);
    var BufferResultValidator = function BufferResultValidator2(input, distance, result2) {
      this._isValid = true;
      this._errorMsg = null;
      this._errorLocation = null;
      this._errorIndicator = null;
      this._input = input || null;
      this._distance = distance || null;
      this._result = result2 || null;
    };
    var staticAccessors$40 = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
    BufferResultValidator.prototype.isValid = function isValid() {
      this.checkPolygonal();
      if (!this._isValid) {
        return this._isValid;
      }
      this.checkExpectedEmpty();
      if (!this._isValid) {
        return this._isValid;
      }
      this.checkEnvelope();
      if (!this._isValid) {
        return this._isValid;
      }
      this.checkArea();
      if (!this._isValid) {
        return this._isValid;
      }
      this.checkDistance();
      return this._isValid;
    };
    BufferResultValidator.prototype.checkEnvelope = function checkEnvelope() {
      if (this._distance < 0) {
        return null;
      }
      var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;
      if (padding === 0) {
        padding = 1e-3;
      }
      var expectedEnv = new Envelope(this._input.getEnvelopeInternal());
      expectedEnv.expandBy(this._distance);
      var bufEnv = new Envelope(this._result.getEnvelopeInternal());
      bufEnv.expandBy(padding);
      if (!bufEnv.contains(expectedEnv)) {
        this._isValid = false;
        this._errorMsg = "Buffer envelope is incorrect";
        this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);
      }
      this.report("Envelope");
    };
    BufferResultValidator.prototype.checkDistance = function checkDistance() {
      var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);
      if (!distValid.isValid()) {
        this._isValid = false;
        this._errorMsg = distValid.getErrorMessage();
        this._errorLocation = distValid.getErrorLocation();
        this._errorIndicator = distValid.getErrorIndicator();
      }
      this.report("Distance");
    };
    BufferResultValidator.prototype.checkArea = function checkArea() {
      var inputArea = this._input.getArea();
      var resultArea = this._result.getArea();
      if (this._distance > 0 && inputArea > resultArea) {
        this._isValid = false;
        this._errorMsg = "Area of positive buffer is smaller than input";
        this._errorIndicator = this._result;
      }
      if (this._distance < 0 && inputArea < resultArea) {
        this._isValid = false;
        this._errorMsg = "Area of negative buffer is larger than input";
        this._errorIndicator = this._result;
      }
      this.report("Area");
    };
    BufferResultValidator.prototype.checkPolygonal = function checkPolygonal() {
      if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) {
        this._isValid = false;
      }
      this._errorMsg = "Result is not polygonal";
      this._errorIndicator = this._result;
      this.report("Polygonal");
    };
    BufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator() {
      return this._errorIndicator;
    };
    BufferResultValidator.prototype.getErrorLocation = function getErrorLocation() {
      return this._errorLocation;
    };
    BufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty() {
      if (this._input.getDimension() >= 2) {
        return null;
      }
      if (this._distance > 0) {
        return null;
      }
      if (!this._result.isEmpty()) {
        this._isValid = false;
        this._errorMsg = "Result is non-empty";
        this._errorIndicator = this._result;
      }
      this.report("ExpectedEmpty");
    };
    BufferResultValidator.prototype.report = function report(checkName) {
      if (!BufferResultValidator.VERBOSE) {
        return null;
      }
      System.out.println("Check " + checkName + ": " + (this._isValid ? "passed" : "FAILED"));
    };
    BufferResultValidator.prototype.getErrorMessage = function getErrorMessage() {
      return this._errorMsg;
    };
    BufferResultValidator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    BufferResultValidator.prototype.getClass = function getClass() {
      return BufferResultValidator;
    };
    BufferResultValidator.isValidMsg = function isValidMsg(g, distance, result2) {
      var validator = new BufferResultValidator(g, distance, result2);
      if (!validator.isValid()) {
        return validator.getErrorMessage();
      }
      return null;
    };
    BufferResultValidator.isValid = function isValid(g, distance, result2) {
      var validator = new BufferResultValidator(g, distance, result2);
      if (validator.isValid()) {
        return true;
      }
      return false;
    };
    staticAccessors$40.VERBOSE.get = function() {
      return false;
    };
    staticAccessors$40.MAX_ENV_DIFF_FRAC.get = function() {
      return 0.012;
    };
    Object.defineProperties(BufferResultValidator, staticAccessors$40);
    var BasicSegmentString = function BasicSegmentString2() {
      this._pts = null;
      this._data = null;
      var pts = arguments[0];
      var data = arguments[1];
      this._pts = pts;
      this._data = data;
    };
    BasicSegmentString.prototype.getCoordinates = function getCoordinates() {
      return this._pts;
    };
    BasicSegmentString.prototype.size = function size() {
      return this._pts.length;
    };
    BasicSegmentString.prototype.getCoordinate = function getCoordinate(i) {
      return this._pts[i];
    };
    BasicSegmentString.prototype.isClosed = function isClosed() {
      return this._pts[0].equals(this._pts[this._pts.length - 1]);
    };
    BasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index) {
      if (index === this._pts.length - 1) {
        return -1;
      }
      return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));
    };
    BasicSegmentString.prototype.setData = function setData(data) {
      this._data = data;
    };
    BasicSegmentString.prototype.getData = function getData() {
      return this._data;
    };
    BasicSegmentString.prototype.toString = function toString() {
      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
    };
    BasicSegmentString.prototype.interfaces_ = function interfaces_() {
      return [SegmentString];
    };
    BasicSegmentString.prototype.getClass = function getClass() {
      return BasicSegmentString;
    };
    var InteriorIntersectionFinder = function InteriorIntersectionFinder2() {
      this._findAllIntersections = false;
      this._isCheckEndSegmentsOnly = false;
      this._li = null;
      this._interiorIntersection = null;
      this._intSegments = null;
      this._intersections = new ArrayList();
      this._intersectionCount = 0;
      this._keepIntersections = true;
      var li = arguments[0];
      this._li = li;
      this._interiorIntersection = null;
    };
    InteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection() {
      return this._interiorIntersection;
    };
    InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
      this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
    };
    InteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments() {
      return this._intSegments;
    };
    InteriorIntersectionFinder.prototype.count = function count() {
      return this._intersectionCount;
    };
    InteriorIntersectionFinder.prototype.getIntersections = function getIntersections() {
      return this._intersections;
    };
    InteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {
      this._findAllIntersections = findAllIntersections;
    };
    InteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections(keepIntersections) {
      this._keepIntersections = keepIntersections;
    };
    InteriorIntersectionFinder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
      if (!this._findAllIntersections && this.hasIntersection()) {
        return null;
      }
      if (e0 === e1 && segIndex0 === segIndex1) {
        return null;
      }
      if (this._isCheckEndSegmentsOnly) {
        var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
        if (!isEndSegPresent) {
          return null;
        }
      }
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._li.isInteriorIntersection()) {
          this._intSegments = new Array(4).fill(null);
          this._intSegments[0] = p00;
          this._intSegments[1] = p01;
          this._intSegments[2] = p10;
          this._intSegments[3] = p11;
          this._interiorIntersection = this._li.getIntersection(0);
          if (this._keepIntersections) {
            this._intersections.add(this._interiorIntersection);
          }
          this._intersectionCount++;
        }
      }
    };
    InteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment(segStr, index) {
      if (index === 0) {
        return true;
      }
      if (index >= segStr.size() - 2) {
        return true;
      }
      return false;
    };
    InteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection() {
      return this._interiorIntersection !== null;
    };
    InteriorIntersectionFinder.prototype.isDone = function isDone() {
      if (this._findAllIntersections) {
        return false;
      }
      return this._interiorIntersection !== null;
    };
    InteriorIntersectionFinder.prototype.interfaces_ = function interfaces_() {
      return [SegmentIntersector];
    };
    InteriorIntersectionFinder.prototype.getClass = function getClass() {
      return InteriorIntersectionFinder;
    };
    InteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder(li) {
      var finder = new InteriorIntersectionFinder(li);
      finder.setFindAllIntersections(true);
      return finder;
    };
    InteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder(li) {
      return new InteriorIntersectionFinder(li);
    };
    InteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter(li) {
      var finder = new InteriorIntersectionFinder(li);
      finder.setFindAllIntersections(true);
      finder.setKeepIntersections(false);
      return finder;
    };
    var FastNodingValidator = function FastNodingValidator2() {
      this._li = new RobustLineIntersector();
      this._segStrings = null;
      this._findAllIntersections = false;
      this._segInt = null;
      this._isValid = true;
      var segStrings = arguments[0];
      this._segStrings = segStrings;
    };
    FastNodingValidator.prototype.execute = function execute() {
      if (this._segInt !== null) {
        return null;
      }
      this.checkInteriorIntersections();
    };
    FastNodingValidator.prototype.getIntersections = function getIntersections() {
      return this._segInt.getIntersections();
    };
    FastNodingValidator.prototype.isValid = function isValid() {
      this.execute();
      return this._isValid;
    };
    FastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {
      this._findAllIntersections = findAllIntersections;
    };
    FastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {
      this._isValid = true;
      this._segInt = new InteriorIntersectionFinder(this._li);
      this._segInt.setFindAllIntersections(this._findAllIntersections);
      var noder = new MCIndexNoder();
      noder.setSegmentIntersector(this._segInt);
      noder.computeNodes(this._segStrings);
      if (this._segInt.hasIntersection()) {
        this._isValid = false;
        return null;
      }
    };
    FastNodingValidator.prototype.checkValid = function checkValid() {
      this.execute();
      if (!this._isValid) {
        throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());
      }
    };
    FastNodingValidator.prototype.getErrorMessage = function getErrorMessage() {
      if (this._isValid) {
        return "no intersections found";
      }
      var intSegs = this._segInt.getIntersectionSegments();
      return "found non-noded intersection between " + WKTWriter.toLineString(intSegs[0], intSegs[1]) + " and " + WKTWriter.toLineString(intSegs[2], intSegs[3]);
    };
    FastNodingValidator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    FastNodingValidator.prototype.getClass = function getClass() {
      return FastNodingValidator;
    };
    FastNodingValidator.computeIntersections = function computeIntersections(segStrings) {
      var nv = new FastNodingValidator(segStrings);
      nv.setFindAllIntersections(true);
      nv.isValid();
      return nv.getIntersections();
    };
    var EdgeNodingValidator = function EdgeNodingValidator2() {
      this._nv = null;
      var edges = arguments[0];
      this._nv = new FastNodingValidator(EdgeNodingValidator2.toSegmentStrings(edges));
    };
    EdgeNodingValidator.prototype.checkValid = function checkValid() {
      this._nv.checkValid();
    };
    EdgeNodingValidator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    EdgeNodingValidator.prototype.getClass = function getClass() {
      return EdgeNodingValidator;
    };
    EdgeNodingValidator.toSegmentStrings = function toSegmentStrings(edges) {
      var segStrings = new ArrayList();
      for (var i = edges.iterator(); i.hasNext(); ) {
        var e = i.next();
        segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
      }
      return segStrings;
    };
    EdgeNodingValidator.checkValid = function checkValid(edges) {
      var validator = new EdgeNodingValidator(edges);
      validator.checkValid();
    };
    var GeometryCollectionMapper = function GeometryCollectionMapper2(mapOp) {
      this._mapOp = mapOp;
    };
    GeometryCollectionMapper.prototype.map = function map2(gc) {
      var this$1 = this;
      var mapped = new ArrayList();
      for (var i = 0; i < gc.getNumGeometries(); i++) {
        var g = this$1._mapOp.map(gc.getGeometryN(i));
        if (!g.isEmpty()) {
          mapped.add(g);
        }
      }
      return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));
    };
    GeometryCollectionMapper.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryCollectionMapper.prototype.getClass = function getClass() {
      return GeometryCollectionMapper;
    };
    GeometryCollectionMapper.map = function map2(gc, op) {
      var mapper = new GeometryCollectionMapper(op);
      return mapper.map(gc);
    };
    var LineBuilder = function LineBuilder2() {
      this._op = null;
      this._geometryFactory = null;
      this._ptLocator = null;
      this._lineEdgesList = new ArrayList();
      this._resultLineList = new ArrayList();
      var op = arguments[0];
      var geometryFactory = arguments[1];
      var ptLocator = arguments[2];
      this._op = op;
      this._geometryFactory = geometryFactory;
      this._ptLocator = ptLocator;
    };
    LineBuilder.prototype.collectLines = function collectLines(opCode) {
      var this$1 = this;
      for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
        var de = it.next();
        this$1.collectLineEdge(de, opCode, this$1._lineEdgesList);
        this$1.collectBoundaryTouchEdge(de, opCode, this$1._lineEdgesList);
      }
    };
    LineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine(e, targetIndex) {
      var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
      e.getLabel().setLocation(targetIndex, loc);
    };
    LineBuilder.prototype.build = function build(opCode) {
      this.findCoveredLineEdges();
      this.collectLines(opCode);
      this.buildLines(opCode);
      return this._resultLineList;
    };
    LineBuilder.prototype.collectLineEdge = function collectLineEdge(de, opCode, edges) {
      var label = de.getLabel();
      var e = de.getEdge();
      if (de.isLineEdge()) {
        if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {
          edges.add(e);
          de.setVisitedEdge(true);
        }
      }
    };
    LineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges() {
      var this$1 = this;
      for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
        var node = nodeit.next();
        node.getEdges().findCoveredLineEdges();
      }
      for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
        var de = it.next();
        var e = de.getEdge();
        if (de.isLineEdge() && !e.isCoveredSet()) {
          var isCovered = this$1._op.isCoveredByA(de.getCoordinate());
          e.setCovered(isCovered);
        }
      }
    };
    LineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines(edgesList) {
      var this$1 = this;
      for (var it = edgesList.iterator(); it.hasNext(); ) {
        var e = it.next();
        var label = e.getLabel();
        if (e.isIsolated()) {
          if (label.isNull(0)) {
            this$1.labelIsolatedLine(e, 0);
          } else {
            this$1.labelIsolatedLine(e, 1);
          }
        }
      }
    };
    LineBuilder.prototype.buildLines = function buildLines(opCode) {
      var this$1 = this;
      for (var it = this._lineEdgesList.iterator(); it.hasNext(); ) {
        var e = it.next();
        var line = this$1._geometryFactory.createLineString(e.getCoordinates());
        this$1._resultLineList.add(line);
        e.setInResult(true);
      }
    };
    LineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge(de, opCode, edges) {
      var label = de.getLabel();
      if (de.isLineEdge()) {
        return null;
      }
      if (de.isVisited()) {
        return null;
      }
      if (de.isInteriorAreaEdge()) {
        return null;
      }
      if (de.getEdge().isInResult()) {
        return null;
      }
      Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
      if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
        edges.add(de.getEdge());
        de.setVisitedEdge(true);
      }
    };
    LineBuilder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    LineBuilder.prototype.getClass = function getClass() {
      return LineBuilder;
    };
    var PointBuilder = function PointBuilder2() {
      this._op = null;
      this._geometryFactory = null;
      this._resultPointList = new ArrayList();
      var op = arguments[0];
      var geometryFactory = arguments[1];
      this._op = op;
      this._geometryFactory = geometryFactory;
    };
    PointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint(n) {
      var coord = n.getCoordinate();
      if (!this._op.isCoveredByLA(coord)) {
        var pt = this._geometryFactory.createPoint(coord);
        this._resultPointList.add(pt);
      }
    };
    PointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes(opCode) {
      var this$1 = this;
      for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
        var n = nodeit.next();
        if (n.isInResult()) {
          continue;
        }
        if (n.isIncidentEdgeInResult()) {
          continue;
        }
        if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
          var label = n.getLabel();
          if (OverlayOp.isResultOfOp(label, opCode)) {
            this$1.filterCoveredNodeToPoint(n);
          }
        }
      }
    };
    PointBuilder.prototype.build = function build(opCode) {
      this.extractNonCoveredResultNodes(opCode);
      return this._resultPointList;
    };
    PointBuilder.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    PointBuilder.prototype.getClass = function getClass() {
      return PointBuilder;
    };
    var GeometryTransformer = function GeometryTransformer2() {
      this._inputGeom = null;
      this._factory = null;
      this._pruneEmptyGeometry = true;
      this._preserveGeometryCollectionType = true;
      this._preserveCollections = false;
      this._preserveType = false;
    };
    GeometryTransformer.prototype.transformPoint = function transformPoint(geom, parent) {
      return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    };
    GeometryTransformer.prototype.transformPolygon = function transformPolygon(geom, parent) {
      var this$1 = this;
      var isAllValidLinearRings = true;
      var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
      if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) {
        isAllValidLinearRings = false;
      }
      var holes = new ArrayList();
      for (var i = 0; i < geom.getNumInteriorRing(); i++) {
        var hole = this$1.transformLinearRing(geom.getInteriorRingN(i), geom);
        if (hole === null || hole.isEmpty()) {
          continue;
        }
        if (!(hole instanceof LinearRing)) {
          isAllValidLinearRings = false;
        }
        holes.add(hole);
      }
      if (isAllValidLinearRings) {
        return this._factory.createPolygon(shell, holes.toArray([]));
      } else {
        var components = new ArrayList();
        if (shell !== null) {
          components.add(shell);
        }
        components.addAll(holes);
        return this._factory.buildGeometry(components);
      }
    };
    GeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence(coords) {
      return this._factory.getCoordinateSequenceFactory().create(coords);
    };
    GeometryTransformer.prototype.getInputGeometry = function getInputGeometry() {
      return this._inputGeom;
    };
    GeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString(geom, parent) {
      var this$1 = this;
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this$1.transformLineString(geom.getGeometryN(i), geom);
        if (transformGeom === null) {
          continue;
        }
        if (transformGeom.isEmpty()) {
          continue;
        }
        transGeomList.add(transformGeom);
      }
      return this._factory.buildGeometry(transGeomList);
    };
    GeometryTransformer.prototype.transformCoordinates = function transformCoordinates(coords, parent) {
      return this.copy(coords);
    };
    GeometryTransformer.prototype.transformLineString = function transformLineString(geom, parent) {
      return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    };
    GeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint(geom, parent) {
      var this$1 = this;
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this$1.transformPoint(geom.getGeometryN(i), geom);
        if (transformGeom === null) {
          continue;
        }
        if (transformGeom.isEmpty()) {
          continue;
        }
        transGeomList.add(transformGeom);
      }
      return this._factory.buildGeometry(transGeomList);
    };
    GeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon(geom, parent) {
      var this$1 = this;
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this$1.transformPolygon(geom.getGeometryN(i), geom);
        if (transformGeom === null) {
          continue;
        }
        if (transformGeom.isEmpty()) {
          continue;
        }
        transGeomList.add(transformGeom);
      }
      return this._factory.buildGeometry(transGeomList);
    };
    GeometryTransformer.prototype.copy = function copy(seq) {
      return seq.copy();
    };
    GeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection(geom, parent) {
      var this$1 = this;
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this$1.transform(geom.getGeometryN(i));
        if (transformGeom === null) {
          continue;
        }
        if (this$1._pruneEmptyGeometry && transformGeom.isEmpty()) {
          continue;
        }
        transGeomList.add(transformGeom);
      }
      if (this._preserveGeometryCollectionType) {
        return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));
      }
      return this._factory.buildGeometry(transGeomList);
    };
    GeometryTransformer.prototype.transform = function transform(inputGeom) {
      this._inputGeom = inputGeom;
      this._factory = inputGeom.getFactory();
      if (inputGeom instanceof Point) {
        return this.transformPoint(inputGeom, null);
      }
      if (inputGeom instanceof MultiPoint) {
        return this.transformMultiPoint(inputGeom, null);
      }
      if (inputGeom instanceof LinearRing) {
        return this.transformLinearRing(inputGeom, null);
      }
      if (inputGeom instanceof LineString) {
        return this.transformLineString(inputGeom, null);
      }
      if (inputGeom instanceof MultiLineString) {
        return this.transformMultiLineString(inputGeom, null);
      }
      if (inputGeom instanceof Polygon) {
        return this.transformPolygon(inputGeom, null);
      }
      if (inputGeom instanceof MultiPolygon) {
        return this.transformMultiPolygon(inputGeom, null);
      }
      if (inputGeom instanceof GeometryCollection) {
        return this.transformGeometryCollection(inputGeom, null);
      }
      throw new IllegalArgumentException("Unknown Geometry subtype: " + inputGeom.getClass().getName());
    };
    GeometryTransformer.prototype.transformLinearRing = function transformLinearRing(geom, parent) {
      var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
      if (seq === null) {
        return this._factory.createLinearRing(null);
      }
      var seqSize = seq.size();
      if (seqSize > 0 && seqSize < 4 && !this._preserveType) {
        return this._factory.createLineString(seq);
      }
      return this._factory.createLinearRing(seq);
    };
    GeometryTransformer.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryTransformer.prototype.getClass = function getClass() {
      return GeometryTransformer;
    };
    var LineStringSnapper = function LineStringSnapper2() {
      this._snapTolerance = 0;
      this._srcPts = null;
      this._seg = new LineSegment();
      this._allowSnappingToSourceVertices = false;
      this._isClosed = false;
      if (arguments[0] instanceof LineString && typeof arguments[1] === "number") {
        var srcLine = arguments[0];
        var snapTolerance = arguments[1];
        LineStringSnapper2.call(this, srcLine.getCoordinates(), snapTolerance);
      } else if (arguments[0] instanceof Array && typeof arguments[1] === "number") {
        var srcPts = arguments[0];
        var snapTolerance$1 = arguments[1];
        this._srcPts = srcPts;
        this._isClosed = LineStringSnapper2.isClosed(srcPts);
        this._snapTolerance = snapTolerance$1;
      }
    };
    LineStringSnapper.prototype.snapVertices = function snapVertices(srcCoords, snapPts) {
      var this$1 = this;
      var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
      for (var i = 0; i < end; i++) {
        var srcPt = srcCoords.get(i);
        var snapVert = this$1.findSnapForVertex(srcPt, snapPts);
        if (snapVert !== null) {
          srcCoords.set(i, new Coordinate(snapVert));
          if (i === 0 && this$1._isClosed) {
            srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));
          }
        }
      }
    };
    LineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex(pt, snapPts) {
      var this$1 = this;
      for (var i = 0; i < snapPts.length; i++) {
        if (pt.equals2D(snapPts[i])) {
          return null;
        }
        if (pt.distance(snapPts[i]) < this$1._snapTolerance) {
          return snapPts[i];
        }
      }
      return null;
    };
    LineStringSnapper.prototype.snapTo = function snapTo(snapPts) {
      var coordList = new CoordinateList(this._srcPts);
      this.snapVertices(coordList, snapPts);
      this.snapSegments(coordList, snapPts);
      var newPts = coordList.toCoordinateArray();
      return newPts;
    };
    LineStringSnapper.prototype.snapSegments = function snapSegments(srcCoords, snapPts) {
      var this$1 = this;
      if (snapPts.length === 0) {
        return null;
      }
      var distinctPtCount = snapPts.length;
      if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) {
        distinctPtCount = snapPts.length - 1;
      }
      for (var i = 0; i < distinctPtCount; i++) {
        var snapPt = snapPts[i];
        var index = this$1.findSegmentIndexToSnap(snapPt, srcCoords);
        if (index >= 0) {
          srcCoords.add(index + 1, new Coordinate(snapPt), false);
        }
      }
    };
    LineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap(snapPt, srcCoords) {
      var this$1 = this;
      var minDist = Double.MAX_VALUE;
      var snapIndex = -1;
      for (var i = 0; i < srcCoords.size() - 1; i++) {
        this$1._seg.p0 = srcCoords.get(i);
        this$1._seg.p1 = srcCoords.get(i + 1);
        if (this$1._seg.p0.equals2D(snapPt) || this$1._seg.p1.equals2D(snapPt)) {
          if (this$1._allowSnappingToSourceVertices) {
            continue;
          } else {
            return -1;
          }
        }
        var dist = this$1._seg.distance(snapPt);
        if (dist < this$1._snapTolerance && dist < minDist) {
          minDist = dist;
          snapIndex = i;
        }
      }
      return snapIndex;
    };
    LineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
      this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
    };
    LineStringSnapper.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    LineStringSnapper.prototype.getClass = function getClass() {
      return LineStringSnapper;
    };
    LineStringSnapper.isClosed = function isClosed(pts) {
      if (pts.length <= 1) {
        return false;
      }
      return pts[0].equals2D(pts[pts.length - 1]);
    };
    var GeometrySnapper = function GeometrySnapper2(srcGeom) {
      this._srcGeom = srcGeom || null;
    };
    var staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };
    GeometrySnapper.prototype.snapTo = function snapTo(snapGeom, snapTolerance) {
      var snapPts = this.extractTargetCoordinates(snapGeom);
      var snapTrans = new SnapTransformer(snapTolerance, snapPts);
      return snapTrans.transform(this._srcGeom);
    };
    GeometrySnapper.prototype.snapToSelf = function snapToSelf(snapTolerance, cleanResult) {
      var snapPts = this.extractTargetCoordinates(this._srcGeom);
      var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
      var snappedGeom = snapTrans.transform(this._srcGeom);
      var result2 = snappedGeom;
      if (cleanResult && hasInterface(result2, Polygonal)) {
        result2 = snappedGeom.buffer(0);
      }
      return result2;
    };
    GeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance(ringPts) {
      var minSegLen = this.computeMinimumSegmentLength(ringPts);
      var snapTol = minSegLen / 10;
      return snapTol;
    };
    GeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates(g) {
      var ptSet = new TreeSet();
      var pts = g.getCoordinates();
      for (var i = 0; i < pts.length; i++) {
        ptSet.add(pts[i]);
      }
      return ptSet.toArray(new Array(0).fill(null));
    };
    GeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength(pts) {
      var minSegLen = Double.MAX_VALUE;
      for (var i = 0; i < pts.length - 1; i++) {
        var segLen = pts[i].distance(pts[i + 1]);
        if (segLen < minSegLen) {
          minSegLen = segLen;
        }
      }
      return minSegLen;
    };
    GeometrySnapper.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometrySnapper.prototype.getClass = function getClass() {
      return GeometrySnapper;
    };
    GeometrySnapper.snap = function snap(g0, g1, snapTolerance) {
      var snapGeom = new Array(2).fill(null);
      var snapper0 = new GeometrySnapper(g0);
      snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
      var snapper1 = new GeometrySnapper(g1);
      snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
      return snapGeom;
    };
    GeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance() {
      if (arguments.length === 1) {
        var g = arguments[0];
        var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
        var pm = g.getPrecisionModel();
        if (pm.getType() === PrecisionModel.FIXED) {
          var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
          if (fixedSnapTol > snapTolerance) {
            snapTolerance = fixedSnapTol;
          }
        }
        return snapTolerance;
      } else if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
      }
    };
    GeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance(g) {
      var env = g.getEnvelopeInternal();
      var minDimension = Math.min(env.getHeight(), env.getWidth());
      var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
      return snapTol;
    };
    GeometrySnapper.snapToSelf = function snapToSelf(geom, snapTolerance, cleanResult) {
      var snapper0 = new GeometrySnapper(geom);
      return snapper0.snapToSelf(snapTolerance, cleanResult);
    };
    staticAccessors$41.SNAP_PRECISION_FACTOR.get = function() {
      return 1e-9;
    };
    Object.defineProperties(GeometrySnapper, staticAccessors$41);
    var SnapTransformer = function(GeometryTransformer$$1) {
      function SnapTransformer2(snapTolerance, snapPts, isSelfSnap) {
        GeometryTransformer$$1.call(this);
        this._snapTolerance = snapTolerance || null;
        this._snapPts = snapPts || null;
        this._isSelfSnap = isSelfSnap !== void 0 ? isSelfSnap : false;
      }
      if (GeometryTransformer$$1) SnapTransformer2.__proto__ = GeometryTransformer$$1;
      SnapTransformer2.prototype = Object.create(GeometryTransformer$$1 && GeometryTransformer$$1.prototype);
      SnapTransformer2.prototype.constructor = SnapTransformer2;
      SnapTransformer2.prototype.snapLine = function snapLine(srcPts, snapPts) {
        var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
        snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
        return snapper.snapTo(snapPts);
      };
      SnapTransformer2.prototype.transformCoordinates = function transformCoordinates(coords, parent) {
        var srcPts = coords.toCoordinateArray();
        var newPts = this.snapLine(srcPts, this._snapPts);
        return this._factory.getCoordinateSequenceFactory().create(newPts);
      };
      SnapTransformer2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      SnapTransformer2.prototype.getClass = function getClass() {
        return SnapTransformer2;
      };
      return SnapTransformer2;
    }(GeometryTransformer);
    var CommonBits = function CommonBits2() {
      this._isFirst = true;
      this._commonMantissaBitsCount = 53;
      this._commonBits = 0;
      this._commonSignExp = null;
    };
    CommonBits.prototype.getCommon = function getCommon() {
      return Double.longBitsToDouble(this._commonBits);
    };
    CommonBits.prototype.add = function add(num) {
      var numBits = Double.doubleToLongBits(num);
      if (this._isFirst) {
        this._commonBits = numBits;
        this._commonSignExp = CommonBits.signExpBits(this._commonBits);
        this._isFirst = false;
        return null;
      }
      var numSignExp = CommonBits.signExpBits(numBits);
      if (numSignExp !== this._commonSignExp) {
        this._commonBits = 0;
        return null;
      }
      this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
      this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
    };
    CommonBits.prototype.toString = function toString() {
      if (arguments.length === 1) {
        var bits = arguments[0];
        var x = Double.longBitsToDouble(bits);
        var numStr = Double.toBinaryString(bits);
        var padStr = "0000000000000000000000000000000000000000000000000000000000000000" + numStr;
        var bitStr = padStr.substring(padStr.length - 64);
        var str = bitStr.substring(0, 1) + "  " + bitStr.substring(1, 12) + "(exp) " + bitStr.substring(12) + " [ " + x + " ]";
        return str;
      }
    };
    CommonBits.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CommonBits.prototype.getClass = function getClass() {
      return CommonBits;
    };
    CommonBits.getBit = function getBit(bits, i) {
      var mask = 1 << i;
      return (bits & mask) !== 0 ? 1 : 0;
    };
    CommonBits.signExpBits = function signExpBits(num) {
      return num >> 52;
    };
    CommonBits.zeroLowerBits = function zeroLowerBits(bits, nBits) {
      var invMask = (1 << nBits) - 1;
      var mask = ~invMask;
      var zeroed = bits & mask;
      return zeroed;
    };
    CommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits(num1, num2) {
      var count = 0;
      for (var i = 52; i >= 0; i--) {
        if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) {
          return count;
        }
        count++;
      }
      return 52;
    };
    var CommonBitsRemover = function CommonBitsRemover2() {
      this._commonCoord = null;
      this._ccFilter = new CommonCoordinateFilter();
    };
    var staticAccessors$42 = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
    CommonBitsRemover.prototype.addCommonBits = function addCommonBits(geom) {
      var trans = new Translater(this._commonCoord);
      geom.apply(trans);
      geom.geometryChanged();
    };
    CommonBitsRemover.prototype.removeCommonBits = function removeCommonBits(geom) {
      if (this._commonCoord.x === 0 && this._commonCoord.y === 0) {
        return geom;
      }
      var invCoord = new Coordinate(this._commonCoord);
      invCoord.x = -invCoord.x;
      invCoord.y = -invCoord.y;
      var trans = new Translater(invCoord);
      geom.apply(trans);
      geom.geometryChanged();
      return geom;
    };
    CommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate() {
      return this._commonCoord;
    };
    CommonBitsRemover.prototype.add = function add(geom) {
      geom.apply(this._ccFilter);
      this._commonCoord = this._ccFilter.getCommonCoordinate();
    };
    CommonBitsRemover.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CommonBitsRemover.prototype.getClass = function getClass() {
      return CommonBitsRemover;
    };
    staticAccessors$42.CommonCoordinateFilter.get = function() {
      return CommonCoordinateFilter;
    };
    staticAccessors$42.Translater.get = function() {
      return Translater;
    };
    Object.defineProperties(CommonBitsRemover, staticAccessors$42);
    var CommonCoordinateFilter = function CommonCoordinateFilter2() {
      this._commonBitsX = new CommonBits();
      this._commonBitsY = new CommonBits();
    };
    CommonCoordinateFilter.prototype.filter = function filter(coord) {
      this._commonBitsX.add(coord.x);
      this._commonBitsY.add(coord.y);
    };
    CommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate() {
      return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
    };
    CommonCoordinateFilter.prototype.interfaces_ = function interfaces_() {
      return [CoordinateFilter];
    };
    CommonCoordinateFilter.prototype.getClass = function getClass() {
      return CommonCoordinateFilter;
    };
    var Translater = function Translater2() {
      this.trans = null;
      var trans = arguments[0];
      this.trans = trans;
    };
    Translater.prototype.filter = function filter(seq, i) {
      var xp = seq.getOrdinate(i, 0) + this.trans.x;
      var yp = seq.getOrdinate(i, 1) + this.trans.y;
      seq.setOrdinate(i, 0, xp);
      seq.setOrdinate(i, 1, yp);
    };
    Translater.prototype.isDone = function isDone() {
      return false;
    };
    Translater.prototype.isGeometryChanged = function isGeometryChanged() {
      return true;
    };
    Translater.prototype.interfaces_ = function interfaces_() {
      return [CoordinateSequenceFilter];
    };
    Translater.prototype.getClass = function getClass() {
      return Translater;
    };
    var SnapOverlayOp = function SnapOverlayOp2(g1, g2) {
      this._geom = new Array(2).fill(null);
      this._snapTolerance = null;
      this._cbr = null;
      this._geom[0] = g1;
      this._geom[1] = g2;
      this.computeSnapTolerance();
    };
    SnapOverlayOp.prototype.selfSnap = function selfSnap(geom) {
      var snapper0 = new GeometrySnapper(geom);
      var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
      return snapGeom;
    };
    SnapOverlayOp.prototype.removeCommonBits = function removeCommonBits(geom) {
      this._cbr = new CommonBitsRemover();
      this._cbr.add(geom[0]);
      this._cbr.add(geom[1]);
      var remGeom = new Array(2).fill(null);
      remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
      remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
      return remGeom;
    };
    SnapOverlayOp.prototype.prepareResult = function prepareResult(geom) {
      this._cbr.addCommonBits(geom);
      return geom;
    };
    SnapOverlayOp.prototype.getResultGeometry = function getResultGeometry(opCode) {
      var prepGeom = this.snap(this._geom);
      var result2 = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
      return this.prepareResult(result2);
    };
    SnapOverlayOp.prototype.checkValid = function checkValid(g) {
      if (!g.isValid()) {
        System.out.println("Snapped geometry is invalid");
      }
    };
    SnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance() {
      this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
    };
    SnapOverlayOp.prototype.snap = function snap(geom) {
      var remGeom = this.removeCommonBits(geom);
      var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
      return snapGeom;
    };
    SnapOverlayOp.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SnapOverlayOp.prototype.getClass = function getClass() {
      return SnapOverlayOp;
    };
    SnapOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {
      var op = new SnapOverlayOp(g0, g1);
      return op.getResultGeometry(opCode);
    };
    SnapOverlayOp.union = function union(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
    };
    SnapOverlayOp.intersection = function intersection(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
    };
    SnapOverlayOp.symDifference = function symDifference(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
    };
    SnapOverlayOp.difference = function difference(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
    };
    var SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp2(g1, g2) {
      this._geom = new Array(2).fill(null);
      this._geom[0] = g1;
      this._geom[1] = g2;
    };
    SnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry(opCode) {
      var result2 = null;
      var isSuccess = false;
      var savedException = null;
      try {
        result2 = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
        var isValid = true;
        if (isValid) {
          isSuccess = true;
        }
      } catch (ex) {
        if (ex instanceof RuntimeException) {
          savedException = ex;
        } else {
          throw ex;
        }
      } finally {
      }
      if (!isSuccess) {
        try {
          result2 = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
        } catch (ex) {
          if (ex instanceof RuntimeException) {
            throw savedException;
          } else {
            throw ex;
          }
        } finally {
        }
      }
      return result2;
    };
    SnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SnapIfNeededOverlayOp.prototype.getClass = function getClass() {
      return SnapIfNeededOverlayOp;
    };
    SnapIfNeededOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {
      var op = new SnapIfNeededOverlayOp(g0, g1);
      return op.getResultGeometry(opCode);
    };
    SnapIfNeededOverlayOp.union = function union(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
    };
    SnapIfNeededOverlayOp.intersection = function intersection(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
    };
    SnapIfNeededOverlayOp.symDifference = function symDifference(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
    };
    SnapIfNeededOverlayOp.difference = function difference(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
    };
    var MonotoneChain$2 = function MonotoneChain2() {
      this.mce = null;
      this.chainIndex = null;
      var mce = arguments[0];
      var chainIndex = arguments[1];
      this.mce = mce;
      this.chainIndex = chainIndex;
    };
    MonotoneChain$2.prototype.computeIntersections = function computeIntersections(mc, si) {
      this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
    };
    MonotoneChain$2.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    MonotoneChain$2.prototype.getClass = function getClass() {
      return MonotoneChain$2;
    };
    var SweepLineEvent = function SweepLineEvent2() {
      this._label = null;
      this._xValue = null;
      this._eventType = null;
      this._insertEvent = null;
      this._deleteEventIndex = null;
      this._obj = null;
      if (arguments.length === 2) {
        var x = arguments[0];
        var insertEvent = arguments[1];
        this._eventType = SweepLineEvent2.DELETE;
        this._xValue = x;
        this._insertEvent = insertEvent;
      } else if (arguments.length === 3) {
        var label = arguments[0];
        var x$1 = arguments[1];
        var obj = arguments[2];
        this._eventType = SweepLineEvent2.INSERT;
        this._label = label;
        this._xValue = x$1;
        this._obj = obj;
      }
    };
    var staticAccessors$43 = { INSERT: { configurable: true }, DELETE: { configurable: true } };
    SweepLineEvent.prototype.isDelete = function isDelete() {
      return this._eventType === SweepLineEvent.DELETE;
    };
    SweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex(deleteEventIndex) {
      this._deleteEventIndex = deleteEventIndex;
    };
    SweepLineEvent.prototype.getObject = function getObject() {
      return this._obj;
    };
    SweepLineEvent.prototype.compareTo = function compareTo(o) {
      var pe = o;
      if (this._xValue < pe._xValue) {
        return -1;
      }
      if (this._xValue > pe._xValue) {
        return 1;
      }
      if (this._eventType < pe._eventType) {
        return -1;
      }
      if (this._eventType > pe._eventType) {
        return 1;
      }
      return 0;
    };
    SweepLineEvent.prototype.getInsertEvent = function getInsertEvent() {
      return this._insertEvent;
    };
    SweepLineEvent.prototype.isInsert = function isInsert() {
      return this._eventType === SweepLineEvent.INSERT;
    };
    SweepLineEvent.prototype.isSameLabel = function isSameLabel(ev) {
      if (this._label === null) {
        return false;
      }
      return this._label === ev._label;
    };
    SweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex() {
      return this._deleteEventIndex;
    };
    SweepLineEvent.prototype.interfaces_ = function interfaces_() {
      return [Comparable];
    };
    SweepLineEvent.prototype.getClass = function getClass() {
      return SweepLineEvent;
    };
    staticAccessors$43.INSERT.get = function() {
      return 1;
    };
    staticAccessors$43.DELETE.get = function() {
      return 2;
    };
    Object.defineProperties(SweepLineEvent, staticAccessors$43);
    var EdgeSetIntersector = function EdgeSetIntersector2() {
    };
    EdgeSetIntersector.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    EdgeSetIntersector.prototype.getClass = function getClass() {
      return EdgeSetIntersector;
    };
    var SegmentIntersector$2 = function SegmentIntersector2() {
      this._hasIntersection = false;
      this._hasProper = false;
      this._hasProperInterior = false;
      this._properIntersectionPoint = null;
      this._li = null;
      this._includeProper = null;
      this._recordIsolated = null;
      this._isSelfIntersection = null;
      this._numIntersections = 0;
      this.numTests = 0;
      this._bdyNodes = null;
      this._isDone = false;
      this._isDoneWhenProperInt = false;
      var li = arguments[0];
      var includeProper = arguments[1];
      var recordIsolated = arguments[2];
      this._li = li;
      this._includeProper = includeProper;
      this._recordIsolated = recordIsolated;
    };
    SegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1) {
        if (this._li.getIntersectionNum() === 1) {
          if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) {
            return true;
          }
          if (e0.isClosed()) {
            var maxSegIndex = e0.getNumPoints() - 1;
            if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
              return true;
            }
          }
        }
      }
      return false;
    };
    SegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {
      return this._properIntersectionPoint;
    };
    SegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt(isDoneWhenProperInt) {
      this._isDoneWhenProperInt = isDoneWhenProperInt;
    };
    SegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {
      return this._hasProperInterior;
    };
    SegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal(li, bdyNodes) {
      for (var i = bdyNodes.iterator(); i.hasNext(); ) {
        var node = i.next();
        var pt = node.getCoordinate();
        if (li.isIntersection(pt)) {
          return true;
        }
      }
      return false;
    };
    SegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection() {
      return this._hasProper;
    };
    SegmentIntersector$2.prototype.hasIntersection = function hasIntersection() {
      return this._hasIntersection;
    };
    SegmentIntersector$2.prototype.isDone = function isDone() {
      return this._isDone;
    };
    SegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint(li, bdyNodes) {
      if (bdyNodes === null) {
        return false;
      }
      if (this.isBoundaryPointInternal(li, bdyNodes[0])) {
        return true;
      }
      if (this.isBoundaryPointInternal(li, bdyNodes[1])) {
        return true;
      }
      return false;
    };
    SegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes(bdyNodes0, bdyNodes1) {
      this._bdyNodes = new Array(2).fill(null);
      this._bdyNodes[0] = bdyNodes0;
      this._bdyNodes[1] = bdyNodes1;
    };
    SegmentIntersector$2.prototype.addIntersections = function addIntersections(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1 && segIndex0 === segIndex1) {
        return null;
      }
      this.numTests++;
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._recordIsolated) {
          e0.setIsolated(false);
          e1.setIsolated(false);
        }
        this._numIntersections++;
        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
          this._hasIntersection = true;
          if (this._includeProper || !this._li.isProper()) {
            e0.addIntersections(this._li, segIndex0, 0);
            e1.addIntersections(this._li, segIndex1, 1);
          }
          if (this._li.isProper()) {
            this._properIntersectionPoint = this._li.getIntersection(0).copy();
            this._hasProper = true;
            if (this._isDoneWhenProperInt) {
              this._isDone = true;
            }
            if (!this.isBoundaryPoint(this._li, this._bdyNodes)) {
              this._hasProperInterior = true;
            }
          }
        }
      }
    };
    SegmentIntersector$2.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SegmentIntersector$2.prototype.getClass = function getClass() {
      return SegmentIntersector$2;
    };
    SegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments(i1, i2) {
      return Math.abs(i1 - i2) === 1;
    };
    var SimpleMCSweepLineIntersector = function(EdgeSetIntersector$$1) {
      function SimpleMCSweepLineIntersector2() {
        EdgeSetIntersector$$1.call(this);
        this.events = new ArrayList();
        this.nOverlaps = null;
      }
      if (EdgeSetIntersector$$1) SimpleMCSweepLineIntersector2.__proto__ = EdgeSetIntersector$$1;
      SimpleMCSweepLineIntersector2.prototype = Object.create(EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype);
      SimpleMCSweepLineIntersector2.prototype.constructor = SimpleMCSweepLineIntersector2;
      SimpleMCSweepLineIntersector2.prototype.prepareEvents = function prepareEvents() {
        var this$1 = this;
        Collections.sort(this.events);
        for (var i = 0; i < this.events.size(); i++) {
          var ev = this$1.events.get(i);
          if (ev.isDelete()) {
            ev.getInsertEvent().setDeleteEventIndex(i);
          }
        }
      };
      SimpleMCSweepLineIntersector2.prototype.computeIntersections = function computeIntersections() {
        var this$1 = this;
        if (arguments.length === 1) {
          var si = arguments[0];
          this.nOverlaps = 0;
          this.prepareEvents();
          for (var i = 0; i < this.events.size(); i++) {
            var ev = this$1.events.get(i);
            if (ev.isInsert()) {
              this$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
            }
            if (si.isDone()) {
              break;
            }
          }
        } else if (arguments.length === 3) {
          if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
            var edges0 = arguments[0];
            var edges1 = arguments[1];
            var si$1 = arguments[2];
            this.addEdges(edges0, edges0);
            this.addEdges(edges1, edges1);
            this.computeIntersections(si$1);
          } else if (typeof arguments[2] === "boolean" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {
            var edges = arguments[0];
            var si$2 = arguments[1];
            var testAllSegments = arguments[2];
            if (testAllSegments) {
              this.addEdges(edges, null);
            } else {
              this.addEdges(edges);
            }
            this.computeIntersections(si$2);
          }
        }
      };
      SimpleMCSweepLineIntersector2.prototype.addEdge = function addEdge(edge, edgeSet) {
        var this$1 = this;
        var mce = edge.getMonotoneChainEdge();
        var startIndex = mce.getStartIndexes();
        for (var i = 0; i < startIndex.length - 1; i++) {
          var mc = new MonotoneChain$2(mce, i);
          var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
          this$1.events.add(insertEvent);
          this$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
        }
      };
      SimpleMCSweepLineIntersector2.prototype.processOverlaps = function processOverlaps(start, end, ev0, si) {
        var this$1 = this;
        var mc0 = ev0.getObject();
        for (var i = start; i < end; i++) {
          var ev1 = this$1.events.get(i);
          if (ev1.isInsert()) {
            var mc1 = ev1.getObject();
            if (!ev0.isSameLabel(ev1)) {
              mc0.computeIntersections(mc1, si);
              this$1.nOverlaps++;
            }
          }
        }
      };
      SimpleMCSweepLineIntersector2.prototype.addEdges = function addEdges() {
        var this$1 = this;
        if (arguments.length === 1) {
          var edges = arguments[0];
          for (var i = edges.iterator(); i.hasNext(); ) {
            var edge = i.next();
            this$1.addEdge(edge, edge);
          }
        } else if (arguments.length === 2) {
          var edges$1 = arguments[0];
          var edgeSet = arguments[1];
          for (var i$1 = edges$1.iterator(); i$1.hasNext(); ) {
            var edge$1 = i$1.next();
            this$1.addEdge(edge$1, edgeSet);
          }
        }
      };
      SimpleMCSweepLineIntersector2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      SimpleMCSweepLineIntersector2.prototype.getClass = function getClass() {
        return SimpleMCSweepLineIntersector2;
      };
      return SimpleMCSweepLineIntersector2;
    }(EdgeSetIntersector);
    var IntervalRTreeNode = function IntervalRTreeNode2() {
      this._min = Double.POSITIVE_INFINITY;
      this._max = Double.NEGATIVE_INFINITY;
    };
    var staticAccessors$45 = { NodeComparator: { configurable: true } };
    IntervalRTreeNode.prototype.getMin = function getMin() {
      return this._min;
    };
    IntervalRTreeNode.prototype.intersects = function intersects(queryMin, queryMax) {
      if (this._min > queryMax || this._max < queryMin) {
        return false;
      }
      return true;
    };
    IntervalRTreeNode.prototype.getMax = function getMax() {
      return this._max;
    };
    IntervalRTreeNode.prototype.toString = function toString() {
      return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));
    };
    IntervalRTreeNode.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    IntervalRTreeNode.prototype.getClass = function getClass() {
      return IntervalRTreeNode;
    };
    staticAccessors$45.NodeComparator.get = function() {
      return NodeComparator;
    };
    Object.defineProperties(IntervalRTreeNode, staticAccessors$45);
    var NodeComparator = function NodeComparator2() {
    };
    NodeComparator.prototype.compare = function compare(o1, o2) {
      var n1 = o1;
      var n2 = o2;
      var mid1 = (n1._min + n1._max) / 2;
      var mid2 = (n2._min + n2._max) / 2;
      if (mid1 < mid2) {
        return -1;
      }
      if (mid1 > mid2) {
        return 1;
      }
      return 0;
    };
    NodeComparator.prototype.interfaces_ = function interfaces_() {
      return [Comparator];
    };
    NodeComparator.prototype.getClass = function getClass() {
      return NodeComparator;
    };
    var IntervalRTreeLeafNode = function(IntervalRTreeNode$$1) {
      function IntervalRTreeLeafNode2() {
        IntervalRTreeNode$$1.call(this);
        this._item = null;
        var min = arguments[0];
        var max = arguments[1];
        var item = arguments[2];
        this._min = min;
        this._max = max;
        this._item = item;
      }
      if (IntervalRTreeNode$$1) IntervalRTreeLeafNode2.__proto__ = IntervalRTreeNode$$1;
      IntervalRTreeLeafNode2.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
      IntervalRTreeLeafNode2.prototype.constructor = IntervalRTreeLeafNode2;
      IntervalRTreeLeafNode2.prototype.query = function query(queryMin, queryMax, visitor) {
        if (!this.intersects(queryMin, queryMax)) {
          return null;
        }
        visitor.visitItem(this._item);
      };
      IntervalRTreeLeafNode2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      IntervalRTreeLeafNode2.prototype.getClass = function getClass() {
        return IntervalRTreeLeafNode2;
      };
      return IntervalRTreeLeafNode2;
    }(IntervalRTreeNode);
    var IntervalRTreeBranchNode = function(IntervalRTreeNode$$1) {
      function IntervalRTreeBranchNode2() {
        IntervalRTreeNode$$1.call(this);
        this._node1 = null;
        this._node2 = null;
        var n1 = arguments[0];
        var n2 = arguments[1];
        this._node1 = n1;
        this._node2 = n2;
        this.buildExtent(this._node1, this._node2);
      }
      if (IntervalRTreeNode$$1) IntervalRTreeBranchNode2.__proto__ = IntervalRTreeNode$$1;
      IntervalRTreeBranchNode2.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
      IntervalRTreeBranchNode2.prototype.constructor = IntervalRTreeBranchNode2;
      IntervalRTreeBranchNode2.prototype.buildExtent = function buildExtent(n1, n2) {
        this._min = Math.min(n1._min, n2._min);
        this._max = Math.max(n1._max, n2._max);
      };
      IntervalRTreeBranchNode2.prototype.query = function query(queryMin, queryMax, visitor) {
        if (!this.intersects(queryMin, queryMax)) {
          return null;
        }
        if (this._node1 !== null) {
          this._node1.query(queryMin, queryMax, visitor);
        }
        if (this._node2 !== null) {
          this._node2.query(queryMin, queryMax, visitor);
        }
      };
      IntervalRTreeBranchNode2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      IntervalRTreeBranchNode2.prototype.getClass = function getClass() {
        return IntervalRTreeBranchNode2;
      };
      return IntervalRTreeBranchNode2;
    }(IntervalRTreeNode);
    var SortedPackedIntervalRTree = function SortedPackedIntervalRTree2() {
      this._leaves = new ArrayList();
      this._root = null;
      this._level = 0;
    };
    SortedPackedIntervalRTree.prototype.buildTree = function buildTree() {
      var this$1 = this;
      Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
      var src = this._leaves;
      var temp = null;
      var dest = new ArrayList();
      while (true) {
        this$1.buildLevel(src, dest);
        if (dest.size() === 1) {
          return dest.get(0);
        }
        temp = src;
        src = dest;
        dest = temp;
      }
    };
    SortedPackedIntervalRTree.prototype.insert = function insert(min, max, item) {
      if (this._root !== null) {
        throw new Error("Index cannot be added to once it has been queried");
      }
      this._leaves.add(new IntervalRTreeLeafNode(min, max, item));
    };
    SortedPackedIntervalRTree.prototype.query = function query(min, max, visitor) {
      this.init();
      this._root.query(min, max, visitor);
    };
    SortedPackedIntervalRTree.prototype.buildRoot = function buildRoot() {
      if (this._root !== null) {
        return null;
      }
      this._root = this.buildTree();
    };
    SortedPackedIntervalRTree.prototype.printNode = function printNode(node) {
      System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
    };
    SortedPackedIntervalRTree.prototype.init = function init() {
      if (this._root !== null) {
        return null;
      }
      this.buildRoot();
    };
    SortedPackedIntervalRTree.prototype.buildLevel = function buildLevel(src, dest) {
      this._level++;
      dest.clear();
      for (var i = 0; i < src.size(); i += 2) {
        var n1 = src.get(i);
        var n2 = i + 1 < src.size() ? src.get(i) : null;
        if (n2 === null) {
          dest.add(n1);
        } else {
          var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));
          dest.add(node);
        }
      }
    };
    SortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    SortedPackedIntervalRTree.prototype.getClass = function getClass() {
      return SortedPackedIntervalRTree;
    };
    var ArrayListVisitor = function ArrayListVisitor2() {
      this._items = new ArrayList();
    };
    ArrayListVisitor.prototype.visitItem = function visitItem(item) {
      this._items.add(item);
    };
    ArrayListVisitor.prototype.getItems = function getItems() {
      return this._items;
    };
    ArrayListVisitor.prototype.interfaces_ = function interfaces_() {
      return [ItemVisitor];
    };
    ArrayListVisitor.prototype.getClass = function getClass() {
      return ArrayListVisitor;
    };
    var IndexedPointInAreaLocator = function IndexedPointInAreaLocator2() {
      this._index = null;
      var g = arguments[0];
      if (!hasInterface(g, Polygonal)) {
        throw new IllegalArgumentException("Argument must be Polygonal");
      }
      this._index = new IntervalIndexedGeometry(g);
    };
    var staticAccessors$44 = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
    IndexedPointInAreaLocator.prototype.locate = function locate(p) {
      var rcc = new RayCrossingCounter(p);
      var visitor = new SegmentVisitor(rcc);
      this._index.query(p.y, p.y, visitor);
      return rcc.getLocation();
    };
    IndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_() {
      return [PointOnGeometryLocator];
    };
    IndexedPointInAreaLocator.prototype.getClass = function getClass() {
      return IndexedPointInAreaLocator;
    };
    staticAccessors$44.SegmentVisitor.get = function() {
      return SegmentVisitor;
    };
    staticAccessors$44.IntervalIndexedGeometry.get = function() {
      return IntervalIndexedGeometry;
    };
    Object.defineProperties(IndexedPointInAreaLocator, staticAccessors$44);
    var SegmentVisitor = function SegmentVisitor2() {
      this._counter = null;
      var counter = arguments[0];
      this._counter = counter;
    };
    SegmentVisitor.prototype.visitItem = function visitItem(item) {
      var seg = item;
      this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
    };
    SegmentVisitor.prototype.interfaces_ = function interfaces_() {
      return [ItemVisitor];
    };
    SegmentVisitor.prototype.getClass = function getClass() {
      return SegmentVisitor;
    };
    var IntervalIndexedGeometry = function IntervalIndexedGeometry2() {
      this._index = new SortedPackedIntervalRTree();
      var geom = arguments[0];
      this.init(geom);
    };
    IntervalIndexedGeometry.prototype.init = function init(geom) {
      var this$1 = this;
      var lines = LinearComponentExtracter.getLines(geom);
      for (var i = lines.iterator(); i.hasNext(); ) {
        var line = i.next();
        var pts = line.getCoordinates();
        this$1.addLine(pts);
      }
    };
    IntervalIndexedGeometry.prototype.addLine = function addLine(pts) {
      var this$1 = this;
      for (var i = 1; i < pts.length; i++) {
        var seg = new LineSegment(pts[i - 1], pts[i]);
        var min = Math.min(seg.p0.y, seg.p1.y);
        var max = Math.max(seg.p0.y, seg.p1.y);
        this$1._index.insert(min, max, seg);
      }
    };
    IntervalIndexedGeometry.prototype.query = function query() {
      if (arguments.length === 2) {
        var min = arguments[0];
        var max = arguments[1];
        var visitor = new ArrayListVisitor();
        this._index.query(min, max, visitor);
        return visitor.getItems();
      } else if (arguments.length === 3) {
        var min$1 = arguments[0];
        var max$1 = arguments[1];
        var visitor$1 = arguments[2];
        this._index.query(min$1, max$1, visitor$1);
      }
    };
    IntervalIndexedGeometry.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    IntervalIndexedGeometry.prototype.getClass = function getClass() {
      return IntervalIndexedGeometry;
    };
    var GeometryGraph = function(PlanarGraph$$1) {
      function GeometryGraph2() {
        PlanarGraph$$1.call(this);
        this._parentGeom = null;
        this._lineEdgeMap = new HashMap();
        this._boundaryNodeRule = null;
        this._useBoundaryDeterminationRule = true;
        this._argIndex = null;
        this._boundaryNodes = null;
        this._hasTooFewPoints = false;
        this._invalidPoint = null;
        this._areaPtLocator = null;
        this._ptLocator = new PointLocator();
        if (arguments.length === 2) {
          var argIndex = arguments[0];
          var parentGeom = arguments[1];
          var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
          this._argIndex = argIndex;
          this._parentGeom = parentGeom;
          this._boundaryNodeRule = boundaryNodeRule;
          if (parentGeom !== null) {
            this.add(parentGeom);
          }
        } else if (arguments.length === 3) {
          var argIndex$1 = arguments[0];
          var parentGeom$1 = arguments[1];
          var boundaryNodeRule$1 = arguments[2];
          this._argIndex = argIndex$1;
          this._parentGeom = parentGeom$1;
          this._boundaryNodeRule = boundaryNodeRule$1;
          if (parentGeom$1 !== null) {
            this.add(parentGeom$1);
          }
        }
      }
      if (PlanarGraph$$1) GeometryGraph2.__proto__ = PlanarGraph$$1;
      GeometryGraph2.prototype = Object.create(PlanarGraph$$1 && PlanarGraph$$1.prototype);
      GeometryGraph2.prototype.constructor = GeometryGraph2;
      GeometryGraph2.prototype.insertBoundaryPoint = function insertBoundaryPoint(argIndex, coord) {
        var n = this._nodes.addNode(coord);
        var lbl = n.getLabel();
        var boundaryCount = 1;
        var loc = Location.NONE;
        loc = lbl.getLocation(argIndex, Position.ON);
        if (loc === Location.BOUNDARY) {
          boundaryCount++;
        }
        var newLoc = GeometryGraph2.determineBoundary(this._boundaryNodeRule, boundaryCount);
        lbl.setLocation(argIndex, newLoc);
      };
      GeometryGraph2.prototype.computeSelfNodes = function computeSelfNodes() {
        if (arguments.length === 2) {
          var li = arguments[0];
          var computeRingSelfNodes = arguments[1];
          return this.computeSelfNodes(li, computeRingSelfNodes, false);
        } else if (arguments.length === 3) {
          var li$1 = arguments[0];
          var computeRingSelfNodes$1 = arguments[1];
          var isDoneIfProperInt = arguments[2];
          var si = new SegmentIntersector$2(li$1, true, false);
          si.setIsDoneIfProperInt(isDoneIfProperInt);
          var esi = this.createEdgeSetIntersector();
          var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;
          var computeAllSegments = computeRingSelfNodes$1 || !isRings;
          esi.computeIntersections(this._edges, si, computeAllSegments);
          this.addSelfIntersectionNodes(this._argIndex);
          return si;
        }
      };
      GeometryGraph2.prototype.computeSplitEdges = function computeSplitEdges(edgelist) {
        for (var i = this._edges.iterator(); i.hasNext(); ) {
          var e = i.next();
          e.eiList.addSplitEdges(edgelist);
        }
      };
      GeometryGraph2.prototype.computeEdgeIntersections = function computeEdgeIntersections(g, li, includeProper) {
        var si = new SegmentIntersector$2(li, includeProper, true);
        si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
        var esi = this.createEdgeSetIntersector();
        esi.computeIntersections(this._edges, g._edges, si);
        return si;
      };
      GeometryGraph2.prototype.getGeometry = function getGeometry() {
        return this._parentGeom;
      };
      GeometryGraph2.prototype.getBoundaryNodeRule = function getBoundaryNodeRule() {
        return this._boundaryNodeRule;
      };
      GeometryGraph2.prototype.hasTooFewPoints = function hasTooFewPoints() {
        return this._hasTooFewPoints;
      };
      GeometryGraph2.prototype.addPoint = function addPoint() {
        if (arguments[0] instanceof Point) {
          var p = arguments[0];
          var coord = p.getCoordinate();
          this.insertPoint(this._argIndex, coord, Location.INTERIOR);
        } else if (arguments[0] instanceof Coordinate) {
          var pt = arguments[0];
          this.insertPoint(this._argIndex, pt, Location.INTERIOR);
        }
      };
      GeometryGraph2.prototype.addPolygon = function addPolygon(p) {
        var this$1 = this;
        this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
        for (var i = 0; i < p.getNumInteriorRing(); i++) {
          var hole = p.getInteriorRingN(i);
          this$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
        }
      };
      GeometryGraph2.prototype.addEdge = function addEdge(e) {
        this.insertEdge(e);
        var coord = e.getCoordinates();
        this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
        this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
      };
      GeometryGraph2.prototype.addLineString = function addLineString(line) {
        var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
        if (coord.length < 2) {
          this._hasTooFewPoints = true;
          this._invalidPoint = coord[0];
          return null;
        }
        var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));
        this._lineEdgeMap.put(line, e);
        this.insertEdge(e);
        Assert.isTrue(coord.length >= 2, "found LineString with single point");
        this.insertBoundaryPoint(this._argIndex, coord[0]);
        this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
      };
      GeometryGraph2.prototype.getInvalidPoint = function getInvalidPoint() {
        return this._invalidPoint;
      };
      GeometryGraph2.prototype.getBoundaryPoints = function getBoundaryPoints() {
        var coll = this.getBoundaryNodes();
        var pts = new Array(coll.size()).fill(null);
        var i = 0;
        for (var it = coll.iterator(); it.hasNext(); ) {
          var node = it.next();
          pts[i++] = node.getCoordinate().copy();
        }
        return pts;
      };
      GeometryGraph2.prototype.getBoundaryNodes = function getBoundaryNodes() {
        if (this._boundaryNodes === null) {
          this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
        }
        return this._boundaryNodes;
      };
      GeometryGraph2.prototype.addSelfIntersectionNode = function addSelfIntersectionNode(argIndex, coord, loc) {
        if (this.isBoundaryNode(argIndex, coord)) {
          return null;
        }
        if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) {
          this.insertBoundaryPoint(argIndex, coord);
        } else {
          this.insertPoint(argIndex, coord, loc);
        }
      };
      GeometryGraph2.prototype.addPolygonRing = function addPolygonRing(lr, cwLeft, cwRight) {
        if (lr.isEmpty()) {
          return null;
        }
        var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
        if (coord.length < 4) {
          this._hasTooFewPoints = true;
          this._invalidPoint = coord[0];
          return null;
        }
        var left = cwLeft;
        var right = cwRight;
        if (CGAlgorithms.isCCW(coord)) {
          left = cwRight;
          right = cwLeft;
        }
        var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
        this._lineEdgeMap.put(lr, e);
        this.insertEdge(e);
        this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
      };
      GeometryGraph2.prototype.insertPoint = function insertPoint(argIndex, coord, onLocation) {
        var n = this._nodes.addNode(coord);
        var lbl = n.getLabel();
        if (lbl === null) {
          n._label = new Label(argIndex, onLocation);
        } else {
          lbl.setLocation(argIndex, onLocation);
        }
      };
      GeometryGraph2.prototype.createEdgeSetIntersector = function createEdgeSetIntersector() {
        return new SimpleMCSweepLineIntersector();
      };
      GeometryGraph2.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes(argIndex) {
        var this$1 = this;
        for (var i = this._edges.iterator(); i.hasNext(); ) {
          var e = i.next();
          var eLoc = e.getLabel().getLocation(argIndex);
          for (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {
            var ei = eiIt.next();
            this$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
          }
        }
      };
      GeometryGraph2.prototype.add = function add() {
        if (arguments.length === 1) {
          var g = arguments[0];
          if (g.isEmpty()) {
            return null;
          }
          if (g instanceof MultiPolygon) {
            this._useBoundaryDeterminationRule = false;
          }
          if (g instanceof Polygon) {
            this.addPolygon(g);
          } else if (g instanceof LineString) {
            this.addLineString(g);
          } else if (g instanceof Point) {
            this.addPoint(g);
          } else if (g instanceof MultiPoint) {
            this.addCollection(g);
          } else if (g instanceof MultiLineString) {
            this.addCollection(g);
          } else if (g instanceof MultiPolygon) {
            this.addCollection(g);
          } else if (g instanceof GeometryCollection) {
            this.addCollection(g);
          } else {
            throw new Error(g.getClass().getName());
          }
        } else {
          return PlanarGraph$$1.prototype.add.apply(this, arguments);
        }
      };
      GeometryGraph2.prototype.addCollection = function addCollection(gc) {
        var this$1 = this;
        for (var i = 0; i < gc.getNumGeometries(); i++) {
          var g = gc.getGeometryN(i);
          this$1.add(g);
        }
      };
      GeometryGraph2.prototype.locate = function locate(pt) {
        if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
          if (this._areaPtLocator === null) {
            this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
          }
          return this._areaPtLocator.locate(pt);
        }
        return this._ptLocator.locate(pt, this._parentGeom);
      };
      GeometryGraph2.prototype.findEdge = function findEdge() {
        if (arguments.length === 1) {
          var line = arguments[0];
          return this._lineEdgeMap.get(line);
        } else {
          return PlanarGraph$$1.prototype.findEdge.apply(this, arguments);
        }
      };
      GeometryGraph2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      GeometryGraph2.prototype.getClass = function getClass() {
        return GeometryGraph2;
      };
      GeometryGraph2.determineBoundary = function determineBoundary(boundaryNodeRule, boundaryCount) {
        return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;
      };
      return GeometryGraph2;
    }(PlanarGraph);
    var GeometryGraphOp = function GeometryGraphOp2() {
      this._li = new RobustLineIntersector();
      this._resultPrecisionModel = null;
      this._arg = null;
      if (arguments.length === 1) {
        var g0 = arguments[0];
        this.setComputationPrecision(g0.getPrecisionModel());
        this._arg = new Array(1).fill(null);
        this._arg[0] = new GeometryGraph(0, g0);
      } else if (arguments.length === 2) {
        var g0$1 = arguments[0];
        var g1 = arguments[1];
        var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
        if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) {
          this.setComputationPrecision(g0$1.getPrecisionModel());
        } else {
          this.setComputationPrecision(g1.getPrecisionModel());
        }
        this._arg = new Array(2).fill(null);
        this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);
        this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
      } else if (arguments.length === 3) {
        var g0$2 = arguments[0];
        var g1$1 = arguments[1];
        var boundaryNodeRule$1 = arguments[2];
        if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) {
          this.setComputationPrecision(g0$2.getPrecisionModel());
        } else {
          this.setComputationPrecision(g1$1.getPrecisionModel());
        }
        this._arg = new Array(2).fill(null);
        this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);
        this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);
      }
    };
    GeometryGraphOp.prototype.getArgGeometry = function getArgGeometry(i) {
      return this._arg[i].getGeometry();
    };
    GeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision(pm) {
      this._resultPrecisionModel = pm;
      this._li.setPrecisionModel(this._resultPrecisionModel);
    };
    GeometryGraphOp.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryGraphOp.prototype.getClass = function getClass() {
      return GeometryGraphOp;
    };
    var GeometryMapper = function GeometryMapper2() {
    };
    GeometryMapper.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryMapper.prototype.getClass = function getClass() {
      return GeometryMapper;
    };
    GeometryMapper.map = function map2() {
      if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {
        var geom = arguments[0];
        var op = arguments[1];
        var mapped = new ArrayList();
        for (var i = 0; i < geom.getNumGeometries(); i++) {
          var g = op.map(geom.getGeometryN(i));
          if (g !== null) {
            mapped.add(g);
          }
        }
        return geom.getFactory().buildGeometry(mapped);
      } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {
        var geoms = arguments[0];
        var op$1 = arguments[1];
        var mapped$1 = new ArrayList();
        for (var i$1 = geoms.iterator(); i$1.hasNext(); ) {
          var g$1 = i$1.next();
          var gr = op$1.map(g$1);
          if (gr !== null) {
            mapped$1.add(gr);
          }
        }
        return mapped$1;
      }
    };
    GeometryMapper.MapOp = function MapOp() {
    };
    var OverlayOp = function(GeometryGraphOp2) {
      function OverlayOp2() {
        var g0 = arguments[0];
        var g1 = arguments[1];
        GeometryGraphOp2.call(this, g0, g1);
        this._ptLocator = new PointLocator();
        this._geomFact = null;
        this._resultGeom = null;
        this._graph = null;
        this._edgeList = new EdgeList();
        this._resultPolyList = new ArrayList();
        this._resultLineList = new ArrayList();
        this._resultPointList = new ArrayList();
        this._graph = new PlanarGraph(new OverlayNodeFactory());
        this._geomFact = g0.getFactory();
      }
      if (GeometryGraphOp2) OverlayOp2.__proto__ = GeometryGraphOp2;
      OverlayOp2.prototype = Object.create(GeometryGraphOp2 && GeometryGraphOp2.prototype);
      OverlayOp2.prototype.constructor = OverlayOp2;
      OverlayOp2.prototype.insertUniqueEdge = function insertUniqueEdge(e) {
        var existingEdge = this._edgeList.findEqualEdge(e);
        if (existingEdge !== null) {
          var existingLabel = existingEdge.getLabel();
          var labelToMerge = e.getLabel();
          if (!existingEdge.isPointwiseEqual(e)) {
            labelToMerge = new Label(e.getLabel());
            labelToMerge.flip();
          }
          var depth = existingEdge.getDepth();
          if (depth.isNull()) {
            depth.add(existingLabel);
          }
          depth.add(labelToMerge);
          existingLabel.merge(labelToMerge);
        } else {
          this._edgeList.add(e);
        }
      };
      OverlayOp2.prototype.getGraph = function getGraph() {
        return this._graph;
      };
      OverlayOp2.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges() {
        for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
          var de = it.next();
          var sym = de.getSym();
          if (de.isInResult() && sym.isInResult()) {
            de.setInResult(false);
            sym.setInResult(false);
          }
        }
      };
      OverlayOp2.prototype.isCoveredByLA = function isCoveredByLA(coord) {
        if (this.isCovered(coord, this._resultLineList)) {
          return true;
        }
        if (this.isCovered(coord, this._resultPolyList)) {
          return true;
        }
        return false;
      };
      OverlayOp2.prototype.computeGeometry = function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {
        var geomList = new ArrayList();
        geomList.addAll(resultPointList);
        geomList.addAll(resultLineList);
        geomList.addAll(resultPolyList);
        if (geomList.isEmpty()) {
          return OverlayOp2.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
        }
        return this._geomFact.buildGeometry(geomList);
      };
      OverlayOp2.prototype.mergeSymLabels = function mergeSymLabels() {
        for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
          var node = nodeit.next();
          node.getEdges().mergeSymLabels();
        }
      };
      OverlayOp2.prototype.isCovered = function isCovered(coord, geomList) {
        var this$1 = this;
        for (var it = geomList.iterator(); it.hasNext(); ) {
          var geom = it.next();
          var loc = this$1._ptLocator.locate(coord, geom);
          if (loc !== Location.EXTERIOR) {
            return true;
          }
        }
        return false;
      };
      OverlayOp2.prototype.replaceCollapsedEdges = function replaceCollapsedEdges() {
        var newEdges = new ArrayList();
        for (var it = this._edgeList.iterator(); it.hasNext(); ) {
          var e = it.next();
          if (e.isCollapsed()) {
            it.remove();
            newEdges.add(e.getCollapsedEdge());
          }
        }
        this._edgeList.addAll(newEdges);
      };
      OverlayOp2.prototype.updateNodeLabelling = function updateNodeLabelling() {
        for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
          var node = nodeit.next();
          var lbl = node.getEdges().getLabel();
          node.getLabel().merge(lbl);
        }
      };
      OverlayOp2.prototype.getResultGeometry = function getResultGeometry(overlayOpCode) {
        this.computeOverlay(overlayOpCode);
        return this._resultGeom;
      };
      OverlayOp2.prototype.insertUniqueEdges = function insertUniqueEdges(edges) {
        var this$1 = this;
        for (var i = edges.iterator(); i.hasNext(); ) {
          var e = i.next();
          this$1.insertUniqueEdge(e);
        }
      };
      OverlayOp2.prototype.computeOverlay = function computeOverlay(opCode) {
        this.copyPoints(0);
        this.copyPoints(1);
        this._arg[0].computeSelfNodes(this._li, false);
        this._arg[1].computeSelfNodes(this._li, false);
        this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
        var baseSplitEdges = new ArrayList();
        this._arg[0].computeSplitEdges(baseSplitEdges);
        this._arg[1].computeSplitEdges(baseSplitEdges);
        this.insertUniqueEdges(baseSplitEdges);
        this.computeLabelsFromDepths();
        this.replaceCollapsedEdges();
        EdgeNodingValidator.checkValid(this._edgeList.getEdges());
        this._graph.addEdges(this._edgeList.getEdges());
        this.computeLabelling();
        this.labelIncompleteNodes();
        this.findResultAreaEdges(opCode);
        this.cancelDuplicateResultEdges();
        var polyBuilder = new PolygonBuilder(this._geomFact);
        polyBuilder.add(this._graph);
        this._resultPolyList = polyBuilder.getPolygons();
        var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
        this._resultLineList = lineBuilder.build(opCode);
        var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
        this._resultPointList = pointBuilder.build(opCode);
        this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
      };
      OverlayOp2.prototype.labelIncompleteNode = function labelIncompleteNode(n, targetIndex) {
        var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
        n.getLabel().setLocation(targetIndex, loc);
      };
      OverlayOp2.prototype.copyPoints = function copyPoints(argIndex) {
        var this$1 = this;
        for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {
          var graphNode = i.next();
          var newNode = this$1._graph.addNode(graphNode.getCoordinate());
          newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
        }
      };
      OverlayOp2.prototype.findResultAreaEdges = function findResultAreaEdges(opCode) {
        for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
          var de = it.next();
          var label = de.getLabel();
          if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp2.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
            de.setInResult(true);
          }
        }
      };
      OverlayOp2.prototype.computeLabelsFromDepths = function computeLabelsFromDepths() {
        for (var it = this._edgeList.iterator(); it.hasNext(); ) {
          var e = it.next();
          var lbl = e.getLabel();
          var depth = e.getDepth();
          if (!depth.isNull()) {
            depth.normalize();
            for (var i = 0; i < 2; i++) {
              if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
                if (depth.getDelta(i) === 0) {
                  lbl.toLine(i);
                } else {
                  Assert.isTrue(!depth.isNull(i, Position.LEFT), "depth of LEFT side has not been initialized");
                  lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));
                  Assert.isTrue(!depth.isNull(i, Position.RIGHT), "depth of RIGHT side has not been initialized");
                  lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));
                }
              }
            }
          }
        }
      };
      OverlayOp2.prototype.computeLabelling = function computeLabelling() {
        var this$1 = this;
        for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
          var node = nodeit.next();
          node.getEdges().computeLabelling(this$1._arg);
        }
        this.mergeSymLabels();
        this.updateNodeLabelling();
      };
      OverlayOp2.prototype.labelIncompleteNodes = function labelIncompleteNodes() {
        var this$1 = this;
        for (var ni = this._graph.getNodes().iterator(); ni.hasNext(); ) {
          var n = ni.next();
          var label = n.getLabel();
          if (n.isIsolated()) {
            if (label.isNull(0)) {
              this$1.labelIncompleteNode(n, 0);
            } else {
              this$1.labelIncompleteNode(n, 1);
            }
          }
          n.getEdges().updateLabelling(label);
        }
      };
      OverlayOp2.prototype.isCoveredByA = function isCoveredByA(coord) {
        if (this.isCovered(coord, this._resultPolyList)) {
          return true;
        }
        return false;
      };
      OverlayOp2.prototype.interfaces_ = function interfaces_() {
        return [];
      };
      OverlayOp2.prototype.getClass = function getClass() {
        return OverlayOp2;
      };
      return OverlayOp2;
    }(GeometryGraphOp);
    OverlayOp.overlayOp = function(geom0, geom1, opCode) {
      var gov = new OverlayOp(geom0, geom1);
      var geomOv = gov.getResultGeometry(opCode);
      return geomOv;
    };
    OverlayOp.intersection = function(g, other) {
      if (g.isEmpty() || other.isEmpty()) {
        return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());
      }
      if (g.isGeometryCollection()) {
        var g2 = other;
        return GeometryCollectionMapper.map(g, {
          interfaces_: function() {
            return [GeometryMapper.MapOp];
          },
          map: function(g3) {
            return g3.intersection(g2);
          }
        });
      }
      g.checkNotGeometryCollection(g);
      g.checkNotGeometryCollection(other);
      return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);
    };
    OverlayOp.symDifference = function(g, other) {
      if (g.isEmpty() || other.isEmpty()) {
        if (g.isEmpty() && other.isEmpty()) {
          return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());
        }
        if (g.isEmpty()) {
          return other.copy();
        }
        if (other.isEmpty()) {
          return g.copy();
        }
      }
      g.checkNotGeometryCollection(g);
      g.checkNotGeometryCollection(other);
      return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);
    };
    OverlayOp.resultDimension = function(opCode, g0, g1) {
      var dim0 = g0.getDimension();
      var dim1 = g1.getDimension();
      var resultDimension = -1;
      switch (opCode) {
        case OverlayOp.INTERSECTION:
          resultDimension = Math.min(dim0, dim1);
          break;
        case OverlayOp.UNION:
          resultDimension = Math.max(dim0, dim1);
          break;
        case OverlayOp.DIFFERENCE:
          resultDimension = dim0;
          break;
        case OverlayOp.SYMDIFFERENCE:
          resultDimension = Math.max(dim0, dim1);
          break;
        default:
      }
      return resultDimension;
    };
    OverlayOp.createEmptyResult = function(overlayOpCode, a, b, geomFact) {
      var result2 = null;
      switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
        case -1:
          result2 = geomFact.createGeometryCollection(new Array(0).fill(null));
          break;
        case 0:
          result2 = geomFact.createPoint();
          break;
        case 1:
          result2 = geomFact.createLineString();
          break;
        case 2:
          result2 = geomFact.createPolygon();
          break;
        default:
      }
      return result2;
    };
    OverlayOp.difference = function(g, other) {
      if (g.isEmpty()) {
        return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());
      }
      if (other.isEmpty()) {
        return g.copy();
      }
      g.checkNotGeometryCollection(g);
      g.checkNotGeometryCollection(other);
      return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);
    };
    OverlayOp.isResultOfOp = function() {
      if (arguments.length === 2) {
        var label = arguments[0];
        var opCode = arguments[1];
        var loc0 = label.getLocation(0);
        var loc1 = label.getLocation(1);
        return OverlayOp.isResultOfOp(loc0, loc1, opCode);
      } else if (arguments.length === 3) {
        var loc0$1 = arguments[0];
        var loc1$1 = arguments[1];
        var overlayOpCode = arguments[2];
        if (loc0$1 === Location.BOUNDARY) {
          loc0$1 = Location.INTERIOR;
        }
        if (loc1$1 === Location.BOUNDARY) {
          loc1$1 = Location.INTERIOR;
        }
        switch (overlayOpCode) {
          case OverlayOp.INTERSECTION:
            return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR;
          case OverlayOp.UNION:
            return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR;
          case OverlayOp.DIFFERENCE:
            return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR;
          case OverlayOp.SYMDIFFERENCE:
            return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR || loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR;
          default:
        }
        return false;
      }
    };
    OverlayOp.INTERSECTION = 1;
    OverlayOp.UNION = 2;
    OverlayOp.DIFFERENCE = 3;
    OverlayOp.SYMDIFFERENCE = 4;
    var FuzzyPointLocator = function FuzzyPointLocator2() {
      this._g = null;
      this._boundaryDistanceTolerance = null;
      this._linework = null;
      this._ptLocator = new PointLocator();
      this._seg = new LineSegment();
      var g = arguments[0];
      var boundaryDistanceTolerance = arguments[1];
      this._g = g;
      this._boundaryDistanceTolerance = boundaryDistanceTolerance;
      this._linework = this.extractLinework(g);
    };
    FuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary(pt) {
      var this$1 = this;
      for (var i = 0; i < this._linework.getNumGeometries(); i++) {
        var line = this$1._linework.getGeometryN(i);
        var seq = line.getCoordinateSequence();
        for (var j = 0; j < seq.size() - 1; j++) {
          seq.getCoordinate(j, this$1._seg.p0);
          seq.getCoordinate(j + 1, this$1._seg.p1);
          var dist = this$1._seg.distance(pt);
          if (dist <= this$1._boundaryDistanceTolerance) {
            return true;
          }
        }
      }
      return false;
    };
    FuzzyPointLocator.prototype.getLocation = function getLocation(pt) {
      if (this.isWithinToleranceOfBoundary(pt)) {
        return Location.BOUNDARY;
      }
      return this._ptLocator.locate(pt, this._g);
    };
    FuzzyPointLocator.prototype.extractLinework = function extractLinework(g) {
      var extracter = new PolygonalLineworkExtracter();
      g.apply(extracter);
      var linework = extracter.getLinework();
      var lines = GeometryFactory.toLineStringArray(linework);
      return g.getFactory().createMultiLineString(lines);
    };
    FuzzyPointLocator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    FuzzyPointLocator.prototype.getClass = function getClass() {
      return FuzzyPointLocator;
    };
    var PolygonalLineworkExtracter = function PolygonalLineworkExtracter2() {
      this._linework = null;
      this._linework = new ArrayList();
    };
    PolygonalLineworkExtracter.prototype.getLinework = function getLinework() {
      return this._linework;
    };
    PolygonalLineworkExtracter.prototype.filter = function filter(g) {
      var this$1 = this;
      if (g instanceof Polygon) {
        var poly = g;
        this._linework.add(poly.getExteriorRing());
        for (var i = 0; i < poly.getNumInteriorRing(); i++) {
          this$1._linework.add(poly.getInteriorRingN(i));
        }
      }
    };
    PolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_() {
      return [GeometryFilter];
    };
    PolygonalLineworkExtracter.prototype.getClass = function getClass() {
      return PolygonalLineworkExtracter;
    };
    var OffsetPointGenerator = function OffsetPointGenerator2() {
      this._g = null;
      this._doLeft = true;
      this._doRight = true;
      var g = arguments[0];
      this._g = g;
    };
    OffsetPointGenerator.prototype.extractPoints = function extractPoints(line, offsetDistance, offsetPts) {
      var this$1 = this;
      var pts = line.getCoordinates();
      for (var i = 0; i < pts.length - 1; i++) {
        this$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);
      }
    };
    OffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate(doLeft, doRight) {
      this._doLeft = doLeft;
      this._doRight = doRight;
    };
    OffsetPointGenerator.prototype.getPoints = function getPoints(offsetDistance) {
      var this$1 = this;
      var offsetPts = new ArrayList();
      var lines = LinearComponentExtracter.getLines(this._g);
      for (var i = lines.iterator(); i.hasNext(); ) {
        var line = i.next();
        this$1.extractPoints(line, offsetDistance, offsetPts);
      }
      return offsetPts;
    };
    OffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints(p0, p1, offsetDistance, offsetPts) {
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;
      var len = Math.sqrt(dx * dx + dy * dy);
      var ux = offsetDistance * dx / len;
      var uy = offsetDistance * dy / len;
      var midX = (p1.x + p0.x) / 2;
      var midY = (p1.y + p0.y) / 2;
      if (this._doLeft) {
        var offsetLeft = new Coordinate(midX - uy, midY + ux);
        offsetPts.add(offsetLeft);
      }
      if (this._doRight) {
        var offsetRight = new Coordinate(midX + uy, midY - ux);
        offsetPts.add(offsetRight);
      }
    };
    OffsetPointGenerator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    OffsetPointGenerator.prototype.getClass = function getClass() {
      return OffsetPointGenerator;
    };
    var OverlayResultValidator = function OverlayResultValidator2() {
      this._geom = null;
      this._locFinder = null;
      this._location = new Array(3).fill(null);
      this._invalidLocation = null;
      this._boundaryDistanceTolerance = OverlayResultValidator2.TOLERANCE;
      this._testCoords = new ArrayList();
      var a = arguments[0];
      var b = arguments[1];
      var result2 = arguments[2];
      this._boundaryDistanceTolerance = OverlayResultValidator2.computeBoundaryDistanceTolerance(a, b);
      this._geom = [a, b, result2];
      this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];
    };
    var staticAccessors$46 = { TOLERANCE: { configurable: true } };
    OverlayResultValidator.prototype.reportResult = function reportResult(overlayOp, location, expectedInterior) {
      System.out.println("Overlay result invalid - A:" + Location.toLocationSymbol(location[0]) + " B:" + Location.toLocationSymbol(location[1]) + " expected:" + (expectedInterior ? "i" : "e") + " actual:" + Location.toLocationSymbol(location[2]));
    };
    OverlayResultValidator.prototype.isValid = function isValid(overlayOp) {
      this.addTestPts(this._geom[0]);
      this.addTestPts(this._geom[1]);
      var isValid2 = this.checkValid(overlayOp);
      return isValid2;
    };
    OverlayResultValidator.prototype.checkValid = function checkValid() {
      var this$1 = this;
      if (arguments.length === 1) {
        var overlayOp = arguments[0];
        for (var i = 0; i < this._testCoords.size(); i++) {
          var pt = this$1._testCoords.get(i);
          if (!this$1.checkValid(overlayOp, pt)) {
            this$1._invalidLocation = pt;
            return false;
          }
        }
        return true;
      } else if (arguments.length === 2) {
        var overlayOp$1 = arguments[0];
        var pt$1 = arguments[1];
        this._location[0] = this._locFinder[0].getLocation(pt$1);
        this._location[1] = this._locFinder[1].getLocation(pt$1);
        this._location[2] = this._locFinder[2].getLocation(pt$1);
        if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) {
          return true;
        }
        return this.isValidResult(overlayOp$1, this._location);
      }
    };
    OverlayResultValidator.prototype.addTestPts = function addTestPts(g) {
      var ptGen = new OffsetPointGenerator(g);
      this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));
    };
    OverlayResultValidator.prototype.isValidResult = function isValidResult(overlayOp, location) {
      var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);
      var resultInInterior = location[2] === Location.INTERIOR;
      var isValid = !(expectedInterior ^ resultInInterior);
      if (!isValid) {
        this.reportResult(overlayOp, location, expectedInterior);
      }
      return isValid;
    };
    OverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation() {
      return this._invalidLocation;
    };
    OverlayResultValidator.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    OverlayResultValidator.prototype.getClass = function getClass() {
      return OverlayResultValidator;
    };
    OverlayResultValidator.hasLocation = function hasLocation(location, loc) {
      for (var i = 0; i < 3; i++) {
        if (location[i] === loc) {
          return true;
        }
      }
      return false;
    };
    OverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance(g0, g1) {
      return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1));
    };
    OverlayResultValidator.isValid = function isValid(a, b, overlayOp, result2) {
      var validator = new OverlayResultValidator(a, b, result2);
      return validator.isValid(overlayOp);
    };
    staticAccessors$46.TOLERANCE.get = function() {
      return 1e-6;
    };
    Object.defineProperties(OverlayResultValidator, staticAccessors$46);
    var GeometryCombiner = function GeometryCombiner2(geoms) {
      this._geomFactory = null;
      this._skipEmpty = false;
      this._inputGeoms = null;
      this._geomFactory = GeometryCombiner2.extractFactory(geoms);
      this._inputGeoms = geoms;
    };
    GeometryCombiner.prototype.extractElements = function extractElements(geom, elems) {
      var this$1 = this;
      if (geom === null) {
        return null;
      }
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var elemGeom = geom.getGeometryN(i);
        if (this$1._skipEmpty && elemGeom.isEmpty()) {
          continue;
        }
        elems.add(elemGeom);
      }
    };
    GeometryCombiner.prototype.combine = function combine() {
      var this$1 = this;
      var elems = new ArrayList();
      for (var i = this._inputGeoms.iterator(); i.hasNext(); ) {
        var g = i.next();
        this$1.extractElements(g, elems);
      }
      if (elems.size() === 0) {
        if (this._geomFactory !== null) {
          return this._geomFactory.createGeometryCollection(null);
        }
        return null;
      }
      return this._geomFactory.buildGeometry(elems);
    };
    GeometryCombiner.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    GeometryCombiner.prototype.getClass = function getClass() {
      return GeometryCombiner;
    };
    GeometryCombiner.combine = function combine() {
      if (arguments.length === 1) {
        var geoms = arguments[0];
        var combiner = new GeometryCombiner(geoms);
        return combiner.combine();
      } else if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
        return combiner$1.combine();
      } else if (arguments.length === 3) {
        var g0$1 = arguments[0];
        var g1$1 = arguments[1];
        var g2 = arguments[2];
        var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));
        return combiner$2.combine();
      }
    };
    GeometryCombiner.extractFactory = function extractFactory(geoms) {
      if (geoms.isEmpty()) {
        return null;
      }
      return geoms.iterator().next().getFactory();
    };
    GeometryCombiner.createList = function createList() {
      if (arguments.length === 2) {
        var obj0 = arguments[0];
        var obj1 = arguments[1];
        var list = new ArrayList();
        list.add(obj0);
        list.add(obj1);
        return list;
      } else if (arguments.length === 3) {
        var obj0$1 = arguments[0];
        var obj1$1 = arguments[1];
        var obj2 = arguments[2];
        var list$1 = new ArrayList();
        list$1.add(obj0$1);
        list$1.add(obj1$1);
        list$1.add(obj2);
        return list$1;
      }
    };
    var CascadedPolygonUnion = function CascadedPolygonUnion2() {
      this._inputPolys = null;
      this._geomFactory = null;
      var polys = arguments[0];
      this._inputPolys = polys;
      if (this._inputPolys === null) {
        this._inputPolys = new ArrayList();
      }
    };
    var staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };
    CascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries(geomTree) {
      var this$1 = this;
      var geoms = new ArrayList();
      for (var i = geomTree.iterator(); i.hasNext(); ) {
        var o = i.next();
        var geom = null;
        if (hasInterface(o, List)) {
          geom = this$1.unionTree(o);
        } else if (o instanceof Geometry) {
          geom = o;
        }
        geoms.add(geom);
      }
      return geoms;
    };
    CascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope(env, geom, disjointGeoms) {
      var intersectingGeoms = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var elem = geom.getGeometryN(i);
        if (elem.getEnvelopeInternal().intersects(env)) {
          intersectingGeoms.add(elem);
        } else {
          disjointGeoms.add(elem);
        }
      }
      return this._geomFactory.buildGeometry(intersectingGeoms);
    };
    CascadedPolygonUnion.prototype.unionOptimized = function unionOptimized(g0, g1) {
      var g0Env = g0.getEnvelopeInternal();
      var g1Env = g1.getEnvelopeInternal();
      if (!g0Env.intersects(g1Env)) {
        var combo = GeometryCombiner.combine(g0, g1);
        return combo;
      }
      if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) {
        return this.unionActual(g0, g1);
      }
      var commonEnv = g0Env.intersection(g1Env);
      return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);
    };
    CascadedPolygonUnion.prototype.union = function union() {
      if (this._inputPolys === null) {
        throw new Error("union() method cannot be called twice");
      }
      if (this._inputPolys.isEmpty()) {
        return null;
      }
      this._geomFactory = this._inputPolys.iterator().next().getFactory();
      var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
      for (var i = this._inputPolys.iterator(); i.hasNext(); ) {
        var item = i.next();
        index.insert(item.getEnvelopeInternal(), item);
      }
      this._inputPolys = null;
      var itemTree = index.itemsTree();
      var unionAll = this.unionTree(itemTree);
      return unionAll;
    };
    CascadedPolygonUnion.prototype.binaryUnion = function binaryUnion() {
      if (arguments.length === 1) {
        var geoms = arguments[0];
        return this.binaryUnion(geoms, 0, geoms.size());
      } else if (arguments.length === 3) {
        var geoms$1 = arguments[0];
        var start = arguments[1];
        var end = arguments[2];
        if (end - start <= 1) {
          var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);
          return this.unionSafe(g0, null);
        } else if (end - start === 2) {
          return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1));
        } else {
          var mid = Math.trunc((end + start) / 2);
          var g0$1 = this.binaryUnion(geoms$1, start, mid);
          var g1 = this.binaryUnion(geoms$1, mid, end);
          return this.unionSafe(g0$1, g1);
        }
      }
    };
    CascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion(geoms) {
      var union = null;
      for (var i = geoms.iterator(); i.hasNext(); ) {
        var g = i.next();
        if (union === null) {
          union = g.copy();
        } else {
          union = union.union(g);
        }
      }
      return union;
    };
    CascadedPolygonUnion.prototype.unionSafe = function unionSafe(g0, g1) {
      if (g0 === null && g1 === null) {
        return null;
      }
      if (g0 === null) {
        return g1.copy();
      }
      if (g1 === null) {
        return g0.copy();
      }
      return this.unionOptimized(g0, g1);
    };
    CascadedPolygonUnion.prototype.unionActual = function unionActual(g0, g1) {
      return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));
    };
    CascadedPolygonUnion.prototype.unionTree = function unionTree(geomTree) {
      var geoms = this.reduceToGeometries(geomTree);
      var union = this.binaryUnion(geoms);
      return union;
    };
    CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection(g0, g1, common) {
      var disjointPolys = new ArrayList();
      var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
      var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
      var union = this.unionActual(g0Int, g1Int);
      disjointPolys.add(union);
      var overallUnion = GeometryCombiner.combine(disjointPolys);
      return overallUnion;
    };
    CascadedPolygonUnion.prototype.bufferUnion = function bufferUnion() {
      if (arguments.length === 1) {
        var geoms = arguments[0];
        var factory = geoms.get(0).getFactory();
        var gColl = factory.buildGeometry(geoms);
        var unionAll = gColl.buffer(0);
        return unionAll;
      } else if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        var factory$1 = g0.getFactory();
        var gColl$1 = factory$1.createGeometryCollection([g0, g1]);
        var unionAll$1 = gColl$1.buffer(0);
        return unionAll$1;
      }
    };
    CascadedPolygonUnion.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    CascadedPolygonUnion.prototype.getClass = function getClass() {
      return CascadedPolygonUnion;
    };
    CascadedPolygonUnion.restrictToPolygons = function restrictToPolygons(g) {
      if (hasInterface(g, Polygonal)) {
        return g;
      }
      var polygons = PolygonExtracter.getPolygons(g);
      if (polygons.size() === 1) {
        return polygons.get(0);
      }
      return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));
    };
    CascadedPolygonUnion.getGeometry = function getGeometry(list, index) {
      if (index >= list.size()) {
        return null;
      }
      return list.get(index);
    };
    CascadedPolygonUnion.union = function union(polys) {
      var op = new CascadedPolygonUnion(polys);
      return op.union();
    };
    staticAccessors$47.STRTREE_NODE_CAPACITY.get = function() {
      return 4;
    };
    Object.defineProperties(CascadedPolygonUnion, staticAccessors$47);
    var UnionOp = function UnionOp2() {
    };
    UnionOp.prototype.interfaces_ = function interfaces_() {
      return [];
    };
    UnionOp.prototype.getClass = function getClass() {
      return UnionOp;
    };
    UnionOp.union = function union(g, other) {
      if (g.isEmpty() || other.isEmpty()) {
        if (g.isEmpty() && other.isEmpty()) {
          return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());
        }
        if (g.isEmpty()) {
          return other.copy();
        }
        if (other.isEmpty()) {
          return g.copy();
        }
      }
      g.checkNotGeometryCollection(g);
      g.checkNotGeometryCollection(other);
      return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);
    };
    exports2.GeoJSONReader = GeoJSONReader;
    exports2.GeoJSONWriter = GeoJSONWriter;
    exports2.OverlayOp = OverlayOp;
    exports2.UnionOp = UnionOp;
    exports2.BufferOp = BufferOp;
  }
});

// node_modules/d3-array/dist/d3-array.js
var require_d3_array = __commonJS({
  "node_modules/d3-array/dist/d3-array.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
    })(exports2, function(exports3) {
      "use strict";
      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      function bisector(compare) {
        if (compare.length === 1) compare = ascendingComparator(compare);
        return {
          left: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0) lo = mid + 1;
              else hi = mid;
            }
            return lo;
          },
          right: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0) hi = mid;
              else lo = mid + 1;
            }
            return lo;
          }
        };
      }
      function ascendingComparator(f) {
        return function(d, x) {
          return ascending(f(d), x);
        };
      }
      var ascendingBisect = bisector(ascending);
      var bisectRight = ascendingBisect.right;
      var bisectLeft = ascendingBisect.left;
      function pairs(array2, f) {
        if (f == null) f = pair;
        var i = 0, n = array2.length - 1, p = array2[0], pairs2 = new Array(n < 0 ? 0 : n);
        while (i < n) pairs2[i] = f(p, p = array2[++i]);
        return pairs2;
      }
      function pair(a, b) {
        return [a, b];
      }
      function cross(values0, values1, reduce) {
        var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;
        if (reduce == null) reduce = pair;
        for (i0 = i = 0; i0 < n0; ++i0) {
          for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
            values[i] = reduce(value0, values1[i1]);
          }
        }
        return values;
      }
      function descending(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      }
      function number(x) {
        return x === null ? NaN : +x;
      }
      function variance(values, valueof) {
        var n = values.length, m = 0, i = -1, mean2 = 0, value, delta, sum2 = 0;
        if (valueof == null) {
          while (++i < n) {
            if (!isNaN(value = number(values[i]))) {
              delta = value - mean2;
              mean2 += delta / ++m;
              sum2 += delta * (value - mean2);
            }
          }
        } else {
          while (++i < n) {
            if (!isNaN(value = number(valueof(values[i], i, values)))) {
              delta = value - mean2;
              mean2 += delta / ++m;
              sum2 += delta * (value - mean2);
            }
          }
        }
        if (m > 1) return sum2 / (m - 1);
      }
      function deviation(array2, f) {
        var v = variance(array2, f);
        return v ? Math.sqrt(v) : v;
      }
      function extent(values, valueof) {
        var n = values.length, i = -1, value, min2, max2;
        if (valueof == null) {
          while (++i < n) {
            if ((value = values[i]) != null && value >= value) {
              min2 = max2 = value;
              while (++i < n) {
                if ((value = values[i]) != null) {
                  if (min2 > value) min2 = value;
                  if (max2 < value) max2 = value;
                }
              }
            }
          }
        } else {
          while (++i < n) {
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
              min2 = max2 = value;
              while (++i < n) {
                if ((value = valueof(values[i], i, values)) != null) {
                  if (min2 > value) min2 = value;
                  if (max2 < value) max2 = value;
                }
              }
            }
          }
        }
        return [min2, max2];
      }
      var array = Array.prototype;
      var slice = array.slice;
      var map2 = array.map;
      function constant(x) {
        return function() {
          return x;
        };
      }
      function identity(x) {
        return x;
      }
      function range(start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
        var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
        while (++i < n) {
          range2[i] = start + i * step;
        }
        return range2;
      }
      var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
      function ticks(start, stop, count) {
        var reverse, i = -1, n, ticks2, step;
        stop = +stop, start = +start, count = +count;
        if (start === stop && count > 0) return [start];
        if (reverse = stop < start) n = start, start = stop, stop = n;
        if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];
        if (step > 0) {
          start = Math.ceil(start / step);
          stop = Math.floor(stop / step);
          ticks2 = new Array(n = Math.ceil(stop - start + 1));
          while (++i < n) ticks2[i] = (start + i) * step;
        } else {
          start = Math.floor(start * step);
          stop = Math.ceil(stop * step);
          ticks2 = new Array(n = Math.ceil(start - stop + 1));
          while (++i < n) ticks2[i] = (start - i) / step;
        }
        if (reverse) ticks2.reverse();
        return ticks2;
      }
      function tickIncrement(start, stop, count) {
        var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
        return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
      }
      function tickStep(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
        if (error >= e10) step1 *= 10;
        else if (error >= e5) step1 *= 5;
        else if (error >= e2) step1 *= 2;
        return stop < start ? -step1 : step1;
      }
      function sturges(values) {
        return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
      }
      function histogram() {
        var value = identity, domain = extent, threshold = sturges;
        function histogram2(data) {
          var i, n = data.length, x, values = new Array(n);
          for (i = 0; i < n; ++i) {
            values[i] = value(data[i], i, data);
          }
          var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
          if (!Array.isArray(tz)) {
            tz = tickStep(x0, x1, tz);
            tz = range(Math.ceil(x0 / tz) * tz, x1, tz);
          }
          var m = tz.length;
          while (tz[0] <= x0) tz.shift(), --m;
          while (tz[m - 1] > x1) tz.pop(), --m;
          var bins = new Array(m + 1), bin;
          for (i = 0; i <= m; ++i) {
            bin = bins[i] = [];
            bin.x0 = i > 0 ? tz[i - 1] : x0;
            bin.x1 = i < m ? tz[i] : x1;
          }
          for (i = 0; i < n; ++i) {
            x = values[i];
            if (x0 <= x && x <= x1) {
              bins[bisectRight(tz, x, 0, m)].push(data[i]);
            }
          }
          return bins;
        }
        histogram2.value = function(_) {
          return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram2) : value;
        };
        histogram2.domain = function(_) {
          return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram2) : domain;
        };
        histogram2.thresholds = function(_) {
          return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram2) : threshold;
        };
        return histogram2;
      }
      function quantile(values, p, valueof) {
        if (valueof == null) valueof = number;
        if (!(n = values.length)) return;
        if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
        if (p >= 1) return +valueof(values[n - 1], n - 1, values);
        var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
        return value0 + (value1 - value0) * (i - i0);
      }
      function freedmanDiaconis(values, min2, max2) {
        values = map2.call(values, number).sort(ascending);
        return Math.ceil((max2 - min2) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
      }
      function scott(values, min2, max2) {
        return Math.ceil((max2 - min2) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
      }
      function max(values, valueof) {
        var n = values.length, i = -1, value, max2;
        if (valueof == null) {
          while (++i < n) {
            if ((value = values[i]) != null && value >= value) {
              max2 = value;
              while (++i < n) {
                if ((value = values[i]) != null && value > max2) {
                  max2 = value;
                }
              }
            }
          }
        } else {
          while (++i < n) {
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
              max2 = value;
              while (++i < n) {
                if ((value = valueof(values[i], i, values)) != null && value > max2) {
                  max2 = value;
                }
              }
            }
          }
        }
        return max2;
      }
      function mean(values, valueof) {
        var n = values.length, m = n, i = -1, value, sum2 = 0;
        if (valueof == null) {
          while (++i < n) {
            if (!isNaN(value = number(values[i]))) sum2 += value;
            else --m;
          }
        } else {
          while (++i < n) {
            if (!isNaN(value = number(valueof(values[i], i, values)))) sum2 += value;
            else --m;
          }
        }
        if (m) return sum2 / m;
      }
      function median(values, valueof) {
        var n = values.length, i = -1, value, numbers = [];
        if (valueof == null) {
          while (++i < n) {
            if (!isNaN(value = number(values[i]))) {
              numbers.push(value);
            }
          }
        } else {
          while (++i < n) {
            if (!isNaN(value = number(valueof(values[i], i, values)))) {
              numbers.push(value);
            }
          }
        }
        return quantile(numbers.sort(ascending), 0.5);
      }
      function merge(arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array2;
        while (++i < n) j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array2 = arrays[n];
          m = array2.length;
          while (--m >= 0) {
            merged[--j] = array2[m];
          }
        }
        return merged;
      }
      function min(values, valueof) {
        var n = values.length, i = -1, value, min2;
        if (valueof == null) {
          while (++i < n) {
            if ((value = values[i]) != null && value >= value) {
              min2 = value;
              while (++i < n) {
                if ((value = values[i]) != null && min2 > value) {
                  min2 = value;
                }
              }
            }
          }
        } else {
          while (++i < n) {
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
              min2 = value;
              while (++i < n) {
                if ((value = valueof(values[i], i, values)) != null && min2 > value) {
                  min2 = value;
                }
              }
            }
          }
        }
        return min2;
      }
      function permute(array2, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--) permutes[i] = array2[indexes[i]];
        return permutes;
      }
      function scan(values, compare) {
        if (!(n = values.length)) return;
        var n, i = 0, j = 0, xi, xj = values[j];
        if (compare == null) compare = ascending;
        while (++i < n) {
          if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
            xj = xi, j = i;
          }
        }
        if (compare(xj, xj) === 0) return j;
      }
      function shuffle(array2, i0, i1) {
        var m = (i1 == null ? array2.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array2[m + i0];
          array2[m + i0] = array2[i + i0];
          array2[i + i0] = t;
        }
        return array2;
      }
      function sum(values, valueof) {
        var n = values.length, i = -1, value, sum2 = 0;
        if (valueof == null) {
          while (++i < n) {
            if (value = +values[i]) sum2 += value;
          }
        } else {
          while (++i < n) {
            if (value = +valueof(values[i], i, values)) sum2 += value;
          }
        }
        return sum2;
      }
      function transpose(matrix) {
        if (!(n = matrix.length)) return [];
        for (var i = -1, m = min(matrix, length), transpose2 = new Array(m); ++i < m; ) {
          for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
            row[j] = matrix[j][i];
          }
        }
        return transpose2;
      }
      function length(d) {
        return d.length;
      }
      function zip() {
        return transpose(arguments);
      }
      exports3.bisect = bisectRight;
      exports3.bisectRight = bisectRight;
      exports3.bisectLeft = bisectLeft;
      exports3.ascending = ascending;
      exports3.bisector = bisector;
      exports3.cross = cross;
      exports3.descending = descending;
      exports3.deviation = deviation;
      exports3.extent = extent;
      exports3.histogram = histogram;
      exports3.thresholdFreedmanDiaconis = freedmanDiaconis;
      exports3.thresholdScott = scott;
      exports3.thresholdSturges = sturges;
      exports3.max = max;
      exports3.mean = mean;
      exports3.median = median;
      exports3.merge = merge;
      exports3.min = min;
      exports3.pairs = pairs;
      exports3.permute = permute;
      exports3.quantile = quantile;
      exports3.range = range;
      exports3.scan = scan;
      exports3.shuffle = shuffle;
      exports3.sum = sum;
      exports3.ticks = ticks;
      exports3.tickIncrement = tickIncrement;
      exports3.tickStep = tickStep;
      exports3.transpose = transpose;
      exports3.variance = variance;
      exports3.zip = zip;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-geo/build/d3-geo.js
var require_d3_geo = __commonJS({
  "node_modules/d3-geo/build/d3-geo.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_d3_array()) : typeof define === "function" && define.amd ? define(["exports", "d3-array"], factory) : factory(global2.d3 = global2.d3 || {}, global2.d3);
    })(exports2, function(exports3, d3Array) {
      "use strict";
      var adder = function() {
        return new Adder();
      };
      function Adder() {
        this.reset();
      }
      Adder.prototype = {
        constructor: Adder,
        reset: function() {
          this.s = // rounded value
          this.t = 0;
        },
        add: function(y) {
          add(temp, y, this.t);
          add(this, temp.s, this.s);
          if (this.s) this.t += temp.t;
          else this.s = temp.t;
        },
        valueOf: function() {
          return this.s;
        }
      };
      var temp = new Adder();
      function add(adder2, a, b) {
        var x = adder2.s = a + b, bv = x - a, av = x - bv;
        adder2.t = a - av + (b - bv);
      }
      var epsilon = 1e-6;
      var epsilon2 = 1e-12;
      var pi = Math.PI;
      var halfPi = pi / 2;
      var quarterPi = pi / 4;
      var tau = pi * 2;
      var degrees = 180 / pi;
      var radians = pi / 180;
      var abs = Math.abs;
      var atan = Math.atan;
      var atan2 = Math.atan2;
      var cos = Math.cos;
      var ceil = Math.ceil;
      var exp = Math.exp;
      var log = Math.log;
      var pow = Math.pow;
      var sin = Math.sin;
      var sign = Math.sign || function(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      };
      var sqrt = Math.sqrt;
      var tan = Math.tan;
      function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
      }
      function asin(x) {
        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
      }
      function haversin(x) {
        return (x = sin(x / 2)) * x;
      }
      function noop() {
      }
      function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
          streamGeometryType[geometry.type](geometry, stream);
        }
      }
      var streamObjectType = {
        Feature: function(object2, stream) {
          streamGeometry(object2.geometry, stream);
        },
        FeatureCollection: function(object2, stream) {
          var features = object2.features, i = -1, n = features.length;
          while (++i < n) streamGeometry(features[i].geometry, stream);
        }
      };
      var streamGeometryType = {
        Sphere: function(object2, stream) {
          stream.sphere();
        },
        Point: function(object2, stream) {
          object2 = object2.coordinates;
          stream.point(object2[0], object2[1], object2[2]);
        },
        MultiPoint: function(object2, stream) {
          var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
          while (++i < n) object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
        },
        LineString: function(object2, stream) {
          streamLine(object2.coordinates, stream, 0);
        },
        MultiLineString: function(object2, stream) {
          var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
          while (++i < n) streamLine(coordinates2[i], stream, 0);
        },
        Polygon: function(object2, stream) {
          streamPolygon(object2.coordinates, stream);
        },
        MultiPolygon: function(object2, stream) {
          var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
          while (++i < n) streamPolygon(coordinates2[i], stream);
        },
        GeometryCollection: function(object2, stream) {
          var geometries = object2.geometries, i = -1, n = geometries.length;
          while (++i < n) streamGeometry(geometries[i], stream);
        }
      };
      function streamLine(coordinates2, stream, closed) {
        var i = -1, n = coordinates2.length - closed, coordinate;
        stream.lineStart();
        while (++i < n) coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
        stream.lineEnd();
      }
      function streamPolygon(coordinates2, stream) {
        var i = -1, n = coordinates2.length;
        stream.polygonStart();
        while (++i < n) streamLine(coordinates2[i], stream, 1);
        stream.polygonEnd();
      }
      var geoStream = function(object2, stream) {
        if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
          streamObjectType[object2.type](object2, stream);
        } else {
          streamGeometry(object2, stream);
        }
      };
      var areaRingSum = adder();
      var areaSum = adder();
      var lambda00;
      var phi00;
      var lambda0;
      var cosPhi0;
      var sinPhi0;
      var areaStream = {
        point: noop,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: function() {
          areaRingSum.reset();
          areaStream.lineStart = areaRingStart;
          areaStream.lineEnd = areaRingEnd;
        },
        polygonEnd: function() {
          var areaRing = +areaRingSum;
          areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
          this.lineStart = this.lineEnd = this.point = noop;
        },
        sphere: function() {
          areaSum.add(tau);
        }
      };
      function areaRingStart() {
        areaStream.point = areaPointFirst;
      }
      function areaRingEnd() {
        areaPoint(lambda00, phi00);
      }
      function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint;
        lambda00 = lambda, phi00 = phi;
        lambda *= radians, phi *= radians;
        lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
      }
      function areaPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        phi = phi / 2 + quarterPi;
        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
        areaRingSum.add(atan2(v, u));
        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
      }
      var area = function(object2) {
        areaSum.reset();
        geoStream(object2, areaStream);
        return areaSum * 2;
      };
      function spherical(cartesian2) {
        return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
      }
      function cartesian(spherical2) {
        var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
        return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
      }
      function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2];
      }
      function cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function cartesianNormalizeInPlace(d) {
        var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l, d[1] /= l, d[2] /= l;
      }
      var lambda0$1;
      var phi0;
      var lambda1;
      var phi1;
      var lambda2;
      var lambda00$1;
      var phi00$1;
      var p0;
      var deltaSum = adder();
      var ranges;
      var range$1;
      var boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function() {
          boundsStream.point = boundsRingPoint;
          boundsStream.lineStart = boundsRingStart;
          boundsStream.lineEnd = boundsRingEnd;
          deltaSum.reset();
          areaStream.polygonStart();
        },
        polygonEnd: function() {
          areaStream.polygonEnd();
          boundsStream.point = boundsPoint;
          boundsStream.lineStart = boundsLineStart;
          boundsStream.lineEnd = boundsLineEnd;
          if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
          else if (deltaSum > epsilon) phi1 = 90;
          else if (deltaSum < -epsilon) phi0 = -90;
          range$1[0] = lambda0$1, range$1[1] = lambda1;
        }
      };
      function boundsPoint(lambda, phi) {
        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
        if (phi < phi0) phi0 = phi;
        if (phi > phi1) phi1 = phi;
      }
      function linePoint(lambda, phi) {
        var p = cartesian([lambda * radians, phi * radians]);
        if (p0) {
          var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
          cartesianNormalizeInPlace(inflection);
          inflection = spherical(inflection);
          var delta = lambda - lambda2, sign$$1 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign$$1, phii, antimeridian = abs(delta) > 180;
          if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
            phii = inflection[1] * degrees;
            if (phii > phi1) phi1 = phii;
          } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
            phii = -inflection[1] * degrees;
            if (phii < phi0) phi0 = phii;
          } else {
            if (phi < phi0) phi0 = phi;
            if (phi > phi1) phi1 = phi;
          }
          if (antimeridian) {
            if (lambda < lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          } else {
            if (lambda1 >= lambda0$1) {
              if (lambda < lambda0$1) lambda0$1 = lambda;
              if (lambda > lambda1) lambda1 = lambda;
            } else {
              if (lambda > lambda2) {
                if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
              } else {
                if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
              }
            }
          }
        } else {
          ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
        }
        if (phi < phi0) phi0 = phi;
        if (phi > phi1) phi1 = phi;
        p0 = p, lambda2 = lambda;
      }
      function boundsLineStart() {
        boundsStream.point = linePoint;
      }
      function boundsLineEnd() {
        range$1[0] = lambda0$1, range$1[1] = lambda1;
        boundsStream.point = boundsPoint;
        p0 = null;
      }
      function boundsRingPoint(lambda, phi) {
        if (p0) {
          var delta = lambda - lambda2;
          deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
        } else {
          lambda00$1 = lambda, phi00$1 = phi;
        }
        areaStream.point(lambda, phi);
        linePoint(lambda, phi);
      }
      function boundsRingStart() {
        areaStream.lineStart();
      }
      function boundsRingEnd() {
        boundsRingPoint(lambda00$1, phi00$1);
        areaStream.lineEnd();
        if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
        range$1[0] = lambda0$1, range$1[1] = lambda1;
        p0 = null;
      }
      function angle(lambda02, lambda12) {
        return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
      }
      function rangeCompare(a, b) {
        return a[0] - b[0];
      }
      function rangeContains(range$$1, x) {
        return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;
      }
      var bounds = function(feature) {
        var i, n, a, b, merged, deltaMax, delta;
        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
        ranges = [];
        geoStream(feature, boundsStream);
        if (n = ranges.length) {
          ranges.sort(rangeCompare);
          for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
            b = ranges[i];
            if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
              if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
              if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
            } else {
              merged.push(a = b);
            }
          }
          for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
            b = merged[i];
            if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
          }
        }
        ranges = range$1 = null;
        return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
      };
      var W0;
      var W1;
      var X0;
      var Y0;
      var Z0;
      var X1;
      var Y1;
      var Z1;
      var X2;
      var Y2;
      var Z2;
      var lambda00$2;
      var phi00$2;
      var x0;
      var y0;
      var z0;
      var centroidStream = {
        sphere: noop,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function() {
          centroidStream.lineStart = centroidRingStart;
          centroidStream.lineEnd = centroidRingEnd;
        },
        polygonEnd: function() {
          centroidStream.lineStart = centroidLineStart;
          centroidStream.lineEnd = centroidLineEnd;
        }
      };
      function centroidPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
      }
      function centroidPointCartesian(x, y, z) {
        ++W0;
        X0 += (x - X0) / W0;
        Y0 += (y - Y0) / W0;
        Z0 += (z - Z0) / W0;
      }
      function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst;
      }
      function centroidLinePointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda);
        y0 = cosPhi * sin(lambda);
        z0 = sin(phi);
        centroidStream.point = centroidLinePoint;
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidLinePoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidLineEnd() {
        centroidStream.point = centroidPoint;
      }
      function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst;
      }
      function centroidRingEnd() {
        centroidRingPoint(lambda00$2, phi00$2);
        centroidStream.point = centroidPoint;
      }
      function centroidRingPointFirst(lambda, phi) {
        lambda00$2 = lambda, phi00$2 = phi;
        lambda *= radians, phi *= radians;
        centroidStream.point = centroidRingPoint;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda);
        y0 = cosPhi * sin(lambda);
        z0 = sin(phi);
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidRingPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), v = m && -w / m;
        X2 += v * cx;
        Y2 += v * cy;
        Z2 += v * cz;
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
      }
      var centroid = function(object2) {
        W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
        geoStream(object2, centroidStream);
        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
        if (m < epsilon2) {
          x = X1, y = Y1, z = Z1;
          if (W1 < epsilon) x = X0, y = Y0, z = Z0;
          m = x * x + y * y + z * z;
          if (m < epsilon2) return [NaN, NaN];
        }
        return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
      };
      var constant = function(x) {
        return function() {
          return x;
        };
      };
      var compose = function(a, b) {
        function compose2(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose2.invert = function(x, y) {
          return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose2;
      };
      function rotationIdentity(lambda, phi) {
        return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
      }
      rotationIdentity.invert = rotationIdentity;
      function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
      }
      function forwardRotationLambda(deltaLambda) {
        return function(lambda, phi) {
          return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
        };
      }
      function rotationLambda(deltaLambda) {
        var rotation2 = forwardRotationLambda(deltaLambda);
        rotation2.invert = forwardRotationLambda(-deltaLambda);
        return rotation2;
      }
      function rotationPhiGamma(deltaPhi, deltaGamma) {
        var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
        function rotation2(lambda, phi) {
          var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
          return [
            atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
            asin(k * cosDeltaGamma + y * sinDeltaGamma)
          ];
        }
        rotation2.invert = function(lambda, phi) {
          var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
          return [
            atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
            asin(k * cosDeltaPhi - x * sinDeltaPhi)
          ];
        };
        return rotation2;
      }
      var rotation = function(rotate) {
        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
        function forward(coordinates2) {
          coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
          return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
        }
        forward.invert = function(coordinates2) {
          coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
          return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
        };
        return forward;
      };
      function circleStream(stream, radius, delta, direction, t0, t1) {
        if (!delta) return;
        var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
        if (t0 == null) {
          t0 = radius + direction * tau;
          t1 = radius - step / 2;
        } else {
          t0 = circleRadius(cosRadius, t0);
          t1 = circleRadius(cosRadius, t1);
          if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
        }
        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
          point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
          stream.point(point[0], point[1]);
        }
      }
      function circleRadius(cosRadius, point) {
        point = cartesian(point), point[0] -= cosRadius;
        cartesianNormalizeInPlace(point);
        var radius = acos(-point[1]);
        return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
      }
      var circle = function() {
        var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point };
        function point(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= degrees, x[1] *= degrees;
        }
        function circle2() {
          var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
          ring = [];
          rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
          circleStream(stream, r, p, 1);
          c = { type: "Polygon", coordinates: [ring] };
          ring = rotate = null;
          return c;
        }
        circle2.center = function(_) {
          return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle2) : center;
        };
        circle2.radius = function(_) {
          return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle2) : radius;
        };
        circle2.precision = function(_) {
          return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle2) : precision;
        };
        return circle2;
      };
      var clipBuffer = function() {
        var lines = [], line;
        return {
          point: function(x, y) {
            line.push([x, y]);
          },
          lineStart: function() {
            lines.push(line = []);
          },
          lineEnd: noop,
          rejoin: function() {
            if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
          },
          result: function() {
            var result2 = lines;
            lines = [];
            line = null;
            return result2;
          }
        };
      };
      var clipLine = function(a, b, x02, y02, x12, y12) {
        var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
        r = x02 - ax;
        if (!dx && r > 0) return;
        r /= dx;
        if (dx < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dx > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = x12 - ax;
        if (!dx && r < 0) return;
        r /= dx;
        if (dx < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dx > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        r = y02 - ay;
        if (!dy && r > 0) return;
        r /= dy;
        if (dy < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dy > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = y12 - ay;
        if (!dy && r < 0) return;
        r /= dy;
        if (dy < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dy > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
        if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
        return true;
      };
      var pointEqual = function(a, b) {
        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
      };
      function Intersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      var clipPolygon = function(segments, compareIntersection2, startInside, interpolate2, stream) {
        var subject = [], clip2 = [], i, n;
        segments.forEach(function(segment) {
          if ((n2 = segment.length - 1) <= 0) return;
          var n2, p02 = segment[0], p1 = segment[n2], x;
          if (pointEqual(p02, p1)) {
            stream.lineStart();
            for (i = 0; i < n2; ++i) stream.point((p02 = segment[i])[0], p02[1]);
            stream.lineEnd();
            return;
          }
          subject.push(x = new Intersection(p02, segment, null, true));
          clip2.push(x.o = new Intersection(p02, null, x, false));
          subject.push(x = new Intersection(p1, segment, null, false));
          clip2.push(x.o = new Intersection(p1, null, x, true));
        });
        if (!subject.length) return;
        clip2.sort(compareIntersection2);
        link(subject);
        link(clip2);
        for (i = 0, n = clip2.length; i < n; ++i) {
          clip2[i].e = startInside = !startInside;
        }
        var start = subject[0], points, point;
        while (1) {
          var current = start, isSubject = true;
          while (current.v) if ((current = current.n) === start) return;
          points = current.z;
          stream.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
              } else {
                interpolate2(current.x, current.n.x, 1, stream);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
              } else {
                interpolate2(current.x, current.p.x, -1, stream);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          stream.lineEnd();
        }
      };
      function link(array) {
        if (!(n = array.length)) return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      var clipMax = 1e9;
      var clipMin = -clipMax;
      function clipExtent(x02, y02, x12, y12) {
        function visible(x, y) {
          return x02 <= x && x <= x12 && y02 <= y && y <= y12;
        }
        function interpolate2(from, to, direction, stream) {
          var a = 0, a1 = 0;
          if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
            do
              stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
            while ((a = (a + direction + 4) % 4) !== a1);
          } else {
            stream.point(to[0], to[1]);
          }
        }
        function corner(p, direction) {
          return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compareIntersection2(a, b) {
          return comparePoint(a.x, b.x);
        }
        function comparePoint(a, b) {
          var ca = corner(a, 1), cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
        return function(stream) {
          var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
          var clipStream = {
            point,
            lineStart,
            lineEnd,
            polygonStart,
            polygonEnd
          };
          function point(x, y) {
            if (visible(x, y)) activeStream.point(x, y);
          }
          function polygonInside() {
            var winding = 0;
            for (var i = 0, n = polygon.length; i < n; ++i) {
              for (var ring2 = polygon[i], j = 1, m = ring2.length, point2 = ring2[0], a0, a1, b0 = point2[0], b1 = point2[1]; j < m; ++j) {
                a0 = b0, a1 = b1, point2 = ring2[j], b0 = point2[0], b1 = point2[1];
                if (a1 <= y12) {
                  if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0)) ++winding;
                } else {
                  if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0)) --winding;
                }
              }
            }
            return winding;
          }
          function polygonStart() {
            activeStream = bufferStream, segments = [], polygon = [], clean = true;
          }
          function polygonEnd() {
            var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = d3Array.merge(segments)).length;
            if (cleanInside || visible2) {
              stream.polygonStart();
              if (cleanInside) {
                stream.lineStart();
                interpolate2(null, null, 1, stream);
                stream.lineEnd();
              }
              if (visible2) {
                clipPolygon(segments, compareIntersection2, startInside, interpolate2, stream);
              }
              stream.polygonEnd();
            }
            activeStream = stream, segments = polygon = ring = null;
          }
          function lineStart() {
            clipStream.point = linePoint2;
            if (polygon) polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint2(x__, y__);
              if (v__ && v_) bufferStream.rejoin();
              segments.push(bufferStream.result());
            }
            clipStream.point = point;
            if (v_) activeStream.lineEnd();
          }
          function linePoint2(x, y) {
            var v = visible(x, y);
            if (polygon) ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
              }
            } else {
              if (v && v_) activeStream.point(x, y);
              else {
                var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                if (clipLine(a, b, x02, y02, x12, y12)) {
                  if (!v_) {
                    activeStream.lineStart();
                    activeStream.point(a[0], a[1]);
                  }
                  activeStream.point(b[0], b[1]);
                  if (!v) activeStream.lineEnd();
                  clean = false;
                } else if (v) {
                  activeStream.lineStart();
                  activeStream.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clipStream;
        };
      }
      var extent = function() {
        var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
        return clip2 = {
          stream: function(stream) {
            return cache && cacheStream === stream ? cache : cache = clipExtent(x02, y02, x12, y12)(cacheStream = stream);
          },
          extent: function(_) {
            return arguments.length ? (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
          }
        };
      };
      var sum = adder();
      var polygonContains = function(polygon, point) {
        var lambda = point[0], phi = point[1], normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
        sum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
          if (!(m = (ring = polygon[i]).length)) continue;
          var ring, m, point0 = ring[m - 1], lambda02 = point0[0], phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
          for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
            var point1 = ring[j], lambda12 = point1[0], phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda02, sign$$1 = delta >= 0 ? 1 : -1, absDelta = sign$$1 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
            sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
            angle2 += antimeridian ? delta + sign$$1 * tau : delta;
            if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
              var arc = cartesianCross(cartesian(point0), cartesian(point1));
              cartesianNormalizeInPlace(arc);
              var intersection = cartesianCross(normal, arc);
              cartesianNormalizeInPlace(intersection);
              var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
              if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                winding += antimeridian ^ delta >= 0 ? 1 : -1;
              }
            }
          }
        }
        return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon) ^ winding & 1;
      };
      var lengthSum = adder();
      var lambda0$2;
      var sinPhi0$1;
      var cosPhi0$1;
      var lengthStream = {
        sphere: noop,
        point: noop,
        lineStart: lengthLineStart,
        lineEnd: noop,
        polygonStart: noop,
        polygonEnd: noop
      };
      function lengthLineStart() {
        lengthStream.point = lengthPointFirst;
        lengthStream.lineEnd = lengthLineEnd;
      }
      function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = noop;
      }
      function lengthPointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
        lengthStream.point = lengthPoint;
      }
      function lengthPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
        lengthSum.add(atan2(sqrt(x * x + y * y), z));
        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
      }
      var length = function(object2) {
        lengthSum.reset();
        geoStream(object2, lengthStream);
        return +lengthSum;
      };
      var coordinates = [null, null];
      var object = { type: "LineString", coordinates };
      var distance = function(a, b) {
        coordinates[0] = a;
        coordinates[1] = b;
        return length(object);
      };
      var containsObjectType = {
        Feature: function(object2, point) {
          return containsGeometry(object2.geometry, point);
        },
        FeatureCollection: function(object2, point) {
          var features = object2.features, i = -1, n = features.length;
          while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
          return false;
        }
      };
      var containsGeometryType = {
        Sphere: function() {
          return true;
        },
        Point: function(object2, point) {
          return containsPoint(object2.coordinates, point);
        },
        MultiPoint: function(object2, point) {
          var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
          while (++i < n) if (containsPoint(coordinates2[i], point)) return true;
          return false;
        },
        LineString: function(object2, point) {
          return containsLine(object2.coordinates, point);
        },
        MultiLineString: function(object2, point) {
          var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
          while (++i < n) if (containsLine(coordinates2[i], point)) return true;
          return false;
        },
        Polygon: function(object2, point) {
          return containsPolygon(object2.coordinates, point);
        },
        MultiPolygon: function(object2, point) {
          var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
          while (++i < n) if (containsPolygon(coordinates2[i], point)) return true;
          return false;
        },
        GeometryCollection: function(object2, point) {
          var geometries = object2.geometries, i = -1, n = geometries.length;
          while (++i < n) if (containsGeometry(geometries[i], point)) return true;
          return false;
        }
      };
      function containsGeometry(geometry, point) {
        return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
      }
      function containsPoint(coordinates2, point) {
        return distance(coordinates2, point) === 0;
      }
      function containsLine(coordinates2, point) {
        var ab = distance(coordinates2[0], coordinates2[1]), ao = distance(coordinates2[0], point), ob = distance(point, coordinates2[1]);
        return ao + ob <= ab + epsilon;
      }
      function containsPolygon(coordinates2, point) {
        return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point));
      }
      function ringRadians(ring) {
        return ring = ring.map(pointRadians), ring.pop(), ring;
      }
      function pointRadians(point) {
        return [point[0] * radians, point[1] * radians];
      }
      var contains = function(object2, point) {
        return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point);
      };
      function graticuleX(y02, y12, dy) {
        var y = d3Array.range(y02, y12 - epsilon, dy).concat(y12);
        return function(x) {
          return y.map(function(y2) {
            return [x, y2];
          });
        };
      }
      function graticuleY(x02, x12, dx) {
        var x = d3Array.range(x02, x12 - epsilon, dx).concat(x12);
        return function(y) {
          return x.map(function(x2) {
            return [x2, y];
          });
        };
      }
      function graticule() {
        var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule2() {
          return { type: "MultiLineString", coordinates: lines() };
        }
        function lines() {
          return d3Array.range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(d3Array.range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(d3Array.range(ceil(x02 / dx) * dx, x12, dx).filter(function(x2) {
            return abs(x2 % DX) > epsilon;
          }).map(x)).concat(d3Array.range(ceil(y02 / dy) * dy, y12, dy).filter(function(y2) {
            return abs(y2 % DY) > epsilon;
          }).map(y));
        }
        graticule2.lines = function() {
          return lines().map(function(coordinates2) {
            return { type: "LineString", coordinates: coordinates2 };
          });
        };
        graticule2.outline = function() {
          return {
            type: "Polygon",
            coordinates: [
              X(X02).concat(
                Y(Y12).slice(1),
                X(X12).reverse().slice(1),
                Y(Y02).reverse().slice(1)
              )
            ]
          };
        };
        graticule2.extent = function(_) {
          if (!arguments.length) return graticule2.extentMinor();
          return graticule2.extentMajor(_).extentMinor(_);
        };
        graticule2.extentMajor = function(_) {
          if (!arguments.length) return [[X02, Y02], [X12, Y12]];
          X02 = +_[0][0], X12 = +_[1][0];
          Y02 = +_[0][1], Y12 = +_[1][1];
          if (X02 > X12) _ = X02, X02 = X12, X12 = _;
          if (Y02 > Y12) _ = Y02, Y02 = Y12, Y12 = _;
          return graticule2.precision(precision);
        };
        graticule2.extentMinor = function(_) {
          if (!arguments.length) return [[x02, y02], [x12, y12]];
          x02 = +_[0][0], x12 = +_[1][0];
          y02 = +_[0][1], y12 = +_[1][1];
          if (x02 > x12) _ = x02, x02 = x12, x12 = _;
          if (y02 > y12) _ = y02, y02 = y12, y12 = _;
          return graticule2.precision(precision);
        };
        graticule2.step = function(_) {
          if (!arguments.length) return graticule2.stepMinor();
          return graticule2.stepMajor(_).stepMinor(_);
        };
        graticule2.stepMajor = function(_) {
          if (!arguments.length) return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule2;
        };
        graticule2.stepMinor = function(_) {
          if (!arguments.length) return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule2;
        };
        graticule2.precision = function(_) {
          if (!arguments.length) return precision;
          precision = +_;
          x = graticuleX(y02, y12, 90);
          y = graticuleY(x02, x12, precision);
          X = graticuleX(Y02, Y12, 90);
          Y = graticuleY(X02, X12, precision);
          return graticule2;
        };
        return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
      }
      function graticule10() {
        return graticule()();
      }
      var interpolate = function(a, b) {
        var x02 = a[0] * radians, y02 = a[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos(y02), sy0 = sin(y02), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x02), ky0 = cy0 * sin(x02), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d = 2 * asin(sqrt(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k = sin(d);
        var interpolate2 = d ? function(t) {
          var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
          return [
            atan2(y, x) * degrees,
            atan2(z, sqrt(x * x + y * y)) * degrees
          ];
        } : function() {
          return [x02 * degrees, y02 * degrees];
        };
        interpolate2.distance = d;
        return interpolate2;
      };
      var identity = function(x) {
        return x;
      };
      var areaSum$1 = adder();
      var areaRingSum$1 = adder();
      var x00;
      var y00;
      var x0$1;
      var y0$1;
      var areaStream$1 = {
        point: noop,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: function() {
          areaStream$1.lineStart = areaRingStart$1;
          areaStream$1.lineEnd = areaRingEnd$1;
        },
        polygonEnd: function() {
          areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
          areaSum$1.add(abs(areaRingSum$1));
          areaRingSum$1.reset();
        },
        result: function() {
          var area2 = areaSum$1 / 2;
          areaSum$1.reset();
          return area2;
        }
      };
      function areaRingStart$1() {
        areaStream$1.point = areaPointFirst$1;
      }
      function areaPointFirst$1(x, y) {
        areaStream$1.point = areaPoint$1;
        x00 = x0$1 = x, y00 = y0$1 = y;
      }
      function areaPoint$1(x, y) {
        areaRingSum$1.add(y0$1 * x - x0$1 * y);
        x0$1 = x, y0$1 = y;
      }
      function areaRingEnd$1() {
        areaPoint$1(x00, y00);
      }
      var x0$2 = Infinity;
      var y0$2 = x0$2;
      var x1 = -x0$2;
      var y1 = x1;
      var boundsStream$1 = {
        point: boundsPoint$1,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: noop,
        polygonEnd: noop,
        result: function() {
          var bounds2 = [[x0$2, y0$2], [x1, y1]];
          x1 = y1 = -(y0$2 = x0$2 = Infinity);
          return bounds2;
        }
      };
      function boundsPoint$1(x, y) {
        if (x < x0$2) x0$2 = x;
        if (x > x1) x1 = x;
        if (y < y0$2) y0$2 = y;
        if (y > y1) y1 = y;
      }
      var X0$1 = 0;
      var Y0$1 = 0;
      var Z0$1 = 0;
      var X1$1 = 0;
      var Y1$1 = 0;
      var Z1$1 = 0;
      var X2$1 = 0;
      var Y2$1 = 0;
      var Z2$1 = 0;
      var x00$1;
      var y00$1;
      var x0$3;
      var y0$3;
      var centroidStream$1 = {
        point: centroidPoint$1,
        lineStart: centroidLineStart$1,
        lineEnd: centroidLineEnd$1,
        polygonStart: function() {
          centroidStream$1.lineStart = centroidRingStart$1;
          centroidStream$1.lineEnd = centroidRingEnd$1;
        },
        polygonEnd: function() {
          centroidStream$1.point = centroidPoint$1;
          centroidStream$1.lineStart = centroidLineStart$1;
          centroidStream$1.lineEnd = centroidLineEnd$1;
        },
        result: function() {
          var centroid2 = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
          X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
          return centroid2;
        }
      };
      function centroidPoint$1(x, y) {
        X0$1 += x;
        Y0$1 += y;
        ++Z0$1;
      }
      function centroidLineStart$1() {
        centroidStream$1.point = centroidPointFirstLine;
      }
      function centroidPointFirstLine(x, y) {
        centroidStream$1.point = centroidPointLine;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function centroidPointLine(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function centroidLineEnd$1() {
        centroidStream$1.point = centroidPoint$1;
      }
      function centroidRingStart$1() {
        centroidStream$1.point = centroidPointFirstRing;
      }
      function centroidRingEnd$1() {
        centroidPointRing(x00$1, y00$1);
      }
      function centroidPointFirstRing(x, y) {
        centroidStream$1.point = centroidPointRing;
        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
      }
      function centroidPointRing(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        z = y0$3 * x - x0$3 * y;
        X2$1 += z * (x0$3 + x);
        Y2$1 += z * (y0$3 + y);
        Z2$1 += z * 3;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function PathContext(context) {
        this._context = context;
      }
      PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function(_) {
          return this._radius = _, this;
        },
        polygonStart: function() {
          this._line = 0;
        },
        polygonEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          if (this._line === 0) this._context.closePath();
          this._point = NaN;
        },
        point: function(x, y) {
          switch (this._point) {
            case 0: {
              this._context.moveTo(x, y);
              this._point = 1;
              break;
            }
            case 1: {
              this._context.lineTo(x, y);
              break;
            }
            default: {
              this._context.moveTo(x + this._radius, y);
              this._context.arc(x, y, this._radius, 0, tau);
              break;
            }
          }
        },
        result: noop
      };
      var lengthSum$1 = adder();
      var lengthRing;
      var x00$2;
      var y00$2;
      var x0$4;
      var y0$4;
      var lengthStream$1 = {
        point: noop,
        lineStart: function() {
          lengthStream$1.point = lengthPointFirst$1;
        },
        lineEnd: function() {
          if (lengthRing) lengthPoint$1(x00$2, y00$2);
          lengthStream$1.point = noop;
        },
        polygonStart: function() {
          lengthRing = true;
        },
        polygonEnd: function() {
          lengthRing = null;
        },
        result: function() {
          var length2 = +lengthSum$1;
          lengthSum$1.reset();
          return length2;
        }
      };
      function lengthPointFirst$1(x, y) {
        lengthStream$1.point = lengthPoint$1;
        x00$2 = x0$4 = x, y00$2 = y0$4 = y;
      }
      function lengthPoint$1(x, y) {
        x0$4 -= x, y0$4 -= y;
        lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
        x0$4 = x, y0$4 = y;
      }
      function PathString() {
        this._string = [];
      }
      PathString.prototype = {
        _radius: 4.5,
        _circle: circle$1(4.5),
        pointRadius: function(_) {
          if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
          return this;
        },
        polygonStart: function() {
          this._line = 0;
        },
        polygonEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          if (this._line === 0) this._string.push("Z");
          this._point = NaN;
        },
        point: function(x, y) {
          switch (this._point) {
            case 0: {
              this._string.push("M", x, ",", y);
              this._point = 1;
              break;
            }
            case 1: {
              this._string.push("L", x, ",", y);
              break;
            }
            default: {
              if (this._circle == null) this._circle = circle$1(this._radius);
              this._string.push("M", x, ",", y, this._circle);
              break;
            }
          }
        },
        result: function() {
          if (this._string.length) {
            var result2 = this._string.join("");
            this._string = [];
            return result2;
          } else {
            return null;
          }
        }
      };
      function circle$1(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var index = function(projection2, context) {
        var pointRadius = 4.5, projectionStream, contextStream;
        function path(object2) {
          if (object2) {
            if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
            geoStream(object2, projectionStream(contextStream));
          }
          return contextStream.result();
        }
        path.area = function(object2) {
          geoStream(object2, projectionStream(areaStream$1));
          return areaStream$1.result();
        };
        path.measure = function(object2) {
          geoStream(object2, projectionStream(lengthStream$1));
          return lengthStream$1.result();
        };
        path.bounds = function(object2) {
          geoStream(object2, projectionStream(boundsStream$1));
          return boundsStream$1.result();
        };
        path.centroid = function(object2) {
          geoStream(object2, projectionStream(centroidStream$1));
          return centroidStream$1.result();
        };
        path.projection = function(_) {
          return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity) : (projection2 = _).stream, path) : projection2;
        };
        path.context = function(_) {
          if (!arguments.length) return context;
          contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
          if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
          return path;
        };
        path.pointRadius = function(_) {
          if (!arguments.length) return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        return path.projection(projection2).context(context);
      };
      var clip = function(pointVisible, clipLine2, interpolate2, start) {
        return function(rotate, sink) {
          var line = clipLine2(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
          var clip2 = {
            point,
            lineStart,
            lineEnd,
            polygonStart: function() {
              clip2.point = pointRing;
              clip2.lineStart = ringStart;
              clip2.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function() {
              clip2.point = point;
              clip2.lineStart = lineStart;
              clip2.lineEnd = lineEnd;
              segments = d3Array.merge(segments);
              var startInside = polygonContains(polygon, rotatedStart);
              if (segments.length) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                clipPolygon(segments, compareIntersection, startInside, interpolate2, sink);
              } else if (startInside) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                sink.lineStart();
                interpolate2(null, null, 1, sink);
                sink.lineEnd();
              }
              if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function() {
              sink.polygonStart();
              sink.lineStart();
              interpolate2(null, null, 1, sink);
              sink.lineEnd();
              sink.polygonEnd();
            }
          };
          function point(lambda, phi) {
            var point2 = rotate(lambda, phi);
            if (pointVisible(lambda = point2[0], phi = point2[1])) sink.point(lambda, phi);
          }
          function pointLine(lambda, phi) {
            var point2 = rotate(lambda, phi);
            line.point(point2[0], point2[1]);
          }
          function lineStart() {
            clip2.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip2.point = point;
            line.lineEnd();
          }
          function pointRing(lambda, phi) {
            ring.push([lambda, phi]);
            var point2 = rotate(lambda, phi);
            ringSink.point(point2[0], point2[1]);
          }
          function ringStart() {
            ringSink.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringSink.lineEnd();
            var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point2;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n) return;
            if (clean & 1) {
              segment = ringSegments[0];
              if ((m = segment.length - 1) > 0) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                sink.lineStart();
                for (i = 0; i < m; ++i) sink.point((point2 = segment[i])[0], point2[1]);
                sink.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(validSegment));
          }
          return clip2;
        };
      };
      function validSegment(segment) {
        return segment.length > 1;
      }
      function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
      }
      var clipAntimeridian = clip(
        function() {
          return true;
        },
        clipAntimeridianLine,
        clipAntimeridianInterpolate,
        [-pi, -halfPi]
      );
      function clipAntimeridianLine(stream) {
        var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
        return {
          lineStart: function() {
            stream.lineStart();
            clean = 1;
          },
          point: function(lambda12, phi12) {
            var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda02);
            if (abs(delta - pi) < epsilon) {
              stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
              stream.point(sign0, phi02);
              stream.lineEnd();
              stream.lineStart();
              stream.point(sign1, phi02);
              stream.point(lambda12, phi02);
              clean = 0;
            } else if (sign0 !== sign1 && delta >= pi) {
              if (abs(lambda02 - sign0) < epsilon) lambda02 -= sign0 * epsilon;
              if (abs(lambda12 - sign1) < epsilon) lambda12 -= sign1 * epsilon;
              phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
              stream.point(sign0, phi02);
              stream.lineEnd();
              stream.lineStart();
              stream.point(sign1, phi02);
              clean = 0;
            }
            stream.point(lambda02 = lambda12, phi02 = phi12);
            sign0 = sign1;
          },
          lineEnd: function() {
            stream.lineEnd();
            lambda02 = phi02 = NaN;
          },
          clean: function() {
            return 2 - clean;
          }
        };
      }
      function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
        var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda02 - lambda12);
        return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
      }
      function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi;
        if (from == null) {
          phi = direction * halfPi;
          stream.point(-pi, phi);
          stream.point(0, phi);
          stream.point(pi, phi);
          stream.point(pi, 0);
          stream.point(pi, -phi);
          stream.point(0, -phi);
          stream.point(-pi, -phi);
          stream.point(-pi, 0);
          stream.point(-pi, phi);
        } else if (abs(from[0] - to[0]) > epsilon) {
          var lambda = from[0] < to[0] ? pi : -pi;
          phi = direction * lambda / 2;
          stream.point(-lambda, phi);
          stream.point(0, phi);
          stream.point(lambda, phi);
        } else {
          stream.point(to[0], to[1]);
        }
      }
      var clipCircle = function(radius, delta) {
        var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
        function interpolate2(from, to, direction, stream) {
          circleStream(stream, radius, delta, direction, from, to);
        }
        function visible(lambda, phi) {
          return cos(lambda) * cos(phi) > cr;
        }
        function clipLine2(stream) {
          var point0, c0, v0, v00, clean;
          return {
            lineStart: function() {
              v00 = v0 = false;
              clean = 1;
            },
            point: function(lambda, phi) {
              var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
              if (!point0 && (v00 = v0 = v)) stream.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
                  point1[0] += epsilon;
                  point1[1] += epsilon;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  stream.lineStart();
                  point2 = intersect(point1, point0);
                  stream.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  stream.point(point2[0], point2[1]);
                  stream.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    stream.lineStart();
                    stream.point(t[0][0], t[0][1]);
                    stream.point(t[1][0], t[1][1]);
                    stream.lineEnd();
                  } else {
                    stream.point(t[1][0], t[1][1]);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !pointEqual(point0, point1))) {
                stream.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function() {
              if (v0) stream.lineEnd();
              point0 = null;
            },
            // Rejoin first and last segments if there were intersections and the first
            // and last points were visible.
            clean: function() {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = cartesian(a), pb = cartesian(b);
          var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
          if (!determinant) return !two && a;
          var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
          cartesianAddInPlace(A, B);
          var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
          if (t2 < 0) return;
          var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
          cartesianAddInPlace(q, A);
          q = spherical(q);
          if (!two) return q;
          var lambda02 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
          if (lambda12 < lambda02) z = lambda02, lambda02 = lambda12, lambda12 = z;
          var delta2 = lambda12 - lambda02, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
          if (!polar && phi12 < phi02) z = phi02, phi02 = phi12, phi12 = z;
          if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda02) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
            var q1 = cartesianScale(u, (-w + t) / uu);
            cartesianAddInPlace(q1, A);
            return [q, spherical(q1)];
          }
        }
        function code(lambda, phi) {
          var r = smallRadius ? radius : pi - radius, code2 = 0;
          if (lambda < -r) code2 |= 1;
          else if (lambda > r) code2 |= 2;
          if (phi < -r) code2 |= 4;
          else if (phi > r) code2 |= 8;
          return code2;
        }
        return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
      };
      var transform = function(methods) {
        return {
          stream: transformer(methods)
        };
      };
      function transformer(methods) {
        return function(stream) {
          var s = new TransformStream();
          for (var key in methods) s[key] = methods[key];
          s.stream = stream;
          return s;
        };
      }
      function TransformStream() {
      }
      TransformStream.prototype = {
        constructor: TransformStream,
        point: function(x, y) {
          this.stream.point(x, y);
        },
        sphere: function() {
          this.stream.sphere();
        },
        lineStart: function() {
          this.stream.lineStart();
        },
        lineEnd: function() {
          this.stream.lineEnd();
        },
        polygonStart: function() {
          this.stream.polygonStart();
        },
        polygonEnd: function() {
          this.stream.polygonEnd();
        }
      };
      function fitExtent(projection2, extent2, object2) {
        var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], clip2 = projection2.clipExtent && projection2.clipExtent();
        projection2.scale(150).translate([0, 0]);
        if (clip2 != null) projection2.clipExtent(null);
        geoStream(object2, projection2.stream(boundsStream$1));
        var b = boundsStream$1.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        if (clip2 != null) projection2.clipExtent(clip2);
        return projection2.scale(k * 150).translate([x, y]);
      }
      function fitSize(projection2, size, object2) {
        return fitExtent(projection2, [[0, 0], size], object2);
      }
      var maxDepth = 16;
      var cosMinDistance = cos(30 * radians);
      var resample = function(project, delta2) {
        return +delta2 ? resample$1(project, delta2) : resampleNone(project);
      };
      function resampleNone(project) {
        return transformer({
          point: function(x, y) {
            x = project(x, y);
            this.stream.point(x[0], x[1]);
          }
        });
      }
      function resample$1(project, delta2) {
        function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
          var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
          if (d2 > 4 * delta2 && depth--) {
            var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda22 = abs(abs(c) - 1) < epsilon || abs(lambda02 - lambda12) < epsilon ? (lambda02 + lambda12) / 2 : atan2(b, a), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, lambda22, a, b, c, x12, y12, lambda12, a1, b1, c1, depth, stream);
            }
          }
        }
        return function(stream) {
          var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
          var resampleStream = {
            point,
            lineStart,
            lineEnd,
            polygonStart: function() {
              stream.polygonStart();
              resampleStream.lineStart = ringStart;
            },
            polygonEnd: function() {
              stream.polygonEnd();
              resampleStream.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x02 = NaN;
            resampleStream.point = linePoint2;
            stream.lineStart();
          }
          function linePoint2(lambda, phi) {
            var c = cartesian([lambda, phi]), p = project(lambda, phi);
            resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x02, y02);
          }
          function lineEnd() {
            resampleStream.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resampleStream.point = ringPoint;
            resampleStream.lineEnd = ringEnd;
          }
          function ringPoint(lambda, phi) {
            linePoint2(lambda002 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
            resampleStream.point = linePoint2;
          }
          function ringEnd() {
            resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
            resampleStream.lineEnd = lineEnd;
            lineEnd();
          }
          return resampleStream;
        };
      }
      var transformRadians = transformer({
        point: function(x, y) {
          this.stream.point(x * radians, y * radians);
        }
      });
      function projection(project) {
        return projectionMutator(function() {
          return project;
        })();
      }
      function projectionMutator(projectAt) {
        var project, k = 150, x = 480, y = 250, dx, dy, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample = resample(projectTransform, delta2), cache, cacheStream;
        function projection2(point) {
          point = projectRotate(point[0] * radians, point[1] * radians);
          return [point[0] * k + dx, dy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
          return point && [point[0] * degrees, point[1] * degrees];
        }
        function projectTransform(x2, y2) {
          return x2 = project(x2, y2), [x2[0] * k + dx, dy - x2[1] * k];
        }
        projection2.stream = function(stream) {
          return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
        };
        projection2.clipAngle = function(_) {
          return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
        };
        projection2.clipExtent = function(_) {
          return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
        };
        projection2.scale = function(_) {
          return arguments.length ? (k = +_, recenter()) : k;
        };
        projection2.translate = function(_) {
          return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
        };
        projection2.center = function(_) {
          return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
        };
        projection2.rotate = function(_) {
          return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
        };
        projection2.precision = function(_) {
          return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
        };
        projection2.fitExtent = function(extent$$1, object2) {
          return fitExtent(projection2, extent$$1, object2);
        };
        projection2.fitSize = function(size, object2) {
          return fitSize(projection2, size, object2);
        };
        function recenter() {
          projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
          var center = project(lambda, phi);
          dx = x - center[0] * k;
          dy = y + center[1] * k;
          return reset();
        }
        function reset() {
          cache = cacheStream = null;
          return projection2;
        }
        return function() {
          project = projectAt.apply(this, arguments);
          projection2.invert = project.invert && invert;
          return recenter();
        };
      }
      function conicProjection(projectAt) {
        var phi02 = 0, phi12 = pi / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
        p.parallels = function(_) {
          return arguments.length ? m(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
        };
        return p;
      }
      function cylindricalEqualAreaRaw(phi02) {
        var cosPhi02 = cos(phi02);
        function forward(lambda, phi) {
          return [lambda * cosPhi02, sin(phi) / cosPhi02];
        }
        forward.invert = function(x, y) {
          return [x / cosPhi02, asin(y * cosPhi02)];
        };
        return forward;
      }
      function conicEqualAreaRaw(y02, y12) {
        var sy0 = sin(y02), n = (sy0 + sin(y12)) / 2;
        if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y02);
        var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
        function project(x, y) {
          var r = sqrt(c - 2 * n * sin(y)) / n;
          return [r * sin(x *= n), r0 - r * cos(x)];
        }
        project.invert = function(x, y) {
          var r0y = r0 - y;
          return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
        };
        return project;
      }
      var conicEqualArea = function() {
        return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
      };
      var albers = function() {
        return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
      };
      function multiplex(streams) {
        var n = streams.length;
        return {
          point: function(x, y) {
            var i = -1;
            while (++i < n) streams[i].point(x, y);
          },
          sphere: function() {
            var i = -1;
            while (++i < n) streams[i].sphere();
          },
          lineStart: function() {
            var i = -1;
            while (++i < n) streams[i].lineStart();
          },
          lineEnd: function() {
            var i = -1;
            while (++i < n) streams[i].lineEnd();
          },
          polygonStart: function() {
            var i = -1;
            while (++i < n) streams[i].polygonStart();
          },
          polygonEnd: function() {
            var i = -1;
            while (++i < n) streams[i].polygonEnd();
          }
        };
      }
      var albersUsa = function() {
        var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point, pointStream = { point: function(x, y) {
          point = [x, y];
        } };
        function albersUsa2(coordinates2) {
          var x = coordinates2[0], y = coordinates2[1];
          return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
        }
        albersUsa2.invert = function(coordinates2) {
          var k = lower48.scale(), t = lower48.translate(), x = (coordinates2[0] - t[0]) / k, y = (coordinates2[1] - t[1]) / k;
          return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates2);
        };
        albersUsa2.stream = function(stream) {
          return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
        };
        albersUsa2.precision = function(_) {
          if (!arguments.length) return lower48.precision();
          lower48.precision(_), alaska.precision(_), hawaii.precision(_);
          return reset();
        };
        albersUsa2.scale = function(_) {
          if (!arguments.length) return lower48.scale();
          lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
          return albersUsa2.translate(lower48.translate());
        };
        albersUsa2.translate = function(_) {
          if (!arguments.length) return lower48.translate();
          var k = lower48.scale(), x = +_[0], y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
          alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
          hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
          return reset();
        };
        albersUsa2.fitExtent = function(extent2, object2) {
          return fitExtent(albersUsa2, extent2, object2);
        };
        albersUsa2.fitSize = function(size, object2) {
          return fitSize(albersUsa2, size, object2);
        };
        function reset() {
          cache = cacheStream = null;
          return albersUsa2;
        }
        return albersUsa2.scale(1070);
      };
      function azimuthalRaw(scale) {
        return function(x, y) {
          var cx = cos(x), cy = cos(y), k = scale(cx * cy);
          return [
            k * cy * sin(x),
            k * sin(y)
          ];
        };
      }
      function azimuthalInvert(angle2) {
        return function(x, y) {
          var z = sqrt(x * x + y * y), c = angle2(z), sc = sin(c), cc = cos(c);
          return [
            atan2(x * sc, z * cc),
            asin(z && y * sc / z)
          ];
        };
      }
      var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
        return sqrt(2 / (1 + cxcy));
      });
      azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
        return 2 * asin(z / 2);
      });
      var azimuthalEqualArea = function() {
        return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
      };
      var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
        return (c = acos(c)) && c / sin(c);
      });
      azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
        return z;
      });
      var azimuthalEquidistant = function() {
        return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
      };
      function mercatorRaw(lambda, phi) {
        return [lambda, log(tan((halfPi + phi) / 2))];
      }
      mercatorRaw.invert = function(x, y) {
        return [x, 2 * atan(exp(y)) - halfPi];
      };
      var mercator = function() {
        return mercatorProjection(mercatorRaw).scale(961 / tau);
      };
      function mercatorProjection(project) {
        var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent2 = m.clipExtent, x02 = null, y02, x12, y12;
        m.scale = function(_) {
          return arguments.length ? (scale(_), reclip()) : scale();
        };
        m.translate = function(_) {
          return arguments.length ? (translate(_), reclip()) : translate();
        };
        m.center = function(_) {
          return arguments.length ? (center(_), reclip()) : center();
        };
        m.clipExtent = function(_) {
          return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
        };
        function reclip() {
          var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
          return clipExtent2(x02 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x02), y02], [Math.min(t[0] + k, x12), y12]] : [[x02, Math.max(t[1] - k, y02)], [x12, Math.min(t[1] + k, y12)]]);
        }
        return reclip();
      }
      function tany(y) {
        return tan((halfPi + y) / 2);
      }
      function conicConformalRaw(y02, y12) {
        var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y02)), f = cy0 * pow(tany(y02), n) / n;
        if (!n) return mercatorRaw;
        function project(x, y) {
          if (f > 0) {
            if (y < -halfPi + epsilon) y = -halfPi + epsilon;
          } else {
            if (y > halfPi - epsilon) y = halfPi - epsilon;
          }
          var r = f / pow(tany(y), n);
          return [r * sin(n * x), f - r * cos(n * x)];
        }
        project.invert = function(x, y) {
          var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
          return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
        };
        return project;
      }
      var conicConformal = function() {
        return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
      };
      function equirectangularRaw(lambda, phi) {
        return [lambda, phi];
      }
      equirectangularRaw.invert = equirectangularRaw;
      var equirectangular = function() {
        return projection(equirectangularRaw).scale(152.63);
      };
      function conicEquidistantRaw(y02, y12) {
        var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : (cy0 - cos(y12)) / (y12 - y02), g = cy0 / n + y02;
        if (abs(n) < epsilon) return equirectangularRaw;
        function project(x, y) {
          var gy = g - y, nx = n * x;
          return [gy * sin(nx), g - gy * cos(nx)];
        }
        project.invert = function(x, y) {
          var gy = g - y;
          return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
        };
        return project;
      }
      var conicEquidistant = function() {
        return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
      };
      function gnomonicRaw(x, y) {
        var cy = cos(y), k = cos(x) * cy;
        return [cy * sin(x) / k, sin(y) / k];
      }
      gnomonicRaw.invert = azimuthalInvert(atan);
      var gnomonic = function() {
        return projection(gnomonicRaw).scale(144.049).clipAngle(60);
      };
      function scaleTranslate(kx, ky, tx, ty) {
        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
          point: function(x, y) {
            this.stream.point(x * kx + tx, y * ky + ty);
          }
        });
      }
      var identity$1 = function() {
        var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity, x02 = null, y02, x12, y12, clip2 = identity, cache, cacheStream, projection2;
        function reset() {
          cache = cacheStream = null;
          return projection2;
        }
        return projection2 = {
          stream: function(stream) {
            return cache && cacheStream === stream ? cache : cache = transform$$1(clip2(cacheStream = stream));
          },
          clipExtent: function(_) {
            return arguments.length ? (clip2 = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
          },
          scale: function(_) {
            return arguments.length ? (transform$$1 = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
          },
          translate: function(_) {
            return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
          },
          reflectX: function(_) {
            return arguments.length ? (transform$$1 = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
          },
          reflectY: function(_) {
            return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
          },
          fitExtent: function(extent$$1, object2) {
            return fitExtent(projection2, extent$$1, object2);
          },
          fitSize: function(size, object2) {
            return fitSize(projection2, size, object2);
          }
        };
      };
      function naturalEarth1Raw(lambda, phi) {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        return [
          lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
          phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
        ];
      }
      naturalEarth1Raw.invert = function(x, y) {
        var phi = y, i = 25, delta;
        do {
          var phi2 = phi * phi, phi4 = phi2 * phi2;
          phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
        } while (abs(delta) > epsilon && --i > 0);
        return [
          x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
          phi
        ];
      };
      var naturalEarth1 = function() {
        return projection(naturalEarth1Raw).scale(175.295);
      };
      function orthographicRaw(x, y) {
        return [cos(y) * sin(x), sin(y)];
      }
      orthographicRaw.invert = azimuthalInvert(asin);
      var orthographic = function() {
        return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
      };
      function stereographicRaw(x, y) {
        var cy = cos(y), k = 1 + cos(x) * cy;
        return [cy * sin(x) / k, sin(y) / k];
      }
      stereographicRaw.invert = azimuthalInvert(function(z) {
        return 2 * atan(z);
      });
      var stereographic = function() {
        return projection(stereographicRaw).scale(250).clipAngle(142);
      };
      function transverseMercatorRaw(lambda, phi) {
        return [log(tan((halfPi + phi) / 2)), -lambda];
      }
      transverseMercatorRaw.invert = function(x, y) {
        return [-y, 2 * atan(exp(x)) - halfPi];
      };
      var transverseMercator = function() {
        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
        m.center = function(_) {
          return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        m.rotate = function(_) {
          return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]).scale(159.155);
      };
      exports3.geoArea = area;
      exports3.geoBounds = bounds;
      exports3.geoCentroid = centroid;
      exports3.geoCircle = circle;
      exports3.geoClipExtent = extent;
      exports3.geoContains = contains;
      exports3.geoDistance = distance;
      exports3.geoGraticule = graticule;
      exports3.geoGraticule10 = graticule10;
      exports3.geoInterpolate = interpolate;
      exports3.geoLength = length;
      exports3.geoPath = index;
      exports3.geoAlbers = albers;
      exports3.geoAlbersUsa = albersUsa;
      exports3.geoAzimuthalEqualArea = azimuthalEqualArea;
      exports3.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
      exports3.geoAzimuthalEquidistant = azimuthalEquidistant;
      exports3.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
      exports3.geoConicConformal = conicConformal;
      exports3.geoConicConformalRaw = conicConformalRaw;
      exports3.geoConicEqualArea = conicEqualArea;
      exports3.geoConicEqualAreaRaw = conicEqualAreaRaw;
      exports3.geoConicEquidistant = conicEquidistant;
      exports3.geoConicEquidistantRaw = conicEquidistantRaw;
      exports3.geoEquirectangular = equirectangular;
      exports3.geoEquirectangularRaw = equirectangularRaw;
      exports3.geoGnomonic = gnomonic;
      exports3.geoGnomonicRaw = gnomonicRaw;
      exports3.geoIdentity = identity$1;
      exports3.geoProjection = projection;
      exports3.geoProjectionMutator = projectionMutator;
      exports3.geoMercator = mercator;
      exports3.geoMercatorRaw = mercatorRaw;
      exports3.geoNaturalEarth1 = naturalEarth1;
      exports3.geoNaturalEarth1Raw = naturalEarth1Raw;
      exports3.geoOrthographic = orthographic;
      exports3.geoOrthographicRaw = orthographicRaw;
      exports3.geoStereographic = stereographic;
      exports3.geoStereographicRaw = stereographicRaw;
      exports3.geoTransverseMercator = transverseMercator;
      exports3.geoTransverseMercatorRaw = transverseMercatorRaw;
      exports3.geoRotation = rotation;
      exports3.geoStream = geoStream;
      exports3.geoTransform = transform;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@turf/buffer/dist/js/index.js
var require_js97 = __commonJS({
  "node_modules/@turf/buffer/dist/js/index.js"(exports2, module2) {
    "use strict";
    var center = require_js27();
    var turfJsts = require_jsts();
    var meta = require_js2();
    var d3Geo = require_d3_geo();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var center__default = /* @__PURE__ */ _interopDefaultLegacy(center);
    function buffer(geojson, radius, options) {
      options = options || {};
      var units = options.units || "kilometers";
      var steps = options.steps || 8;
      if (!geojson) throw new Error("geojson is required");
      if (typeof options !== "object") throw new Error("options must be an object");
      if (typeof steps !== "number") throw new Error("steps must be an number");
      if (radius === void 0) throw new Error("radius is required");
      if (steps <= 0) throw new Error("steps must be greater than 0");
      var results = [];
      switch (geojson.type) {
        case "GeometryCollection":
          meta.geomEach(geojson, function(geometry) {
            var buffered = bufferFeature(geometry, radius, units, steps);
            if (buffered) results.push(buffered);
          });
          return helpers.featureCollection(results);
        case "FeatureCollection":
          meta.featureEach(geojson, function(feature) {
            var multiBuffered = bufferFeature(feature, radius, units, steps);
            if (multiBuffered) {
              meta.featureEach(multiBuffered, function(buffered) {
                if (buffered) results.push(buffered);
              });
            }
          });
          return helpers.featureCollection(results);
      }
      return bufferFeature(geojson, radius, units, steps);
    }
    function bufferFeature(geojson, radius, units, steps) {
      var properties = geojson.properties || {};
      var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;
      if (geometry.type === "GeometryCollection") {
        var results = [];
        meta.geomEach(geojson, function(geometry2) {
          var buffered2 = bufferFeature(geometry2, radius, units, steps);
          if (buffered2) results.push(buffered2);
        });
        return helpers.featureCollection(results);
      }
      var projection = defineProjection(geometry);
      var projected = {
        type: geometry.type,
        coordinates: projectCoords(geometry.coordinates, projection)
      };
      var reader = new turfJsts.GeoJSONReader();
      var geom = reader.read(projected);
      var distance = helpers.radiansToLength(helpers.lengthToRadians(radius, units), "meters");
      var buffered = turfJsts.BufferOp.bufferOp(geom, distance, steps);
      var writer = new turfJsts.GeoJSONWriter();
      buffered = writer.write(buffered);
      if (coordsIsNaN(buffered.coordinates)) return void 0;
      var result2 = {
        type: buffered.type,
        coordinates: unprojectCoords(buffered.coordinates, projection)
      };
      return helpers.feature(result2, properties);
    }
    function coordsIsNaN(coords) {
      if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
      return isNaN(coords[0]);
    }
    function projectCoords(coords, proj) {
      if (typeof coords[0] !== "object") return proj(coords);
      return coords.map(function(coord) {
        return projectCoords(coord, proj);
      });
    }
    function unprojectCoords(coords, proj) {
      if (typeof coords[0] !== "object") return proj.invert(coords);
      return coords.map(function(coord) {
        return unprojectCoords(coord, proj);
      });
    }
    function defineProjection(geojson) {
      var coords = center__default["default"](geojson).geometry.coordinates;
      var rotation = [-coords[0], -coords[1]];
      return d3Geo.geoAzimuthalEquidistant().rotate(rotation).scale(helpers.earthRadius);
    }
    module2.exports = buffer;
    module2.exports.default = buffer;
  }
});

// node_modules/@turf/union/dist/js/index.js
var require_js98 = __commonJS({
  "node_modules/@turf/union/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var polygon_clipping_1 = __importDefault(require_polygon_clipping_cjs());
    var invariant_1 = require_js4();
    var helpers_1 = require_js();
    function union(poly1, poly2, options) {
      if (options === void 0) {
        options = {};
      }
      var geom1 = invariant_1.getGeom(poly1);
      var geom2 = invariant_1.getGeom(poly2);
      var unioned = polygon_clipping_1.default.union(geom1.coordinates, geom2.coordinates);
      if (unioned.length === 0)
        return null;
      if (unioned.length === 1)
        return helpers_1.polygon(unioned[0], options.properties);
      else
        return helpers_1.multiPolygon(unioned, options.properties);
    }
    exports2.default = union;
  }
});

// node_modules/@turf/intersect/dist/js/index.js
var require_js99 = __commonJS({
  "node_modules/@turf/intersect/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var polygon_clipping_1 = __importDefault(require_polygon_clipping_cjs());
    function intersect(poly1, poly2, options) {
      if (options === void 0) {
        options = {};
      }
      var geom1 = invariant_1.getGeom(poly1);
      var geom2 = invariant_1.getGeom(poly2);
      var intersection = polygon_clipping_1.default.intersection(geom1.coordinates, geom2.coordinates);
      if (intersection.length === 0)
        return null;
      if (intersection.length === 1)
        return helpers_1.polygon(intersection[0], options.properties);
      return helpers_1.multiPolygon(intersection, options.properties);
    }
    exports2.default = intersect;
  }
});

// node_modules/@turf/dissolve/dist/js/index.js
var require_js100 = __commonJS({
  "node_modules/@turf/dissolve/dist/js/index.js"(exports2, module2) {
    "use strict";
    var helpers = require_js();
    var invariant = require_js4();
    var meta = require_js2();
    var flatten = require_js52();
    var polygonClipping = require_polygon_clipping_cjs();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var flatten__default = /* @__PURE__ */ _interopDefaultLegacy(flatten);
    var polygonClipping__default = /* @__PURE__ */ _interopDefaultLegacy(polygonClipping);
    function dissolve(fc, options) {
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var propertyName = options.propertyName;
      invariant.collectionOf(fc, "Polygon", "dissolve");
      var outFeatures = [];
      if (!options.propertyName) {
        return flatten__default["default"](
          helpers.multiPolygon(
            polygonClipping__default["default"].union.apply(
              null,
              fc.features.map(function(f) {
                return f.geometry.coordinates;
              })
            )
          )
        );
      } else {
        var uniquePropertyVals = {};
        meta.featureEach(fc, function(feature) {
          if (!Object.prototype.hasOwnProperty.call(
            uniquePropertyVals,
            feature.properties[propertyName]
          )) {
            uniquePropertyVals[feature.properties[propertyName]] = [];
          }
          uniquePropertyVals[feature.properties[propertyName]].push(feature);
        });
        var vals = Object.keys(uniquePropertyVals);
        for (var i = 0; i < vals.length; i++) {
          var mp = helpers.multiPolygon(
            polygonClipping__default["default"].union.apply(
              null,
              uniquePropertyVals[vals[i]].map(function(f) {
                return f.geometry.coordinates;
              })
            )
          );
          mp.properties[propertyName] = vals[i];
          outFeatures.push(mp);
        }
      }
      return flatten__default["default"](helpers.featureCollection(outFeatures));
    }
    module2.exports = dissolve;
    module2.exports.default = dissolve;
  }
});

// node_modules/@turf/hex-grid/dist/js/index.js
var require_js101 = __commonJS({
  "node_modules/@turf/hex-grid/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var distance_1 = __importDefault(require_js9());
    var intersect_1 = __importDefault(require_js99());
    var helpers_1 = require_js();
    function hexGrid(bbox, cellSide, options) {
      if (options === void 0) {
        options = {};
      }
      var clonedProperties = JSON.stringify(options.properties || {});
      var west = bbox[0], south = bbox[1], east = bbox[2], north = bbox[3];
      var centerY = (south + north) / 2;
      var centerX = (west + east) / 2;
      var xFraction = cellSide * 2 / distance_1.default([west, centerY], [east, centerY], options);
      var cellWidth = xFraction * (east - west);
      var yFraction = cellSide * 2 / distance_1.default([centerX, south], [centerX, north], options);
      var cellHeight = yFraction * (north - south);
      var radius = cellWidth / 2;
      var hex_width = radius * 2;
      var hex_height = Math.sqrt(3) / 2 * cellHeight;
      var box_width = east - west;
      var box_height = north - south;
      var x_interval = 3 / 4 * hex_width;
      var y_interval = hex_height;
      var x_span = (box_width - hex_width) / (hex_width - radius / 2);
      var x_count = Math.floor(x_span);
      var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;
      var y_count = Math.floor((box_height - hex_height) / hex_height);
      var y_adjust = (box_height - y_count * hex_height) / 2;
      var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
      if (hasOffsetY) {
        y_adjust -= hex_height / 4;
      }
      var cosines = [];
      var sines = [];
      for (var i = 0; i < 6; i++) {
        var angle = 2 * Math.PI / 6 * i;
        cosines.push(Math.cos(angle));
        sines.push(Math.sin(angle));
      }
      var results = [];
      for (var x = 0; x <= x_count; x++) {
        for (var y = 0; y <= y_count; y++) {
          var isOdd = x % 2 === 1;
          if (y === 0 && isOdd)
            continue;
          if (y === 0 && hasOffsetY)
            continue;
          var center_x = x * x_interval + west - x_adjust;
          var center_y = y * y_interval + south + y_adjust;
          if (isOdd) {
            center_y -= hex_height / 2;
          }
          if (options.triangles === true) {
            hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function(triangle) {
              if (options.mask) {
                if (intersect_1.default(options.mask, triangle))
                  results.push(triangle);
              } else {
                results.push(triangle);
              }
            });
          } else {
            var hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
            if (options.mask) {
              if (intersect_1.default(options.mask, hex))
                results.push(hex);
            } else {
              results.push(hex);
            }
          }
        }
      }
      return helpers_1.featureCollection(results);
    }
    function hexagon(center, rx, ry, properties, cosines, sines) {
      var vertices = [];
      for (var i = 0; i < 6; i++) {
        var x = center[0] + rx * cosines[i];
        var y = center[1] + ry * sines[i];
        vertices.push([x, y]);
      }
      vertices.push(vertices[0].slice());
      return helpers_1.polygon([vertices], properties);
    }
    function hexTriangles(center, rx, ry, properties, cosines, sines) {
      var triangles = [];
      for (var i = 0; i < 6; i++) {
        var vertices = [];
        vertices.push(center);
        vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);
        vertices.push([
          center[0] + rx * cosines[(i + 1) % 6],
          center[1] + ry * sines[(i + 1) % 6]
        ]);
        vertices.push(center);
        triangles.push(helpers_1.polygon([vertices], properties));
      }
      return triangles;
    }
    exports2.default = hexGrid;
  }
});

// node_modules/@turf/mask/dist/js/index.js
var require_js102 = __commonJS({
  "node_modules/@turf/mask/dist/js/index.js"(exports2, module2) {
    "use strict";
    var helpers = require_js();
    var polygonClipping = require_polygon_clipping_cjs();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var polygonClipping__default = /* @__PURE__ */ _interopDefaultLegacy(polygonClipping);
    function mask(polygon, mask2) {
      var maskPolygon = createMask(mask2);
      var polygonOuters = null;
      if (polygon.type === "FeatureCollection") polygonOuters = unionFc(polygon);
      else
        polygonOuters = createGeomFromPolygonClippingOutput(
          polygonClipping__default["default"].union(polygon.geometry.coordinates)
        );
      polygonOuters.geometry.coordinates.forEach(function(contour) {
        maskPolygon.geometry.coordinates.push(contour[0]);
      });
      return maskPolygon;
    }
    function unionFc(fc) {
      var unioned = fc.features.length === 2 ? polygonClipping__default["default"].union(
        fc.features[0].geometry.coordinates,
        fc.features[1].geometry.coordinates
      ) : polygonClipping__default["default"].union.apply(
        polygonClipping__default["default"],
        fc.features.map(function(f) {
          return f.geometry.coordinates;
        })
      );
      return createGeomFromPolygonClippingOutput(unioned);
    }
    function createGeomFromPolygonClippingOutput(unioned) {
      return helpers.multiPolygon(unioned);
    }
    function createMask(mask2) {
      var world = [
        [
          [180, 90],
          [-180, 90],
          [-180, -90],
          [180, -90],
          [180, 90]
        ]
      ];
      var coordinates = mask2 && mask2.geometry.coordinates || world;
      return helpers.polygon(coordinates);
    }
    module2.exports = mask;
    module2.exports.default = mask;
  }
});

// node_modules/@turf/rectangle-grid/dist/js/index.js
var require_js103 = __commonJS({
  "node_modules/@turf/rectangle-grid/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var boolean_intersects_1 = __importDefault(require_js79());
    var distance_1 = __importDefault(require_js9());
    var helpers_1 = require_js();
    function rectangleGrid(bbox, cellWidth, cellHeight, options) {
      if (options === void 0) {
        options = {};
      }
      var results = [];
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];
      var xFraction = cellWidth / distance_1.default([west, south], [east, south], options);
      var cellWidthDeg = xFraction * (east - west);
      var yFraction = cellHeight / distance_1.default([west, south], [west, north], options);
      var cellHeightDeg = yFraction * (north - south);
      var bboxWidth = east - west;
      var bboxHeight = north - south;
      var columns = Math.floor(bboxWidth / cellWidthDeg);
      var rows = Math.floor(bboxHeight / cellHeightDeg);
      var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
      var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
      var currentX = west + deltaX;
      for (var column = 0; column < columns; column++) {
        var currentY = south + deltaY;
        for (var row = 0; row < rows; row++) {
          var cellPoly = helpers_1.polygon([
            [
              [currentX, currentY],
              [currentX, currentY + cellHeightDeg],
              [currentX + cellWidthDeg, currentY + cellHeightDeg],
              [currentX + cellWidthDeg, currentY],
              [currentX, currentY]
            ]
          ], options.properties);
          if (options.mask) {
            if (boolean_intersects_1.default(options.mask, cellPoly)) {
              results.push(cellPoly);
            }
          } else {
            results.push(cellPoly);
          }
          currentY += cellHeightDeg;
        }
        currentX += cellWidthDeg;
      }
      return helpers_1.featureCollection(results);
    }
    exports2.default = rectangleGrid;
  }
});

// node_modules/@turf/square-grid/dist/js/index.js
var require_js104 = __commonJS({
  "node_modules/@turf/square-grid/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var rectangle_grid_1 = __importDefault(require_js103());
    function squareGrid(bbox, cellSide, options) {
      if (options === void 0) {
        options = {};
      }
      return rectangle_grid_1.default(bbox, cellSide, cellSide, options);
    }
    exports2.default = squareGrid;
  }
});

// node_modules/@turf/triangle-grid/dist/js/index.js
var require_js105 = __commonJS({
  "node_modules/@turf/triangle-grid/dist/js/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var distance_1 = __importDefault(require_js9());
    var intersect_1 = __importDefault(require_js99());
    var helpers_1 = require_js();
    function triangleGrid(bbox, cellSide, options) {
      if (options === void 0) {
        options = {};
      }
      var results = [];
      var xFraction = cellSide / distance_1.default([bbox[0], bbox[1]], [bbox[2], bbox[1]], options);
      var cellWidth = xFraction * (bbox[2] - bbox[0]);
      var yFraction = cellSide / distance_1.default([bbox[0], bbox[1]], [bbox[0], bbox[3]], options);
      var cellHeight = yFraction * (bbox[3] - bbox[1]);
      var xi = 0;
      var currentX = bbox[0];
      while (currentX <= bbox[2]) {
        var yi = 0;
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
          var cellTriangle1 = null;
          var cellTriangle2 = null;
          if (xi % 2 === 0 && yi % 2 === 0) {
            cellTriangle1 = helpers_1.polygon([
              [
                [currentX, currentY],
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY]
              ]
            ], options.properties);
            cellTriangle2 = helpers_1.polygon([
              [
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY + cellHeight]
              ]
            ], options.properties);
          } else if (xi % 2 === 0 && yi % 2 === 1) {
            cellTriangle1 = helpers_1.polygon([
              [
                [currentX, currentY],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY]
              ]
            ], options.properties);
            cellTriangle2 = helpers_1.polygon([
              [
                [currentX, currentY],
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX, currentY]
              ]
            ], options.properties);
          } else if (yi % 2 === 0 && xi % 2 === 1) {
            cellTriangle1 = helpers_1.polygon([
              [
                [currentX, currentY],
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX, currentY]
              ]
            ], options.properties);
            cellTriangle2 = helpers_1.polygon([
              [
                [currentX, currentY],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY]
              ]
            ], options.properties);
          } else if (yi % 2 === 1 && xi % 2 === 1) {
            cellTriangle1 = helpers_1.polygon([
              [
                [currentX, currentY],
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY]
              ]
            ], options.properties);
            cellTriangle2 = helpers_1.polygon([
              [
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY + cellHeight]
              ]
            ], options.properties);
          }
          if (options.mask) {
            if (intersect_1.default(options.mask, cellTriangle1))
              results.push(cellTriangle1);
            if (intersect_1.default(options.mask, cellTriangle2))
              results.push(cellTriangle2);
          } else {
            results.push(cellTriangle1);
            results.push(cellTriangle2);
          }
          currentY += cellHeight;
          yi++;
        }
        xi++;
        currentX += cellWidth;
      }
      return helpers_1.featureCollection(results);
    }
    exports2.default = triangleGrid;
  }
});

// node_modules/@turf/interpolate/dist/js/index.js
var require_js106 = __commonJS({
  "node_modules/@turf/interpolate/dist/js/index.js"(exports2, module2) {
    "use strict";
    var bbox = require_js3();
    var hexGrid = require_js101();
    var pointGrid = require_js50();
    var distance = require_js9();
    var centroid = require_js28();
    var squareGrid = require_js104();
    var triangleGrid = require_js105();
    var clone = require_js11();
    var helpers = require_js();
    var meta = require_js2();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bbox__default = /* @__PURE__ */ _interopDefaultLegacy(bbox);
    var hexGrid__default = /* @__PURE__ */ _interopDefaultLegacy(hexGrid);
    var pointGrid__default = /* @__PURE__ */ _interopDefaultLegacy(pointGrid);
    var distance__default = /* @__PURE__ */ _interopDefaultLegacy(distance);
    var centroid__default = /* @__PURE__ */ _interopDefaultLegacy(centroid);
    var squareGrid__default = /* @__PURE__ */ _interopDefaultLegacy(squareGrid);
    var triangleGrid__default = /* @__PURE__ */ _interopDefaultLegacy(triangleGrid);
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    function interpolate(points, cellSize, options) {
      options = options || {};
      if (typeof options !== "object") throw new Error("options is invalid");
      var gridType = options.gridType;
      var property = options.property;
      var weight = options.weight;
      if (!points) throw new Error("points is required");
      invariant.collectionOf(points, "Point", "input must contain Points");
      if (!cellSize) throw new Error("cellSize is required");
      if (weight !== void 0 && typeof weight !== "number")
        throw new Error("weight must be a number");
      property = property || "elevation";
      gridType = gridType || "square";
      weight = weight || 1;
      var box = bbox__default["default"](points);
      var grid;
      switch (gridType) {
        case "point":
        case "points":
          grid = pointGrid__default["default"](box, cellSize, options);
          break;
        case "square":
        case "squares":
          grid = squareGrid__default["default"](box, cellSize, options);
          break;
        case "hex":
        case "hexes":
          grid = hexGrid__default["default"](box, cellSize, options);
          break;
        case "triangle":
        case "triangles":
          grid = triangleGrid__default["default"](box, cellSize, options);
          break;
        default:
          throw new Error("invalid gridType");
      }
      var results = [];
      meta.featureEach(grid, function(gridFeature) {
        var zw = 0;
        var sw = 0;
        meta.featureEach(points, function(point) {
          var gridPoint = gridType === "point" ? gridFeature : centroid__default["default"](gridFeature);
          var d = distance__default["default"](gridPoint, point, options);
          var zValue;
          if (property !== void 0) zValue = point.properties[property];
          if (zValue === void 0) zValue = point.geometry.coordinates[2];
          if (zValue === void 0) throw new Error("zValue is missing");
          if (d === 0) zw = zValue;
          var w = 1 / Math.pow(d, weight);
          sw += w;
          zw += w * zValue;
        });
        var newFeature = clone__default["default"](gridFeature);
        newFeature.properties[property] = zw / sw;
        results.push(newFeature);
      });
      return helpers.featureCollection(results);
    }
    module2.exports = interpolate;
    module2.exports.default = interpolate;
  }
});

// node_modules/@turf/turf/dist/js/index.js
var require_js107 = __commonJS({
  "node_modules/@turf/turf/dist/js/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isolines = require_js5();
    var convex = require_js6();
    var pointsWithinPolygon = require_js8();
    var concave = require_js12();
    var collect = require_js13();
    var flip = require_js14();
    var simplify = require_js16();
    var bezierSpline = require_js17();
    var tag = require_js18();
    var sample = require_js19();
    var envelope = require_js21();
    var square = require_js22();
    var circle = require_js24();
    var midpoint = require_js26();
    var center = require_js27();
    var centerOfMass = require_js29();
    var centroid = require_js28();
    var combine = require_js30();
    var distance = require_js9();
    var explode = require_js31();
    var bbox = require_js3();
    var tesselate = require_js32();
    var bboxPolygon = require_js20();
    var booleanPointInPolygon = require_js7();
    var nearestPoint = require_js33();
    var nearestPointOnLine = require_js36();
    var nearestPointToLine = require_js39();
    var planepoint = require_js40();
    var tin = require_js10();
    var bearing = require_js25();
    var destination = require_js23();
    var kinks = require_js41();
    var pointOnFeature = require_js42();
    var area = require_js43();
    var along = require_js44();
    var length = require_js45();
    var lineSlice = require_js46();
    var lineSliceAlong = require_js47();
    var pointGrid = require_js50();
    var truncate = require_js51();
    var flatten = require_js52();
    var lineIntersect = require_js35();
    var lineChunk = require_js53();
    var unkinkPolygon = require_js54();
    var greatCircle = require_js55();
    var lineSegment = require_js34();
    var lineSplit = require_js56();
    var lineArc = require_js57();
    var polygonToLine = require_js58();
    var lineToPolygon = require_js59();
    var bboxClip = require_js60();
    var lineOverlap = require_js61();
    var sector = require_js62();
    var rhumbBearing = require_js63();
    var rhumbDistance = require_js37();
    var rhumbDestination = require_js64();
    var polygonTangents = require_js65();
    var rewind = require_js67();
    var isobands = require_js68();
    var transformRotate = require_js69();
    var transformScale = require_js70();
    var transformTranslate = require_js71();
    var lineOffset = require_js72();
    var polygonize = require_js73();
    var booleanDisjoint = require_js74();
    var booleanContains = require_js75();
    var booleanCrosses = require_js76();
    var booleanClockwise = require_js66();
    var booleanOverlap = require_js77();
    var booleanPointOnLine = require_js48();
    var booleanEqual = require_js78();
    var booleanWithin = require_js49();
    var booleanIntersects = require_js79();
    var clone = require_js11();
    var cleanCoords = require_js15();
    var clustersDbscan = require_js80();
    var clustersKmeans = require_js81();
    var pointToLineDistance = require_js38();
    var booleanParallel = require_js82();
    var shortestPath = require_js83();
    var voronoi = require_js84();
    var ellipse = require_js85();
    var centerMean = require_js86();
    var centerMedian = require_js87();
    var standardDeviationalEllipse = require_js88();
    var angle = require_js89();
    var polygonSmooth = require_js90();
    var moranIndex = require_js92();
    var distanceWeight = require_js91();
    var projection = require_js93();
    var random = require_js94();
    var clusters = require_js95();
    var helpers = require_js();
    var invariant = require_js4();
    var meta = require_js2();
    var difference = require_js96();
    var buffer = require_js97();
    var union = require_js98();
    var intersect = require_js99();
    var dissolve = require_js100();
    var hexGrid = require_js101();
    var mask = require_js102();
    var squareGrid = require_js104();
    var triangleGrid = require_js105();
    var interpolate = require_js106();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var isolines__default = /* @__PURE__ */ _interopDefaultLegacy(isolines);
    var convex__default = /* @__PURE__ */ _interopDefaultLegacy(convex);
    var pointsWithinPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(pointsWithinPolygon);
    var concave__default = /* @__PURE__ */ _interopDefaultLegacy(concave);
    var collect__default = /* @__PURE__ */ _interopDefaultLegacy(collect);
    var flip__default = /* @__PURE__ */ _interopDefaultLegacy(flip);
    var simplify__default = /* @__PURE__ */ _interopDefaultLegacy(simplify);
    var bezierSpline__default = /* @__PURE__ */ _interopDefaultLegacy(bezierSpline);
    var tag__default = /* @__PURE__ */ _interopDefaultLegacy(tag);
    var sample__default = /* @__PURE__ */ _interopDefaultLegacy(sample);
    var envelope__default = /* @__PURE__ */ _interopDefaultLegacy(envelope);
    var square__default = /* @__PURE__ */ _interopDefaultLegacy(square);
    var circle__default = /* @__PURE__ */ _interopDefaultLegacy(circle);
    var midpoint__default = /* @__PURE__ */ _interopDefaultLegacy(midpoint);
    var center__default = /* @__PURE__ */ _interopDefaultLegacy(center);
    var centerOfMass__default = /* @__PURE__ */ _interopDefaultLegacy(centerOfMass);
    var centroid__default = /* @__PURE__ */ _interopDefaultLegacy(centroid);
    var combine__default = /* @__PURE__ */ _interopDefaultLegacy(combine);
    var distance__default = /* @__PURE__ */ _interopDefaultLegacy(distance);
    var explode__default = /* @__PURE__ */ _interopDefaultLegacy(explode);
    var bbox__default = /* @__PURE__ */ _interopDefaultLegacy(bbox);
    var tesselate__default = /* @__PURE__ */ _interopDefaultLegacy(tesselate);
    var bboxPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(bboxPolygon);
    var booleanPointInPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(booleanPointInPolygon);
    var nearestPoint__default = /* @__PURE__ */ _interopDefaultLegacy(nearestPoint);
    var nearestPointOnLine__default = /* @__PURE__ */ _interopDefaultLegacy(nearestPointOnLine);
    var nearestPointToLine__default = /* @__PURE__ */ _interopDefaultLegacy(nearestPointToLine);
    var planepoint__default = /* @__PURE__ */ _interopDefaultLegacy(planepoint);
    var tin__default = /* @__PURE__ */ _interopDefaultLegacy(tin);
    var bearing__default = /* @__PURE__ */ _interopDefaultLegacy(bearing);
    var destination__default = /* @__PURE__ */ _interopDefaultLegacy(destination);
    var kinks__default = /* @__PURE__ */ _interopDefaultLegacy(kinks);
    var pointOnFeature__default = /* @__PURE__ */ _interopDefaultLegacy(pointOnFeature);
    var area__default = /* @__PURE__ */ _interopDefaultLegacy(area);
    var along__default = /* @__PURE__ */ _interopDefaultLegacy(along);
    var length__default = /* @__PURE__ */ _interopDefaultLegacy(length);
    var lineSlice__default = /* @__PURE__ */ _interopDefaultLegacy(lineSlice);
    var lineSliceAlong__default = /* @__PURE__ */ _interopDefaultLegacy(lineSliceAlong);
    var pointGrid__default = /* @__PURE__ */ _interopDefaultLegacy(pointGrid);
    var truncate__default = /* @__PURE__ */ _interopDefaultLegacy(truncate);
    var flatten__default = /* @__PURE__ */ _interopDefaultLegacy(flatten);
    var lineIntersect__default = /* @__PURE__ */ _interopDefaultLegacy(lineIntersect);
    var lineChunk__default = /* @__PURE__ */ _interopDefaultLegacy(lineChunk);
    var unkinkPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(unkinkPolygon);
    var greatCircle__default = /* @__PURE__ */ _interopDefaultLegacy(greatCircle);
    var lineSegment__default = /* @__PURE__ */ _interopDefaultLegacy(lineSegment);
    var lineSplit__default = /* @__PURE__ */ _interopDefaultLegacy(lineSplit);
    var lineArc__default = /* @__PURE__ */ _interopDefaultLegacy(lineArc);
    var polygonToLine__default = /* @__PURE__ */ _interopDefaultLegacy(polygonToLine);
    var lineToPolygon__default = /* @__PURE__ */ _interopDefaultLegacy(lineToPolygon);
    var bboxClip__default = /* @__PURE__ */ _interopDefaultLegacy(bboxClip);
    var lineOverlap__default = /* @__PURE__ */ _interopDefaultLegacy(lineOverlap);
    var sector__default = /* @__PURE__ */ _interopDefaultLegacy(sector);
    var rhumbBearing__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbBearing);
    var rhumbDistance__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDistance);
    var rhumbDestination__default = /* @__PURE__ */ _interopDefaultLegacy(rhumbDestination);
    var polygonTangents__default = /* @__PURE__ */ _interopDefaultLegacy(polygonTangents);
    var rewind__default = /* @__PURE__ */ _interopDefaultLegacy(rewind);
    var isobands__default = /* @__PURE__ */ _interopDefaultLegacy(isobands);
    var transformRotate__default = /* @__PURE__ */ _interopDefaultLegacy(transformRotate);
    var transformScale__default = /* @__PURE__ */ _interopDefaultLegacy(transformScale);
    var transformTranslate__default = /* @__PURE__ */ _interopDefaultLegacy(transformTranslate);
    var lineOffset__default = /* @__PURE__ */ _interopDefaultLegacy(lineOffset);
    var polygonize__default = /* @__PURE__ */ _interopDefaultLegacy(polygonize);
    var booleanDisjoint__default = /* @__PURE__ */ _interopDefaultLegacy(booleanDisjoint);
    var booleanContains__default = /* @__PURE__ */ _interopDefaultLegacy(booleanContains);
    var booleanCrosses__default = /* @__PURE__ */ _interopDefaultLegacy(booleanCrosses);
    var booleanClockwise__default = /* @__PURE__ */ _interopDefaultLegacy(booleanClockwise);
    var booleanOverlap__default = /* @__PURE__ */ _interopDefaultLegacy(booleanOverlap);
    var booleanPointOnLine__default = /* @__PURE__ */ _interopDefaultLegacy(booleanPointOnLine);
    var booleanEqual__default = /* @__PURE__ */ _interopDefaultLegacy(booleanEqual);
    var booleanWithin__default = /* @__PURE__ */ _interopDefaultLegacy(booleanWithin);
    var booleanIntersects__default = /* @__PURE__ */ _interopDefaultLegacy(booleanIntersects);
    var clone__default = /* @__PURE__ */ _interopDefaultLegacy(clone);
    var cleanCoords__default = /* @__PURE__ */ _interopDefaultLegacy(cleanCoords);
    var clustersDbscan__default = /* @__PURE__ */ _interopDefaultLegacy(clustersDbscan);
    var clustersKmeans__default = /* @__PURE__ */ _interopDefaultLegacy(clustersKmeans);
    var pointToLineDistance__default = /* @__PURE__ */ _interopDefaultLegacy(pointToLineDistance);
    var booleanParallel__default = /* @__PURE__ */ _interopDefaultLegacy(booleanParallel);
    var shortestPath__default = /* @__PURE__ */ _interopDefaultLegacy(shortestPath);
    var voronoi__default = /* @__PURE__ */ _interopDefaultLegacy(voronoi);
    var ellipse__default = /* @__PURE__ */ _interopDefaultLegacy(ellipse);
    var centerMean__default = /* @__PURE__ */ _interopDefaultLegacy(centerMean);
    var centerMedian__default = /* @__PURE__ */ _interopDefaultLegacy(centerMedian);
    var standardDeviationalEllipse__default = /* @__PURE__ */ _interopDefaultLegacy(standardDeviationalEllipse);
    var angle__default = /* @__PURE__ */ _interopDefaultLegacy(angle);
    var polygonSmooth__default = /* @__PURE__ */ _interopDefaultLegacy(polygonSmooth);
    var moranIndex__default = /* @__PURE__ */ _interopDefaultLegacy(moranIndex);
    var distanceWeight__default = /* @__PURE__ */ _interopDefaultLegacy(distanceWeight);
    var projection__namespace = /* @__PURE__ */ _interopNamespace(projection);
    var random__namespace = /* @__PURE__ */ _interopNamespace(random);
    var clusters__namespace = /* @__PURE__ */ _interopNamespace(clusters);
    var helpers__namespace = /* @__PURE__ */ _interopNamespace(helpers);
    var invariant__namespace = /* @__PURE__ */ _interopNamespace(invariant);
    var meta__namespace = /* @__PURE__ */ _interopNamespace(meta);
    var difference__default = /* @__PURE__ */ _interopDefaultLegacy(difference);
    var buffer__default = /* @__PURE__ */ _interopDefaultLegacy(buffer);
    var union__default = /* @__PURE__ */ _interopDefaultLegacy(union);
    var intersect__default = /* @__PURE__ */ _interopDefaultLegacy(intersect);
    var dissolve__default = /* @__PURE__ */ _interopDefaultLegacy(dissolve);
    var hexGrid__default = /* @__PURE__ */ _interopDefaultLegacy(hexGrid);
    var mask__default = /* @__PURE__ */ _interopDefaultLegacy(mask);
    var squareGrid__default = /* @__PURE__ */ _interopDefaultLegacy(squareGrid);
    var triangleGrid__default = /* @__PURE__ */ _interopDefaultLegacy(triangleGrid);
    var interpolate__default = /* @__PURE__ */ _interopDefaultLegacy(interpolate);
    Object.keys(projection).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return projection[k];
        }
      });
    });
    Object.keys(random).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return random[k];
        }
      });
    });
    Object.keys(clusters).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return clusters[k];
        }
      });
    });
    Object.keys(helpers).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return helpers[k];
        }
      });
    });
    Object.keys(invariant).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return invariant[k];
        }
      });
    });
    Object.keys(meta).forEach(function(k) {
      if (k !== "default") Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return meta[k];
        }
      });
    });
    Object.defineProperty(exports2, "isolines", {
      enumerable: true,
      get: function() {
        return isolines__default["default"];
      }
    });
    Object.defineProperty(exports2, "convex", {
      enumerable: true,
      get: function() {
        return convex__default["default"];
      }
    });
    Object.defineProperty(exports2, "pointsWithinPolygon", {
      enumerable: true,
      get: function() {
        return pointsWithinPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "within", {
      enumerable: true,
      get: function() {
        return pointsWithinPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "concave", {
      enumerable: true,
      get: function() {
        return concave__default["default"];
      }
    });
    Object.defineProperty(exports2, "collect", {
      enumerable: true,
      get: function() {
        return collect__default["default"];
      }
    });
    Object.defineProperty(exports2, "flip", {
      enumerable: true,
      get: function() {
        return flip__default["default"];
      }
    });
    Object.defineProperty(exports2, "simplify", {
      enumerable: true,
      get: function() {
        return simplify__default["default"];
      }
    });
    Object.defineProperty(exports2, "bezier", {
      enumerable: true,
      get: function() {
        return bezierSpline__default["default"];
      }
    });
    Object.defineProperty(exports2, "bezierSpline", {
      enumerable: true,
      get: function() {
        return bezierSpline__default["default"];
      }
    });
    Object.defineProperty(exports2, "tag", {
      enumerable: true,
      get: function() {
        return tag__default["default"];
      }
    });
    Object.defineProperty(exports2, "sample", {
      enumerable: true,
      get: function() {
        return sample__default["default"];
      }
    });
    Object.defineProperty(exports2, "envelope", {
      enumerable: true,
      get: function() {
        return envelope__default["default"];
      }
    });
    Object.defineProperty(exports2, "square", {
      enumerable: true,
      get: function() {
        return square__default["default"];
      }
    });
    Object.defineProperty(exports2, "circle", {
      enumerable: true,
      get: function() {
        return circle__default["default"];
      }
    });
    Object.defineProperty(exports2, "midpoint", {
      enumerable: true,
      get: function() {
        return midpoint__default["default"];
      }
    });
    Object.defineProperty(exports2, "center", {
      enumerable: true,
      get: function() {
        return center__default["default"];
      }
    });
    Object.defineProperty(exports2, "centerOfMass", {
      enumerable: true,
      get: function() {
        return centerOfMass__default["default"];
      }
    });
    Object.defineProperty(exports2, "centroid", {
      enumerable: true,
      get: function() {
        return centroid__default["default"];
      }
    });
    Object.defineProperty(exports2, "combine", {
      enumerable: true,
      get: function() {
        return combine__default["default"];
      }
    });
    Object.defineProperty(exports2, "distance", {
      enumerable: true,
      get: function() {
        return distance__default["default"];
      }
    });
    Object.defineProperty(exports2, "explode", {
      enumerable: true,
      get: function() {
        return explode__default["default"];
      }
    });
    Object.defineProperty(exports2, "bbox", {
      enumerable: true,
      get: function() {
        return bbox__default["default"];
      }
    });
    Object.defineProperty(exports2, "tesselate", {
      enumerable: true,
      get: function() {
        return tesselate__default["default"];
      }
    });
    Object.defineProperty(exports2, "bboxPolygon", {
      enumerable: true,
      get: function() {
        return bboxPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanPointInPolygon", {
      enumerable: true,
      get: function() {
        return booleanPointInPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "inside", {
      enumerable: true,
      get: function() {
        return booleanPointInPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "nearest", {
      enumerable: true,
      get: function() {
        return nearestPoint__default["default"];
      }
    });
    Object.defineProperty(exports2, "nearestPoint", {
      enumerable: true,
      get: function() {
        return nearestPoint__default["default"];
      }
    });
    Object.defineProperty(exports2, "nearestPointOnLine", {
      enumerable: true,
      get: function() {
        return nearestPointOnLine__default["default"];
      }
    });
    Object.defineProperty(exports2, "pointOnLine", {
      enumerable: true,
      get: function() {
        return nearestPointOnLine__default["default"];
      }
    });
    Object.defineProperty(exports2, "nearestPointToLine", {
      enumerable: true,
      get: function() {
        return nearestPointToLine__default["default"];
      }
    });
    Object.defineProperty(exports2, "planepoint", {
      enumerable: true,
      get: function() {
        return planepoint__default["default"];
      }
    });
    Object.defineProperty(exports2, "tin", {
      enumerable: true,
      get: function() {
        return tin__default["default"];
      }
    });
    Object.defineProperty(exports2, "bearing", {
      enumerable: true,
      get: function() {
        return bearing__default["default"];
      }
    });
    Object.defineProperty(exports2, "destination", {
      enumerable: true,
      get: function() {
        return destination__default["default"];
      }
    });
    Object.defineProperty(exports2, "kinks", {
      enumerable: true,
      get: function() {
        return kinks__default["default"];
      }
    });
    Object.defineProperty(exports2, "pointOnFeature", {
      enumerable: true,
      get: function() {
        return pointOnFeature__default["default"];
      }
    });
    Object.defineProperty(exports2, "pointOnSurface", {
      enumerable: true,
      get: function() {
        return pointOnFeature__default["default"];
      }
    });
    Object.defineProperty(exports2, "area", {
      enumerable: true,
      get: function() {
        return area__default["default"];
      }
    });
    Object.defineProperty(exports2, "along", {
      enumerable: true,
      get: function() {
        return along__default["default"];
      }
    });
    Object.defineProperty(exports2, "length", {
      enumerable: true,
      get: function() {
        return length__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineDistance", {
      enumerable: true,
      get: function() {
        return length__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineSlice", {
      enumerable: true,
      get: function() {
        return lineSlice__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineSliceAlong", {
      enumerable: true,
      get: function() {
        return lineSliceAlong__default["default"];
      }
    });
    Object.defineProperty(exports2, "pointGrid", {
      enumerable: true,
      get: function() {
        return pointGrid__default["default"];
      }
    });
    Object.defineProperty(exports2, "truncate", {
      enumerable: true,
      get: function() {
        return truncate__default["default"];
      }
    });
    Object.defineProperty(exports2, "flatten", {
      enumerable: true,
      get: function() {
        return flatten__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineIntersect", {
      enumerable: true,
      get: function() {
        return lineIntersect__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineChunk", {
      enumerable: true,
      get: function() {
        return lineChunk__default["default"];
      }
    });
    Object.defineProperty(exports2, "unkinkPolygon", {
      enumerable: true,
      get: function() {
        return unkinkPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "greatCircle", {
      enumerable: true,
      get: function() {
        return greatCircle__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineSegment", {
      enumerable: true,
      get: function() {
        return lineSegment__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineSplit", {
      enumerable: true,
      get: function() {
        return lineSplit__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineArc", {
      enumerable: true,
      get: function() {
        return lineArc__default["default"];
      }
    });
    Object.defineProperty(exports2, "polygonToLine", {
      enumerable: true,
      get: function() {
        return polygonToLine__default["default"];
      }
    });
    Object.defineProperty(exports2, "polygonToLineString", {
      enumerable: true,
      get: function() {
        return polygonToLine__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineStringToPolygon", {
      enumerable: true,
      get: function() {
        return lineToPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineToPolygon", {
      enumerable: true,
      get: function() {
        return lineToPolygon__default["default"];
      }
    });
    Object.defineProperty(exports2, "bboxClip", {
      enumerable: true,
      get: function() {
        return bboxClip__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineOverlap", {
      enumerable: true,
      get: function() {
        return lineOverlap__default["default"];
      }
    });
    Object.defineProperty(exports2, "sector", {
      enumerable: true,
      get: function() {
        return sector__default["default"];
      }
    });
    Object.defineProperty(exports2, "rhumbBearing", {
      enumerable: true,
      get: function() {
        return rhumbBearing__default["default"];
      }
    });
    Object.defineProperty(exports2, "rhumbDistance", {
      enumerable: true,
      get: function() {
        return rhumbDistance__default["default"];
      }
    });
    Object.defineProperty(exports2, "rhumbDestination", {
      enumerable: true,
      get: function() {
        return rhumbDestination__default["default"];
      }
    });
    Object.defineProperty(exports2, "polygonTangents", {
      enumerable: true,
      get: function() {
        return polygonTangents__default["default"];
      }
    });
    Object.defineProperty(exports2, "rewind", {
      enumerable: true,
      get: function() {
        return rewind__default["default"];
      }
    });
    Object.defineProperty(exports2, "isobands", {
      enumerable: true,
      get: function() {
        return isobands__default["default"];
      }
    });
    Object.defineProperty(exports2, "transformRotate", {
      enumerable: true,
      get: function() {
        return transformRotate__default["default"];
      }
    });
    Object.defineProperty(exports2, "transformScale", {
      enumerable: true,
      get: function() {
        return transformScale__default["default"];
      }
    });
    Object.defineProperty(exports2, "transformTranslate", {
      enumerable: true,
      get: function() {
        return transformTranslate__default["default"];
      }
    });
    Object.defineProperty(exports2, "lineOffset", {
      enumerable: true,
      get: function() {
        return lineOffset__default["default"];
      }
    });
    Object.defineProperty(exports2, "polygonize", {
      enumerable: true,
      get: function() {
        return polygonize__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanDisjoint", {
      enumerable: true,
      get: function() {
        return booleanDisjoint__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanContains", {
      enumerable: true,
      get: function() {
        return booleanContains__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanCrosses", {
      enumerable: true,
      get: function() {
        return booleanCrosses__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanClockwise", {
      enumerable: true,
      get: function() {
        return booleanClockwise__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanOverlap", {
      enumerable: true,
      get: function() {
        return booleanOverlap__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanPointOnLine", {
      enumerable: true,
      get: function() {
        return booleanPointOnLine__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanEqual", {
      enumerable: true,
      get: function() {
        return booleanEqual__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanWithin", {
      enumerable: true,
      get: function() {
        return booleanWithin__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanIntersects", {
      enumerable: true,
      get: function() {
        return booleanIntersects__default["default"];
      }
    });
    Object.defineProperty(exports2, "clone", {
      enumerable: true,
      get: function() {
        return clone__default["default"];
      }
    });
    Object.defineProperty(exports2, "cleanCoords", {
      enumerable: true,
      get: function() {
        return cleanCoords__default["default"];
      }
    });
    Object.defineProperty(exports2, "clustersDbscan", {
      enumerable: true,
      get: function() {
        return clustersDbscan__default["default"];
      }
    });
    Object.defineProperty(exports2, "clustersKmeans", {
      enumerable: true,
      get: function() {
        return clustersKmeans__default["default"];
      }
    });
    Object.defineProperty(exports2, "pointToLineDistance", {
      enumerable: true,
      get: function() {
        return pointToLineDistance__default["default"];
      }
    });
    Object.defineProperty(exports2, "booleanParallel", {
      enumerable: true,
      get: function() {
        return booleanParallel__default["default"];
      }
    });
    Object.defineProperty(exports2, "shortestPath", {
      enumerable: true,
      get: function() {
        return shortestPath__default["default"];
      }
    });
    Object.defineProperty(exports2, "voronoi", {
      enumerable: true,
      get: function() {
        return voronoi__default["default"];
      }
    });
    Object.defineProperty(exports2, "ellipse", {
      enumerable: true,
      get: function() {
        return ellipse__default["default"];
      }
    });
    Object.defineProperty(exports2, "centerMean", {
      enumerable: true,
      get: function() {
        return centerMean__default["default"];
      }
    });
    Object.defineProperty(exports2, "centerMedian", {
      enumerable: true,
      get: function() {
        return centerMedian__default["default"];
      }
    });
    Object.defineProperty(exports2, "standardDeviationalEllipse", {
      enumerable: true,
      get: function() {
        return standardDeviationalEllipse__default["default"];
      }
    });
    Object.defineProperty(exports2, "angle", {
      enumerable: true,
      get: function() {
        return angle__default["default"];
      }
    });
    Object.defineProperty(exports2, "polygonSmooth", {
      enumerable: true,
      get: function() {
        return polygonSmooth__default["default"];
      }
    });
    Object.defineProperty(exports2, "moranIndex", {
      enumerable: true,
      get: function() {
        return moranIndex__default["default"];
      }
    });
    Object.defineProperty(exports2, "distanceWeight", {
      enumerable: true,
      get: function() {
        return distanceWeight__default["default"];
      }
    });
    exports2.projection = projection__namespace;
    exports2.random = random__namespace;
    exports2.clusters = clusters__namespace;
    Object.defineProperty(exports2, "bearingToAngle", {
      enumerable: true,
      get: function() {
        return helpers.bearingToAzimuth;
      }
    });
    Object.defineProperty(exports2, "convertDistance", {
      enumerable: true,
      get: function() {
        return helpers.convertLength;
      }
    });
    Object.defineProperty(exports2, "degrees2radians", {
      enumerable: true,
      get: function() {
        return helpers.degreesToRadians;
      }
    });
    Object.defineProperty(exports2, "distanceToDegrees", {
      enumerable: true,
      get: function() {
        return helpers.lengthToDegrees;
      }
    });
    Object.defineProperty(exports2, "distanceToRadians", {
      enumerable: true,
      get: function() {
        return helpers.lengthToRadians;
      }
    });
    exports2.helpers = helpers__namespace;
    Object.defineProperty(exports2, "radians2degrees", {
      enumerable: true,
      get: function() {
        return helpers.radiansToDegrees;
      }
    });
    Object.defineProperty(exports2, "radiansToDistance", {
      enumerable: true,
      get: function() {
        return helpers.radiansToLength;
      }
    });
    exports2.invariant = invariant__namespace;
    exports2.meta = meta__namespace;
    Object.defineProperty(exports2, "difference", {
      enumerable: true,
      get: function() {
        return difference__default["default"];
      }
    });
    Object.defineProperty(exports2, "buffer", {
      enumerable: true,
      get: function() {
        return buffer__default["default"];
      }
    });
    Object.defineProperty(exports2, "union", {
      enumerable: true,
      get: function() {
        return union__default["default"];
      }
    });
    Object.defineProperty(exports2, "intersect", {
      enumerable: true,
      get: function() {
        return intersect__default["default"];
      }
    });
    Object.defineProperty(exports2, "dissolve", {
      enumerable: true,
      get: function() {
        return dissolve__default["default"];
      }
    });
    Object.defineProperty(exports2, "hexGrid", {
      enumerable: true,
      get: function() {
        return hexGrid__default["default"];
      }
    });
    Object.defineProperty(exports2, "mask", {
      enumerable: true,
      get: function() {
        return mask__default["default"];
      }
    });
    Object.defineProperty(exports2, "squareGrid", {
      enumerable: true,
      get: function() {
        return squareGrid__default["default"];
      }
    });
    Object.defineProperty(exports2, "triangleGrid", {
      enumerable: true,
      get: function() {
        return triangleGrid__default["default"];
      }
    });
    Object.defineProperty(exports2, "interpolate", {
      enumerable: true,
      get: function() {
        return interpolate__default["default"];
      }
    });
  }
});

// node_modules/csv-parse/lib/ResizeableBuffer.js
var require_ResizeableBuffer = __commonJS({
  "node_modules/csv-parse/lib/ResizeableBuffer.js"(exports2, module2) {
    var ResizeableBuffer = class {
      constructor(size = 100) {
        this.size = size;
        this.length = 0;
        this.buf = Buffer.alloc(size);
      }
      prepend(val) {
        if (Buffer.isBuffer(val)) {
          const length = this.length + val.length;
          if (length >= this.size) {
            this.resize();
            if (length >= this.size) {
              throw Error("INVALID_BUFFER_STATE");
            }
          }
          const buf = this.buf;
          this.buf = Buffer.alloc(this.size);
          val.copy(this.buf, 0);
          buf.copy(this.buf, val.length);
          this.length += val.length;
        } else {
          const length = this.length++;
          if (length === this.size) {
            this.resize();
          }
          const buf = this.clone();
          this.buf[0] = val;
          buf.copy(this.buf, 1, 0, length);
        }
      }
      append(val) {
        const length = this.length++;
        if (length === this.size) {
          this.resize();
        }
        this.buf[length] = val;
      }
      clone() {
        return Buffer.from(this.buf.slice(0, this.length));
      }
      resize() {
        const length = this.length;
        this.size = this.size * 2;
        const buf = Buffer.alloc(this.size);
        this.buf.copy(buf, 0, 0, length);
        this.buf = buf;
      }
      toString(encoding) {
        if (encoding) {
          return this.buf.slice(0, this.length).toString(encoding);
        } else {
          return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
        }
      }
      toJSON() {
        return this.toString("utf8");
      }
      reset() {
        this.length = 0;
      }
    };
    module2.exports = ResizeableBuffer;
  }
});

// node_modules/csv-parse/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/csv-parse/lib/index.js"(exports2, module2) {
    var { Transform } = require("stream");
    var ResizeableBuffer = require_ResizeableBuffer();
    var tab = 9;
    var nl = 10;
    var np = 12;
    var cr = 13;
    var space = 32;
    var boms = {
      // Note, the following are equals:
      // Buffer.from("\ufeff")
      // Buffer.from([239, 187, 191])
      // Buffer.from('EFBBBF', 'hex')
      "utf8": Buffer.from([239, 187, 191]),
      // Note, the following are equals:
      // Buffer.from "\ufeff", 'utf16le
      // Buffer.from([255, 254])
      "utf16le": Buffer.from([255, 254])
    };
    var Parser = class extends Transform {
      constructor(opts = {}) {
        super({ ...{ readableObjectMode: true }, ...opts, encoding: null });
        this.__originalOptions = opts;
        this.__normalizeOptions(opts);
      }
      __normalizeOptions(opts) {
        const options = {};
        for (let opt in opts) {
          options[underscore(opt)] = opts[opt];
        }
        if (options.encoding === void 0 || options.encoding === true) {
          options.encoding = "utf8";
        } else if (options.encoding === null || options.encoding === false) {
          options.encoding = null;
        } else if (typeof options.encoding !== "string" && options.encoding !== null) {
          throw new CsvError("CSV_INVALID_OPTION_ENCODING", [
            "Invalid option encoding:",
            "encoding must be a string or null to return a buffer,",
            `got ${JSON.stringify(options.encoding)}`
          ], options);
        }
        if (options.bom === void 0 || options.bom === null || options.bom === false) {
          options.bom = false;
        } else if (options.bom !== true) {
          throw new CsvError("CSV_INVALID_OPTION_BOM", [
            "Invalid option bom:",
            "bom must be true,",
            `got ${JSON.stringify(options.bom)}`
          ], options);
        }
        let fnCastField = null;
        if (options.cast === void 0 || options.cast === null || options.cast === false || options.cast === "") {
          options.cast = void 0;
        } else if (typeof options.cast === "function") {
          fnCastField = options.cast;
          options.cast = true;
        } else if (options.cast !== true) {
          throw new CsvError("CSV_INVALID_OPTION_CAST", [
            "Invalid option cast:",
            "cast must be true or a function,",
            `got ${JSON.stringify(options.cast)}`
          ], options);
        }
        if (options.cast_date === void 0 || options.cast_date === null || options.cast_date === false || options.cast_date === "") {
          options.cast_date = false;
        } else if (options.cast_date === true) {
          options.cast_date = function(value) {
            const date = Date.parse(value);
            return !isNaN(date) ? new Date(date) : value;
          };
        } else {
          throw new CsvError("CSV_INVALID_OPTION_CAST_DATE", [
            "Invalid option cast_date:",
            "cast_date must be true or a function,",
            `got ${JSON.stringify(options.cast_date)}`
          ], options);
        }
        let fnFirstLineToHeaders = null;
        if (options.columns === true) {
          fnFirstLineToHeaders = void 0;
        } else if (typeof options.columns === "function") {
          fnFirstLineToHeaders = options.columns;
          options.columns = true;
        } else if (Array.isArray(options.columns)) {
          options.columns = normalizeColumnsArray(options.columns);
        } else if (options.columns === void 0 || options.columns === null || options.columns === false) {
          options.columns = false;
        } else {
          throw new CsvError("CSV_INVALID_OPTION_COLUMNS", [
            "Invalid option columns:",
            "expect an array, a function or true,",
            `got ${JSON.stringify(options.columns)}`
          ], options);
        }
        if (options.columns_duplicates_to_array === void 0 || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {
          options.columns_duplicates_to_array = false;
        } else if (options.columns_duplicates_to_array !== true) {
          throw new CsvError("CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY", [
            "Invalid option columns_duplicates_to_array:",
            "expect an boolean,",
            `got ${JSON.stringify(options.columns_duplicates_to_array)}`
          ], options);
        } else if (options.columns === false) {
          throw new CsvError("CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY", [
            "Invalid option columns_duplicates_to_array:",
            "the `columns` mode must be activated."
          ], options);
        }
        if (options.comment === void 0 || options.comment === null || options.comment === false || options.comment === "") {
          options.comment = null;
        } else {
          if (typeof options.comment === "string") {
            options.comment = Buffer.from(options.comment, options.encoding);
          }
          if (!Buffer.isBuffer(options.comment)) {
            throw new CsvError("CSV_INVALID_OPTION_COMMENT", [
              "Invalid option comment:",
              "comment must be a buffer or a string,",
              `got ${JSON.stringify(options.comment)}`
            ], options);
          }
        }
        const delimiter_json = JSON.stringify(options.delimiter);
        if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];
        if (options.delimiter.length === 0) {
          throw new CsvError("CSV_INVALID_OPTION_DELIMITER", [
            "Invalid option delimiter:",
            "delimiter must be a non empty string or buffer or array of string|buffer,",
            `got ${delimiter_json}`
          ], options);
        }
        options.delimiter = options.delimiter.map(function(delimiter) {
          if (delimiter === void 0 || delimiter === null || delimiter === false) {
            return Buffer.from(",", options.encoding);
          }
          if (typeof delimiter === "string") {
            delimiter = Buffer.from(delimiter, options.encoding);
          }
          if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
            throw new CsvError("CSV_INVALID_OPTION_DELIMITER", [
              "Invalid option delimiter:",
              "delimiter must be a non empty string or buffer or array of string|buffer,",
              `got ${delimiter_json}`
            ], options);
          }
          return delimiter;
        });
        if (options.escape === void 0 || options.escape === true) {
          options.escape = Buffer.from('"', options.encoding);
        } else if (typeof options.escape === "string") {
          options.escape = Buffer.from(options.escape, options.encoding);
        } else if (options.escape === null || options.escape === false) {
          options.escape = null;
        }
        if (options.escape !== null) {
          if (!Buffer.isBuffer(options.escape)) {
            throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
          }
        }
        if (options.from === void 0 || options.from === null) {
          options.from = 1;
        } else {
          if (typeof options.from === "string" && /\d+/.test(options.from)) {
            options.from = parseInt(options.from);
          }
          if (Number.isInteger(options.from)) {
            if (options.from < 0) {
              throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
            }
          } else {
            throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
          }
        }
        if (options.from_line === void 0 || options.from_line === null) {
          options.from_line = 1;
        } else {
          if (typeof options.from_line === "string" && /\d+/.test(options.from_line)) {
            options.from_line = parseInt(options.from_line);
          }
          if (Number.isInteger(options.from_line)) {
            if (options.from_line <= 0) {
              throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
            }
          } else {
            throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
          }
        }
        if (options.ignore_last_delimiters === void 0 || options.ignore_last_delimiters === null) {
          options.ignore_last_delimiters = false;
        } else if (typeof options.ignore_last_delimiters === "number") {
          options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
          if (options.ignore_last_delimiters === 0) {
            options.ignore_last_delimiters = false;
          }
        } else if (typeof options.ignore_last_delimiters !== "boolean") {
          throw new CsvError("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS", [
            "Invalid option `ignore_last_delimiters`:",
            "the value must be a boolean value or an integer,",
            `got ${JSON.stringify(options.ignore_last_delimiters)}`
          ], options);
        }
        if (options.ignore_last_delimiters === true && options.columns === false) {
          throw new CsvError("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS", [
            "The option `ignore_last_delimiters`",
            "requires the activation of the `columns` option"
          ], options);
        }
        if (options.info === void 0 || options.info === null || options.info === false) {
          options.info = false;
        } else if (options.info !== true) {
          throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
        }
        if (options.max_record_size === void 0 || options.max_record_size === null || options.max_record_size === false) {
          options.max_record_size = 0;
        } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {
        } else if (typeof options.max_record_size === "string" && /\d+/.test(options.max_record_size)) {
          options.max_record_size = parseInt(options.max_record_size);
        } else {
          throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
        }
        if (options.objname === void 0 || options.objname === null || options.objname === false) {
          options.objname = void 0;
        } else if (Buffer.isBuffer(options.objname)) {
          if (options.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty buffer`);
          }
          if (options.encoding === null) {
          } else {
            options.objname = options.objname.toString(options.encoding);
          }
        } else if (typeof options.objname === "string") {
          if (options.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty string`);
          }
        } else {
          throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
        }
        if (options.on_record === void 0 || options.on_record === null) {
          options.on_record = void 0;
        } else if (typeof options.on_record !== "function") {
          throw new CsvError("CSV_INVALID_OPTION_ON_RECORD", [
            "Invalid option `on_record`:",
            "expect a function,",
            `got ${JSON.stringify(options.on_record)}`
          ], options);
        }
        if (options.quote === null || options.quote === false || options.quote === "") {
          options.quote = null;
        } else {
          if (options.quote === void 0 || options.quote === true) {
            options.quote = Buffer.from('"', options.encoding);
          } else if (typeof options.quote === "string") {
            options.quote = Buffer.from(options.quote, options.encoding);
          }
          if (!Buffer.isBuffer(options.quote)) {
            throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
          }
        }
        if (options.raw === void 0 || options.raw === null || options.raw === false) {
          options.raw = false;
        } else if (options.raw !== true) {
          throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
        }
        if (!options.record_delimiter) {
          options.record_delimiter = [];
        } else if (!Array.isArray(options.record_delimiter)) {
          options.record_delimiter = [options.record_delimiter];
        }
        options.record_delimiter = options.record_delimiter.map(function(rd) {
          if (typeof rd === "string") {
            rd = Buffer.from(rd, options.encoding);
          }
          return rd;
        });
        if (typeof options.relax === "boolean") {
        } else if (options.relax === void 0 || options.relax === null) {
          options.relax = false;
        } else {
          throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`);
        }
        if (typeof options.relax_column_count === "boolean") {
        } else if (options.relax_column_count === void 0 || options.relax_column_count === null) {
          options.relax_column_count = false;
        } else {
          throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
        }
        if (typeof options.relax_column_count_less === "boolean") {
        } else if (options.relax_column_count_less === void 0 || options.relax_column_count_less === null) {
          options.relax_column_count_less = false;
        } else {
          throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
        }
        if (typeof options.relax_column_count_more === "boolean") {
        } else if (options.relax_column_count_more === void 0 || options.relax_column_count_more === null) {
          options.relax_column_count_more = false;
        } else {
          throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
        }
        if (typeof options.skip_empty_lines === "boolean") {
        } else if (options.skip_empty_lines === void 0 || options.skip_empty_lines === null) {
          options.skip_empty_lines = false;
        } else {
          throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
        }
        if (typeof options.skip_lines_with_empty_values === "boolean") {
        } else if (options.skip_lines_with_empty_values === void 0 || options.skip_lines_with_empty_values === null) {
          options.skip_lines_with_empty_values = false;
        } else {
          throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`);
        }
        if (typeof options.skip_lines_with_error === "boolean") {
        } else if (options.skip_lines_with_error === void 0 || options.skip_lines_with_error === null) {
          options.skip_lines_with_error = false;
        } else {
          throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`);
        }
        if (options.rtrim === void 0 || options.rtrim === null || options.rtrim === false) {
          options.rtrim = false;
        } else if (options.rtrim !== true) {
          throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
        }
        if (options.ltrim === void 0 || options.ltrim === null || options.ltrim === false) {
          options.ltrim = false;
        } else if (options.ltrim !== true) {
          throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
        }
        if (options.trim === void 0 || options.trim === null || options.trim === false) {
          options.trim = false;
        } else if (options.trim !== true) {
          throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
        }
        if (options.trim === true && opts.ltrim !== false) {
          options.ltrim = true;
        } else if (options.ltrim !== true) {
          options.ltrim = false;
        }
        if (options.trim === true && opts.rtrim !== false) {
          options.rtrim = true;
        } else if (options.rtrim !== true) {
          options.rtrim = false;
        }
        if (options.to === void 0 || options.to === null) {
          options.to = -1;
        } else {
          if (typeof options.to === "string" && /\d+/.test(options.to)) {
            options.to = parseInt(options.to);
          }
          if (Number.isInteger(options.to)) {
            if (options.to <= 0) {
              throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
            }
          } else {
            throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
          }
        }
        if (options.to_line === void 0 || options.to_line === null) {
          options.to_line = -1;
        } else {
          if (typeof options.to_line === "string" && /\d+/.test(options.to_line)) {
            options.to_line = parseInt(options.to_line);
          }
          if (Number.isInteger(options.to_line)) {
            if (options.to_line <= 0) {
              throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
            }
          } else {
            throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
          }
        }
        this.info = {
          bytes: 0,
          comment_lines: 0,
          empty_lines: 0,
          invalid_field_length: 0,
          lines: 1,
          records: 0
        };
        this.options = options;
        this.state = {
          bomSkipped: false,
          bufBytesStart: 0,
          castField: fnCastField,
          commenting: false,
          // Current error encountered by a record
          error: void 0,
          enabled: options.from_line === 1,
          escaping: false,
          // escapeIsQuote: options.escape === options.quote,
          escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
          // columns can be `false`, `true`, `Array`
          expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : void 0,
          field: new ResizeableBuffer(20),
          firstLineToHeaders: fnFirstLineToHeaders,
          needMoreDataSize: Math.max(
            // Skip if the remaining buffer smaller than comment
            options.comment !== null ? options.comment.length : 0,
            ...options.delimiter.map((delimiter) => delimiter.length),
            // Skip if the remaining buffer can be escape sequence
            options.quote !== null ? options.quote.length : 0
          ),
          previousBuf: void 0,
          quoting: false,
          stop: false,
          rawBuffer: new ResizeableBuffer(100),
          record: [],
          recordHasError: false,
          record_length: 0,
          recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map((v) => v.length)),
          trimChars: [Buffer.from(" ", options.encoding)[0], Buffer.from("	", options.encoding)[0]],
          wasQuoting: false,
          wasRowDelimiter: false
        };
      }
      // Implementation of `Transform._transform`
      _transform(buf, encoding, callback) {
        if (this.state.stop === true) {
          return;
        }
        const err = this.__parse(buf, false);
        if (err !== void 0) {
          this.state.stop = true;
        }
        callback(err);
      }
      // Implementation of `Transform._flush`
      _flush(callback) {
        if (this.state.stop === true) {
          return;
        }
        const err = this.__parse(void 0, true);
        callback(err);
      }
      // Central parser implementation
      __parse(nextBuf, end) {
        const { bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line } = this.options;
        let { record_delimiter } = this.options;
        const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;
        let buf;
        if (previousBuf === void 0) {
          if (nextBuf === void 0) {
            this.push(null);
            return;
          } else {
            buf = nextBuf;
          }
        } else if (previousBuf !== void 0 && nextBuf === void 0) {
          buf = previousBuf;
        } else {
          buf = Buffer.concat([previousBuf, nextBuf]);
        }
        if (bomSkipped === false) {
          if (bom === false) {
            this.state.bomSkipped = true;
          } else if (buf.length < 3) {
            if (end === false) {
              this.state.previousBuf = buf;
              return;
            }
          } else {
            for (let encoding in boms) {
              if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {
                let bomLength = boms[encoding].length;
                this.state.bufBytesStart += bomLength;
                buf = buf.slice(bomLength);
                this.__normalizeOptions({ ...this.__originalOptions, encoding });
                break;
              }
            }
            this.state.bomSkipped = true;
          }
        }
        const bufLen = buf.length;
        let pos;
        for (pos = 0; pos < bufLen; pos++) {
          if (this.__needMoreData(pos, bufLen, end)) {
            break;
          }
          if (this.state.wasRowDelimiter === true) {
            this.info.lines++;
            this.state.wasRowDelimiter = false;
          }
          if (to_line !== -1 && this.info.lines > to_line) {
            this.state.stop = true;
            this.push(null);
            return;
          }
          if (this.state.quoting === false && record_delimiter.length === 0) {
            const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
            if (record_delimiterCount) {
              record_delimiter = this.options.record_delimiter;
            }
          }
          const chr = buf[pos];
          if (raw === true) {
            rawBuffer.append(chr);
          }
          if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {
            this.state.wasRowDelimiter = true;
          }
          if (this.state.escaping === true) {
            this.state.escaping = false;
          } else {
            if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {
              if (escapeIsQuote) {
                if (this.__isQuote(buf, pos + escape.length)) {
                  this.state.escaping = true;
                  pos += escape.length - 1;
                  continue;
                }
              } else {
                this.state.escaping = true;
                pos += escape.length - 1;
                continue;
              }
            }
            if (this.state.commenting === false && this.__isQuote(buf, pos)) {
              if (this.state.quoting === true) {
                const nextChr = buf[pos + quote.length];
                const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);
                const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);
                const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);
                const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
                if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {
                  pos += escape.length - 1;
                } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  pos += quote.length - 1;
                  continue;
                } else if (relax === false) {
                  const err = this.__error(
                    new CsvError("CSV_INVALID_CLOSING_QUOTE", [
                      "Invalid Closing Quote:",
                      `got "${String.fromCharCode(nextChr)}"`,
                      `at line ${this.info.lines}`,
                      "instead of delimiter, record delimiter, trimable character",
                      "(if activated) or comment"
                    ], this.options, this.__infoField())
                  );
                  if (err !== void 0) return err;
                } else {
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  this.state.field.prepend(quote);
                  pos += quote.length - 1;
                }
              } else {
                if (this.state.field.length !== 0) {
                  if (relax === false) {
                    const err = this.__error(
                      new CsvError("INVALID_OPENING_QUOTE", [
                        "Invalid Opening Quote:",
                        `a quote is found inside a field at line ${this.info.lines}`
                      ], this.options, this.__infoField(), {
                        field: this.state.field
                      })
                    );
                    if (err !== void 0) return err;
                  }
                } else {
                  this.state.quoting = true;
                  pos += quote.length - 1;
                  continue;
                }
              }
            }
            if (this.state.quoting === false) {
              let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
              if (recordDelimiterLength !== 0) {
                const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);
                if (skipCommentLine) {
                  this.info.comment_lines++;
                } else {
                  if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                    this.state.enabled = true;
                    this.__resetField();
                    this.__resetRecord();
                    pos += recordDelimiterLength - 1;
                    continue;
                  }
                  if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                    this.info.empty_lines++;
                    pos += recordDelimiterLength - 1;
                    continue;
                  }
                  this.info.bytes = this.state.bufBytesStart + pos;
                  const errField = this.__onField();
                  if (errField !== void 0) return errField;
                  this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                  const errRecord = this.__onRecord();
                  if (errRecord !== void 0) return errRecord;
                  if (to !== -1 && this.info.records >= to) {
                    this.state.stop = true;
                    this.push(null);
                    return;
                  }
                }
                this.state.commenting = false;
                pos += recordDelimiterLength - 1;
                continue;
              }
              if (this.state.commenting) {
                continue;
              }
              const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);
              if (commentCount !== 0) {
                this.state.commenting = true;
                continue;
              }
              let delimiterLength = this.__isDelimiter(buf, pos, chr);
              if (delimiterLength !== 0) {
                this.info.bytes = this.state.bufBytesStart + pos;
                const errField = this.__onField();
                if (errField !== void 0) return errField;
                pos += delimiterLength - 1;
                continue;
              }
            }
          }
          if (this.state.commenting === false) {
            if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
              const err = this.__error(
                new CsvError("CSV_MAX_RECORD_SIZE", [
                  "Max Record Size:",
                  "record exceed the maximum number of tolerated bytes",
                  `of ${max_record_size}`,
                  `at line ${this.info.lines}`
                ], this.options, this.__infoField())
              );
              if (err !== void 0) return err;
            }
          }
          const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr);
          const rappend = rtrim === false || this.state.wasQuoting === false;
          if (lappend === true && rappend === true) {
            this.state.field.append(chr);
          } else if (rtrim === true && !this.__isCharTrimable(chr)) {
            const err = this.__error(
              new CsvError("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE", [
                "Invalid Closing Quote:",
                "found non trimable byte after quote",
                `at line ${this.info.lines}`
              ], this.options, this.__infoField())
            );
            if (err !== void 0) return err;
          }
        }
        if (end === true) {
          if (this.state.quoting === true) {
            const err = this.__error(
              new CsvError("CSV_QUOTE_NOT_CLOSED", [
                "Quote Not Closed:",
                `the parsing is finished with an opening quote at line ${this.info.lines}`
              ], this.options, this.__infoField())
            );
            if (err !== void 0) return err;
          } else {
            if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
              this.info.bytes = this.state.bufBytesStart + pos;
              const errField = this.__onField();
              if (errField !== void 0) return errField;
              const errRecord = this.__onRecord();
              if (errRecord !== void 0) return errRecord;
            } else if (this.state.wasRowDelimiter === true) {
              this.info.empty_lines++;
            } else if (this.state.commenting === true) {
              this.info.comment_lines++;
            }
          }
        } else {
          this.state.bufBytesStart += pos;
          this.state.previousBuf = buf.slice(pos);
        }
        if (this.state.wasRowDelimiter === true) {
          this.info.lines++;
          this.state.wasRowDelimiter = false;
        }
      }
      __onRecord() {
        const { columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values } = this.options;
        const { enabled, record } = this.state;
        if (enabled === false) {
          return this.__resetRecord();
        }
        const recordLength = record.length;
        if (columns === true) {
          if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {
            this.__resetRecord();
            return;
          }
          return this.__firstLineToColumns(record);
        }
        if (columns === false && this.info.records === 0) {
          this.state.expectedRecordLength = recordLength;
        }
        if (recordLength !== this.state.expectedRecordLength) {
          const err = columns === false ? (
            // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to
            // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH
            new CsvError("CSV_INCONSISTENT_RECORD_LENGTH", [
              "Invalid Record Length:",
              `expect ${this.state.expectedRecordLength},`,
              `got ${recordLength} on line ${this.info.lines}`
            ], this.options, this.__infoField(), {
              record
            })
          ) : (
            // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to
            // CSV_RECORD_INCONSISTENT_COLUMNS
            new CsvError("CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH", [
              "Invalid Record Length:",
              `columns length is ${columns.length},`,
              // rename columns
              `got ${recordLength} on line ${this.info.lines}`
            ], this.options, this.__infoField(), {
              record
            })
          );
          if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {
            this.info.invalid_field_length++;
            this.state.error = err;
          } else {
            const finalErr = this.__error(err);
            if (finalErr) return finalErr;
          }
        }
        if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {
          this.__resetRecord();
          return;
        }
        if (this.state.recordHasError === true) {
          this.__resetRecord();
          this.state.recordHasError = false;
          return;
        }
        this.info.records++;
        if (from === 1 || this.info.records >= from) {
          if (columns !== false) {
            const obj = {};
            for (let i = 0, l = record.length; i < l; i++) {
              if (columns[i] === void 0 || columns[i].disabled) continue;
              if (columns_duplicates_to_array === true && obj[columns[i].name] !== void 0) {
                if (Array.isArray(obj[columns[i].name])) {
                  obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                } else {
                  obj[columns[i].name] = [obj[columns[i].name], record[i]];
                }
              } else {
                obj[columns[i].name] = record[i];
              }
            }
            const { objname } = this.options;
            if (objname === void 0) {
              if (raw === true || info === true) {
                const err = this.__push(Object.assign(
                  { record: obj },
                  raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {},
                  info === true ? { info: this.__infoRecord() } : {}
                ));
                if (err) {
                  return err;
                }
              } else {
                const err = this.__push(obj);
                if (err) {
                  return err;
                }
              }
            } else {
              if (raw === true || info === true) {
                const err = this.__push(Object.assign(
                  { record: [obj[objname], obj] },
                  raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {},
                  info === true ? { info: this.__infoRecord() } : {}
                ));
                if (err) {
                  return err;
                }
              } else {
                const err = this.__push([obj[objname], obj]);
                if (err) {
                  return err;
                }
              }
            }
          } else {
            if (raw === true || info === true) {
              const err = this.__push(Object.assign(
                { record },
                raw === true ? { raw: this.state.rawBuffer.toString(encoding) } : {},
                info === true ? { info: this.__infoRecord() } : {}
              ));
              if (err) {
                return err;
              }
            } else {
              const err = this.__push(record);
              if (err) {
                return err;
              }
            }
          }
        }
        this.__resetRecord();
      }
      __firstLineToColumns(record) {
        const { firstLineToHeaders } = this.state;
        try {
          const headers = firstLineToHeaders === void 0 ? record : firstLineToHeaders.call(null, record);
          if (!Array.isArray(headers)) {
            return this.__error(
              new CsvError("CSV_INVALID_COLUMN_MAPPING", [
                "Invalid Column Mapping:",
                "expect an array from column function,",
                `got ${JSON.stringify(headers)}`
              ], this.options, this.__infoField(), {
                headers
              })
            );
          }
          const normalizedHeaders = normalizeColumnsArray(headers);
          this.state.expectedRecordLength = normalizedHeaders.length;
          this.options.columns = normalizedHeaders;
          this.__resetRecord();
          return;
        } catch (err) {
          return err;
        }
      }
      __resetRecord() {
        if (this.options.raw === true) {
          this.state.rawBuffer.reset();
        }
        this.state.error = void 0;
        this.state.record = [];
        this.state.record_length = 0;
      }
      __onField() {
        const { cast, encoding, rtrim, max_record_size } = this.options;
        const { enabled, wasQuoting } = this.state;
        if (enabled === false) {
          return this.__resetField();
        }
        let field = this.state.field.toString(encoding);
        if (rtrim === true && wasQuoting === false) {
          field = field.trimRight();
        }
        if (cast === true) {
          const [err, f] = this.__cast(field);
          if (err !== void 0) return err;
          field = f;
        }
        this.state.record.push(field);
        if (max_record_size !== 0 && typeof field === "string") {
          this.state.record_length += field.length;
        }
        this.__resetField();
      }
      __resetField() {
        this.state.field.reset();
        this.state.wasQuoting = false;
      }
      __push(record) {
        const { on_record } = this.options;
        if (on_record !== void 0) {
          const info = this.__infoRecord();
          try {
            record = on_record.call(null, record, info);
          } catch (err) {
            return err;
          }
          if (record === void 0 || record === null) {
            return;
          }
        }
        this.push(record);
      }
      // Return a tuple with the error and the casted value
      __cast(field) {
        const { columns, relax_column_count } = this.options;
        const isColumns = Array.isArray(columns);
        if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
          return [void 0, void 0];
        }
        if (this.state.castField !== null) {
          try {
            const info = this.__infoField();
            return [void 0, this.state.castField.call(null, field, info)];
          } catch (err) {
            return [err];
          }
        }
        if (this.__isFloat(field)) {
          return [void 0, parseFloat(field)];
        } else if (this.options.cast_date !== false) {
          const info = this.__infoField();
          return [void 0, this.options.cast_date.call(null, field, info)];
        }
        return [void 0, field];
      }
      // Helper to test if a character is a space or a line delimiter
      __isCharTrimable(chr) {
        return chr === space || chr === tab || chr === cr || chr === nl || chr === np;
      }
      // Keep it in case we implement the `cast_int` option
      // __isInt(value){
      //   // return Number.isInteger(parseInt(value))
      //   // return !isNaN( parseInt( obj ) );
      //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
      // }
      __isFloat(value) {
        return value - parseFloat(value) + 1 >= 0;
      }
      __compareBytes(sourceBuf, targetBuf, targetPos, firstByte) {
        if (sourceBuf[0] !== firstByte) return 0;
        const sourceLength = sourceBuf.length;
        for (let i = 1; i < sourceLength; i++) {
          if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;
        }
        return sourceLength;
      }
      __needMoreData(i, bufLen, end) {
        if (end) return false;
        const { quote } = this.options;
        const { quoting, needMoreDataSize, recordDelimiterMaxLength } = this.state;
        const numOfCharLeft = bufLen - i - 1;
        const requiredLength = Math.max(
          needMoreDataSize,
          // Skip if the remaining buffer smaller than record delimiter
          recordDelimiterMaxLength,
          // Skip if the remaining buffer can be record delimiter following the closing quote
          // 1 is for quote.length
          quoting ? quote.length + recordDelimiterMaxLength : 0
        );
        return numOfCharLeft < requiredLength;
      }
      __isDelimiter(buf, pos, chr) {
        const { delimiter, ignore_last_delimiters } = this.options;
        if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
          return 0;
        } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === "number" && this.state.record.length === ignore_last_delimiters - 1) {
          return 0;
        }
        loop1: for (let i = 0; i < delimiter.length; i++) {
          const del = delimiter[i];
          if (del[0] === chr) {
            for (let j = 1; j < del.length; j++) {
              if (del[j] !== buf[pos + j]) continue loop1;
            }
            return del.length;
          }
        }
        return 0;
      }
      __isRecordDelimiter(chr, buf, pos) {
        const { record_delimiter } = this.options;
        const recordDelimiterLength = record_delimiter.length;
        loop1: for (let i = 0; i < recordDelimiterLength; i++) {
          const rd = record_delimiter[i];
          const rdLength = rd.length;
          if (rd[0] !== chr) {
            continue;
          }
          for (let j = 1; j < rdLength; j++) {
            if (rd[j] !== buf[pos + j]) {
              continue loop1;
            }
          }
          return rd.length;
        }
        return 0;
      }
      __isEscape(buf, pos, chr) {
        const { escape } = this.options;
        if (escape === null) return false;
        const l = escape.length;
        if (escape[0] === chr) {
          for (let i = 0; i < l; i++) {
            if (escape[i] !== buf[pos + i]) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      __isQuote(buf, pos) {
        const { quote } = this.options;
        if (quote === null) return false;
        const l = quote.length;
        for (let i = 0; i < l; i++) {
          if (quote[i] !== buf[pos + i]) {
            return false;
          }
        }
        return true;
      }
      __autoDiscoverRecordDelimiter(buf, pos) {
        const { encoding } = this.options;
        const chr = buf[pos];
        if (chr === cr) {
          if (buf[pos + 1] === nl) {
            this.options.record_delimiter.push(Buffer.from("\r\n", encoding));
            this.state.recordDelimiterMaxLength = 2;
            return 2;
          } else {
            this.options.record_delimiter.push(Buffer.from("\r", encoding));
            this.state.recordDelimiterMaxLength = 1;
            return 1;
          }
        } else if (chr === nl) {
          this.options.record_delimiter.push(Buffer.from("\n", encoding));
          this.state.recordDelimiterMaxLength = 1;
          return 1;
        }
        return 0;
      }
      __error(msg) {
        const { skip_lines_with_error } = this.options;
        const err = typeof msg === "string" ? new Error(msg) : msg;
        if (skip_lines_with_error) {
          this.state.recordHasError = true;
          this.emit("skip", err);
          return void 0;
        } else {
          return err;
        }
      }
      __infoDataSet() {
        return {
          ...this.info,
          columns: this.options.columns
        };
      }
      __infoRecord() {
        const { columns } = this.options;
        return {
          ...this.__infoDataSet(),
          error: this.state.error,
          header: columns === true,
          index: this.state.record.length
        };
      }
      __infoField() {
        const { columns } = this.options;
        const isColumns = Array.isArray(columns);
        return {
          ...this.__infoRecord(),
          column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,
          quoting: this.state.wasQuoting
        };
      }
    };
    var parse2 = function() {
      let data, options, callback;
      for (let i in arguments) {
        const argument = arguments[i];
        const type = typeof argument;
        if (data === void 0 && (typeof argument === "string" || Buffer.isBuffer(argument))) {
          data = argument;
        } else if (options === void 0 && isObject(argument)) {
          options = argument;
        } else if (callback === void 0 && type === "function") {
          callback = argument;
        } else {
          throw new CsvError("CSV_INVALID_ARGUMENT", [
            "Invalid argument:",
            `got ${JSON.stringify(argument)} at index ${i}`
          ], options || {});
        }
      }
      const parser = new Parser(options);
      if (callback) {
        const records = options === void 0 || options.objname === void 0 ? [] : {};
        parser.on("readable", function() {
          let record;
          while ((record = this.read()) !== null) {
            if (options === void 0 || options.objname === void 0) {
              records.push(record);
            } else {
              records[record[0]] = record[1];
            }
          }
        });
        parser.on("error", function(err) {
          callback(err, void 0, parser.__infoDataSet());
        });
        parser.on("end", function() {
          callback(void 0, records, parser.__infoDataSet());
        });
      }
      if (data !== void 0) {
        if (typeof setImmediate === "function") {
          setImmediate(function() {
            parser.write(data);
            parser.end();
          });
        } else {
          parser.write(data);
          parser.end();
        }
      }
      return parser;
    };
    var CsvError = class _CsvError extends Error {
      constructor(code, message, options, ...contexts) {
        if (Array.isArray(message)) message = message.join(" ");
        super(message);
        if (Error.captureStackTrace !== void 0) {
          Error.captureStackTrace(this, _CsvError);
        }
        this.code = code;
        for (const context of contexts) {
          for (const key in context) {
            const value = context[key];
            this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
          }
        }
      }
    };
    parse2.Parser = Parser;
    parse2.CsvError = CsvError;
    module2.exports = parse2;
    var underscore = function(str) {
      return str.replace(/([A-Z])/g, function(_, match) {
        return "_" + match.toLowerCase();
      });
    };
    var isObject = function(obj) {
      return typeof obj === "object" && obj !== null && !Array.isArray(obj);
    };
    var isRecordEmpty = function(record) {
      return record.every((field) => field == null || field.toString && field.toString().trim() === "");
    };
    var normalizeColumnsArray = function(columns) {
      const normalizedColumns = [];
      for (let i = 0, l = columns.length; i < l; i++) {
        const column = columns[i];
        if (column === void 0 || column === null || column === false) {
          normalizedColumns[i] = { disabled: true };
        } else if (typeof column === "string") {
          normalizedColumns[i] = { name: column };
        } else if (isObject(column)) {
          if (typeof column.name !== "string") {
            throw new CsvError("CSV_OPTION_COLUMNS_MISSING_NAME", [
              "Option columns missing name:",
              `property "name" is required at position ${i}`,
              "when column is an object literal"
            ]);
          }
          normalizedColumns[i] = column;
        } else {
          throw new CsvError("CSV_INVALID_COLUMN_DEFINITION", [
            "Invalid column definition:",
            "expect a string or a literal object,",
            `got ${JSON.stringify(column)} at position ${i}`
          ]);
        }
      }
      return normalizedColumns;
    };
  }
});

// node_modules/jsonparse/jsonparse.js
var require_jsonparse = __commonJS({
  "node_modules/jsonparse/jsonparse.js"(exports2, module2) {
    var C = {};
    var LEFT_BRACE = C.LEFT_BRACE = 1;
    var RIGHT_BRACE = C.RIGHT_BRACE = 2;
    var LEFT_BRACKET = C.LEFT_BRACKET = 3;
    var RIGHT_BRACKET = C.RIGHT_BRACKET = 4;
    var COLON = C.COLON = 5;
    var COMMA = C.COMMA = 6;
    var TRUE = C.TRUE = 7;
    var FALSE = C.FALSE = 8;
    var NULL = C.NULL = 9;
    var STRING = C.STRING = 10;
    var NUMBER = C.NUMBER = 11;
    var START = C.START = 17;
    var STOP = C.STOP = 18;
    var TRUE1 = C.TRUE1 = 33;
    var TRUE2 = C.TRUE2 = 34;
    var TRUE3 = C.TRUE3 = 35;
    var FALSE1 = C.FALSE1 = 49;
    var FALSE2 = C.FALSE2 = 50;
    var FALSE3 = C.FALSE3 = 51;
    var FALSE4 = C.FALSE4 = 52;
    var NULL1 = C.NULL1 = 65;
    var NULL2 = C.NULL2 = 66;
    var NULL3 = C.NULL3 = 67;
    var NUMBER1 = C.NUMBER1 = 81;
    var NUMBER3 = C.NUMBER3 = 83;
    var STRING1 = C.STRING1 = 97;
    var STRING2 = C.STRING2 = 98;
    var STRING3 = C.STRING3 = 99;
    var STRING4 = C.STRING4 = 100;
    var STRING5 = C.STRING5 = 101;
    var STRING6 = C.STRING6 = 102;
    var VALUE = C.VALUE = 113;
    var KEY = C.KEY = 114;
    var OBJECT = C.OBJECT = 129;
    var ARRAY = C.ARRAY = 130;
    var BACK_SLASH = "\\".charCodeAt(0);
    var FORWARD_SLASH = "/".charCodeAt(0);
    var BACKSPACE = "\b".charCodeAt(0);
    var FORM_FEED = "\f".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var CARRIAGE_RETURN = "\r".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var STRING_BUFFER_SIZE = 64 * 1024;
    function Parser() {
      this.tState = START;
      this.value = void 0;
      this.string = void 0;
      this.stringBuffer = Buffer.alloc ? Buffer.alloc(STRING_BUFFER_SIZE) : new Buffer(STRING_BUFFER_SIZE);
      this.stringBufferOffset = 0;
      this.unicode = void 0;
      this.highSurrogate = void 0;
      this.key = void 0;
      this.mode = void 0;
      this.stack = [];
      this.state = VALUE;
      this.bytes_remaining = 0;
      this.bytes_in_sequence = 0;
      this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) };
      this.offset = -1;
    }
    Parser.toknam = function(code) {
      var keys = Object.keys(C);
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (C[key] === code) {
          return key;
        }
      }
      return code && "0x" + code.toString(16);
    };
    var proto = Parser.prototype;
    proto.onError = function(err) {
      throw err;
    };
    proto.charError = function(buffer, i) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
    };
    proto.appendStringChar = function(char) {
      if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
        this.string += this.stringBuffer.toString("utf8");
        this.stringBufferOffset = 0;
      }
      this.stringBuffer[this.stringBufferOffset++] = char;
    };
    proto.appendStringBuf = function(buf, start, end) {
      var size = buf.length;
      if (typeof start === "number") {
        if (typeof end === "number") {
          if (end < 0) {
            size = buf.length - start + end;
          } else {
            size = end - start;
          }
        } else {
          size = buf.length - start;
        }
      }
      if (size < 0) {
        size = 0;
      }
      if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
        this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
        this.stringBufferOffset = 0;
      }
      buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
      this.stringBufferOffset += size;
    };
    proto.write = function(buffer) {
      if (typeof buffer === "string") buffer = new Buffer(buffer);
      var n;
      for (var i = 0, l = buffer.length; i < l; i++) {
        if (this.tState === START) {
          n = buffer[i];
          this.offset++;
          if (n === 123) {
            this.onToken(LEFT_BRACE, "{");
          } else if (n === 125) {
            this.onToken(RIGHT_BRACE, "}");
          } else if (n === 91) {
            this.onToken(LEFT_BRACKET, "[");
          } else if (n === 93) {
            this.onToken(RIGHT_BRACKET, "]");
          } else if (n === 58) {
            this.onToken(COLON, ":");
          } else if (n === 44) {
            this.onToken(COMMA, ",");
          } else if (n === 116) {
            this.tState = TRUE1;
          } else if (n === 102) {
            this.tState = FALSE1;
          } else if (n === 110) {
            this.tState = NULL1;
          } else if (n === 34) {
            this.string = "";
            this.stringBufferOffset = 0;
            this.tState = STRING1;
          } else if (n === 45) {
            this.string = "-";
            this.tState = NUMBER1;
          } else {
            if (n >= 48 && n < 64) {
              this.string = String.fromCharCode(n);
              this.tState = NUMBER3;
            } else if (n === 32 || n === 9 || n === 10 || n === 13) {
            } else {
              return this.charError(buffer, i);
            }
          }
        } else if (this.tState === STRING1) {
          n = buffer[i];
          if (this.bytes_remaining > 0) {
            for (var j = 0; j < this.bytes_remaining; j++) {
              this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
            }
            this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
            this.bytes_in_sequence = this.bytes_remaining = 0;
            i = i + j - 1;
          } else if (this.bytes_remaining === 0 && n >= 128) {
            if (n <= 193 || n > 244) {
              return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
            }
            if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;
            if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;
            if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;
            if (this.bytes_in_sequence + i > buffer.length) {
              for (var k = 0; k <= buffer.length - 1 - i; k++) {
                this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
              }
              this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
              i = buffer.length - 1;
            } else {
              this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
              i = i + this.bytes_in_sequence - 1;
            }
          } else if (n === 34) {
            this.tState = START;
            this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
            this.stringBufferOffset = 0;
            this.onToken(STRING, this.string);
            this.offset += Buffer.byteLength(this.string, "utf8") + 1;
            this.string = void 0;
          } else if (n === 92) {
            this.tState = STRING2;
          } else if (n >= 32) {
            this.appendStringChar(n);
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === STRING2) {
          n = buffer[i];
          if (n === 34) {
            this.appendStringChar(n);
            this.tState = STRING1;
          } else if (n === 92) {
            this.appendStringChar(BACK_SLASH);
            this.tState = STRING1;
          } else if (n === 47) {
            this.appendStringChar(FORWARD_SLASH);
            this.tState = STRING1;
          } else if (n === 98) {
            this.appendStringChar(BACKSPACE);
            this.tState = STRING1;
          } else if (n === 102) {
            this.appendStringChar(FORM_FEED);
            this.tState = STRING1;
          } else if (n === 110) {
            this.appendStringChar(NEWLINE);
            this.tState = STRING1;
          } else if (n === 114) {
            this.appendStringChar(CARRIAGE_RETURN);
            this.tState = STRING1;
          } else if (n === 116) {
            this.appendStringChar(TAB);
            this.tState = STRING1;
          } else if (n === 117) {
            this.unicode = "";
            this.tState = STRING3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
          n = buffer[i];
          if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
            this.unicode += String.fromCharCode(n);
            if (this.tState++ === STRING6) {
              var intVal = parseInt(this.unicode, 16);
              this.unicode = void 0;
              if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal)));
                this.highSurrogate = void 0;
              } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                this.highSurrogate = intVal;
              } else {
                if (this.highSurrogate !== void 0) {
                  this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate)));
                  this.highSurrogate = void 0;
                }
                this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));
              }
              this.tState = STRING1;
            }
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
          n = buffer[i];
          switch (n) {
            case 48:
            // 0
            case 49:
            // 1
            case 50:
            // 2
            case 51:
            // 3
            case 52:
            // 4
            case 53:
            // 5
            case 54:
            // 6
            case 55:
            // 7
            case 56:
            // 8
            case 57:
            // 9
            case 46:
            // .
            case 101:
            // e
            case 69:
            // E
            case 43:
            // +
            case 45:
              this.string += String.fromCharCode(n);
              this.tState = NUMBER3;
              break;
            default:
              this.tState = START;
              var result2 = Number(this.string);
              if (isNaN(result2)) {
                return this.charError(buffer, i);
              }
              if (this.string.match(/[0-9]+/) == this.string && result2.toString() != this.string) {
                this.onToken(STRING, this.string);
              } else {
                this.onToken(NUMBER, result2);
              }
              this.offset += this.string.length - 1;
              this.string = void 0;
              i--;
              break;
          }
        } else if (this.tState === TRUE1) {
          if (buffer[i] === 114) {
            this.tState = TRUE2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === TRUE2) {
          if (buffer[i] === 117) {
            this.tState = TRUE3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === TRUE3) {
          if (buffer[i] === 101) {
            this.tState = START;
            this.onToken(TRUE, true);
            this.offset += 3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE1) {
          if (buffer[i] === 97) {
            this.tState = FALSE2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE2) {
          if (buffer[i] === 108) {
            this.tState = FALSE3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE3) {
          if (buffer[i] === 115) {
            this.tState = FALSE4;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE4) {
          if (buffer[i] === 101) {
            this.tState = START;
            this.onToken(FALSE, false);
            this.offset += 4;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL1) {
          if (buffer[i] === 117) {
            this.tState = NULL2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL2) {
          if (buffer[i] === 108) {
            this.tState = NULL3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL3) {
          if (buffer[i] === 108) {
            this.tState = START;
            this.onToken(NULL, null);
            this.offset += 3;
          } else {
            return this.charError(buffer, i);
          }
        }
      }
    };
    proto.onToken = function(token, value) {
    };
    proto.parseError = function(token, value) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser.toknam(this.state)));
    };
    proto.push = function() {
      this.stack.push({ value: this.value, key: this.key, mode: this.mode });
    };
    proto.pop = function() {
      var value = this.value;
      var parent = this.stack.pop();
      this.value = parent.value;
      this.key = parent.key;
      this.mode = parent.mode;
      this.emit(value);
      if (!this.mode) {
        this.state = VALUE;
      }
    };
    proto.emit = function(value) {
      if (this.mode) {
        this.state = COMMA;
      }
      this.onValue(value);
    };
    proto.onValue = function(value) {
    };
    proto.onToken = function(token, value) {
      if (this.state === VALUE) {
        if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {
          if (this.value) {
            this.value[this.key] = value;
          }
          this.emit(value);
        } else if (token === LEFT_BRACE) {
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = {};
          } else {
            this.value = {};
          }
          this.key = void 0;
          this.state = KEY;
          this.mode = OBJECT;
        } else if (token === LEFT_BRACKET) {
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = [];
          } else {
            this.value = [];
          }
          this.key = 0;
          this.mode = ARRAY;
          this.state = VALUE;
        } else if (token === RIGHT_BRACE) {
          if (this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (token === RIGHT_BRACKET) {
          if (this.mode === ARRAY) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === KEY) {
        if (token === STRING) {
          this.key = value;
          this.state = COLON;
        } else if (token === RIGHT_BRACE) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === COLON) {
        if (token === COLON) {
          this.state = VALUE;
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === COMMA) {
        if (token === COMMA) {
          if (this.mode === ARRAY) {
            this.key++;
            this.state = VALUE;
          } else if (this.mode === OBJECT) {
            this.state = KEY;
          }
        } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      } else {
        return this.parseError(token, value);
      }
    };
    Parser.C = C;
    module2.exports = Parser;
  }
});

// node_modules/through/index.js
var require_through = __commonJS({
  "node_modules/through/index.js"(exports2, module2) {
    var Stream = require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream = new Stream();
      stream.readable = stream.writable = true;
      stream.paused = false;
      stream.autoDestroy = !(opts && opts.autoDestroy === false);
      stream.write = function(data) {
        write.call(this, data);
        return !stream.paused;
      };
      function drain() {
        while (buffer.length && !stream.paused) {
          var data = buffer.shift();
          if (null === data)
            return stream.emit("end");
          else
            stream.emit("data", data);
        }
      }
      stream.queue = stream.push = function(data) {
        if (_ended) return stream;
        if (data === null) _ended = true;
        buffer.push(data);
        drain();
        return stream;
      };
      stream.on("end", function() {
        stream.readable = false;
        if (!stream.writable && stream.autoDestroy)
          process.nextTick(function() {
            stream.destroy();
          });
      });
      function _end() {
        stream.writable = false;
        end.call(stream);
        if (!stream.readable && stream.autoDestroy)
          stream.destroy();
      }
      stream.end = function(data) {
        if (ended) return;
        ended = true;
        if (arguments.length) stream.write(data);
        _end();
        return stream;
      };
      stream.destroy = function() {
        if (destroyed) return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit("close");
        return stream;
      };
      stream.pause = function() {
        if (stream.paused) return;
        stream.paused = true;
        return stream;
      };
      stream.resume = function() {
        if (stream.paused) {
          stream.paused = false;
          stream.emit("resume");
        }
        drain();
        if (!stream.paused)
          stream.emit("drain");
        return stream;
      };
      return stream;
    }
  }
});

// node_modules/JSONStream/index.js
var require_JSONStream = __commonJS({
  "node_modules/JSONStream/index.js"(exports2) {
    "use strict";
    var Parser = require_jsonparse();
    var through = require_through();
    var bufferFrom = Buffer.from && Buffer.from !== Uint8Array.from;
    exports2.parse = function(path, map2) {
      var header, footer;
      var parser = new Parser();
      var stream = through(
        function(chunk) {
          if ("string" === typeof chunk)
            chunk = bufferFrom ? Buffer.from(chunk) : new Buffer(chunk);
          parser.write(chunk);
        },
        function(data) {
          if (data)
            stream.write(data);
          if (header)
            stream.emit("header", header);
          if (footer)
            stream.emit("footer", footer);
          stream.queue(null);
        }
      );
      if ("string" === typeof path)
        path = path.split(".").map(function(e) {
          if (e === "$*")
            return { emitKey: true };
          else if (e === "*")
            return true;
          else if (e === "")
            return { recurse: true };
          else
            return e;
        });
      var count = 0, _key;
      if (!path || !path.length)
        path = null;
      parser.onValue = function(value) {
        if (!this.root)
          stream.root = value;
        if (!path) return;
        var i = 0;
        var j = 0;
        var emitKey = false;
        var emitPath = false;
        while (i < path.length) {
          var key = path[i];
          var c;
          j++;
          if (key && !key.recurse) {
            c = j === this.stack.length ? this : this.stack[j];
            if (!c) return;
            if (!check(key, c.key)) {
              setHeaderFooter(c.key, value);
              return;
            }
            emitKey = !!key.emitKey;
            emitPath = !!key.emitPath;
            i++;
          } else {
            i++;
            var nextKey = path[i];
            if (!nextKey) return;
            while (true) {
              c = j === this.stack.length ? this : this.stack[j];
              if (!c) return;
              if (check(nextKey, c.key)) {
                i++;
                if (!Object.isFrozen(this.stack[j]))
                  this.stack[j].value = null;
                break;
              } else {
                setHeaderFooter(c.key, value);
              }
              j++;
            }
          }
        }
        if (header) {
          stream.emit("header", header);
          header = false;
        }
        if (j !== this.stack.length) return;
        count++;
        var actualPath = this.stack.slice(1).map(function(element) {
          return element.key;
        }).concat([this.key]);
        var data = value;
        if (null != data) {
          if (null != (data = map2 ? map2(data, actualPath) : data)) {
            if (emitKey || emitPath) {
              data = { value: data };
              if (emitKey)
                data["key"] = this.key;
              if (emitPath)
                data["path"] = actualPath;
            }
            stream.queue(data);
          }
        }
        if (this.value) delete this.value[this.key];
        for (var k in this.stack)
          if (!Object.isFrozen(this.stack[k]))
            this.stack[k].value = null;
      };
      parser._onToken = parser.onToken;
      parser.onToken = function(token, value) {
        parser._onToken(token, value);
        if (this.stack.length === 0) {
          if (stream.root) {
            if (!path)
              stream.queue(stream.root);
            count = 0;
            stream.root = null;
          }
        }
      };
      parser.onError = function(err) {
        if (err.message.indexOf("at position") > -1)
          err.message = "Invalid JSON (" + err.message + ")";
        stream.emit("error", err);
      };
      return stream;
      function setHeaderFooter(key, value) {
        if (header !== false) {
          header = header || {};
          header[key] = value;
        }
        if (footer !== false && header === false) {
          footer = footer || {};
          footer[key] = value;
        }
      }
    };
    function check(x, y) {
      if ("string" === typeof x)
        return y == x;
      else if (x && "function" === typeof x.exec)
        return x.exec(y);
      else if ("boolean" === typeof x || "object" === typeof x)
        return x;
      else if ("function" === typeof x)
        return x(y);
      return false;
    }
    exports2.stringify = function(op, sep, cl, indent) {
      indent = indent || 0;
      if (op === false) {
        op = "";
        sep = "\n";
        cl = "";
      } else if (op == null) {
        op = "[\n";
        sep = "\n,\n";
        cl = "\n]\n";
      }
      var stream, first = true, anyData = false;
      stream = through(
        function(data) {
          anyData = true;
          try {
            var json = JSON.stringify(data, null, indent);
          } catch (err) {
            return stream.emit("error", err);
          }
          if (first) {
            first = false;
            stream.queue(op + json);
          } else stream.queue(sep + json);
        },
        function(data) {
          if (!anyData)
            stream.queue(op);
          stream.queue(cl);
          stream.queue(null);
        }
      );
      return stream;
    };
    exports2.stringifyObject = function(op, sep, cl, indent) {
      indent = indent || 0;
      if (op === false) {
        op = "";
        sep = "\n";
        cl = "";
      } else if (op == null) {
        op = "{\n";
        sep = "\n,\n";
        cl = "\n}\n";
      }
      var first = true;
      var anyData = false;
      var stream = through(
        function(data) {
          anyData = true;
          var json = JSON.stringify(data[0]) + ":" + JSON.stringify(data[1], null, indent);
          if (first) {
            first = false;
            this.queue(op + json);
          } else this.queue(sep + json);
        },
        function(data) {
          if (!anyData) this.queue(op);
          this.queue(cl);
          this.queue(null);
        }
      );
      return stream;
    };
  }
});

// node_modules/geojson-stream/index.js
var require_geojson_stream = __commonJS({
  "node_modules/geojson-stream/index.js"(exports2, module2) {
    var JSONStream = require_JSONStream();
    var open = '{"type":"FeatureCollection","features":[';
    var close = "]}";
    module2.exports.parse = function(mapFunc) {
      var indexFunc;
      if (mapFunc) {
        indexFunc = function(feature, context) {
          return mapFunc(feature, context[1]);
        };
      }
      var jsonstream = JSONStream.parse("features.*", indexFunc);
      return jsonstream;
    };
    module2.exports.stringify = function() {
      var jsonstream = JSONStream.stringify(open, "\n,\n", close);
      return jsonstream;
    };
  }
});

// node_modules/text-encoding/lib/encoding-indexes.js
var require_encoding_indexes = __commonJS({
  "node_modules/text-encoding/lib/encoding-indexes.js"(exports2, module2) {
    (function(global2) {
      "use strict";
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = global2;
      }
      global2["encoding-indexes"] = {
        "big5": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 17392, 19506, 17923, 17830, 17784, 160359, 19831, 17843, 162993, 19682, 163013, 15253, 18230, 18244, 19527, 19520, 148159, 144919, 160594, 159371, 159954, 19543, 172881, 18255, 17882, 19589, 162924, 19719, 19108, 18081, 158499, 29221, 154196, 137827, 146950, 147297, 26189, 22267, null, 32149, 22813, 166841, 15860, 38708, 162799, 23515, 138590, 23204, 13861, 171696, 23249, 23479, 23804, 26478, 34195, 170309, 29793, 29853, 14453, 138579, 145054, 155681, 16108, 153822, 15093, 31484, 40855, 147809, 166157, 143850, 133770, 143966, 17162, 33924, 40854, 37935, 18736, 34323, 22678, 38730, 37400, 31184, 31282, 26208, 27177, 34973, 29772, 31685, 26498, 31276, 21071, 36934, 13542, 29636, 155065, 29894, 40903, 22451, 18735, 21580, 16689, 145038, 22552, 31346, 162661, 35727, 18094, 159368, 16769, 155033, 31662, 140476, 40904, 140481, 140489, 140492, 40905, 34052, 144827, 16564, 40906, 17633, 175615, 25281, 28782, 40907, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 12736, 12737, 12738, 12739, 12740, 131340, 12741, 131281, 131277, 12742, 12743, 131275, 139240, 12744, 131274, 12745, 12746, 12747, 12748, 131342, 12749, 12750, 256, 193, 461, 192, 274, 201, 282, 200, 332, 211, 465, 210, null, 7870, null, 7872, 202, 257, 225, 462, 224, 593, 275, 233, 283, 232, 299, 237, 464, 236, 333, 243, 466, 242, 363, 250, 468, 249, 470, 472, 474, 476, 252, null, 7871, null, 7873, 234, 609, 9178, 9179, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 172969, 135493, null, 25866, null, null, 20029, 28381, 40270, 37343, null, null, 161589, 25745, 20250, 20264, 20392, 20822, 20852, 20892, 20964, 21153, 21160, 21307, 21326, 21457, 21464, 22242, 22768, 22788, 22791, 22834, 22836, 23398, 23454, 23455, 23706, 24198, 24635, 25993, 26622, 26628, 26725, 27982, 28860, 30005, 32420, 32428, 32442, 32455, 32463, 32479, 32518, 32567, 33402, 33487, 33647, 35270, 35774, 35810, 36710, 36711, 36718, 29713, 31996, 32205, 26950, 31433, 21031, null, null, null, null, 37260, 30904, 37214, 32956, null, 36107, 33014, 133607, null, null, 32927, 40647, 19661, 40393, 40460, 19518, 171510, 159758, 40458, 172339, 13761, null, 28314, 33342, 29977, null, 18705, 39532, 39567, 40857, 31111, 164972, 138698, 132560, 142054, 20004, 20097, 20096, 20103, 20159, 20203, 20279, 13388, 20413, 15944, 20483, 20616, 13437, 13459, 13477, 20870, 22789, 20955, 20988, 20997, 20105, 21113, 21136, 21287, 13767, 21417, 13649, 21424, 13651, 21442, 21539, 13677, 13682, 13953, 21651, 21667, 21684, 21689, 21712, 21743, 21784, 21795, 21800, 13720, 21823, 13733, 13759, 21975, 13765, 163204, 21797, null, 134210, 134421, 151851, 21904, 142534, 14828, 131905, 36422, 150968, 169189, 16467, 164030, 30586, 142392, 14900, 18389, 164189, 158194, 151018, 25821, 134524, 135092, 134357, 135412, 25741, 36478, 134806, 134155, 135012, 142505, 164438, 148691, null, 134470, 170573, 164073, 18420, 151207, 142530, 39602, 14951, 169460, 16365, 13574, 152263, 169940, 161992, 142660, 40302, 38933, null, 17369, 155813, 25780, 21731, 142668, 142282, 135287, 14843, 135279, 157402, 157462, 162208, 25834, 151634, 134211, 36456, 139681, 166732, 132913, null, 18443, 131497, 16378, 22643, 142733, null, 148936, 132348, 155799, 134988, 134550, 21881, 16571, 17338, null, 19124, 141926, 135325, 33194, 39157, 134556, 25465, 14846, 141173, 36288, 22177, 25724, 15939, null, 173569, 134665, 142031, 142537, null, 135368, 145858, 14738, 14854, 164507, 13688, 155209, 139463, 22098, 134961, 142514, 169760, 13500, 27709, 151099, null, null, 161140, 142987, 139784, 173659, 167117, 134778, 134196, 157724, 32659, 135375, 141315, 141625, 13819, 152035, 134796, 135053, 134826, 16275, 134960, 134471, 135503, 134732, null, 134827, 134057, 134472, 135360, 135485, 16377, 140950, 25650, 135085, 144372, 161337, 142286, 134526, 134527, 142417, 142421, 14872, 134808, 135367, 134958, 173618, 158544, 167122, 167321, 167114, 38314, 21708, 33476, 21945, null, 171715, 39974, 39606, 161630, 142830, 28992, 33133, 33004, 23580, 157042, 33076, 14231, 21343, 164029, 37302, 134906, 134671, 134775, 134907, 13789, 151019, 13833, 134358, 22191, 141237, 135369, 134672, 134776, 135288, 135496, 164359, 136277, 134777, 151120, 142756, 23124, 135197, 135198, 135413, 135414, 22428, 134673, 161428, 164557, 135093, 134779, 151934, 14083, 135094, 135552, 152280, 172733, 149978, 137274, 147831, 164476, 22681, 21096, 13850, 153405, 31666, 23400, 18432, 19244, 40743, 18919, 39967, 39821, 154484, 143677, 22011, 13810, 22153, 20008, 22786, 138177, 194680, 38737, 131206, 20059, 20155, 13630, 23587, 24401, 24516, 14586, 25164, 25909, 27514, 27701, 27706, 28780, 29227, 20012, 29357, 149737, 32594, 31035, 31993, 32595, 156266, 13505, null, 156491, 32770, 32896, 157202, 158033, 21341, 34916, 35265, 161970, 35744, 36125, 38021, 38264, 38271, 38376, 167439, 38886, 39029, 39118, 39134, 39267, 17e4, 40060, 40479, 40644, 27503, 63751, 20023, 131207, 38429, 25143, 38050, null, 20539, 28158, 171123, 40870, 15817, 34959, 147790, 28791, 23797, 19232, 152013, 13657, 154928, 24866, 166450, 36775, 37366, 29073, 26393, 29626, 144001, 172295, 15499, 137600, 19216, 30948, 29698, 20910, 165647, 16393, 27235, 172730, 16931, 34319, 133743, 31274, 170311, 166634, 38741, 28749, 21284, 139390, 37876, 30425, 166371, 40871, 30685, 20131, 20464, 20668, 20015, 20247, 40872, 21556, 32139, 22674, 22736, 138678, 24210, 24217, 24514, 141074, 25995, 144377, 26905, 27203, 146531, 27903, null, 29184, 148741, 29580, 16091, 150035, 23317, 29881, 35715, 154788, 153237, 31379, 31724, 31939, 32364, 33528, 34199, 40873, 34960, 40874, 36537, 40875, 36815, 34143, 39392, 37409, 40876, 167353, 136255, 16497, 17058, 23066, null, null, null, 39016, 26475, 17014, 22333, null, 34262, 149883, 33471, 160013, 19585, 159092, 23931, 158485, 159678, 40877, 40878, 23446, 40879, 26343, 32347, 28247, 31178, 15752, 17603, 143958, 141206, 17306, 17718, null, 23765, 146202, 35577, 23672, 15634, 144721, 23928, 40882, 29015, 17752, 147692, 138787, 19575, 14712, 13386, 131492, 158785, 35532, 20404, 131641, 22975, 33132, 38998, 170234, 24379, 134047, null, 139713, 166253, 16642, 18107, 168057, 16135, 40883, 172469, 16632, 14294, 18167, 158790, 16764, 165554, 160767, 17773, 14548, 152730, 17761, 17691, 19849, 19579, 19830, 17898, 16328, 150287, 13921, 17630, 17597, 16877, 23870, 23880, 23894, 15868, 14351, 23972, 23993, 14368, 14392, 24130, 24253, 24357, 24451, 14600, 14612, 14655, 14669, 24791, 24893, 23781, 14729, 25015, 25017, 25039, 14776, 25132, 25232, 25317, 25368, 14840, 22193, 14851, 25570, 25595, 25607, 25690, 14923, 25792, 23829, 22049, 40863, 14999, 25990, 15037, 26111, 26195, 15090, 26258, 15138, 26390, 15170, 26532, 26624, 15192, 26698, 26756, 15218, 15217, 15227, 26889, 26947, 29276, 26980, 27039, 27013, 15292, 27094, 15325, 27237, 27252, 27249, 27266, 15340, 27289, 15346, 27307, 27317, 27348, 27382, 27521, 27585, 27626, 27765, 27818, 15563, 27906, 27910, 27942, 28033, 15599, 28068, 28081, 28181, 28184, 28201, 28294, 166336, 28347, 28386, 28378, 40831, 28392, 28393, 28452, 28468, 15686, 147265, 28545, 28606, 15722, 15733, 29111, 23705, 15754, 28716, 15761, 28752, 28756, 28783, 28799, 28809, 131877, 17345, 13809, 134872, 147159, 22462, 159443, 28990, 153568, 13902, 27042, 166889, 23412, 31305, 153825, 169177, 31333, 31357, 154028, 31419, 31408, 31426, 31427, 29137, 156813, 16842, 31450, 31453, 31466, 16879, 21682, 154625, 31499, 31573, 31529, 152334, 154878, 31650, 31599, 33692, 154548, 158847, 31696, 33825, 31634, 31672, 154912, 15789, 154725, 33938, 31738, 31750, 31797, 154817, 31812, 31875, 149634, 31910, 26237, 148856, 31945, 31943, 31974, 31860, 31987, 31989, 31950, 32359, 17693, 159300, 32093, 159446, 29837, 32137, 32171, 28981, 32179, 32210, 147543, 155689, 32228, 15635, 32245, 137209, 32229, 164717, 32285, 155937, 155994, 32366, 32402, 17195, 37996, 32295, 32576, 32577, 32583, 31030, 156368, 39393, 32663, 156497, 32675, 136801, 131176, 17756, 145254, 17667, 164666, 32762, 156809, 32773, 32776, 32797, 32808, 32815, 172167, 158915, 32827, 32828, 32865, 141076, 18825, 157222, 146915, 157416, 26405, 32935, 166472, 33031, 33050, 22704, 141046, 27775, 156824, 151480, 25831, 136330, 33304, 137310, 27219, 150117, 150165, 17530, 33321, 133901, 158290, 146814, 20473, 136445, 34018, 33634, 158474, 149927, 144688, 137075, 146936, 33450, 26907, 194964, 16859, 34123, 33488, 33562, 134678, 137140, 14017, 143741, 144730, 33403, 33506, 33560, 147083, 159139, 158469, 158615, 144846, 15807, 33565, 21996, 33669, 17675, 159141, 33708, 33729, 33747, 13438, 159444, 27223, 34138, 13462, 159298, 143087, 33880, 154596, 33905, 15827, 17636, 27303, 33866, 146613, 31064, 33960, 158614, 159351, 159299, 34014, 33807, 33681, 17568, 33939, 34020, 154769, 16960, 154816, 17731, 34100, 23282, 159385, 17703, 34163, 17686, 26559, 34326, 165413, 165435, 34241, 159880, 34306, 136578, 159949, 194994, 17770, 34344, 13896, 137378, 21495, 160666, 34430, 34673, 172280, 34798, 142375, 34737, 34778, 34831, 22113, 34412, 26710, 17935, 34885, 34886, 161248, 146873, 161252, 34910, 34972, 18011, 34996, 34997, 25537, 35013, 30583, 161551, 35207, 35210, 35238, 35241, 35239, 35260, 166437, 35303, 162084, 162493, 35484, 30611, 37374, 35472, 162393, 31465, 162618, 147343, 18195, 162616, 29052, 35596, 35615, 152624, 152933, 35647, 35660, 35661, 35497, 150138, 35728, 35739, 35503, 136927, 17941, 34895, 35995, 163156, 163215, 195028, 14117, 163155, 36054, 163224, 163261, 36114, 36099, 137488, 36059, 28764, 36113, 150729, 16080, 36215, 36265, 163842, 135188, 149898, 15228, 164284, 160012, 31463, 36525, 36534, 36547, 37588, 36633, 36653, 164709, 164882, 36773, 37635, 172703, 133712, 36787, 18730, 166366, 165181, 146875, 24312, 143970, 36857, 172052, 165564, 165121, 140069, 14720, 159447, 36919, 165180, 162494, 36961, 165228, 165387, 37032, 165651, 37060, 165606, 37038, 37117, 37223, 15088, 37289, 37316, 31916, 166195, 138889, 37390, 27807, 37441, 37474, 153017, 37561, 166598, 146587, 166668, 153051, 134449, 37676, 37739, 166625, 166891, 28815, 23235, 166626, 166629, 18789, 37444, 166892, 166969, 166911, 37747, 37979, 36540, 38277, 38310, 37926, 38304, 28662, 17081, 140922, 165592, 135804, 146990, 18911, 27676, 38523, 38550, 16748, 38563, 159445, 25050, 38582, 30965, 166624, 38589, 21452, 18849, 158904, 131700, 156688, 168111, 168165, 150225, 137493, 144138, 38705, 34370, 38710, 18959, 17725, 17797, 150249, 28789, 23361, 38683, 38748, 168405, 38743, 23370, 168427, 38751, 37925, 20688, 143543, 143548, 38793, 38815, 38833, 38846, 38848, 38866, 38880, 152684, 38894, 29724, 169011, 38911, 38901, 168989, 162170, 19153, 38964, 38963, 38987, 39014, 15118, 160117, 15697, 132656, 147804, 153350, 39114, 39095, 39112, 39111, 19199, 159015, 136915, 21936, 39137, 39142, 39148, 37752, 39225, 150057, 19314, 170071, 170245, 39413, 39436, 39483, 39440, 39512, 153381, 14020, 168113, 170965, 39648, 39650, 170757, 39668, 19470, 39700, 39725, 165376, 20532, 39732, 158120, 14531, 143485, 39760, 39744, 171326, 23109, 137315, 39822, 148043, 39938, 39935, 39948, 171624, 40404, 171959, 172434, 172459, 172257, 172323, 172511, 40318, 40323, 172340, 40462, 26760, 40388, 139611, 172435, 172576, 137531, 172595, 40249, 172217, 172724, 40592, 40597, 40606, 40610, 19764, 40618, 40623, 148324, 40641, 15200, 14821, 15645, 20274, 14270, 166955, 40706, 40712, 19350, 37924, 159138, 40727, 40726, 40761, 22175, 22154, 40773, 39352, 168075, 38898, 33919, 40802, 40809, 31452, 40846, 29206, 19390, 149877, 149947, 29047, 150008, 148296, 150097, 29598, 166874, 137466, 31135, 166270, 167478, 37737, 37875, 166468, 37612, 37761, 37835, 166252, 148665, 29207, 16107, 30578, 31299, 28880, 148595, 148472, 29054, 137199, 28835, 137406, 144793, 16071, 137349, 152623, 137208, 14114, 136955, 137273, 14049, 137076, 137425, 155467, 14115, 136896, 22363, 150053, 136190, 135848, 136134, 136374, 34051, 145062, 34051, 33877, 149908, 160101, 146993, 152924, 147195, 159826, 17652, 145134, 170397, 159526, 26617, 14131, 15381, 15847, 22636, 137506, 26640, 16471, 145215, 147681, 147595, 147727, 158753, 21707, 22174, 157361, 22162, 135135, 134056, 134669, 37830, 166675, 37788, 20216, 20779, 14361, 148534, 20156, 132197, 131967, 20299, 20362, 153169, 23144, 131499, 132043, 14745, 131850, 132116, 13365, 20265, 131776, 167603, 131701, 35546, 131596, 20120, 20685, 20749, 20386, 20227, 150030, 147082, 20290, 20526, 20588, 20609, 20428, 20453, 20568, 20732, 20825, 20827, 20829, 20830, 28278, 144789, 147001, 147135, 28018, 137348, 147081, 20904, 20931, 132576, 17629, 132259, 132242, 132241, 36218, 166556, 132878, 21081, 21156, 133235, 21217, 37742, 18042, 29068, 148364, 134176, 149932, 135396, 27089, 134685, 29817, 16094, 29849, 29716, 29782, 29592, 19342, 150204, 147597, 21456, 13700, 29199, 147657, 21940, 131909, 21709, 134086, 22301, 37469, 38644, 37734, 22493, 22413, 22399, 13886, 22731, 23193, 166470, 136954, 137071, 136976, 23084, 22968, 37519, 23166, 23247, 23058, 153926, 137715, 137313, 148117, 14069, 27909, 29763, 23073, 155267, 23169, 166871, 132115, 37856, 29836, 135939, 28933, 18802, 37896, 166395, 37821, 14240, 23582, 23710, 24158, 24136, 137622, 137596, 146158, 24269, 23375, 137475, 137476, 14081, 137376, 14045, 136958, 14035, 33066, 166471, 138682, 144498, 166312, 24332, 24334, 137511, 137131, 23147, 137019, 23364, 34324, 161277, 34912, 24702, 141408, 140843, 24539, 16056, 140719, 140734, 168072, 159603, 25024, 131134, 131142, 140827, 24985, 24984, 24693, 142491, 142599, 149204, 168269, 25713, 149093, 142186, 14889, 142114, 144464, 170218, 142968, 25399, 173147, 25782, 25393, 25553, 149987, 142695, 25252, 142497, 25659, 25963, 26994, 15348, 143502, 144045, 149897, 144043, 21773, 144096, 137433, 169023, 26318, 144009, 143795, 15072, 16784, 152964, 166690, 152975, 136956, 152923, 152613, 30958, 143619, 137258, 143924, 13412, 143887, 143746, 148169, 26254, 159012, 26219, 19347, 26160, 161904, 138731, 26211, 144082, 144097, 26142, 153714, 14545, 145466, 145340, 15257, 145314, 144382, 29904, 15254, 26511, 149034, 26806, 26654, 15300, 27326, 14435, 145365, 148615, 27187, 27218, 27337, 27397, 137490, 25873, 26776, 27212, 15319, 27258, 27479, 147392, 146586, 37792, 37618, 166890, 166603, 37513, 163870, 166364, 37991, 28069, 28427, 149996, 28007, 147327, 15759, 28164, 147516, 23101, 28170, 22599, 27940, 30786, 28987, 148250, 148086, 28913, 29264, 29319, 29332, 149391, 149285, 20857, 150180, 132587, 29818, 147192, 144991, 150090, 149783, 155617, 16134, 16049, 150239, 166947, 147253, 24743, 16115, 29900, 29756, 37767, 29751, 17567, 159210, 17745, 30083, 16227, 150745, 150790, 16216, 30037, 30323, 173510, 15129, 29800, 166604, 149931, 149902, 15099, 15821, 150094, 16127, 149957, 149747, 37370, 22322, 37698, 166627, 137316, 20703, 152097, 152039, 30584, 143922, 30478, 30479, 30587, 149143, 145281, 14942, 149744, 29752, 29851, 16063, 150202, 150215, 16584, 150166, 156078, 37639, 152961, 30750, 30861, 30856, 30930, 29648, 31065, 161601, 153315, 16654, 31131, 33942, 31141, 27181, 147194, 31290, 31220, 16750, 136934, 16690, 37429, 31217, 134476, 149900, 131737, 146874, 137070, 13719, 21867, 13680, 13994, 131540, 134157, 31458, 23129, 141045, 154287, 154268, 23053, 131675, 30960, 23082, 154566, 31486, 16889, 31837, 31853, 16913, 154547, 155324, 155302, 31949, 150009, 137136, 31886, 31868, 31918, 27314, 32220, 32263, 32211, 32590, 156257, 155996, 162632, 32151, 155266, 17002, 158581, 133398, 26582, 131150, 144847, 22468, 156690, 156664, 149858, 32733, 31527, 133164, 154345, 154947, 31500, 155150, 39398, 34373, 39523, 27164, 144447, 14818, 150007, 157101, 39455, 157088, 33920, 160039, 158929, 17642, 33079, 17410, 32966, 33033, 33090, 157620, 39107, 158274, 33378, 33381, 158289, 33875, 159143, 34320, 160283, 23174, 16767, 137280, 23339, 137377, 23268, 137432, 34464, 195004, 146831, 34861, 160802, 23042, 34926, 20293, 34951, 35007, 35046, 35173, 35149, 153219, 35156, 161669, 161668, 166901, 166873, 166812, 166393, 16045, 33955, 18165, 18127, 14322, 35389, 35356, 169032, 24397, 37419, 148100, 26068, 28969, 28868, 137285, 40301, 35999, 36073, 163292, 22938, 30659, 23024, 17262, 14036, 36394, 36519, 150537, 36656, 36682, 17140, 27736, 28603, 140065, 18587, 28537, 28299, 137178, 39913, 14005, 149807, 37051, 37015, 21873, 18694, 37307, 37892, 166475, 16482, 166652, 37927, 166941, 166971, 34021, 35371, 38297, 38311, 38295, 38294, 167220, 29765, 16066, 149759, 150082, 148458, 16103, 143909, 38543, 167655, 167526, 167525, 16076, 149997, 150136, 147438, 29714, 29803, 16124, 38721, 168112, 26695, 18973, 168083, 153567, 38749, 37736, 166281, 166950, 166703, 156606, 37562, 23313, 35689, 18748, 29689, 147995, 38811, 38769, 39224, 134950, 24001, 166853, 150194, 38943, 169178, 37622, 169431, 37349, 17600, 166736, 150119, 166756, 39132, 166469, 16128, 37418, 18725, 33812, 39227, 39245, 162566, 15869, 39323, 19311, 39338, 39516, 166757, 153800, 27279, 39457, 23294, 39471, 170225, 19344, 170312, 39356, 19389, 19351, 37757, 22642, 135938, 22562, 149944, 136424, 30788, 141087, 146872, 26821, 15741, 37976, 14631, 24912, 141185, 141675, 24839, 40015, 40019, 40059, 39989, 39952, 39807, 39887, 171565, 39839, 172533, 172286, 40225, 19630, 147716, 40472, 19632, 40204, 172468, 172269, 172275, 170287, 40357, 33981, 159250, 159711, 158594, 34300, 17715, 159140, 159364, 159216, 33824, 34286, 159232, 145367, 155748, 31202, 144796, 144960, 18733, 149982, 15714, 37851, 37566, 37704, 131775, 30905, 37495, 37965, 20452, 13376, 36964, 152925, 30781, 30804, 30902, 30795, 137047, 143817, 149825, 13978, 20338, 28634, 28633, 28702, 28702, 21524, 147893, 22459, 22771, 22410, 40214, 22487, 28980, 13487, 147884, 29163, 158784, 151447, 23336, 137141, 166473, 24844, 23246, 23051, 17084, 148616, 14124, 19323, 166396, 37819, 37816, 137430, 134941, 33906, 158912, 136211, 148218, 142374, 148417, 22932, 146871, 157505, 32168, 155995, 155812, 149945, 149899, 166394, 37605, 29666, 16105, 29876, 166755, 137375, 16097, 150195, 27352, 29683, 29691, 16086, 150078, 150164, 137177, 150118, 132007, 136228, 149989, 29768, 149782, 28837, 149878, 37508, 29670, 37727, 132350, 37681, 166606, 166422, 37766, 166887, 153045, 18741, 166530, 29035, 149827, 134399, 22180, 132634, 134123, 134328, 21762, 31172, 137210, 32254, 136898, 150096, 137298, 17710, 37889, 14090, 166592, 149933, 22960, 137407, 137347, 160900, 23201, 14050, 146779, 14e3, 37471, 23161, 166529, 137314, 37748, 15565, 133812, 19094, 14730, 20724, 15721, 15692, 136092, 29045, 17147, 164376, 28175, 168164, 17643, 27991, 163407, 28775, 27823, 15574, 147437, 146989, 28162, 28428, 15727, 132085, 30033, 14012, 13512, 18048, 16090, 18545, 22980, 37486, 18750, 36673, 166940, 158656, 22546, 22472, 14038, 136274, 28926, 148322, 150129, 143331, 135856, 140221, 26809, 26983, 136088, 144613, 162804, 145119, 166531, 145366, 144378, 150687, 27162, 145069, 158903, 33854, 17631, 17614, 159014, 159057, 158850, 159710, 28439, 160009, 33597, 137018, 33773, 158848, 159827, 137179, 22921, 23170, 137139, 23137, 23153, 137477, 147964, 14125, 23023, 137020, 14023, 29070, 37776, 26266, 148133, 23150, 23083, 148115, 27179, 147193, 161590, 148571, 148170, 28957, 148057, 166369, 20400, 159016, 23746, 148686, 163405, 148413, 27148, 148054, 135940, 28838, 28979, 148457, 15781, 27871, 194597, 150095, 32357, 23019, 23855, 15859, 24412, 150109, 137183, 32164, 33830, 21637, 146170, 144128, 131604, 22398, 133333, 132633, 16357, 139166, 172726, 28675, 168283, 23920, 29583, 31955, 166489, 168992, 20424, 32743, 29389, 29456, 162548, 29496, 29497, 153334, 29505, 29512, 16041, 162584, 36972, 29173, 149746, 29665, 33270, 16074, 30476, 16081, 27810, 22269, 29721, 29726, 29727, 16098, 16112, 16116, 16122, 29907, 16142, 16211, 30018, 30061, 30066, 30093, 16252, 30152, 30172, 16320, 30285, 16343, 30324, 16348, 30330, 151388, 29064, 22051, 35200, 22633, 16413, 30531, 16441, 26465, 16453, 13787, 30616, 16490, 16495, 23646, 30654, 30667, 22770, 30744, 28857, 30748, 16552, 30777, 30791, 30801, 30822, 33864, 152885, 31027, 26627, 31026, 16643, 16649, 31121, 31129, 36795, 31238, 36796, 16743, 31377, 16818, 31420, 33401, 16836, 31439, 31451, 16847, 20001, 31586, 31596, 31611, 31762, 31771, 16992, 17018, 31867, 31900, 17036, 31928, 17044, 31981, 36755, 28864, 134351, 32207, 32212, 32208, 32253, 32686, 32692, 29343, 17303, 32800, 32805, 31545, 32814, 32817, 32852, 15820, 22452, 28832, 32951, 33001, 17389, 33036, 29482, 33038, 33042, 30048, 33044, 17409, 15161, 33110, 33113, 33114, 17427, 22586, 33148, 33156, 17445, 33171, 17453, 33189, 22511, 33217, 33252, 33364, 17551, 33446, 33398, 33482, 33496, 33535, 17584, 33623, 38505, 27018, 33797, 28917, 33892, 24803, 33928, 17668, 33982, 34017, 34040, 34064, 34104, 34130, 17723, 34159, 34160, 34272, 17783, 34418, 34450, 34482, 34543, 38469, 34699, 17926, 17943, 34990, 35071, 35108, 35143, 35217, 162151, 35369, 35384, 35476, 35508, 35921, 36052, 36082, 36124, 18328, 22623, 36291, 18413, 20206, 36410, 21976, 22356, 36465, 22005, 36528, 18487, 36558, 36578, 36580, 36589, 36594, 36791, 36801, 36810, 36812, 36915, 39364, 18605, 39136, 37395, 18718, 37416, 37464, 37483, 37553, 37550, 37567, 37603, 37611, 37619, 37620, 37629, 37699, 37764, 37805, 18757, 18769, 40639, 37911, 21249, 37917, 37933, 37950, 18794, 37972, 38009, 38189, 38306, 18855, 38388, 38451, 18917, 26528, 18980, 38720, 18997, 38834, 38850, 22100, 19172, 24808, 39097, 19225, 39153, 22596, 39182, 39193, 20916, 39196, 39223, 39234, 39261, 39266, 19312, 39365, 19357, 39484, 39695, 31363, 39785, 39809, 39901, 39921, 39924, 19565, 39968, 14191, 138178, 40265, 39994, 40702, 22096, 40339, 40381, 40384, 40444, 38134, 36790, 40571, 40620, 40625, 40637, 40646, 38108, 40674, 40689, 40696, 31432, 40772, 131220, 131767, 132e3, 26906, 38083, 22956, 132311, 22592, 38081, 14265, 132565, 132629, 132726, 136890, 22359, 29043, 133826, 133837, 134079, 21610, 194619, 134091, 21662, 134139, 134203, 134227, 134245, 134268, 24807, 134285, 22138, 134325, 134365, 134381, 134511, 134578, 134600, 26965, 39983, 34725, 134660, 134670, 134871, 135056, 134957, 134771, 23584, 135100, 24075, 135260, 135247, 135286, 26398, 135291, 135304, 135318, 13895, 135359, 135379, 135471, 135483, 21348, 33965, 135907, 136053, 135990, 35713, 136567, 136729, 137155, 137159, 20088, 28859, 137261, 137578, 137773, 137797, 138282, 138352, 138412, 138952, 25283, 138965, 139029, 29080, 26709, 139333, 27113, 14024, 139900, 140247, 140282, 141098, 141425, 141647, 33533, 141671, 141715, 142037, 35237, 142056, 36768, 142094, 38840, 142143, 38983, 39613, 142412, null, 142472, 142519, 154600, 142600, 142610, 142775, 142741, 142914, 143220, 143308, 143411, 143462, 144159, 144350, 24497, 26184, 26303, 162425, 144743, 144883, 29185, 149946, 30679, 144922, 145174, 32391, 131910, 22709, 26382, 26904, 146087, 161367, 155618, 146961, 147129, 161278, 139418, 18640, 19128, 147737, 166554, 148206, 148237, 147515, 148276, 148374, 150085, 132554, 20946, 132625, 22943, 138920, 15294, 146687, 148484, 148694, 22408, 149108, 14747, 149295, 165352, 170441, 14178, 139715, 35678, 166734, 39382, 149522, 149755, 150037, 29193, 150208, 134264, 22885, 151205, 151430, 132985, 36570, 151596, 21135, 22335, 29041, 152217, 152601, 147274, 150183, 21948, 152646, 152686, 158546, 37332, 13427, 152895, 161330, 152926, 18200, 152930, 152934, 153543, 149823, 153693, 20582, 13563, 144332, 24798, 153859, 18300, 166216, 154286, 154505, 154630, 138640, 22433, 29009, 28598, 155906, 162834, 36950, 156082, 151450, 35682, 156674, 156746, 23899, 158711, 36662, 156804, 137500, 35562, 150006, 156808, 147439, 156946, 19392, 157119, 157365, 141083, 37989, 153569, 24981, 23079, 194765, 20411, 22201, 148769, 157436, 20074, 149812, 38486, 28047, 158909, 13848, 35191, 157593, 157806, 156689, 157790, 29151, 157895, 31554, 168128, 133649, 157990, 37124, 158009, 31301, 40432, 158202, 39462, 158253, 13919, 156777, 131105, 31107, 158260, 158555, 23852, 144665, 33743, 158621, 18128, 158884, 30011, 34917, 159150, 22710, 14108, 140685, 159819, 160205, 15444, 160384, 160389, 37505, 139642, 160395, 37680, 160486, 149968, 27705, 38047, 160848, 134904, 34855, 35061, 141606, 164979, 137137, 28344, 150058, 137248, 14756, 14009, 23568, 31203, 17727, 26294, 171181, 170148, 35139, 161740, 161880, 22230, 16607, 136714, 14753, 145199, 164072, 136133, 29101, 33638, 162269, 168360, 23143, 19639, 159919, 166315, 162301, 162314, 162571, 163174, 147834, 31555, 31102, 163849, 28597, 172767, 27139, 164632, 21410, 159239, 37823, 26678, 38749, 164207, 163875, 158133, 136173, 143919, 163912, 23941, 166960, 163971, 22293, 38947, 166217, 23979, 149896, 26046, 27093, 21458, 150181, 147329, 15377, 26422, 163984, 164084, 164142, 139169, 164175, 164233, 164271, 164378, 164614, 164655, 164746, 13770, 164968, 165546, 18682, 25574, 166230, 30728, 37461, 166328, 17394, 166375, 17375, 166376, 166726, 166868, 23032, 166921, 36619, 167877, 168172, 31569, 168208, 168252, 15863, 168286, 150218, 36816, 29327, 22155, 169191, 169449, 169392, 169400, 169778, 170193, 170313, 170346, 170435, 170536, 170766, 171354, 171419, 32415, 171768, 171811, 19620, 38215, 172691, 29090, 172799, 19857, 36882, 173515, 19868, 134300, 36798, 21953, 36794, 140464, 36793, 150163, 17673, 32383, 28502, 27313, 20202, 13540, 166700, 161949, 14138, 36480, 137205, 163876, 166764, 166809, 162366, 157359, 15851, 161365, 146615, 153141, 153942, 20122, 155265, 156248, 22207, 134765, 36366, 23405, 147080, 150686, 25566, 25296, 137206, 137339, 25904, 22061, 154698, 21530, 152337, 15814, 171416, 19581, 22050, 22046, 32585, 155352, 22901, 146752, 34672, 19996, 135146, 134473, 145082, 33047, 40286, 36120, 30267, 40005, 30286, 30649, 37701, 21554, 33096, 33527, 22053, 33074, 33816, 32957, 21994, 31074, 22083, 21526, 134813, 13774, 22021, 22001, 26353, 164578, 13869, 30004, 22e3, 21946, 21655, 21874, 134209, 134294, 24272, 151880, 134774, 142434, 134818, 40619, 32090, 21982, 135285, 25245, 38765, 21652, 36045, 29174, 37238, 25596, 25529, 25598, 21865, 142147, 40050, 143027, 20890, 13535, 134567, 20903, 21581, 21790, 21779, 30310, 36397, 157834, 30129, 32950, 34820, 34694, 35015, 33206, 33820, 135361, 17644, 29444, 149254, 23440, 33547, 157843, 22139, 141044, 163119, 147875, 163187, 159440, 160438, 37232, 135641, 37384, 146684, 173737, 134828, 134905, 29286, 138402, 18254, 151490, 163833, 135147, 16634, 40029, 25887, 142752, 18675, 149472, 171388, 135148, 134666, 24674, 161187, 135149, null, 155720, 135559, 29091, 32398, 40272, 19994, 19972, 13687, 23309, 27826, 21351, 13996, 14812, 21373, 13989, 149016, 22682, 150382, 33325, 21579, 22442, 154261, 133497, null, 14930, 140389, 29556, 171692, 19721, 39917, 146686, 171824, 19547, 151465, 169374, 171998, 33884, 146870, 160434, 157619, 145184, 25390, 32037, 147191, 146988, 14890, 36872, 21196, 15988, 13946, 17897, 132238, 30272, 23280, 134838, 30842, 163630, 22695, 16575, 22140, 39819, 23924, 30292, 173108, 40581, 19681, 30201, 14331, 24857, 143578, 148466, null, 22109, 135849, 22439, 149859, 171526, 21044, 159918, 13741, 27722, 40316, 31830, 39737, 22494, 137068, 23635, 25811, 169168, 156469, 160100, 34477, 134440, 159010, 150242, 134513, null, 20990, 139023, 23950, 38659, 138705, 40577, 36940, 31519, 39682, 23761, 31651, 25192, 25397, 39679, 31695, 39722, 31870, 39726, 31810, 31878, 39957, 31740, 39689, 40727, 39963, 149822, 40794, 21875, 23491, 20477, 40600, 20466, 21088, 15878, 21201, 22375, 20566, 22967, 24082, 38856, 40363, 36700, 21609, 38836, 39232, 38842, 21292, 24880, 26924, 21466, 39946, 40194, 19515, 38465, 27008, 20646, 30022, 137069, 39386, 21107, null, 37209, 38529, 37212, null, 37201, 167575, 25471, 159011, 27338, 22033, 37262, 30074, 25221, 132092, 29519, 31856, 154657, 146685, null, 149785, 30422, 39837, 20010, 134356, 33726, 34882, null, 23626, 27072, 20717, 22394, 21023, 24053, 20174, 27697, 131570, 20281, 21660, 21722, 21146, 36226, 13822, 24332, 13811, null, 27474, 37244, 40869, 39831, 38958, 39092, 39610, 40616, 40580, 29050, 31508, null, 27642, 34840, 32632, null, 22048, 173642, 36471, 40787, null, 36308, 36431, 40476, 36353, 25218, 164733, 36392, 36469, 31443, 150135, 31294, 30936, 27882, 35431, 30215, 166490, 40742, 27854, 34774, 30147, 172722, 30803, 194624, 36108, 29410, 29553, 35629, 29442, 29937, 36075, 150203, 34351, 24506, 34976, 17591, null, 137275, 159237, null, 35454, 140571, null, 24829, 30311, 39639, 40260, 37742, 39823, 34805, null, 34831, 36087, 29484, 38689, 39856, 13782, 29362, 19463, 31825, 39242, 155993, 24921, 19460, 40598, 24957, null, 22367, 24943, 25254, 25145, 25294, 14940, 25058, 21418, 144373, 25444, 26626, 13778, 23895, 166850, 36826, 167481, null, 20697, 138566, 30982, 21298, 38456, 134971, 16485, null, 30718, null, 31938, 155418, 31962, 31277, 32870, 32867, 32077, 29957, 29938, 35220, 33306, 26380, 32866, 160902, 32859, 29936, 33027, 30500, 35209, 157644, 30035, 159441, 34729, 34766, 33224, 34700, 35401, 36013, 35651, 30507, 29944, 34010, 13877, 27058, 36262, null, 35241, 29800, 28089, 34753, 147473, 29927, 15835, 29046, 24740, 24988, 15569, 29026, 24695, null, 32625, 166701, 29264, 24809, 19326, 21024, 15384, 146631, 155351, 161366, 152881, 137540, 135934, 170243, 159196, 159917, 23745, 156077, 166415, 145015, 131310, 157766, 151310, 17762, 23327, 156492, 40784, 40614, 156267, 12288, 65292, 12289, 12290, 65294, 8231, 65307, 65306, 65311, 65281, 65072, 8230, 8229, 65104, 65105, 65106, 183, 65108, 65109, 65110, 65111, 65372, 8211, 65073, 8212, 65075, 9588, 65076, 65103, 65288, 65289, 65077, 65078, 65371, 65373, 65079, 65080, 12308, 12309, 65081, 65082, 12304, 12305, 65083, 65084, 12298, 12299, 65085, 65086, 12296, 12297, 65087, 65088, 12300, 12301, 65089, 65090, 12302, 12303, 65091, 65092, 65113, 65114, 65115, 65116, 65117, 65118, 8216, 8217, 8220, 8221, 12317, 12318, 8245, 8242, 65283, 65286, 65290, 8251, 167, 12291, 9675, 9679, 9651, 9650, 9678, 9734, 9733, 9671, 9670, 9633, 9632, 9661, 9660, 12963, 8453, 175, 65507, 65343, 717, 65097, 65098, 65101, 65102, 65099, 65100, 65119, 65120, 65121, 65291, 65293, 215, 247, 177, 8730, 65308, 65310, 65309, 8806, 8807, 8800, 8734, 8786, 8801, 65122, 65123, 65124, 65125, 65126, 65374, 8745, 8746, 8869, 8736, 8735, 8895, 13266, 13265, 8747, 8750, 8757, 8756, 9792, 9794, 8853, 8857, 8593, 8595, 8592, 8594, 8598, 8599, 8601, 8600, 8741, 8739, 65295, 65340, 8725, 65128, 65284, 65509, 12306, 65504, 65505, 65285, 65312, 8451, 8457, 65129, 65130, 65131, 13269, 13212, 13213, 13214, 13262, 13217, 13198, 13199, 13252, 176, 20825, 20827, 20830, 20829, 20833, 20835, 21991, 29929, 31950, 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608, 9615, 9614, 9613, 9612, 9611, 9610, 9609, 9532, 9524, 9516, 9508, 9500, 9620, 9472, 9474, 9621, 9484, 9488, 9492, 9496, 9581, 9582, 9584, 9583, 9552, 9566, 9578, 9569, 9698, 9699, 9701, 9700, 9585, 9586, 9587, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 12321, 12322, 12323, 12324, 12325, 12326, 12327, 12328, 12329, 21313, 21316, 21317, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, 12549, 12550, 12551, 12552, 12553, 12554, 12555, 12556, 12557, 12558, 12559, 12560, 12561, 12562, 12563, 12564, 12565, 12566, 12567, 12568, 12569, 12570, 12571, 12572, 12573, 12574, 12575, 12576, 12577, 12578, 12579, 12580, 12581, 12582, 12583, 12584, 12585, 729, 713, 714, 711, 715, 9216, 9217, 9218, 9219, 9220, 9221, 9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229, 9230, 9231, 9232, 9233, 9234, 9235, 9236, 9237, 9238, 9239, 9240, 9241, 9242, 9243, 9244, 9245, 9246, 9247, 9249, 8364, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 19968, 20057, 19969, 19971, 20035, 20061, 20102, 20108, 20154, 20799, 20837, 20843, 20960, 20992, 20993, 21147, 21269, 21313, 21340, 21448, 19977, 19979, 19976, 19978, 20011, 20024, 20961, 20037, 20040, 20063, 20062, 20110, 20129, 20800, 20995, 21242, 21315, 21449, 21475, 22303, 22763, 22805, 22823, 22899, 23376, 23377, 23379, 23544, 23567, 23586, 23608, 23665, 24029, 24037, 24049, 24050, 24051, 24062, 24178, 24318, 24331, 24339, 25165, 19985, 19984, 19981, 20013, 20016, 20025, 20043, 23609, 20104, 20113, 20117, 20114, 20116, 20130, 20161, 20160, 20163, 20166, 20167, 20173, 20170, 20171, 20164, 20803, 20801, 20839, 20845, 20846, 20844, 20887, 20982, 20998, 20999, 21e3, 21243, 21246, 21247, 21270, 21305, 21320, 21319, 21317, 21342, 21380, 21451, 21450, 21453, 22764, 22825, 22827, 22826, 22829, 23380, 23569, 23588, 23610, 23663, 24052, 24187, 24319, 24340, 24341, 24515, 25096, 25142, 25163, 25166, 25903, 25991, 26007, 26020, 26041, 26085, 26352, 26376, 26408, 27424, 27490, 27513, 27595, 27604, 27611, 27663, 27700, 28779, 29226, 29238, 29243, 29255, 29273, 29275, 29356, 29579, 19993, 19990, 19989, 19988, 19992, 20027, 20045, 20047, 20046, 20197, 20184, 20180, 20181, 20182, 20183, 20195, 20196, 20185, 20190, 20805, 20804, 20873, 20874, 20908, 20985, 20986, 20984, 21002, 21152, 21151, 21253, 21254, 21271, 21277, 20191, 21322, 21321, 21345, 21344, 21359, 21358, 21435, 21487, 21476, 21491, 21484, 21486, 21481, 21480, 21500, 21496, 21493, 21483, 21478, 21482, 21490, 21489, 21488, 21477, 21485, 21499, 22235, 22234, 22806, 22830, 22833, 22900, 22902, 23381, 23427, 23612, 24040, 24039, 24038, 24066, 24067, 24179, 24188, 24321, 24344, 24343, 24517, 25098, 25171, 25172, 25170, 25169, 26021, 26086, 26414, 26412, 26410, 26411, 26413, 27491, 27597, 27665, 27664, 27704, 27713, 27712, 27710, 29359, 29572, 29577, 29916, 29926, 29976, 29983, 29992, 29993, 3e4, 30001, 30002, 30003, 30091, 30333, 30382, 30399, 30446, 30683, 30690, 30707, 31034, 31166, 31348, 31435, 19998, 19999, 20050, 20051, 20073, 20121, 20132, 20134, 20133, 20223, 20233, 20249, 20234, 20245, 20237, 20240, 20241, 20239, 20210, 20214, 20219, 20208, 20211, 20221, 20225, 20235, 20809, 20807, 20806, 20808, 20840, 20849, 20877, 20912, 21015, 21009, 21010, 21006, 21014, 21155, 21256, 21281, 21280, 21360, 21361, 21513, 21519, 21516, 21514, 21520, 21505, 21515, 21508, 21521, 21517, 21512, 21507, 21518, 21510, 21522, 22240, 22238, 22237, 22323, 22320, 22312, 22317, 22316, 22319, 22313, 22809, 22810, 22839, 22840, 22916, 22904, 22915, 22909, 22905, 22914, 22913, 23383, 23384, 23431, 23432, 23429, 23433, 23546, 23574, 23673, 24030, 24070, 24182, 24180, 24335, 24347, 24537, 24534, 25102, 25100, 25101, 25104, 25187, 25179, 25176, 25910, 26089, 26088, 26092, 26093, 26354, 26355, 26377, 26429, 26420, 26417, 26421, 27425, 27492, 27515, 27670, 27741, 27735, 27737, 27743, 27744, 27728, 27733, 27745, 27739, 27725, 27726, 28784, 29279, 29277, 30334, 31481, 31859, 31992, 32566, 32650, 32701, 32769, 32771, 32780, 32786, 32819, 32895, 32905, 32907, 32908, 33251, 33258, 33267, 33276, 33292, 33307, 33311, 33390, 33394, 33406, 34411, 34880, 34892, 34915, 35199, 38433, 20018, 20136, 20301, 20303, 20295, 20311, 20318, 20276, 20315, 20309, 20272, 20304, 20305, 20285, 20282, 20280, 20291, 20308, 20284, 20294, 20323, 20316, 20320, 20271, 20302, 20278, 20313, 20317, 20296, 20314, 20812, 20811, 20813, 20853, 20918, 20919, 21029, 21028, 21033, 21034, 21032, 21163, 21161, 21162, 21164, 21283, 21363, 21365, 21533, 21549, 21534, 21566, 21542, 21582, 21543, 21574, 21571, 21555, 21576, 21570, 21531, 21545, 21578, 21561, 21563, 21560, 21550, 21557, 21558, 21536, 21564, 21568, 21553, 21547, 21535, 21548, 22250, 22256, 22244, 22251, 22346, 22353, 22336, 22349, 22343, 22350, 22334, 22352, 22351, 22331, 22767, 22846, 22941, 22930, 22952, 22942, 22947, 22937, 22934, 22925, 22948, 22931, 22922, 22949, 23389, 23388, 23386, 23387, 23436, 23435, 23439, 23596, 23616, 23617, 23615, 23614, 23696, 23697, 23700, 23692, 24043, 24076, 24207, 24199, 24202, 24311, 24324, 24351, 24420, 24418, 24439, 24441, 24536, 24524, 24535, 24525, 24561, 24555, 24568, 24554, 25106, 25105, 25220, 25239, 25238, 25216, 25206, 25225, 25197, 25226, 25212, 25214, 25209, 25203, 25234, 25199, 25240, 25198, 25237, 25235, 25233, 25222, 25913, 25915, 25912, 26097, 26356, 26463, 26446, 26447, 26448, 26449, 26460, 26454, 26462, 26441, 26438, 26464, 26451, 26455, 27493, 27599, 27714, 27742, 27801, 27777, 27784, 27785, 27781, 27803, 27754, 27770, 27792, 27760, 27788, 27752, 27798, 27794, 27773, 27779, 27762, 27774, 27764, 27782, 27766, 27789, 27796, 27800, 27778, 28790, 28796, 28797, 28792, 29282, 29281, 29280, 29380, 29378, 29590, 29996, 29995, 30007, 30008, 30338, 30447, 30691, 31169, 31168, 31167, 31350, 31995, 32597, 32918, 32915, 32925, 32920, 32923, 32922, 32946, 33391, 33426, 33419, 33421, 35211, 35282, 35328, 35895, 35910, 35925, 35997, 36196, 36208, 36275, 36523, 36554, 36763, 36784, 36802, 36806, 36805, 36804, 24033, 37009, 37026, 37034, 37030, 37027, 37193, 37318, 37324, 38450, 38446, 38449, 38442, 38444, 20006, 20054, 20083, 20107, 20123, 20126, 20139, 20140, 20335, 20381, 20365, 20339, 20351, 20332, 20379, 20363, 20358, 20355, 20336, 20341, 20360, 20329, 20347, 20374, 20350, 20367, 20369, 20346, 20820, 20818, 20821, 20841, 20855, 20854, 20856, 20925, 20989, 21051, 21048, 21047, 21050, 21040, 21038, 21046, 21057, 21182, 21179, 21330, 21332, 21331, 21329, 21350, 21367, 21368, 21369, 21462, 21460, 21463, 21619, 21621, 21654, 21624, 21653, 21632, 21627, 21623, 21636, 21650, 21638, 21628, 21648, 21617, 21622, 21644, 21658, 21602, 21608, 21643, 21629, 21646, 22266, 22403, 22391, 22378, 22377, 22369, 22374, 22372, 22396, 22812, 22857, 22855, 22856, 22852, 22868, 22974, 22971, 22996, 22969, 22958, 22993, 22982, 22992, 22989, 22987, 22995, 22986, 22959, 22963, 22994, 22981, 23391, 23396, 23395, 23447, 23450, 23448, 23452, 23449, 23451, 23578, 23624, 23621, 23622, 23735, 23713, 23736, 23721, 23723, 23729, 23731, 24088, 24090, 24086, 24085, 24091, 24081, 24184, 24218, 24215, 24220, 24213, 24214, 24310, 24358, 24359, 24361, 24448, 24449, 24447, 24444, 24541, 24544, 24573, 24565, 24575, 24591, 24596, 24623, 24629, 24598, 24618, 24597, 24609, 24615, 24617, 24619, 24603, 25110, 25109, 25151, 25150, 25152, 25215, 25289, 25292, 25284, 25279, 25282, 25273, 25298, 25307, 25259, 25299, 25300, 25291, 25288, 25256, 25277, 25276, 25296, 25305, 25287, 25293, 25269, 25306, 25265, 25304, 25302, 25303, 25286, 25260, 25294, 25918, 26023, 26044, 26106, 26132, 26131, 26124, 26118, 26114, 26126, 26112, 26127, 26133, 26122, 26119, 26381, 26379, 26477, 26507, 26517, 26481, 26524, 26483, 26487, 26503, 26525, 26519, 26479, 26480, 26495, 26505, 26494, 26512, 26485, 26522, 26515, 26492, 26474, 26482, 27427, 27494, 27495, 27519, 27667, 27675, 27875, 27880, 27891, 27825, 27852, 27877, 27827, 27837, 27838, 27836, 27874, 27819, 27861, 27859, 27832, 27844, 27833, 27841, 27822, 27863, 27845, 27889, 27839, 27835, 27873, 27867, 27850, 27820, 27887, 27868, 27862, 27872, 28821, 28814, 28818, 28810, 28825, 29228, 29229, 29240, 29256, 29287, 29289, 29376, 29390, 29401, 29399, 29392, 29609, 29608, 29599, 29611, 29605, 30013, 30109, 30105, 30106, 30340, 30402, 30450, 30452, 30693, 30717, 31038, 31040, 31041, 31177, 31176, 31354, 31353, 31482, 31998, 32596, 32652, 32651, 32773, 32954, 32933, 32930, 32945, 32929, 32939, 32937, 32948, 32938, 32943, 33253, 33278, 33293, 33459, 33437, 33433, 33453, 33469, 33439, 33465, 33457, 33452, 33445, 33455, 33464, 33443, 33456, 33470, 33463, 34382, 34417, 21021, 34920, 36555, 36814, 36820, 36817, 37045, 37048, 37041, 37046, 37319, 37329, 38263, 38272, 38428, 38464, 38463, 38459, 38468, 38466, 38585, 38632, 38738, 38750, 20127, 20141, 20142, 20449, 20405, 20399, 20415, 20448, 20433, 20431, 20445, 20419, 20406, 20440, 20447, 20426, 20439, 20398, 20432, 20420, 20418, 20442, 20430, 20446, 20407, 20823, 20882, 20881, 20896, 21070, 21059, 21066, 21069, 21068, 21067, 21063, 21191, 21193, 21187, 21185, 21261, 21335, 21371, 21402, 21467, 21676, 21696, 21672, 21710, 21705, 21688, 21670, 21683, 21703, 21698, 21693, 21674, 21697, 21700, 21704, 21679, 21675, 21681, 21691, 21673, 21671, 21695, 22271, 22402, 22411, 22432, 22435, 22434, 22478, 22446, 22419, 22869, 22865, 22863, 22862, 22864, 23004, 23e3, 23039, 23011, 23016, 23043, 23013, 23018, 23002, 23014, 23041, 23035, 23401, 23459, 23462, 23460, 23458, 23461, 23553, 23630, 23631, 23629, 23627, 23769, 23762, 24055, 24093, 24101, 24095, 24189, 24224, 24230, 24314, 24328, 24365, 24421, 24456, 24453, 24458, 24459, 24455, 24460, 24457, 24594, 24605, 24608, 24613, 24590, 24616, 24653, 24688, 24680, 24674, 24646, 24643, 24684, 24683, 24682, 24676, 25153, 25308, 25366, 25353, 25340, 25325, 25345, 25326, 25341, 25351, 25329, 25335, 25327, 25324, 25342, 25332, 25361, 25346, 25919, 25925, 26027, 26045, 26082, 26149, 26157, 26144, 26151, 26159, 26143, 26152, 26161, 26148, 26359, 26623, 26579, 26609, 26580, 26576, 26604, 26550, 26543, 26613, 26601, 26607, 26564, 26577, 26548, 26586, 26597, 26552, 26575, 26590, 26611, 26544, 26585, 26594, 26589, 26578, 27498, 27523, 27526, 27573, 27602, 27607, 27679, 27849, 27915, 27954, 27946, 27969, 27941, 27916, 27953, 27934, 27927, 27963, 27965, 27966, 27958, 27931, 27893, 27961, 27943, 27960, 27945, 27950, 27957, 27918, 27947, 28843, 28858, 28851, 28844, 28847, 28845, 28856, 28846, 28836, 29232, 29298, 29295, 29300, 29417, 29408, 29409, 29623, 29642, 29627, 29618, 29645, 29632, 29619, 29978, 29997, 30031, 30028, 30030, 30027, 30123, 30116, 30117, 30114, 30115, 30328, 30342, 30343, 30344, 30408, 30406, 30403, 30405, 30465, 30457, 30456, 30473, 30475, 30462, 30460, 30471, 30684, 30722, 30740, 30732, 30733, 31046, 31049, 31048, 31047, 31161, 31162, 31185, 31186, 31179, 31359, 31361, 31487, 31485, 31869, 32002, 32005, 32e3, 32009, 32007, 32004, 32006, 32568, 32654, 32703, 32772, 32784, 32781, 32785, 32822, 32982, 32997, 32986, 32963, 32964, 32972, 32993, 32987, 32974, 32990, 32996, 32989, 33268, 33314, 33511, 33539, 33541, 33507, 33499, 33510, 33540, 33509, 33538, 33545, 33490, 33495, 33521, 33537, 33500, 33492, 33489, 33502, 33491, 33503, 33519, 33542, 34384, 34425, 34427, 34426, 34893, 34923, 35201, 35284, 35336, 35330, 35331, 35998, 36e3, 36212, 36211, 36276, 36557, 36556, 36848, 36838, 36834, 36842, 36837, 36845, 36843, 36836, 36840, 37066, 37070, 37057, 37059, 37195, 37194, 37325, 38274, 38480, 38475, 38476, 38477, 38754, 38761, 38859, 38893, 38899, 38913, 39080, 39131, 39135, 39318, 39321, 20056, 20147, 20492, 20493, 20515, 20463, 20518, 20517, 20472, 20521, 20502, 20486, 20540, 20511, 20506, 20498, 20497, 20474, 20480, 20500, 20520, 20465, 20513, 20491, 20505, 20504, 20467, 20462, 20525, 20522, 20478, 20523, 20489, 20860, 20900, 20901, 20898, 20941, 20940, 20934, 20939, 21078, 21084, 21076, 21083, 21085, 21290, 21375, 21407, 21405, 21471, 21736, 21776, 21761, 21815, 21756, 21733, 21746, 21766, 21754, 21780, 21737, 21741, 21729, 21769, 21742, 21738, 21734, 21799, 21767, 21757, 21775, 22275, 22276, 22466, 22484, 22475, 22467, 22537, 22799, 22871, 22872, 22874, 23057, 23064, 23068, 23071, 23067, 23059, 23020, 23072, 23075, 23081, 23077, 23052, 23049, 23403, 23640, 23472, 23475, 23478, 23476, 23470, 23477, 23481, 23480, 23556, 23633, 23637, 23632, 23789, 23805, 23803, 23786, 23784, 23792, 23798, 23809, 23796, 24046, 24109, 24107, 24235, 24237, 24231, 24369, 24466, 24465, 24464, 24665, 24675, 24677, 24656, 24661, 24685, 24681, 24687, 24708, 24735, 24730, 24717, 24724, 24716, 24709, 24726, 25159, 25331, 25352, 25343, 25422, 25406, 25391, 25429, 25410, 25414, 25423, 25417, 25402, 25424, 25405, 25386, 25387, 25384, 25421, 25420, 25928, 25929, 26009, 26049, 26053, 26178, 26185, 26191, 26179, 26194, 26188, 26181, 26177, 26360, 26388, 26389, 26391, 26657, 26680, 26696, 26694, 26707, 26681, 26690, 26708, 26665, 26803, 26647, 26700, 26705, 26685, 26612, 26704, 26688, 26684, 26691, 26666, 26693, 26643, 26648, 26689, 27530, 27529, 27575, 27683, 27687, 27688, 27686, 27684, 27888, 28010, 28053, 28040, 28039, 28006, 28024, 28023, 27993, 28051, 28012, 28041, 28014, 27994, 28020, 28009, 28044, 28042, 28025, 28037, 28005, 28052, 28874, 28888, 28900, 28889, 28872, 28879, 29241, 29305, 29436, 29433, 29437, 29432, 29431, 29574, 29677, 29705, 29678, 29664, 29674, 29662, 30036, 30045, 30044, 30042, 30041, 30142, 30149, 30151, 30130, 30131, 30141, 30140, 30137, 30146, 30136, 30347, 30384, 30410, 30413, 30414, 30505, 30495, 30496, 30504, 30697, 30768, 30759, 30776, 30749, 30772, 30775, 30757, 30765, 30752, 30751, 30770, 31061, 31056, 31072, 31071, 31062, 31070, 31069, 31063, 31066, 31204, 31203, 31207, 31199, 31206, 31209, 31192, 31364, 31368, 31449, 31494, 31505, 31881, 32033, 32023, 32011, 32010, 32032, 32034, 32020, 32016, 32021, 32026, 32028, 32013, 32025, 32027, 32570, 32607, 32660, 32709, 32705, 32774, 32792, 32789, 32793, 32791, 32829, 32831, 33009, 33026, 33008, 33029, 33005, 33012, 33030, 33016, 33011, 33032, 33021, 33034, 33020, 33007, 33261, 33260, 33280, 33296, 33322, 33323, 33320, 33324, 33467, 33579, 33618, 33620, 33610, 33592, 33616, 33609, 33589, 33588, 33615, 33586, 33593, 33590, 33559, 33600, 33585, 33576, 33603, 34388, 34442, 34474, 34451, 34468, 34473, 34444, 34467, 34460, 34928, 34935, 34945, 34946, 34941, 34937, 35352, 35344, 35342, 35340, 35349, 35338, 35351, 35347, 35350, 35343, 35345, 35912, 35962, 35961, 36001, 36002, 36215, 36524, 36562, 36564, 36559, 36785, 36865, 36870, 36855, 36864, 36858, 36852, 36867, 36861, 36869, 36856, 37013, 37089, 37085, 37090, 37202, 37197, 37196, 37336, 37341, 37335, 37340, 37337, 38275, 38498, 38499, 38497, 38491, 38493, 38500, 38488, 38494, 38587, 39138, 39340, 39592, 39640, 39717, 39730, 39740, 20094, 20602, 20605, 20572, 20551, 20547, 20556, 20570, 20553, 20581, 20598, 20558, 20565, 20597, 20596, 20599, 20559, 20495, 20591, 20589, 20828, 20885, 20976, 21098, 21103, 21202, 21209, 21208, 21205, 21264, 21263, 21273, 21311, 21312, 21310, 21443, 26364, 21830, 21866, 21862, 21828, 21854, 21857, 21827, 21834, 21809, 21846, 21839, 21845, 21807, 21860, 21816, 21806, 21852, 21804, 21859, 21811, 21825, 21847, 22280, 22283, 22281, 22495, 22533, 22538, 22534, 22496, 22500, 22522, 22530, 22581, 22519, 22521, 22816, 22882, 23094, 23105, 23113, 23142, 23146, 23104, 23100, 23138, 23130, 23110, 23114, 23408, 23495, 23493, 23492, 23490, 23487, 23494, 23561, 23560, 23559, 23648, 23644, 23645, 23815, 23814, 23822, 23835, 23830, 23842, 23825, 23849, 23828, 23833, 23844, 23847, 23831, 24034, 24120, 24118, 24115, 24119, 24247, 24248, 24246, 24245, 24254, 24373, 24375, 24407, 24428, 24425, 24427, 24471, 24473, 24478, 24472, 24481, 24480, 24476, 24703, 24739, 24713, 24736, 24744, 24779, 24756, 24806, 24765, 24773, 24763, 24757, 24796, 24764, 24792, 24789, 24774, 24799, 24760, 24794, 24775, 25114, 25115, 25160, 25504, 25511, 25458, 25494, 25506, 25509, 25463, 25447, 25496, 25514, 25457, 25513, 25481, 25475, 25499, 25451, 25512, 25476, 25480, 25497, 25505, 25516, 25490, 25487, 25472, 25467, 25449, 25448, 25466, 25949, 25942, 25937, 25945, 25943, 21855, 25935, 25944, 25941, 25940, 26012, 26011, 26028, 26063, 26059, 26060, 26062, 26205, 26202, 26212, 26216, 26214, 26206, 26361, 21207, 26395, 26753, 26799, 26786, 26771, 26805, 26751, 26742, 26801, 26791, 26775, 26800, 26755, 26820, 26797, 26758, 26757, 26772, 26781, 26792, 26783, 26785, 26754, 27442, 27578, 27627, 27628, 27691, 28046, 28092, 28147, 28121, 28082, 28129, 28108, 28132, 28155, 28154, 28165, 28103, 28107, 28079, 28113, 28078, 28126, 28153, 28088, 28151, 28149, 28101, 28114, 28186, 28085, 28122, 28139, 28120, 28138, 28145, 28142, 28136, 28102, 28100, 28074, 28140, 28095, 28134, 28921, 28937, 28938, 28925, 28911, 29245, 29309, 29313, 29468, 29467, 29462, 29459, 29465, 29575, 29701, 29706, 29699, 29702, 29694, 29709, 29920, 29942, 29943, 29980, 29986, 30053, 30054, 30050, 30064, 30095, 30164, 30165, 30133, 30154, 30157, 30350, 30420, 30418, 30427, 30519, 30526, 30524, 30518, 30520, 30522, 30827, 30787, 30798, 31077, 31080, 31085, 31227, 31378, 31381, 31520, 31528, 31515, 31532, 31526, 31513, 31518, 31534, 31890, 31895, 31893, 32070, 32067, 32113, 32046, 32057, 32060, 32064, 32048, 32051, 32068, 32047, 32066, 32050, 32049, 32573, 32670, 32666, 32716, 32718, 32722, 32796, 32842, 32838, 33071, 33046, 33059, 33067, 33065, 33072, 33060, 33282, 33333, 33335, 33334, 33337, 33678, 33694, 33688, 33656, 33698, 33686, 33725, 33707, 33682, 33674, 33683, 33673, 33696, 33655, 33659, 33660, 33670, 33703, 34389, 24426, 34503, 34496, 34486, 34500, 34485, 34502, 34507, 34481, 34479, 34505, 34899, 34974, 34952, 34987, 34962, 34966, 34957, 34955, 35219, 35215, 35370, 35357, 35363, 35365, 35377, 35373, 35359, 35355, 35362, 35913, 35930, 36009, 36012, 36011, 36008, 36010, 36007, 36199, 36198, 36286, 36282, 36571, 36575, 36889, 36877, 36890, 36887, 36899, 36895, 36893, 36880, 36885, 36894, 36896, 36879, 36898, 36886, 36891, 36884, 37096, 37101, 37117, 37207, 37326, 37365, 37350, 37347, 37351, 37357, 37353, 38281, 38506, 38517, 38515, 38520, 38512, 38516, 38518, 38519, 38508, 38592, 38634, 38633, 31456, 31455, 38914, 38915, 39770, 40165, 40565, 40575, 40613, 40635, 20642, 20621, 20613, 20633, 20625, 20608, 20630, 20632, 20634, 26368, 20977, 21106, 21108, 21109, 21097, 21214, 21213, 21211, 21338, 21413, 21883, 21888, 21927, 21884, 21898, 21917, 21912, 21890, 21916, 21930, 21908, 21895, 21899, 21891, 21939, 21934, 21919, 21822, 21938, 21914, 21947, 21932, 21937, 21886, 21897, 21931, 21913, 22285, 22575, 22570, 22580, 22564, 22576, 22577, 22561, 22557, 22560, 22777, 22778, 22880, 23159, 23194, 23167, 23186, 23195, 23207, 23411, 23409, 23506, 23500, 23507, 23504, 23562, 23563, 23601, 23884, 23888, 23860, 23879, 24061, 24133, 24125, 24128, 24131, 24190, 24266, 24257, 24258, 24260, 24380, 24429, 24489, 24490, 24488, 24785, 24801, 24754, 24758, 24800, 24860, 24867, 24826, 24853, 24816, 24827, 24820, 24936, 24817, 24846, 24822, 24841, 24832, 24850, 25119, 25161, 25507, 25484, 25551, 25536, 25577, 25545, 25542, 25549, 25554, 25571, 25552, 25569, 25558, 25581, 25582, 25462, 25588, 25578, 25563, 25682, 25562, 25593, 25950, 25958, 25954, 25955, 26001, 26e3, 26031, 26222, 26224, 26228, 26230, 26223, 26257, 26234, 26238, 26231, 26366, 26367, 26399, 26397, 26874, 26837, 26848, 26840, 26839, 26885, 26847, 26869, 26862, 26855, 26873, 26834, 26866, 26851, 26827, 26829, 26893, 26898, 26894, 26825, 26842, 26990, 26875, 27454, 27450, 27453, 27544, 27542, 27580, 27631, 27694, 27695, 27692, 28207, 28216, 28244, 28193, 28210, 28263, 28234, 28192, 28197, 28195, 28187, 28251, 28248, 28196, 28246, 28270, 28205, 28198, 28271, 28212, 28237, 28218, 28204, 28227, 28189, 28222, 28363, 28297, 28185, 28238, 28259, 28228, 28274, 28265, 28255, 28953, 28954, 28966, 28976, 28961, 28982, 29038, 28956, 29260, 29316, 29312, 29494, 29477, 29492, 29481, 29754, 29738, 29747, 29730, 29733, 29749, 29750, 29748, 29743, 29723, 29734, 29736, 29989, 29990, 30059, 30058, 30178, 30171, 30179, 30169, 30168, 30174, 30176, 30331, 30332, 30358, 30355, 30388, 30428, 30543, 30701, 30813, 30828, 30831, 31245, 31240, 31243, 31237, 31232, 31384, 31383, 31382, 31461, 31459, 31561, 31574, 31558, 31568, 31570, 31572, 31565, 31563, 31567, 31569, 31903, 31909, 32094, 32080, 32104, 32085, 32043, 32110, 32114, 32097, 32102, 32098, 32112, 32115, 21892, 32724, 32725, 32779, 32850, 32901, 33109, 33108, 33099, 33105, 33102, 33081, 33094, 33086, 33100, 33107, 33140, 33298, 33308, 33769, 33795, 33784, 33805, 33760, 33733, 33803, 33729, 33775, 33777, 33780, 33879, 33802, 33776, 33804, 33740, 33789, 33778, 33738, 33848, 33806, 33796, 33756, 33799, 33748, 33759, 34395, 34527, 34521, 34541, 34516, 34523, 34532, 34512, 34526, 34903, 35009, 35010, 34993, 35203, 35222, 35387, 35424, 35413, 35422, 35388, 35393, 35412, 35419, 35408, 35398, 35380, 35386, 35382, 35414, 35937, 35970, 36015, 36028, 36019, 36029, 36033, 36027, 36032, 36020, 36023, 36022, 36031, 36024, 36234, 36229, 36225, 36302, 36317, 36299, 36314, 36305, 36300, 36315, 36294, 36603, 36600, 36604, 36764, 36910, 36917, 36913, 36920, 36914, 36918, 37122, 37109, 37129, 37118, 37219, 37221, 37327, 37396, 37397, 37411, 37385, 37406, 37389, 37392, 37383, 37393, 38292, 38287, 38283, 38289, 38291, 38290, 38286, 38538, 38542, 38539, 38525, 38533, 38534, 38541, 38514, 38532, 38593, 38597, 38596, 38598, 38599, 38639, 38642, 38860, 38917, 38918, 38920, 39143, 39146, 39151, 39145, 39154, 39149, 39342, 39341, 40643, 40653, 40657, 20098, 20653, 20661, 20658, 20659, 20677, 20670, 20652, 20663, 20667, 20655, 20679, 21119, 21111, 21117, 21215, 21222, 21220, 21218, 21219, 21295, 21983, 21992, 21971, 21990, 21966, 21980, 21959, 21969, 21987, 21988, 21999, 21978, 21985, 21957, 21958, 21989, 21961, 22290, 22291, 22622, 22609, 22616, 22615, 22618, 22612, 22635, 22604, 22637, 22602, 22626, 22610, 22603, 22887, 23233, 23241, 23244, 23230, 23229, 23228, 23219, 23234, 23218, 23913, 23919, 24140, 24185, 24265, 24264, 24338, 24409, 24492, 24494, 24858, 24847, 24904, 24863, 24819, 24859, 24825, 24833, 24840, 24910, 24908, 24900, 24909, 24894, 24884, 24871, 24845, 24838, 24887, 25121, 25122, 25619, 25662, 25630, 25642, 25645, 25661, 25644, 25615, 25628, 25620, 25613, 25654, 25622, 25623, 25606, 25964, 26015, 26032, 26263, 26249, 26247, 26248, 26262, 26244, 26264, 26253, 26371, 27028, 26989, 26970, 26999, 26976, 26964, 26997, 26928, 27010, 26954, 26984, 26987, 26974, 26963, 27001, 27014, 26973, 26979, 26971, 27463, 27506, 27584, 27583, 27603, 27645, 28322, 28335, 28371, 28342, 28354, 28304, 28317, 28359, 28357, 28325, 28312, 28348, 28346, 28331, 28369, 28310, 28316, 28356, 28372, 28330, 28327, 28340, 29006, 29017, 29033, 29028, 29001, 29031, 29020, 29036, 29030, 29004, 29029, 29022, 28998, 29032, 29014, 29242, 29266, 29495, 29509, 29503, 29502, 29807, 29786, 29781, 29791, 29790, 29761, 29759, 29785, 29787, 29788, 30070, 30072, 30208, 30192, 30209, 30194, 30193, 30202, 30207, 30196, 30195, 30430, 30431, 30555, 30571, 30566, 30558, 30563, 30585, 30570, 30572, 30556, 30565, 30568, 30562, 30702, 30862, 30896, 30871, 30872, 30860, 30857, 30844, 30865, 30867, 30847, 31098, 31103, 31105, 33836, 31165, 31260, 31258, 31264, 31252, 31263, 31262, 31391, 31392, 31607, 31680, 31584, 31598, 31591, 31921, 31923, 31925, 32147, 32121, 32145, 32129, 32143, 32091, 32622, 32617, 32618, 32626, 32681, 32680, 32676, 32854, 32856, 32902, 32900, 33137, 33136, 33144, 33125, 33134, 33139, 33131, 33145, 33146, 33126, 33285, 33351, 33922, 33911, 33853, 33841, 33909, 33894, 33899, 33865, 33900, 33883, 33852, 33845, 33889, 33891, 33897, 33901, 33862, 34398, 34396, 34399, 34553, 34579, 34568, 34567, 34560, 34558, 34555, 34562, 34563, 34566, 34570, 34905, 35039, 35028, 35033, 35036, 35032, 35037, 35041, 35018, 35029, 35026, 35228, 35299, 35435, 35442, 35443, 35430, 35433, 35440, 35463, 35452, 35427, 35488, 35441, 35461, 35437, 35426, 35438, 35436, 35449, 35451, 35390, 35432, 35938, 35978, 35977, 36042, 36039, 36040, 36036, 36018, 36035, 36034, 36037, 36321, 36319, 36328, 36335, 36339, 36346, 36330, 36324, 36326, 36530, 36611, 36617, 36606, 36618, 36767, 36786, 36939, 36938, 36947, 36930, 36948, 36924, 36949, 36944, 36935, 36943, 36942, 36941, 36945, 36926, 36929, 37138, 37143, 37228, 37226, 37225, 37321, 37431, 37463, 37432, 37437, 37440, 37438, 37467, 37451, 37476, 37457, 37428, 37449, 37453, 37445, 37433, 37439, 37466, 38296, 38552, 38548, 38549, 38605, 38603, 38601, 38602, 38647, 38651, 38649, 38646, 38742, 38772, 38774, 38928, 38929, 38931, 38922, 38930, 38924, 39164, 39156, 39165, 39166, 39347, 39345, 39348, 39649, 40169, 40578, 40718, 40723, 40736, 20711, 20718, 20709, 20694, 20717, 20698, 20693, 20687, 20689, 20721, 20686, 20713, 20834, 20979, 21123, 21122, 21297, 21421, 22014, 22016, 22043, 22039, 22013, 22036, 22022, 22025, 22029, 22030, 22007, 22038, 22047, 22024, 22032, 22006, 22296, 22294, 22645, 22654, 22659, 22675, 22666, 22649, 22661, 22653, 22781, 22821, 22818, 22820, 22890, 22889, 23265, 23270, 23273, 23255, 23254, 23256, 23267, 23413, 23518, 23527, 23521, 23525, 23526, 23528, 23522, 23524, 23519, 23565, 23650, 23940, 23943, 24155, 24163, 24149, 24151, 24148, 24275, 24278, 24330, 24390, 24432, 24505, 24903, 24895, 24907, 24951, 24930, 24931, 24927, 24922, 24920, 24949, 25130, 25735, 25688, 25684, 25764, 25720, 25695, 25722, 25681, 25703, 25652, 25709, 25723, 25970, 26017, 26071, 26070, 26274, 26280, 26269, 27036, 27048, 27029, 27073, 27054, 27091, 27083, 27035, 27063, 27067, 27051, 27060, 27088, 27085, 27053, 27084, 27046, 27075, 27043, 27465, 27468, 27699, 28467, 28436, 28414, 28435, 28404, 28457, 28478, 28448, 28460, 28431, 28418, 28450, 28415, 28399, 28422, 28465, 28472, 28466, 28451, 28437, 28459, 28463, 28552, 28458, 28396, 28417, 28402, 28364, 28407, 29076, 29081, 29053, 29066, 29060, 29074, 29246, 29330, 29334, 29508, 29520, 29796, 29795, 29802, 29808, 29805, 29956, 30097, 30247, 30221, 30219, 30217, 30227, 30433, 30435, 30596, 30589, 30591, 30561, 30913, 30879, 30887, 30899, 30889, 30883, 31118, 31119, 31117, 31278, 31281, 31402, 31401, 31469, 31471, 31649, 31637, 31627, 31605, 31639, 31645, 31636, 31631, 31672, 31623, 31620, 31929, 31933, 31934, 32187, 32176, 32156, 32189, 32190, 32160, 32202, 32180, 32178, 32177, 32186, 32162, 32191, 32181, 32184, 32173, 32210, 32199, 32172, 32624, 32736, 32737, 32735, 32862, 32858, 32903, 33104, 33152, 33167, 33160, 33162, 33151, 33154, 33255, 33274, 33287, 33300, 33310, 33355, 33993, 33983, 33990, 33988, 33945, 33950, 33970, 33948, 33995, 33976, 33984, 34003, 33936, 33980, 34001, 33994, 34623, 34588, 34619, 34594, 34597, 34612, 34584, 34645, 34615, 34601, 35059, 35074, 35060, 35065, 35064, 35069, 35048, 35098, 35055, 35494, 35468, 35486, 35491, 35469, 35489, 35475, 35492, 35498, 35493, 35496, 35480, 35473, 35482, 35495, 35946, 35981, 35980, 36051, 36049, 36050, 36203, 36249, 36245, 36348, 36628, 36626, 36629, 36627, 36771, 36960, 36952, 36956, 36963, 36953, 36958, 36962, 36957, 36955, 37145, 37144, 37150, 37237, 37240, 37239, 37236, 37496, 37504, 37509, 37528, 37526, 37499, 37523, 37532, 37544, 37500, 37521, 38305, 38312, 38313, 38307, 38309, 38308, 38553, 38556, 38555, 38604, 38610, 38656, 38780, 38789, 38902, 38935, 38936, 39087, 39089, 39171, 39173, 39180, 39177, 39361, 39599, 39600, 39654, 39745, 39746, 40180, 40182, 40179, 40636, 40763, 40778, 20740, 20736, 20731, 20725, 20729, 20738, 20744, 20745, 20741, 20956, 21127, 21128, 21129, 21133, 21130, 21232, 21426, 22062, 22075, 22073, 22066, 22079, 22068, 22057, 22099, 22094, 22103, 22132, 22070, 22063, 22064, 22656, 22687, 22686, 22707, 22684, 22702, 22697, 22694, 22893, 23305, 23291, 23307, 23285, 23308, 23304, 23534, 23532, 23529, 23531, 23652, 23653, 23965, 23956, 24162, 24159, 24161, 24290, 24282, 24287, 24285, 24291, 24288, 24392, 24433, 24503, 24501, 24950, 24935, 24942, 24925, 24917, 24962, 24956, 24944, 24939, 24958, 24999, 24976, 25003, 24974, 25004, 24986, 24996, 24980, 25006, 25134, 25705, 25711, 25721, 25758, 25778, 25736, 25744, 25776, 25765, 25747, 25749, 25769, 25746, 25774, 25773, 25771, 25754, 25772, 25753, 25762, 25779, 25973, 25975, 25976, 26286, 26283, 26292, 26289, 27171, 27167, 27112, 27137, 27166, 27161, 27133, 27169, 27155, 27146, 27123, 27138, 27141, 27117, 27153, 27472, 27470, 27556, 27589, 27590, 28479, 28540, 28548, 28497, 28518, 28500, 28550, 28525, 28507, 28536, 28526, 28558, 28538, 28528, 28516, 28567, 28504, 28373, 28527, 28512, 28511, 29087, 29100, 29105, 29096, 29270, 29339, 29518, 29527, 29801, 29835, 29827, 29822, 29824, 30079, 30240, 30249, 30239, 30244, 30246, 30241, 30242, 30362, 30394, 30436, 30606, 30599, 30604, 30609, 30603, 30923, 30917, 30906, 30922, 30910, 30933, 30908, 30928, 31295, 31292, 31296, 31293, 31287, 31291, 31407, 31406, 31661, 31665, 31684, 31668, 31686, 31687, 31681, 31648, 31692, 31946, 32224, 32244, 32239, 32251, 32216, 32236, 32221, 32232, 32227, 32218, 32222, 32233, 32158, 32217, 32242, 32249, 32629, 32631, 32687, 32745, 32806, 33179, 33180, 33181, 33184, 33178, 33176, 34071, 34109, 34074, 34030, 34092, 34093, 34067, 34065, 34083, 34081, 34068, 34028, 34085, 34047, 34054, 34690, 34676, 34678, 34656, 34662, 34680, 34664, 34649, 34647, 34636, 34643, 34907, 34909, 35088, 35079, 35090, 35091, 35093, 35082, 35516, 35538, 35527, 35524, 35477, 35531, 35576, 35506, 35529, 35522, 35519, 35504, 35542, 35533, 35510, 35513, 35547, 35916, 35918, 35948, 36064, 36062, 36070, 36068, 36076, 36077, 36066, 36067, 36060, 36074, 36065, 36205, 36255, 36259, 36395, 36368, 36381, 36386, 36367, 36393, 36383, 36385, 36382, 36538, 36637, 36635, 36639, 36649, 36646, 36650, 36636, 36638, 36645, 36969, 36974, 36968, 36973, 36983, 37168, 37165, 37159, 37169, 37255, 37257, 37259, 37251, 37573, 37563, 37559, 37610, 37548, 37604, 37569, 37555, 37564, 37586, 37575, 37616, 37554, 38317, 38321, 38660, 38662, 38663, 38665, 38752, 38797, 38795, 38799, 38945, 38955, 38940, 39091, 39178, 39187, 39186, 39192, 39389, 39376, 39391, 39387, 39377, 39381, 39378, 39385, 39607, 39662, 39663, 39719, 39749, 39748, 39799, 39791, 40198, 40201, 40195, 40617, 40638, 40654, 22696, 40786, 20754, 20760, 20756, 20752, 20757, 20864, 20906, 20957, 21137, 21139, 21235, 22105, 22123, 22137, 22121, 22116, 22136, 22122, 22120, 22117, 22129, 22127, 22124, 22114, 22134, 22721, 22718, 22727, 22725, 22894, 23325, 23348, 23416, 23536, 23566, 24394, 25010, 24977, 25001, 24970, 25037, 25014, 25022, 25034, 25032, 25136, 25797, 25793, 25803, 25787, 25788, 25818, 25796, 25799, 25794, 25805, 25791, 25810, 25812, 25790, 25972, 26310, 26313, 26297, 26308, 26311, 26296, 27197, 27192, 27194, 27225, 27243, 27224, 27193, 27204, 27234, 27233, 27211, 27207, 27189, 27231, 27208, 27481, 27511, 27653, 28610, 28593, 28577, 28611, 28580, 28609, 28583, 28595, 28608, 28601, 28598, 28582, 28576, 28596, 29118, 29129, 29136, 29138, 29128, 29141, 29113, 29134, 29145, 29148, 29123, 29124, 29544, 29852, 29859, 29848, 29855, 29854, 29922, 29964, 29965, 30260, 30264, 30266, 30439, 30437, 30624, 30622, 30623, 30629, 30952, 30938, 30956, 30951, 31142, 31309, 31310, 31302, 31308, 31307, 31418, 31705, 31761, 31689, 31716, 31707, 31713, 31721, 31718, 31957, 31958, 32266, 32273, 32264, 32283, 32291, 32286, 32285, 32265, 32272, 32633, 32690, 32752, 32753, 32750, 32808, 33203, 33193, 33192, 33275, 33288, 33368, 33369, 34122, 34137, 34120, 34152, 34153, 34115, 34121, 34157, 34154, 34142, 34691, 34719, 34718, 34722, 34701, 34913, 35114, 35122, 35109, 35115, 35105, 35242, 35238, 35558, 35578, 35563, 35569, 35584, 35548, 35559, 35566, 35582, 35585, 35586, 35575, 35565, 35571, 35574, 35580, 35947, 35949, 35987, 36084, 36420, 36401, 36404, 36418, 36409, 36405, 36667, 36655, 36664, 36659, 36776, 36774, 36981, 36980, 36984, 36978, 36988, 36986, 37172, 37266, 37664, 37686, 37624, 37683, 37679, 37666, 37628, 37675, 37636, 37658, 37648, 37670, 37665, 37653, 37678, 37657, 38331, 38567, 38568, 38570, 38613, 38670, 38673, 38678, 38669, 38675, 38671, 38747, 38748, 38758, 38808, 38960, 38968, 38971, 38967, 38957, 38969, 38948, 39184, 39208, 39198, 39195, 39201, 39194, 39405, 39394, 39409, 39608, 39612, 39675, 39661, 39720, 39825, 40213, 40227, 40230, 40232, 40210, 40219, 40664, 40660, 40845, 40860, 20778, 20767, 20769, 20786, 21237, 22158, 22144, 22160, 22149, 22151, 22159, 22741, 22739, 22737, 22734, 23344, 23338, 23332, 23418, 23607, 23656, 23996, 23994, 23997, 23992, 24171, 24396, 24509, 25033, 25026, 25031, 25062, 25035, 25138, 25140, 25806, 25802, 25816, 25824, 25840, 25830, 25836, 25841, 25826, 25837, 25986, 25987, 26329, 26326, 27264, 27284, 27268, 27298, 27292, 27355, 27299, 27262, 27287, 27280, 27296, 27484, 27566, 27610, 27656, 28632, 28657, 28639, 28640, 28635, 28644, 28651, 28655, 28544, 28652, 28641, 28649, 28629, 28654, 28656, 29159, 29151, 29166, 29158, 29157, 29165, 29164, 29172, 29152, 29237, 29254, 29552, 29554, 29865, 29872, 29862, 29864, 30278, 30274, 30284, 30442, 30643, 30634, 30640, 30636, 30631, 30637, 30703, 30967, 30970, 30964, 30959, 30977, 31143, 31146, 31319, 31423, 31751, 31757, 31742, 31735, 31756, 31712, 31968, 31964, 31966, 31970, 31967, 31961, 31965, 32302, 32318, 32326, 32311, 32306, 32323, 32299, 32317, 32305, 32325, 32321, 32308, 32313, 32328, 32309, 32319, 32303, 32580, 32755, 32764, 32881, 32882, 32880, 32879, 32883, 33222, 33219, 33210, 33218, 33216, 33215, 33213, 33225, 33214, 33256, 33289, 33393, 34218, 34180, 34174, 34204, 34193, 34196, 34223, 34203, 34183, 34216, 34186, 34407, 34752, 34769, 34739, 34770, 34758, 34731, 34747, 34746, 34760, 34763, 35131, 35126, 35140, 35128, 35133, 35244, 35598, 35607, 35609, 35611, 35594, 35616, 35613, 35588, 35600, 35905, 35903, 35955, 36090, 36093, 36092, 36088, 36091, 36264, 36425, 36427, 36424, 36426, 36676, 36670, 36674, 36677, 36671, 36991, 36989, 36996, 36993, 36994, 36992, 37177, 37283, 37278, 37276, 37709, 37762, 37672, 37749, 37706, 37733, 37707, 37656, 37758, 37740, 37723, 37744, 37722, 37716, 38346, 38347, 38348, 38344, 38342, 38577, 38584, 38614, 38684, 38686, 38816, 38867, 38982, 39094, 39221, 39425, 39423, 39854, 39851, 39850, 39853, 40251, 40255, 40587, 40655, 40670, 40668, 40669, 40667, 40766, 40779, 21474, 22165, 22190, 22745, 22744, 23352, 24413, 25059, 25139, 25844, 25842, 25854, 25862, 25850, 25851, 25847, 26039, 26332, 26406, 27315, 27308, 27331, 27323, 27320, 27330, 27310, 27311, 27487, 27512, 27567, 28681, 28683, 28670, 28678, 28666, 28689, 28687, 29179, 29180, 29182, 29176, 29559, 29557, 29863, 29887, 29973, 30294, 30296, 30290, 30653, 30655, 30651, 30652, 30990, 31150, 31329, 31330, 31328, 31428, 31429, 31787, 31783, 31786, 31774, 31779, 31777, 31975, 32340, 32341, 32350, 32346, 32353, 32338, 32345, 32584, 32761, 32763, 32887, 32886, 33229, 33231, 33290, 34255, 34217, 34253, 34256, 34249, 34224, 34234, 34233, 34214, 34799, 34796, 34802, 34784, 35206, 35250, 35316, 35624, 35641, 35628, 35627, 35920, 36101, 36441, 36451, 36454, 36452, 36447, 36437, 36544, 36681, 36685, 36999, 36995, 37e3, 37291, 37292, 37328, 37780, 37770, 37782, 37794, 37811, 37806, 37804, 37808, 37784, 37786, 37783, 38356, 38358, 38352, 38357, 38626, 38620, 38617, 38619, 38622, 38692, 38819, 38822, 38829, 38905, 38989, 38991, 38988, 38990, 38995, 39098, 39230, 39231, 39229, 39214, 39333, 39438, 39617, 39683, 39686, 39759, 39758, 39757, 39882, 39881, 39933, 39880, 39872, 40273, 40285, 40288, 40672, 40725, 40748, 20787, 22181, 22750, 22751, 22754, 23541, 40848, 24300, 25074, 25079, 25078, 25077, 25856, 25871, 26336, 26333, 27365, 27357, 27354, 27347, 28699, 28703, 28712, 28698, 28701, 28693, 28696, 29190, 29197, 29272, 29346, 29560, 29562, 29885, 29898, 29923, 30087, 30086, 30303, 30305, 30663, 31001, 31153, 31339, 31337, 31806, 31807, 31800, 31805, 31799, 31808, 32363, 32365, 32377, 32361, 32362, 32645, 32371, 32694, 32697, 32696, 33240, 34281, 34269, 34282, 34261, 34276, 34277, 34295, 34811, 34821, 34829, 34809, 34814, 35168, 35167, 35158, 35166, 35649, 35676, 35672, 35657, 35674, 35662, 35663, 35654, 35673, 36104, 36106, 36476, 36466, 36487, 36470, 36460, 36474, 36468, 36692, 36686, 36781, 37002, 37003, 37297, 37294, 37857, 37841, 37855, 37827, 37832, 37852, 37853, 37846, 37858, 37837, 37848, 37860, 37847, 37864, 38364, 38580, 38627, 38698, 38695, 38753, 38876, 38907, 39006, 39e3, 39003, 39100, 39237, 39241, 39446, 39449, 39693, 39912, 39911, 39894, 39899, 40329, 40289, 40306, 40298, 40300, 40594, 40599, 40595, 40628, 21240, 22184, 22199, 22198, 22196, 22204, 22756, 23360, 23363, 23421, 23542, 24009, 25080, 25082, 25880, 25876, 25881, 26342, 26407, 27372, 28734, 28720, 28722, 29200, 29563, 29903, 30306, 30309, 31014, 31018, 31020, 31019, 31431, 31478, 31820, 31811, 31821, 31983, 31984, 36782, 32381, 32380, 32386, 32588, 32768, 33242, 33382, 34299, 34297, 34321, 34298, 34310, 34315, 34311, 34314, 34836, 34837, 35172, 35258, 35320, 35696, 35692, 35686, 35695, 35679, 35691, 36111, 36109, 36489, 36481, 36485, 36482, 37300, 37323, 37912, 37891, 37885, 38369, 38704, 39108, 39250, 39249, 39336, 39467, 39472, 39479, 39477, 39955, 39949, 40569, 40629, 40680, 40751, 40799, 40803, 40801, 20791, 20792, 22209, 22208, 22210, 22804, 23660, 24013, 25084, 25086, 25885, 25884, 26005, 26345, 27387, 27396, 27386, 27570, 28748, 29211, 29351, 29910, 29908, 30313, 30675, 31824, 32399, 32396, 32700, 34327, 34349, 34330, 34851, 34850, 34849, 34847, 35178, 35180, 35261, 35700, 35703, 35709, 36115, 36490, 36493, 36491, 36703, 36783, 37306, 37934, 37939, 37941, 37946, 37944, 37938, 37931, 38370, 38712, 38713, 38706, 38911, 39015, 39013, 39255, 39493, 39491, 39488, 39486, 39631, 39764, 39761, 39981, 39973, 40367, 40372, 40386, 40376, 40605, 40687, 40729, 40796, 40806, 40807, 20796, 20795, 22216, 22218, 22217, 23423, 24020, 24018, 24398, 25087, 25892, 27402, 27489, 28753, 28760, 29568, 29924, 30090, 30318, 30316, 31155, 31840, 31839, 32894, 32893, 33247, 35186, 35183, 35324, 35712, 36118, 36119, 36497, 36499, 36705, 37192, 37956, 37969, 37970, 38717, 38718, 38851, 38849, 39019, 39253, 39509, 39501, 39634, 39706, 40009, 39985, 39998, 39995, 40403, 40407, 40756, 40812, 40810, 40852, 22220, 24022, 25088, 25891, 25899, 25898, 26348, 27408, 29914, 31434, 31844, 31843, 31845, 32403, 32406, 32404, 33250, 34360, 34367, 34865, 35722, 37008, 37007, 37987, 37984, 37988, 38760, 39023, 39260, 39514, 39515, 39511, 39635, 39636, 39633, 40020, 40023, 40022, 40421, 40607, 40692, 22225, 22761, 25900, 28766, 30321, 30322, 30679, 32592, 32648, 34870, 34873, 34914, 35731, 35730, 35734, 33399, 36123, 37312, 37994, 38722, 38728, 38724, 38854, 39024, 39519, 39714, 39768, 40031, 40441, 40442, 40572, 40573, 40711, 40823, 40818, 24307, 27414, 28771, 31852, 31854, 34875, 35264, 36513, 37313, 38002, 38e3, 39025, 39262, 39638, 39715, 40652, 28772, 30682, 35738, 38007, 38857, 39522, 39525, 32412, 35740, 36522, 37317, 38013, 38014, 38012, 40055, 40056, 40695, 35924, 38015, 40474, 29224, 39530, 39729, 40475, 40478, 31858, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 20022, 20031, 20101, 20128, 20866, 20886, 20907, 21241, 21304, 21353, 21430, 22794, 23424, 24027, 12083, 24191, 24308, 24400, 24417, 25908, 26080, 30098, 30326, 36789, 38582, 168, 710, 12541, 12542, 12445, 12446, 12291, 20189, 12293, 12294, 12295, 12540, 65339, 65341, 10045, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 8679, 8632, 8633, 12751, 131276, 20058, 131210, 20994, 17553, 40880, 20872, 40881, 161287, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 65506, 65508, 65287, 65282, 12849, 8470, 8481, 12443, 12444, 11904, 11908, 11910, 11911, 11912, 11914, 11916, 11917, 11925, 11932, 11933, 11941, 11943, 11946, 11948, 11950, 11958, 11964, 11966, 11974, 11978, 11980, 11981, 11983, 11990, 11991, 11998, 12003, null, null, null, 643, 592, 603, 596, 629, 339, 248, 331, 650, 618, 20034, 20060, 20981, 21274, 21378, 19975, 19980, 20039, 20109, 22231, 64012, 23662, 24435, 19983, 20871, 19982, 20014, 20115, 20162, 20169, 20168, 20888, 21244, 21356, 21433, 22304, 22787, 22828, 23568, 24063, 26081, 27571, 27596, 27668, 29247, 20017, 20028, 20200, 20188, 20201, 20193, 20189, 20186, 21004, 21276, 21324, 22306, 22307, 22807, 22831, 23425, 23428, 23570, 23611, 23668, 23667, 24068, 24192, 24194, 24521, 25097, 25168, 27669, 27702, 27715, 27711, 27707, 29358, 29360, 29578, 31160, 32906, 38430, 20238, 20248, 20268, 20213, 20244, 20209, 20224, 20215, 20232, 20253, 20226, 20229, 20258, 20243, 20228, 20212, 20242, 20913, 21011, 21001, 21008, 21158, 21282, 21279, 21325, 21386, 21511, 22241, 22239, 22318, 22314, 22324, 22844, 22912, 22908, 22917, 22907, 22910, 22903, 22911, 23382, 23573, 23589, 23676, 23674, 23675, 23678, 24031, 24181, 24196, 24322, 24346, 24436, 24533, 24532, 24527, 25180, 25182, 25188, 25185, 25190, 25186, 25177, 25184, 25178, 25189, 26095, 26094, 26430, 26425, 26424, 26427, 26426, 26431, 26428, 26419, 27672, 27718, 27730, 27740, 27727, 27722, 27732, 27723, 27724, 28785, 29278, 29364, 29365, 29582, 29994, 30335, 31349, 32593, 33400, 33404, 33408, 33405, 33407, 34381, 35198, 37017, 37015, 37016, 37019, 37012, 38434, 38436, 38432, 38435, 20310, 20283, 20322, 20297, 20307, 20324, 20286, 20327, 20306, 20319, 20289, 20312, 20269, 20275, 20287, 20321, 20879, 20921, 21020, 21022, 21025, 21165, 21166, 21257, 21347, 21362, 21390, 21391, 21552, 21559, 21546, 21588, 21573, 21529, 21532, 21541, 21528, 21565, 21583, 21569, 21544, 21540, 21575, 22254, 22247, 22245, 22337, 22341, 22348, 22345, 22347, 22354, 22790, 22848, 22950, 22936, 22944, 22935, 22926, 22946, 22928, 22927, 22951, 22945, 23438, 23442, 23592, 23594, 23693, 23695, 23688, 23691, 23689, 23698, 23690, 23686, 23699, 23701, 24032, 24074, 24078, 24203, 24201, 24204, 24200, 24205, 24325, 24349, 24440, 24438, 24530, 24529, 24528, 24557, 24552, 24558, 24563, 24545, 24548, 24547, 24570, 24559, 24567, 24571, 24576, 24564, 25146, 25219, 25228, 25230, 25231, 25236, 25223, 25201, 25211, 25210, 25200, 25217, 25224, 25207, 25213, 25202, 25204, 25911, 26096, 26100, 26099, 26098, 26101, 26437, 26439, 26457, 26453, 26444, 26440, 26461, 26445, 26458, 26443, 27600, 27673, 27674, 27768, 27751, 27755, 27780, 27787, 27791, 27761, 27759, 27753, 27802, 27757, 27783, 27797, 27804, 27750, 27763, 27749, 27771, 27790, 28788, 28794, 29283, 29375, 29373, 29379, 29382, 29377, 29370, 29381, 29589, 29591, 29587, 29588, 29586, 30010, 30009, 30100, 30101, 30337, 31037, 32820, 32917, 32921, 32912, 32914, 32924, 33424, 33423, 33413, 33422, 33425, 33427, 33418, 33411, 33412, 35960, 36809, 36799, 37023, 37025, 37029, 37022, 37031, 37024, 38448, 38440, 38447, 38445, 20019, 20376, 20348, 20357, 20349, 20352, 20359, 20342, 20340, 20361, 20356, 20343, 20300, 20375, 20330, 20378, 20345, 20353, 20344, 20368, 20380, 20372, 20382, 20370, 20354, 20373, 20331, 20334, 20894, 20924, 20926, 21045, 21042, 21043, 21062, 21041, 21180, 21258, 21259, 21308, 21394, 21396, 21639, 21631, 21633, 21649, 21634, 21640, 21611, 21626, 21630, 21605, 21612, 21620, 21606, 21645, 21615, 21601, 21600, 21656, 21603, 21607, 21604, 22263, 22265, 22383, 22386, 22381, 22379, 22385, 22384, 22390, 22400, 22389, 22395, 22387, 22388, 22370, 22376, 22397, 22796, 22853, 22965, 22970, 22991, 22990, 22962, 22988, 22977, 22966, 22972, 22979, 22998, 22961, 22973, 22976, 22984, 22964, 22983, 23394, 23397, 23443, 23445, 23620, 23623, 23726, 23716, 23712, 23733, 23727, 23720, 23724, 23711, 23715, 23725, 23714, 23722, 23719, 23709, 23717, 23734, 23728, 23718, 24087, 24084, 24089, 24360, 24354, 24355, 24356, 24404, 24450, 24446, 24445, 24542, 24549, 24621, 24614, 24601, 24626, 24587, 24628, 24586, 24599, 24627, 24602, 24606, 24620, 24610, 24589, 24592, 24622, 24595, 24593, 24588, 24585, 24604, 25108, 25149, 25261, 25268, 25297, 25278, 25258, 25270, 25290, 25262, 25267, 25263, 25275, 25257, 25264, 25272, 25917, 26024, 26043, 26121, 26108, 26116, 26130, 26120, 26107, 26115, 26123, 26125, 26117, 26109, 26129, 26128, 26358, 26378, 26501, 26476, 26510, 26514, 26486, 26491, 26520, 26502, 26500, 26484, 26509, 26508, 26490, 26527, 26513, 26521, 26499, 26493, 26497, 26488, 26489, 26516, 27429, 27520, 27518, 27614, 27677, 27795, 27884, 27883, 27886, 27865, 27830, 27860, 27821, 27879, 27831, 27856, 27842, 27834, 27843, 27846, 27885, 27890, 27858, 27869, 27828, 27786, 27805, 27776, 27870, 27840, 27952, 27853, 27847, 27824, 27897, 27855, 27881, 27857, 28820, 28824, 28805, 28819, 28806, 28804, 28817, 28822, 28802, 28826, 28803, 29290, 29398, 29387, 29400, 29385, 29404, 29394, 29396, 29402, 29388, 29393, 29604, 29601, 29613, 29606, 29602, 29600, 29612, 29597, 29917, 29928, 30015, 30016, 30014, 30092, 30104, 30383, 30451, 30449, 30448, 30453, 30712, 30716, 30713, 30715, 30714, 30711, 31042, 31039, 31173, 31352, 31355, 31483, 31861, 31997, 32821, 32911, 32942, 32931, 32952, 32949, 32941, 33312, 33440, 33472, 33451, 33434, 33432, 33435, 33461, 33447, 33454, 33468, 33438, 33466, 33460, 33448, 33441, 33449, 33474, 33444, 33475, 33462, 33442, 34416, 34415, 34413, 34414, 35926, 36818, 36811, 36819, 36813, 36822, 36821, 36823, 37042, 37044, 37039, 37043, 37040, 38457, 38461, 38460, 38458, 38467, 20429, 20421, 20435, 20402, 20425, 20427, 20417, 20436, 20444, 20441, 20411, 20403, 20443, 20423, 20438, 20410, 20416, 20409, 20460, 21060, 21065, 21184, 21186, 21309, 21372, 21399, 21398, 21401, 21400, 21690, 21665, 21677, 21669, 21711, 21699, 33549, 21687, 21678, 21718, 21686, 21701, 21702, 21664, 21616, 21692, 21666, 21694, 21618, 21726, 21680, 22453, 22430, 22431, 22436, 22412, 22423, 22429, 22427, 22420, 22424, 22415, 22425, 22437, 22426, 22421, 22772, 22797, 22867, 23009, 23006, 23022, 23040, 23025, 23005, 23034, 23037, 23036, 23030, 23012, 23026, 23031, 23003, 23017, 23027, 23029, 23008, 23038, 23028, 23021, 23464, 23628, 23760, 23768, 23756, 23767, 23755, 23771, 23774, 23770, 23753, 23751, 23754, 23766, 23763, 23764, 23759, 23752, 23750, 23758, 23775, 23800, 24057, 24097, 24098, 24099, 24096, 24100, 24240, 24228, 24226, 24219, 24227, 24229, 24327, 24366, 24406, 24454, 24631, 24633, 24660, 24690, 24670, 24645, 24659, 24647, 24649, 24667, 24652, 24640, 24642, 24671, 24612, 24644, 24664, 24678, 24686, 25154, 25155, 25295, 25357, 25355, 25333, 25358, 25347, 25323, 25337, 25359, 25356, 25336, 25334, 25344, 25363, 25364, 25338, 25365, 25339, 25328, 25921, 25923, 26026, 26047, 26166, 26145, 26162, 26165, 26140, 26150, 26146, 26163, 26155, 26170, 26141, 26164, 26169, 26158, 26383, 26384, 26561, 26610, 26568, 26554, 26588, 26555, 26616, 26584, 26560, 26551, 26565, 26603, 26596, 26591, 26549, 26573, 26547, 26615, 26614, 26606, 26595, 26562, 26553, 26574, 26599, 26608, 26546, 26620, 26566, 26605, 26572, 26542, 26598, 26587, 26618, 26569, 26570, 26563, 26602, 26571, 27432, 27522, 27524, 27574, 27606, 27608, 27616, 27680, 27681, 27944, 27956, 27949, 27935, 27964, 27967, 27922, 27914, 27866, 27955, 27908, 27929, 27962, 27930, 27921, 27904, 27933, 27970, 27905, 27928, 27959, 27907, 27919, 27968, 27911, 27936, 27948, 27912, 27938, 27913, 27920, 28855, 28831, 28862, 28849, 28848, 28833, 28852, 28853, 28841, 29249, 29257, 29258, 29292, 29296, 29299, 29294, 29386, 29412, 29416, 29419, 29407, 29418, 29414, 29411, 29573, 29644, 29634, 29640, 29637, 29625, 29622, 29621, 29620, 29675, 29631, 29639, 29630, 29635, 29638, 29624, 29643, 29932, 29934, 29998, 30023, 30024, 30119, 30122, 30329, 30404, 30472, 30467, 30468, 30469, 30474, 30455, 30459, 30458, 30695, 30696, 30726, 30737, 30738, 30725, 30736, 30735, 30734, 30729, 30723, 30739, 31050, 31052, 31051, 31045, 31044, 31189, 31181, 31183, 31190, 31182, 31360, 31358, 31441, 31488, 31489, 31866, 31864, 31865, 31871, 31872, 31873, 32003, 32008, 32001, 32600, 32657, 32653, 32702, 32775, 32782, 32783, 32788, 32823, 32984, 32967, 32992, 32977, 32968, 32962, 32976, 32965, 32995, 32985, 32988, 32970, 32981, 32969, 32975, 32983, 32998, 32973, 33279, 33313, 33428, 33497, 33534, 33529, 33543, 33512, 33536, 33493, 33594, 33515, 33494, 33524, 33516, 33505, 33522, 33525, 33548, 33531, 33526, 33520, 33514, 33508, 33504, 33530, 33523, 33517, 34423, 34420, 34428, 34419, 34881, 34894, 34919, 34922, 34921, 35283, 35332, 35335, 36210, 36835, 36833, 36846, 36832, 37105, 37053, 37055, 37077, 37061, 37054, 37063, 37067, 37064, 37332, 37331, 38484, 38479, 38481, 38483, 38474, 38478, 20510, 20485, 20487, 20499, 20514, 20528, 20507, 20469, 20468, 20531, 20535, 20524, 20470, 20471, 20503, 20508, 20512, 20519, 20533, 20527, 20529, 20494, 20826, 20884, 20883, 20938, 20932, 20933, 20936, 20942, 21089, 21082, 21074, 21086, 21087, 21077, 21090, 21197, 21262, 21406, 21798, 21730, 21783, 21778, 21735, 21747, 21732, 21786, 21759, 21764, 21768, 21739, 21777, 21765, 21745, 21770, 21755, 21751, 21752, 21728, 21774, 21763, 21771, 22273, 22274, 22476, 22578, 22485, 22482, 22458, 22470, 22461, 22460, 22456, 22454, 22463, 22471, 22480, 22457, 22465, 22798, 22858, 23065, 23062, 23085, 23086, 23061, 23055, 23063, 23050, 23070, 23091, 23404, 23463, 23469, 23468, 23555, 23638, 23636, 23788, 23807, 23790, 23793, 23799, 23808, 23801, 24105, 24104, 24232, 24238, 24234, 24236, 24371, 24368, 24423, 24669, 24666, 24679, 24641, 24738, 24712, 24704, 24722, 24705, 24733, 24707, 24725, 24731, 24727, 24711, 24732, 24718, 25113, 25158, 25330, 25360, 25430, 25388, 25412, 25413, 25398, 25411, 25572, 25401, 25419, 25418, 25404, 25385, 25409, 25396, 25432, 25428, 25433, 25389, 25415, 25395, 25434, 25425, 25400, 25431, 25408, 25416, 25930, 25926, 26054, 26051, 26052, 26050, 26186, 26207, 26183, 26193, 26386, 26387, 26655, 26650, 26697, 26674, 26675, 26683, 26699, 26703, 26646, 26673, 26652, 26677, 26667, 26669, 26671, 26702, 26692, 26676, 26653, 26642, 26644, 26662, 26664, 26670, 26701, 26682, 26661, 26656, 27436, 27439, 27437, 27441, 27444, 27501, 32898, 27528, 27622, 27620, 27624, 27619, 27618, 27623, 27685, 28026, 28003, 28004, 28022, 27917, 28001, 28050, 27992, 28002, 28013, 28015, 28049, 28045, 28143, 28031, 28038, 27998, 28007, 28e3, 28055, 28016, 28028, 27999, 28034, 28056, 27951, 28008, 28043, 28030, 28032, 28036, 27926, 28035, 28027, 28029, 28021, 28048, 28892, 28883, 28881, 28893, 28875, 32569, 28898, 28887, 28882, 28894, 28896, 28884, 28877, 28869, 28870, 28871, 28890, 28878, 28897, 29250, 29304, 29303, 29302, 29440, 29434, 29428, 29438, 29430, 29427, 29435, 29441, 29651, 29657, 29669, 29654, 29628, 29671, 29667, 29673, 29660, 29650, 29659, 29652, 29661, 29658, 29655, 29656, 29672, 29918, 29919, 29940, 29941, 29985, 30043, 30047, 30128, 30145, 30139, 30148, 30144, 30143, 30134, 30138, 30346, 30409, 30493, 30491, 30480, 30483, 30482, 30499, 30481, 30485, 30489, 30490, 30498, 30503, 30755, 30764, 30754, 30773, 30767, 30760, 30766, 30763, 30753, 30761, 30771, 30762, 30769, 31060, 31067, 31055, 31068, 31059, 31058, 31057, 31211, 31212, 31200, 31214, 31213, 31210, 31196, 31198, 31197, 31366, 31369, 31365, 31371, 31372, 31370, 31367, 31448, 31504, 31492, 31507, 31493, 31503, 31496, 31498, 31502, 31497, 31506, 31876, 31889, 31882, 31884, 31880, 31885, 31877, 32030, 32029, 32017, 32014, 32024, 32022, 32019, 32031, 32018, 32015, 32012, 32604, 32609, 32606, 32608, 32605, 32603, 32662, 32658, 32707, 32706, 32704, 32790, 32830, 32825, 33018, 33010, 33017, 33013, 33025, 33019, 33024, 33281, 33327, 33317, 33587, 33581, 33604, 33561, 33617, 33573, 33622, 33599, 33601, 33574, 33564, 33570, 33602, 33614, 33563, 33578, 33544, 33596, 33613, 33558, 33572, 33568, 33591, 33583, 33577, 33607, 33605, 33612, 33619, 33566, 33580, 33611, 33575, 33608, 34387, 34386, 34466, 34472, 34454, 34445, 34449, 34462, 34439, 34455, 34438, 34443, 34458, 34437, 34469, 34457, 34465, 34471, 34453, 34456, 34446, 34461, 34448, 34452, 34883, 34884, 34925, 34933, 34934, 34930, 34944, 34929, 34943, 34927, 34947, 34942, 34932, 34940, 35346, 35911, 35927, 35963, 36004, 36003, 36214, 36216, 36277, 36279, 36278, 36561, 36563, 36862, 36853, 36866, 36863, 36859, 36868, 36860, 36854, 37078, 37088, 37081, 37082, 37091, 37087, 37093, 37080, 37083, 37079, 37084, 37092, 37200, 37198, 37199, 37333, 37346, 37338, 38492, 38495, 38588, 39139, 39647, 39727, 20095, 20592, 20586, 20577, 20574, 20576, 20563, 20555, 20573, 20594, 20552, 20557, 20545, 20571, 20554, 20578, 20501, 20549, 20575, 20585, 20587, 20579, 20580, 20550, 20544, 20590, 20595, 20567, 20561, 20944, 21099, 21101, 21100, 21102, 21206, 21203, 21293, 21404, 21877, 21878, 21820, 21837, 21840, 21812, 21802, 21841, 21858, 21814, 21813, 21808, 21842, 21829, 21772, 21810, 21861, 21838, 21817, 21832, 21805, 21819, 21824, 21835, 22282, 22279, 22523, 22548, 22498, 22518, 22492, 22516, 22528, 22509, 22525, 22536, 22520, 22539, 22515, 22479, 22535, 22510, 22499, 22514, 22501, 22508, 22497, 22542, 22524, 22544, 22503, 22529, 22540, 22513, 22505, 22512, 22541, 22532, 22876, 23136, 23128, 23125, 23143, 23134, 23096, 23093, 23149, 23120, 23135, 23141, 23148, 23123, 23140, 23127, 23107, 23133, 23122, 23108, 23131, 23112, 23182, 23102, 23117, 23097, 23116, 23152, 23145, 23111, 23121, 23126, 23106, 23132, 23410, 23406, 23489, 23488, 23641, 23838, 23819, 23837, 23834, 23840, 23820, 23848, 23821, 23846, 23845, 23823, 23856, 23826, 23843, 23839, 23854, 24126, 24116, 24241, 24244, 24249, 24242, 24243, 24374, 24376, 24475, 24470, 24479, 24714, 24720, 24710, 24766, 24752, 24762, 24787, 24788, 24783, 24804, 24793, 24797, 24776, 24753, 24795, 24759, 24778, 24767, 24771, 24781, 24768, 25394, 25445, 25482, 25474, 25469, 25533, 25502, 25517, 25501, 25495, 25515, 25486, 25455, 25479, 25488, 25454, 25519, 25461, 25500, 25453, 25518, 25468, 25508, 25403, 25503, 25464, 25477, 25473, 25489, 25485, 25456, 25939, 26061, 26213, 26209, 26203, 26201, 26204, 26210, 26392, 26745, 26759, 26768, 26780, 26733, 26734, 26798, 26795, 26966, 26735, 26787, 26796, 26793, 26741, 26740, 26802, 26767, 26743, 26770, 26748, 26731, 26738, 26794, 26752, 26737, 26750, 26779, 26774, 26763, 26784, 26761, 26788, 26744, 26747, 26769, 26764, 26762, 26749, 27446, 27443, 27447, 27448, 27537, 27535, 27533, 27534, 27532, 27690, 28096, 28075, 28084, 28083, 28276, 28076, 28137, 28130, 28087, 28150, 28116, 28160, 28104, 28128, 28127, 28118, 28094, 28133, 28124, 28125, 28123, 28148, 28106, 28093, 28141, 28144, 28090, 28117, 28098, 28111, 28105, 28112, 28146, 28115, 28157, 28119, 28109, 28131, 28091, 28922, 28941, 28919, 28951, 28916, 28940, 28912, 28932, 28915, 28944, 28924, 28927, 28934, 28947, 28928, 28920, 28918, 28939, 28930, 28942, 29310, 29307, 29308, 29311, 29469, 29463, 29447, 29457, 29464, 29450, 29448, 29439, 29455, 29470, 29576, 29686, 29688, 29685, 29700, 29697, 29693, 29703, 29696, 29690, 29692, 29695, 29708, 29707, 29684, 29704, 30052, 30051, 30158, 30162, 30159, 30155, 30156, 30161, 30160, 30351, 30345, 30419, 30521, 30511, 30509, 30513, 30514, 30516, 30515, 30525, 30501, 30523, 30517, 30792, 30802, 30793, 30797, 30794, 30796, 30758, 30789, 30800, 31076, 31079, 31081, 31082, 31075, 31083, 31073, 31163, 31226, 31224, 31222, 31223, 31375, 31380, 31376, 31541, 31559, 31540, 31525, 31536, 31522, 31524, 31539, 31512, 31530, 31517, 31537, 31531, 31533, 31535, 31538, 31544, 31514, 31523, 31892, 31896, 31894, 31907, 32053, 32061, 32056, 32054, 32058, 32069, 32044, 32041, 32065, 32071, 32062, 32063, 32074, 32059, 32040, 32611, 32661, 32668, 32669, 32667, 32714, 32715, 32717, 32720, 32721, 32711, 32719, 32713, 32799, 32798, 32795, 32839, 32835, 32840, 33048, 33061, 33049, 33051, 33069, 33055, 33068, 33054, 33057, 33045, 33063, 33053, 33058, 33297, 33336, 33331, 33338, 33332, 33330, 33396, 33680, 33699, 33704, 33677, 33658, 33651, 33700, 33652, 33679, 33665, 33685, 33689, 33653, 33684, 33705, 33661, 33667, 33676, 33693, 33691, 33706, 33675, 33662, 33701, 33711, 33672, 33687, 33712, 33663, 33702, 33671, 33710, 33654, 33690, 34393, 34390, 34495, 34487, 34498, 34497, 34501, 34490, 34480, 34504, 34489, 34483, 34488, 34508, 34484, 34491, 34492, 34499, 34493, 34494, 34898, 34953, 34965, 34984, 34978, 34986, 34970, 34961, 34977, 34975, 34968, 34983, 34969, 34971, 34967, 34980, 34988, 34956, 34963, 34958, 35202, 35286, 35289, 35285, 35376, 35367, 35372, 35358, 35897, 35899, 35932, 35933, 35965, 36005, 36221, 36219, 36217, 36284, 36290, 36281, 36287, 36289, 36568, 36574, 36573, 36572, 36567, 36576, 36577, 36900, 36875, 36881, 36892, 36876, 36897, 37103, 37098, 37104, 37108, 37106, 37107, 37076, 37099, 37100, 37097, 37206, 37208, 37210, 37203, 37205, 37356, 37364, 37361, 37363, 37368, 37348, 37369, 37354, 37355, 37367, 37352, 37358, 38266, 38278, 38280, 38524, 38509, 38507, 38513, 38511, 38591, 38762, 38916, 39141, 39319, 20635, 20629, 20628, 20638, 20619, 20643, 20611, 20620, 20622, 20637, 20584, 20636, 20626, 20610, 20615, 20831, 20948, 21266, 21265, 21412, 21415, 21905, 21928, 21925, 21933, 21879, 22085, 21922, 21907, 21896, 21903, 21941, 21889, 21923, 21906, 21924, 21885, 21900, 21926, 21887, 21909, 21921, 21902, 22284, 22569, 22583, 22553, 22558, 22567, 22563, 22568, 22517, 22600, 22565, 22556, 22555, 22579, 22591, 22582, 22574, 22585, 22584, 22573, 22572, 22587, 22881, 23215, 23188, 23199, 23162, 23202, 23198, 23160, 23206, 23164, 23205, 23212, 23189, 23214, 23095, 23172, 23178, 23191, 23171, 23179, 23209, 23163, 23165, 23180, 23196, 23183, 23187, 23197, 23530, 23501, 23499, 23508, 23505, 23498, 23502, 23564, 23600, 23863, 23875, 23915, 23873, 23883, 23871, 23861, 23889, 23886, 23893, 23859, 23866, 23890, 23869, 23857, 23897, 23874, 23865, 23881, 23864, 23868, 23858, 23862, 23872, 23877, 24132, 24129, 24408, 24486, 24485, 24491, 24777, 24761, 24780, 24802, 24782, 24772, 24852, 24818, 24842, 24854, 24837, 24821, 24851, 24824, 24828, 24830, 24769, 24835, 24856, 24861, 24848, 24831, 24836, 24843, 25162, 25492, 25521, 25520, 25550, 25573, 25576, 25583, 25539, 25757, 25587, 25546, 25568, 25590, 25557, 25586, 25589, 25697, 25567, 25534, 25565, 25564, 25540, 25560, 25555, 25538, 25543, 25548, 25547, 25544, 25584, 25559, 25561, 25906, 25959, 25962, 25956, 25948, 25960, 25957, 25996, 26013, 26014, 26030, 26064, 26066, 26236, 26220, 26235, 26240, 26225, 26233, 26218, 26226, 26369, 26892, 26835, 26884, 26844, 26922, 26860, 26858, 26865, 26895, 26838, 26871, 26859, 26852, 26870, 26899, 26896, 26867, 26849, 26887, 26828, 26888, 26992, 26804, 26897, 26863, 26822, 26900, 26872, 26832, 26877, 26876, 26856, 26891, 26890, 26903, 26830, 26824, 26845, 26846, 26854, 26868, 26833, 26886, 26836, 26857, 26901, 26917, 26823, 27449, 27451, 27455, 27452, 27540, 27543, 27545, 27541, 27581, 27632, 27634, 27635, 27696, 28156, 28230, 28231, 28191, 28233, 28296, 28220, 28221, 28229, 28258, 28203, 28223, 28225, 28253, 28275, 28188, 28211, 28235, 28224, 28241, 28219, 28163, 28206, 28254, 28264, 28252, 28257, 28209, 28200, 28256, 28273, 28267, 28217, 28194, 28208, 28243, 28261, 28199, 28280, 28260, 28279, 28245, 28281, 28242, 28262, 28213, 28214, 28250, 28960, 28958, 28975, 28923, 28974, 28977, 28963, 28965, 28962, 28978, 28959, 28968, 28986, 28955, 29259, 29274, 29320, 29321, 29318, 29317, 29323, 29458, 29451, 29488, 29474, 29489, 29491, 29479, 29490, 29485, 29478, 29475, 29493, 29452, 29742, 29740, 29744, 29739, 29718, 29722, 29729, 29741, 29745, 29732, 29731, 29725, 29737, 29728, 29746, 29947, 29999, 30063, 30060, 30183, 30170, 30177, 30182, 30173, 30175, 30180, 30167, 30357, 30354, 30426, 30534, 30535, 30532, 30541, 30533, 30538, 30542, 30539, 30540, 30686, 30700, 30816, 30820, 30821, 30812, 30829, 30833, 30826, 30830, 30832, 30825, 30824, 30814, 30818, 31092, 31091, 31090, 31088, 31234, 31242, 31235, 31244, 31236, 31385, 31462, 31460, 31562, 31547, 31556, 31560, 31564, 31566, 31552, 31576, 31557, 31906, 31902, 31912, 31905, 32088, 32111, 32099, 32083, 32086, 32103, 32106, 32079, 32109, 32092, 32107, 32082, 32084, 32105, 32081, 32095, 32078, 32574, 32575, 32613, 32614, 32674, 32672, 32673, 32727, 32849, 32847, 32848, 33022, 32980, 33091, 33098, 33106, 33103, 33095, 33085, 33101, 33082, 33254, 33262, 33271, 33272, 33273, 33284, 33340, 33341, 33343, 33397, 33595, 33743, 33785, 33827, 33728, 33768, 33810, 33767, 33764, 33788, 33782, 33808, 33734, 33736, 33771, 33763, 33727, 33793, 33757, 33765, 33752, 33791, 33761, 33739, 33742, 33750, 33781, 33737, 33801, 33807, 33758, 33809, 33798, 33730, 33779, 33749, 33786, 33735, 33745, 33770, 33811, 33731, 33772, 33774, 33732, 33787, 33751, 33762, 33819, 33755, 33790, 34520, 34530, 34534, 34515, 34531, 34522, 34538, 34525, 34539, 34524, 34540, 34537, 34519, 34536, 34513, 34888, 34902, 34901, 35002, 35031, 35001, 35e3, 35008, 35006, 34998, 35004, 34999, 35005, 34994, 35073, 35017, 35221, 35224, 35223, 35293, 35290, 35291, 35406, 35405, 35385, 35417, 35392, 35415, 35416, 35396, 35397, 35410, 35400, 35409, 35402, 35404, 35407, 35935, 35969, 35968, 36026, 36030, 36016, 36025, 36021, 36228, 36224, 36233, 36312, 36307, 36301, 36295, 36310, 36316, 36303, 36309, 36313, 36296, 36311, 36293, 36591, 36599, 36602, 36601, 36582, 36590, 36581, 36597, 36583, 36584, 36598, 36587, 36593, 36588, 36596, 36585, 36909, 36916, 36911, 37126, 37164, 37124, 37119, 37116, 37128, 37113, 37115, 37121, 37120, 37127, 37125, 37123, 37217, 37220, 37215, 37218, 37216, 37377, 37386, 37413, 37379, 37402, 37414, 37391, 37388, 37376, 37394, 37375, 37373, 37382, 37380, 37415, 37378, 37404, 37412, 37401, 37399, 37381, 37398, 38267, 38285, 38284, 38288, 38535, 38526, 38536, 38537, 38531, 38528, 38594, 38600, 38595, 38641, 38640, 38764, 38768, 38766, 38919, 39081, 39147, 40166, 40697, 20099, 20100, 20150, 20669, 20671, 20678, 20654, 20676, 20682, 20660, 20680, 20674, 20656, 20673, 20666, 20657, 20683, 20681, 20662, 20664, 20951, 21114, 21112, 21115, 21116, 21955, 21979, 21964, 21968, 21963, 21962, 21981, 21952, 21972, 21956, 21993, 21951, 21970, 21901, 21967, 21973, 21986, 21974, 21960, 22002, 21965, 21977, 21954, 22292, 22611, 22632, 22628, 22607, 22605, 22601, 22639, 22613, 22606, 22621, 22617, 22629, 22619, 22589, 22627, 22641, 22780, 23239, 23236, 23243, 23226, 23224, 23217, 23221, 23216, 23231, 23240, 23227, 23238, 23223, 23232, 23242, 23220, 23222, 23245, 23225, 23184, 23510, 23512, 23513, 23583, 23603, 23921, 23907, 23882, 23909, 23922, 23916, 23902, 23912, 23911, 23906, 24048, 24143, 24142, 24138, 24141, 24139, 24261, 24268, 24262, 24267, 24263, 24384, 24495, 24493, 24823, 24905, 24906, 24875, 24901, 24886, 24882, 24878, 24902, 24879, 24911, 24873, 24896, 25120, 37224, 25123, 25125, 25124, 25541, 25585, 25579, 25616, 25618, 25609, 25632, 25636, 25651, 25667, 25631, 25621, 25624, 25657, 25655, 25634, 25635, 25612, 25638, 25648, 25640, 25665, 25653, 25647, 25610, 25626, 25664, 25637, 25639, 25611, 25575, 25627, 25646, 25633, 25614, 25967, 26002, 26067, 26246, 26252, 26261, 26256, 26251, 26250, 26265, 26260, 26232, 26400, 26982, 26975, 26936, 26958, 26978, 26993, 26943, 26949, 26986, 26937, 26946, 26967, 26969, 27002, 26952, 26953, 26933, 26988, 26931, 26941, 26981, 26864, 27e3, 26932, 26985, 26944, 26991, 26948, 26998, 26968, 26945, 26996, 26956, 26939, 26955, 26935, 26972, 26959, 26961, 26930, 26962, 26927, 27003, 26940, 27462, 27461, 27459, 27458, 27464, 27457, 27547, 64013, 27643, 27644, 27641, 27639, 27640, 28315, 28374, 28360, 28303, 28352, 28319, 28307, 28308, 28320, 28337, 28345, 28358, 28370, 28349, 28353, 28318, 28361, 28343, 28336, 28365, 28326, 28367, 28338, 28350, 28355, 28380, 28376, 28313, 28306, 28302, 28301, 28324, 28321, 28351, 28339, 28368, 28362, 28311, 28334, 28323, 28999, 29012, 29010, 29027, 29024, 28993, 29021, 29026, 29042, 29048, 29034, 29025, 28994, 29016, 28995, 29003, 29040, 29023, 29008, 29011, 28996, 29005, 29018, 29263, 29325, 29324, 29329, 29328, 29326, 29500, 29506, 29499, 29498, 29504, 29514, 29513, 29764, 29770, 29771, 29778, 29777, 29783, 29760, 29775, 29776, 29774, 29762, 29766, 29773, 29780, 29921, 29951, 29950, 29949, 29981, 30073, 30071, 27011, 30191, 30223, 30211, 30199, 30206, 30204, 30201, 30200, 30224, 30203, 30198, 30189, 30197, 30205, 30361, 30389, 30429, 30549, 30559, 30560, 30546, 30550, 30554, 30569, 30567, 30548, 30553, 30573, 30688, 30855, 30874, 30868, 30863, 30852, 30869, 30853, 30854, 30881, 30851, 30841, 30873, 30848, 30870, 30843, 31100, 31106, 31101, 31097, 31249, 31256, 31257, 31250, 31255, 31253, 31266, 31251, 31259, 31248, 31395, 31394, 31390, 31467, 31590, 31588, 31597, 31604, 31593, 31602, 31589, 31603, 31601, 31600, 31585, 31608, 31606, 31587, 31922, 31924, 31919, 32136, 32134, 32128, 32141, 32127, 32133, 32122, 32142, 32123, 32131, 32124, 32140, 32148, 32132, 32125, 32146, 32621, 32619, 32615, 32616, 32620, 32678, 32677, 32679, 32731, 32732, 32801, 33124, 33120, 33143, 33116, 33129, 33115, 33122, 33138, 26401, 33118, 33142, 33127, 33135, 33092, 33121, 33309, 33353, 33348, 33344, 33346, 33349, 34033, 33855, 33878, 33910, 33913, 33935, 33933, 33893, 33873, 33856, 33926, 33895, 33840, 33869, 33917, 33882, 33881, 33908, 33907, 33885, 34055, 33886, 33847, 33850, 33844, 33914, 33859, 33912, 33842, 33861, 33833, 33753, 33867, 33839, 33858, 33837, 33887, 33904, 33849, 33870, 33868, 33874, 33903, 33989, 33934, 33851, 33863, 33846, 33843, 33896, 33918, 33860, 33835, 33888, 33876, 33902, 33872, 34571, 34564, 34551, 34572, 34554, 34518, 34549, 34637, 34552, 34574, 34569, 34561, 34550, 34573, 34565, 35030, 35019, 35021, 35022, 35038, 35035, 35034, 35020, 35024, 35205, 35227, 35295, 35301, 35300, 35297, 35296, 35298, 35292, 35302, 35446, 35462, 35455, 35425, 35391, 35447, 35458, 35460, 35445, 35459, 35457, 35444, 35450, 35900, 35915, 35914, 35941, 35940, 35942, 35974, 35972, 35973, 36044, 36200, 36201, 36241, 36236, 36238, 36239, 36237, 36243, 36244, 36240, 36242, 36336, 36320, 36332, 36337, 36334, 36304, 36329, 36323, 36322, 36327, 36338, 36331, 36340, 36614, 36607, 36609, 36608, 36613, 36615, 36616, 36610, 36619, 36946, 36927, 36932, 36937, 36925, 37136, 37133, 37135, 37137, 37142, 37140, 37131, 37134, 37230, 37231, 37448, 37458, 37424, 37434, 37478, 37427, 37477, 37470, 37507, 37422, 37450, 37446, 37485, 37484, 37455, 37472, 37479, 37487, 37430, 37473, 37488, 37425, 37460, 37475, 37456, 37490, 37454, 37459, 37452, 37462, 37426, 38303, 38300, 38302, 38299, 38546, 38547, 38545, 38551, 38606, 38650, 38653, 38648, 38645, 38771, 38775, 38776, 38770, 38927, 38925, 38926, 39084, 39158, 39161, 39343, 39346, 39344, 39349, 39597, 39595, 39771, 40170, 40173, 40167, 40576, 40701, 20710, 20692, 20695, 20712, 20723, 20699, 20714, 20701, 20708, 20691, 20716, 20720, 20719, 20707, 20704, 20952, 21120, 21121, 21225, 21227, 21296, 21420, 22055, 22037, 22028, 22034, 22012, 22031, 22044, 22017, 22035, 22018, 22010, 22045, 22020, 22015, 22009, 22665, 22652, 22672, 22680, 22662, 22657, 22655, 22644, 22667, 22650, 22663, 22673, 22670, 22646, 22658, 22664, 22651, 22676, 22671, 22782, 22891, 23260, 23278, 23269, 23253, 23274, 23258, 23277, 23275, 23283, 23266, 23264, 23259, 23276, 23262, 23261, 23257, 23272, 23263, 23415, 23520, 23523, 23651, 23938, 23936, 23933, 23942, 23930, 23937, 23927, 23946, 23945, 23944, 23934, 23932, 23949, 23929, 23935, 24152, 24153, 24147, 24280, 24273, 24279, 24270, 24284, 24277, 24281, 24274, 24276, 24388, 24387, 24431, 24502, 24876, 24872, 24897, 24926, 24945, 24947, 24914, 24915, 24946, 24940, 24960, 24948, 24916, 24954, 24923, 24933, 24891, 24938, 24929, 24918, 25129, 25127, 25131, 25643, 25677, 25691, 25693, 25716, 25718, 25714, 25715, 25725, 25717, 25702, 25766, 25678, 25730, 25694, 25692, 25675, 25683, 25696, 25680, 25727, 25663, 25708, 25707, 25689, 25701, 25719, 25971, 26016, 26273, 26272, 26271, 26373, 26372, 26402, 27057, 27062, 27081, 27040, 27086, 27030, 27056, 27052, 27068, 27025, 27033, 27022, 27047, 27021, 27049, 27070, 27055, 27071, 27076, 27069, 27044, 27092, 27065, 27082, 27034, 27087, 27059, 27027, 27050, 27041, 27038, 27097, 27031, 27024, 27074, 27061, 27045, 27078, 27466, 27469, 27467, 27550, 27551, 27552, 27587, 27588, 27646, 28366, 28405, 28401, 28419, 28453, 28408, 28471, 28411, 28462, 28425, 28494, 28441, 28442, 28455, 28440, 28475, 28434, 28397, 28426, 28470, 28531, 28409, 28398, 28461, 28480, 28464, 28476, 28469, 28395, 28423, 28430, 28483, 28421, 28413, 28406, 28473, 28444, 28412, 28474, 28447, 28429, 28446, 28424, 28449, 29063, 29072, 29065, 29056, 29061, 29058, 29071, 29051, 29062, 29057, 29079, 29252, 29267, 29335, 29333, 29331, 29507, 29517, 29521, 29516, 29794, 29811, 29809, 29813, 29810, 29799, 29806, 29952, 29954, 29955, 30077, 30096, 30230, 30216, 30220, 30229, 30225, 30218, 30228, 30392, 30593, 30588, 30597, 30594, 30574, 30592, 30575, 30590, 30595, 30898, 30890, 30900, 30893, 30888, 30846, 30891, 30878, 30885, 30880, 30892, 30882, 30884, 31128, 31114, 31115, 31126, 31125, 31124, 31123, 31127, 31112, 31122, 31120, 31275, 31306, 31280, 31279, 31272, 31270, 31400, 31403, 31404, 31470, 31624, 31644, 31626, 31633, 31632, 31638, 31629, 31628, 31643, 31630, 31621, 31640, 21124, 31641, 31652, 31618, 31931, 31935, 31932, 31930, 32167, 32183, 32194, 32163, 32170, 32193, 32192, 32197, 32157, 32206, 32196, 32198, 32203, 32204, 32175, 32185, 32150, 32188, 32159, 32166, 32174, 32169, 32161, 32201, 32627, 32738, 32739, 32741, 32734, 32804, 32861, 32860, 33161, 33158, 33155, 33159, 33165, 33164, 33163, 33301, 33943, 33956, 33953, 33951, 33978, 33998, 33986, 33964, 33966, 33963, 33977, 33972, 33985, 33997, 33962, 33946, 33969, 34e3, 33949, 33959, 33979, 33954, 33940, 33991, 33996, 33947, 33961, 33967, 33960, 34006, 33944, 33974, 33999, 33952, 34007, 34004, 34002, 34011, 33968, 33937, 34401, 34611, 34595, 34600, 34667, 34624, 34606, 34590, 34593, 34585, 34587, 34627, 34604, 34625, 34622, 34630, 34592, 34610, 34602, 34605, 34620, 34578, 34618, 34609, 34613, 34626, 34598, 34599, 34616, 34596, 34586, 34608, 34577, 35063, 35047, 35057, 35058, 35066, 35070, 35054, 35068, 35062, 35067, 35056, 35052, 35051, 35229, 35233, 35231, 35230, 35305, 35307, 35304, 35499, 35481, 35467, 35474, 35471, 35478, 35901, 35944, 35945, 36053, 36047, 36055, 36246, 36361, 36354, 36351, 36365, 36349, 36362, 36355, 36359, 36358, 36357, 36350, 36352, 36356, 36624, 36625, 36622, 36621, 37155, 37148, 37152, 37154, 37151, 37149, 37146, 37156, 37153, 37147, 37242, 37234, 37241, 37235, 37541, 37540, 37494, 37531, 37498, 37536, 37524, 37546, 37517, 37542, 37530, 37547, 37497, 37527, 37503, 37539, 37614, 37518, 37506, 37525, 37538, 37501, 37512, 37537, 37514, 37510, 37516, 37529, 37543, 37502, 37511, 37545, 37533, 37515, 37421, 38558, 38561, 38655, 38744, 38781, 38778, 38782, 38787, 38784, 38786, 38779, 38788, 38785, 38783, 38862, 38861, 38934, 39085, 39086, 39170, 39168, 39175, 39325, 39324, 39363, 39353, 39355, 39354, 39362, 39357, 39367, 39601, 39651, 39655, 39742, 39743, 39776, 39777, 39775, 40177, 40178, 40181, 40615, 20735, 20739, 20784, 20728, 20742, 20743, 20726, 20734, 20747, 20748, 20733, 20746, 21131, 21132, 21233, 21231, 22088, 22082, 22092, 22069, 22081, 22090, 22089, 22086, 22104, 22106, 22080, 22067, 22077, 22060, 22078, 22072, 22058, 22074, 22298, 22699, 22685, 22705, 22688, 22691, 22703, 22700, 22693, 22689, 22783, 23295, 23284, 23293, 23287, 23286, 23299, 23288, 23298, 23289, 23297, 23303, 23301, 23311, 23655, 23961, 23959, 23967, 23954, 23970, 23955, 23957, 23968, 23964, 23969, 23962, 23966, 24169, 24157, 24160, 24156, 32243, 24283, 24286, 24289, 24393, 24498, 24971, 24963, 24953, 25009, 25008, 24994, 24969, 24987, 24979, 25007, 25005, 24991, 24978, 25002, 24993, 24973, 24934, 25011, 25133, 25710, 25712, 25750, 25760, 25733, 25751, 25756, 25743, 25739, 25738, 25740, 25763, 25759, 25704, 25777, 25752, 25974, 25978, 25977, 25979, 26034, 26035, 26293, 26288, 26281, 26290, 26295, 26282, 26287, 27136, 27142, 27159, 27109, 27128, 27157, 27121, 27108, 27168, 27135, 27116, 27106, 27163, 27165, 27134, 27175, 27122, 27118, 27156, 27127, 27111, 27200, 27144, 27110, 27131, 27149, 27132, 27115, 27145, 27140, 27160, 27173, 27151, 27126, 27174, 27143, 27124, 27158, 27473, 27557, 27555, 27554, 27558, 27649, 27648, 27647, 27650, 28481, 28454, 28542, 28551, 28614, 28562, 28557, 28553, 28556, 28514, 28495, 28549, 28506, 28566, 28534, 28524, 28546, 28501, 28530, 28498, 28496, 28503, 28564, 28563, 28509, 28416, 28513, 28523, 28541, 28519, 28560, 28499, 28555, 28521, 28543, 28565, 28515, 28535, 28522, 28539, 29106, 29103, 29083, 29104, 29088, 29082, 29097, 29109, 29085, 29093, 29086, 29092, 29089, 29098, 29084, 29095, 29107, 29336, 29338, 29528, 29522, 29534, 29535, 29536, 29533, 29531, 29537, 29530, 29529, 29538, 29831, 29833, 29834, 29830, 29825, 29821, 29829, 29832, 29820, 29817, 29960, 29959, 30078, 30245, 30238, 30233, 30237, 30236, 30243, 30234, 30248, 30235, 30364, 30365, 30366, 30363, 30605, 30607, 30601, 30600, 30925, 30907, 30927, 30924, 30929, 30926, 30932, 30920, 30915, 30916, 30921, 31130, 31137, 31136, 31132, 31138, 31131, 27510, 31289, 31410, 31412, 31411, 31671, 31691, 31678, 31660, 31694, 31663, 31673, 31690, 31669, 31941, 31944, 31948, 31947, 32247, 32219, 32234, 32231, 32215, 32225, 32259, 32250, 32230, 32246, 32241, 32240, 32238, 32223, 32630, 32684, 32688, 32685, 32749, 32747, 32746, 32748, 32742, 32744, 32868, 32871, 33187, 33183, 33182, 33173, 33186, 33177, 33175, 33302, 33359, 33363, 33362, 33360, 33358, 33361, 34084, 34107, 34063, 34048, 34089, 34062, 34057, 34061, 34079, 34058, 34087, 34076, 34043, 34091, 34042, 34056, 34060, 34036, 34090, 34034, 34069, 34039, 34027, 34035, 34044, 34066, 34026, 34025, 34070, 34046, 34088, 34077, 34094, 34050, 34045, 34078, 34038, 34097, 34086, 34023, 34024, 34032, 34031, 34041, 34072, 34080, 34096, 34059, 34073, 34095, 34402, 34646, 34659, 34660, 34679, 34785, 34675, 34648, 34644, 34651, 34642, 34657, 34650, 34641, 34654, 34669, 34666, 34640, 34638, 34655, 34653, 34671, 34668, 34682, 34670, 34652, 34661, 34639, 34683, 34677, 34658, 34663, 34665, 34906, 35077, 35084, 35092, 35083, 35095, 35096, 35097, 35078, 35094, 35089, 35086, 35081, 35234, 35236, 35235, 35309, 35312, 35308, 35535, 35526, 35512, 35539, 35537, 35540, 35541, 35515, 35543, 35518, 35520, 35525, 35544, 35523, 35514, 35517, 35545, 35902, 35917, 35983, 36069, 36063, 36057, 36072, 36058, 36061, 36071, 36256, 36252, 36257, 36251, 36384, 36387, 36389, 36388, 36398, 36373, 36379, 36374, 36369, 36377, 36390, 36391, 36372, 36370, 36376, 36371, 36380, 36375, 36378, 36652, 36644, 36632, 36634, 36640, 36643, 36630, 36631, 36979, 36976, 36975, 36967, 36971, 37167, 37163, 37161, 37162, 37170, 37158, 37166, 37253, 37254, 37258, 37249, 37250, 37252, 37248, 37584, 37571, 37572, 37568, 37593, 37558, 37583, 37617, 37599, 37592, 37609, 37591, 37597, 37580, 37615, 37570, 37608, 37578, 37576, 37582, 37606, 37581, 37589, 37577, 37600, 37598, 37607, 37585, 37587, 37557, 37601, 37574, 37556, 38268, 38316, 38315, 38318, 38320, 38564, 38562, 38611, 38661, 38664, 38658, 38746, 38794, 38798, 38792, 38864, 38863, 38942, 38941, 38950, 38953, 38952, 38944, 38939, 38951, 39090, 39176, 39162, 39185, 39188, 39190, 39191, 39189, 39388, 39373, 39375, 39379, 39380, 39374, 39369, 39382, 39384, 39371, 39383, 39372, 39603, 39660, 39659, 39667, 39666, 39665, 39750, 39747, 39783, 39796, 39793, 39782, 39798, 39797, 39792, 39784, 39780, 39788, 40188, 40186, 40189, 40191, 40183, 40199, 40192, 40185, 40187, 40200, 40197, 40196, 40579, 40659, 40719, 40720, 20764, 20755, 20759, 20762, 20753, 20958, 21300, 21473, 22128, 22112, 22126, 22131, 22118, 22115, 22125, 22130, 22110, 22135, 22300, 22299, 22728, 22717, 22729, 22719, 22714, 22722, 22716, 22726, 23319, 23321, 23323, 23329, 23316, 23315, 23312, 23318, 23336, 23322, 23328, 23326, 23535, 23980, 23985, 23977, 23975, 23989, 23984, 23982, 23978, 23976, 23986, 23981, 23983, 23988, 24167, 24168, 24166, 24175, 24297, 24295, 24294, 24296, 24293, 24395, 24508, 24989, 25e3, 24982, 25029, 25012, 25030, 25025, 25036, 25018, 25023, 25016, 24972, 25815, 25814, 25808, 25807, 25801, 25789, 25737, 25795, 25819, 25843, 25817, 25907, 25983, 25980, 26018, 26312, 26302, 26304, 26314, 26315, 26319, 26301, 26299, 26298, 26316, 26403, 27188, 27238, 27209, 27239, 27186, 27240, 27198, 27229, 27245, 27254, 27227, 27217, 27176, 27226, 27195, 27199, 27201, 27242, 27236, 27216, 27215, 27220, 27247, 27241, 27232, 27196, 27230, 27222, 27221, 27213, 27214, 27206, 27477, 27476, 27478, 27559, 27562, 27563, 27592, 27591, 27652, 27651, 27654, 28589, 28619, 28579, 28615, 28604, 28622, 28616, 28510, 28612, 28605, 28574, 28618, 28584, 28676, 28581, 28590, 28602, 28588, 28586, 28623, 28607, 28600, 28578, 28617, 28587, 28621, 28591, 28594, 28592, 29125, 29122, 29119, 29112, 29142, 29120, 29121, 29131, 29140, 29130, 29127, 29135, 29117, 29144, 29116, 29126, 29146, 29147, 29341, 29342, 29545, 29542, 29543, 29548, 29541, 29547, 29546, 29823, 29850, 29856, 29844, 29842, 29845, 29857, 29963, 30080, 30255, 30253, 30257, 30269, 30259, 30268, 30261, 30258, 30256, 30395, 30438, 30618, 30621, 30625, 30620, 30619, 30626, 30627, 30613, 30617, 30615, 30941, 30953, 30949, 30954, 30942, 30947, 30939, 30945, 30946, 30957, 30943, 30944, 31140, 31300, 31304, 31303, 31414, 31416, 31413, 31409, 31415, 31710, 31715, 31719, 31709, 31701, 31717, 31706, 31720, 31737, 31700, 31722, 31714, 31708, 31723, 31704, 31711, 31954, 31956, 31959, 31952, 31953, 32274, 32289, 32279, 32268, 32287, 32288, 32275, 32270, 32284, 32277, 32282, 32290, 32267, 32271, 32278, 32269, 32276, 32293, 32292, 32579, 32635, 32636, 32634, 32689, 32751, 32810, 32809, 32876, 33201, 33190, 33198, 33209, 33205, 33195, 33200, 33196, 33204, 33202, 33207, 33191, 33266, 33365, 33366, 33367, 34134, 34117, 34155, 34125, 34131, 34145, 34136, 34112, 34118, 34148, 34113, 34146, 34116, 34129, 34119, 34147, 34110, 34139, 34161, 34126, 34158, 34165, 34133, 34151, 34144, 34188, 34150, 34141, 34132, 34149, 34156, 34403, 34405, 34404, 34715, 34703, 34711, 34707, 34706, 34696, 34689, 34710, 34712, 34681, 34695, 34723, 34693, 34704, 34705, 34717, 34692, 34708, 34716, 34714, 34697, 35102, 35110, 35120, 35117, 35118, 35111, 35121, 35106, 35113, 35107, 35119, 35116, 35103, 35313, 35552, 35554, 35570, 35572, 35573, 35549, 35604, 35556, 35551, 35568, 35528, 35550, 35553, 35560, 35583, 35567, 35579, 35985, 35986, 35984, 36085, 36078, 36081, 36080, 36083, 36204, 36206, 36261, 36263, 36403, 36414, 36408, 36416, 36421, 36406, 36412, 36413, 36417, 36400, 36415, 36541, 36662, 36654, 36661, 36658, 36665, 36663, 36660, 36982, 36985, 36987, 36998, 37114, 37171, 37173, 37174, 37267, 37264, 37265, 37261, 37263, 37671, 37662, 37640, 37663, 37638, 37647, 37754, 37688, 37692, 37659, 37667, 37650, 37633, 37702, 37677, 37646, 37645, 37579, 37661, 37626, 37669, 37651, 37625, 37623, 37684, 37634, 37668, 37631, 37673, 37689, 37685, 37674, 37652, 37644, 37643, 37630, 37641, 37632, 37627, 37654, 38332, 38349, 38334, 38329, 38330, 38326, 38335, 38325, 38333, 38569, 38612, 38667, 38674, 38672, 38809, 38807, 38804, 38896, 38904, 38965, 38959, 38962, 39204, 39199, 39207, 39209, 39326, 39406, 39404, 39397, 39396, 39408, 39395, 39402, 39401, 39399, 39609, 39615, 39604, 39611, 39670, 39674, 39673, 39671, 39731, 39808, 39813, 39815, 39804, 39806, 39803, 39810, 39827, 39826, 39824, 39802, 39829, 39805, 39816, 40229, 40215, 40224, 40222, 40212, 40233, 40221, 40216, 40226, 40208, 40217, 40223, 40584, 40582, 40583, 40622, 40621, 40661, 40662, 40698, 40722, 40765, 20774, 20773, 20770, 20772, 20768, 20777, 21236, 22163, 22156, 22157, 22150, 22148, 22147, 22142, 22146, 22143, 22145, 22742, 22740, 22735, 22738, 23341, 23333, 23346, 23331, 23340, 23335, 23334, 23343, 23342, 23419, 23537, 23538, 23991, 24172, 24170, 24510, 24507, 25027, 25013, 25020, 25063, 25056, 25061, 25060, 25064, 25054, 25839, 25833, 25827, 25835, 25828, 25832, 25985, 25984, 26038, 26074, 26322, 27277, 27286, 27265, 27301, 27273, 27295, 27291, 27297, 27294, 27271, 27283, 27278, 27285, 27267, 27304, 27300, 27281, 27263, 27302, 27290, 27269, 27276, 27282, 27483, 27565, 27657, 28620, 28585, 28660, 28628, 28643, 28636, 28653, 28647, 28646, 28638, 28658, 28637, 28642, 28648, 29153, 29169, 29160, 29170, 29156, 29168, 29154, 29555, 29550, 29551, 29847, 29874, 29867, 29840, 29866, 29869, 29873, 29861, 29871, 29968, 29969, 29970, 29967, 30084, 30275, 30280, 30281, 30279, 30372, 30441, 30645, 30635, 30642, 30647, 30646, 30644, 30641, 30632, 30704, 30963, 30973, 30978, 30971, 30972, 30962, 30981, 30969, 30974, 30980, 31147, 31144, 31324, 31323, 31318, 31320, 31316, 31322, 31422, 31424, 31425, 31749, 31759, 31730, 31744, 31743, 31739, 31758, 31732, 31755, 31731, 31746, 31753, 31747, 31745, 31736, 31741, 31750, 31728, 31729, 31760, 31754, 31976, 32301, 32316, 32322, 32307, 38984, 32312, 32298, 32329, 32320, 32327, 32297, 32332, 32304, 32315, 32310, 32324, 32314, 32581, 32639, 32638, 32637, 32756, 32754, 32812, 33211, 33220, 33228, 33226, 33221, 33223, 33212, 33257, 33371, 33370, 33372, 34179, 34176, 34191, 34215, 34197, 34208, 34187, 34211, 34171, 34212, 34202, 34206, 34167, 34172, 34185, 34209, 34170, 34168, 34135, 34190, 34198, 34182, 34189, 34201, 34205, 34177, 34210, 34178, 34184, 34181, 34169, 34166, 34200, 34192, 34207, 34408, 34750, 34730, 34733, 34757, 34736, 34732, 34745, 34741, 34748, 34734, 34761, 34755, 34754, 34764, 34743, 34735, 34756, 34762, 34740, 34742, 34751, 34744, 34749, 34782, 34738, 35125, 35123, 35132, 35134, 35137, 35154, 35127, 35138, 35245, 35247, 35246, 35314, 35315, 35614, 35608, 35606, 35601, 35589, 35595, 35618, 35599, 35602, 35605, 35591, 35597, 35592, 35590, 35612, 35603, 35610, 35919, 35952, 35954, 35953, 35951, 35989, 35988, 36089, 36207, 36430, 36429, 36435, 36432, 36428, 36423, 36675, 36672, 36997, 36990, 37176, 37274, 37282, 37275, 37273, 37279, 37281, 37277, 37280, 37793, 37763, 37807, 37732, 37718, 37703, 37756, 37720, 37724, 37750, 37705, 37712, 37713, 37728, 37741, 37775, 37708, 37738, 37753, 37719, 37717, 37714, 37711, 37745, 37751, 37755, 37729, 37726, 37731, 37735, 37760, 37710, 37721, 38343, 38336, 38345, 38339, 38341, 38327, 38574, 38576, 38572, 38688, 38687, 38680, 38685, 38681, 38810, 38817, 38812, 38814, 38813, 38869, 38868, 38897, 38977, 38980, 38986, 38985, 38981, 38979, 39205, 39211, 39212, 39210, 39219, 39218, 39215, 39213, 39217, 39216, 39320, 39331, 39329, 39426, 39418, 39412, 39415, 39417, 39416, 39414, 39419, 39421, 39422, 39420, 39427, 39614, 39678, 39677, 39681, 39676, 39752, 39834, 39848, 39838, 39835, 39846, 39841, 39845, 39844, 39814, 39842, 39840, 39855, 40243, 40257, 40295, 40246, 40238, 40239, 40241, 40248, 40240, 40261, 40258, 40259, 40254, 40247, 40256, 40253, 32757, 40237, 40586, 40585, 40589, 40624, 40648, 40666, 40699, 40703, 40740, 40739, 40738, 40788, 40864, 20785, 20781, 20782, 22168, 22172, 22167, 22170, 22173, 22169, 22896, 23356, 23657, 23658, 24e3, 24173, 24174, 25048, 25055, 25069, 25070, 25073, 25066, 25072, 25067, 25046, 25065, 25855, 25860, 25853, 25848, 25857, 25859, 25852, 26004, 26075, 26330, 26331, 26328, 27333, 27321, 27325, 27361, 27334, 27322, 27318, 27319, 27335, 27316, 27309, 27486, 27593, 27659, 28679, 28684, 28685, 28673, 28677, 28692, 28686, 28671, 28672, 28667, 28710, 28668, 28663, 28682, 29185, 29183, 29177, 29187, 29181, 29558, 29880, 29888, 29877, 29889, 29886, 29878, 29883, 29890, 29972, 29971, 30300, 30308, 30297, 30288, 30291, 30295, 30298, 30374, 30397, 30444, 30658, 30650, 30975, 30988, 30995, 30996, 30985, 30992, 30994, 30993, 31149, 31148, 31327, 31772, 31785, 31769, 31776, 31775, 31789, 31773, 31782, 31784, 31778, 31781, 31792, 32348, 32336, 32342, 32355, 32344, 32354, 32351, 32337, 32352, 32343, 32339, 32693, 32691, 32759, 32760, 32885, 33233, 33234, 33232, 33375, 33374, 34228, 34246, 34240, 34243, 34242, 34227, 34229, 34237, 34247, 34244, 34239, 34251, 34254, 34248, 34245, 34225, 34230, 34258, 34340, 34232, 34231, 34238, 34409, 34791, 34790, 34786, 34779, 34795, 34794, 34789, 34783, 34803, 34788, 34772, 34780, 34771, 34797, 34776, 34787, 34724, 34775, 34777, 34817, 34804, 34792, 34781, 35155, 35147, 35151, 35148, 35142, 35152, 35153, 35145, 35626, 35623, 35619, 35635, 35632, 35637, 35655, 35631, 35644, 35646, 35633, 35621, 35639, 35622, 35638, 35630, 35620, 35643, 35645, 35642, 35906, 35957, 35993, 35992, 35991, 36094, 36100, 36098, 36096, 36444, 36450, 36448, 36439, 36438, 36446, 36453, 36455, 36443, 36442, 36449, 36445, 36457, 36436, 36678, 36679, 36680, 36683, 37160, 37178, 37179, 37182, 37288, 37285, 37287, 37295, 37290, 37813, 37772, 37778, 37815, 37787, 37789, 37769, 37799, 37774, 37802, 37790, 37798, 37781, 37768, 37785, 37791, 37773, 37809, 37777, 37810, 37796, 37800, 37812, 37795, 37797, 38354, 38355, 38353, 38579, 38615, 38618, 24002, 38623, 38616, 38621, 38691, 38690, 38693, 38828, 38830, 38824, 38827, 38820, 38826, 38818, 38821, 38871, 38873, 38870, 38872, 38906, 38992, 38993, 38994, 39096, 39233, 39228, 39226, 39439, 39435, 39433, 39437, 39428, 39441, 39434, 39429, 39431, 39430, 39616, 39644, 39688, 39684, 39685, 39721, 39733, 39754, 39756, 39755, 39879, 39878, 39875, 39871, 39873, 39861, 39864, 39891, 39862, 39876, 39865, 39869, 40284, 40275, 40271, 40266, 40283, 40267, 40281, 40278, 40268, 40279, 40274, 40276, 40287, 40280, 40282, 40590, 40588, 40671, 40705, 40704, 40726, 40741, 40747, 40746, 40745, 40744, 40780, 40789, 20788, 20789, 21142, 21239, 21428, 22187, 22189, 22182, 22183, 22186, 22188, 22746, 22749, 22747, 22802, 23357, 23358, 23359, 24003, 24176, 24511, 25083, 25863, 25872, 25869, 25865, 25868, 25870, 25988, 26078, 26077, 26334, 27367, 27360, 27340, 27345, 27353, 27339, 27359, 27356, 27344, 27371, 27343, 27341, 27358, 27488, 27568, 27660, 28697, 28711, 28704, 28694, 28715, 28705, 28706, 28707, 28713, 28695, 28708, 28700, 28714, 29196, 29194, 29191, 29186, 29189, 29349, 29350, 29348, 29347, 29345, 29899, 29893, 29879, 29891, 29974, 30304, 30665, 30666, 30660, 30705, 31005, 31003, 31009, 31004, 30999, 31006, 31152, 31335, 31336, 31795, 31804, 31801, 31788, 31803, 31980, 31978, 32374, 32373, 32376, 32368, 32375, 32367, 32378, 32370, 32372, 32360, 32587, 32586, 32643, 32646, 32695, 32765, 32766, 32888, 33239, 33237, 33380, 33377, 33379, 34283, 34289, 34285, 34265, 34273, 34280, 34266, 34263, 34284, 34290, 34296, 34264, 34271, 34275, 34268, 34257, 34288, 34278, 34287, 34270, 34274, 34816, 34810, 34819, 34806, 34807, 34825, 34828, 34827, 34822, 34812, 34824, 34815, 34826, 34818, 35170, 35162, 35163, 35159, 35169, 35164, 35160, 35165, 35161, 35208, 35255, 35254, 35318, 35664, 35656, 35658, 35648, 35667, 35670, 35668, 35659, 35669, 35665, 35650, 35666, 35671, 35907, 35959, 35958, 35994, 36102, 36103, 36105, 36268, 36266, 36269, 36267, 36461, 36472, 36467, 36458, 36463, 36475, 36546, 36690, 36689, 36687, 36688, 36691, 36788, 37184, 37183, 37296, 37293, 37854, 37831, 37839, 37826, 37850, 37840, 37881, 37868, 37836, 37849, 37801, 37862, 37834, 37844, 37870, 37859, 37845, 37828, 37838, 37824, 37842, 37863, 38269, 38362, 38363, 38625, 38697, 38699, 38700, 38696, 38694, 38835, 38839, 38838, 38877, 38878, 38879, 39004, 39001, 39005, 38999, 39103, 39101, 39099, 39102, 39240, 39239, 39235, 39334, 39335, 39450, 39445, 39461, 39453, 39460, 39451, 39458, 39456, 39463, 39459, 39454, 39452, 39444, 39618, 39691, 39690, 39694, 39692, 39735, 39914, 39915, 39904, 39902, 39908, 39910, 39906, 39920, 39892, 39895, 39916, 39900, 39897, 39909, 39893, 39905, 39898, 40311, 40321, 40330, 40324, 40328, 40305, 40320, 40312, 40326, 40331, 40332, 40317, 40299, 40308, 40309, 40304, 40297, 40325, 40307, 40315, 40322, 40303, 40313, 40319, 40327, 40296, 40596, 40593, 40640, 40700, 40749, 40768, 40769, 40781, 40790, 40791, 40792, 21303, 22194, 22197, 22195, 22755, 23365, 24006, 24007, 24302, 24303, 24512, 24513, 25081, 25879, 25878, 25877, 25875, 26079, 26344, 26339, 26340, 27379, 27376, 27370, 27368, 27385, 27377, 27374, 27375, 28732, 28725, 28719, 28727, 28724, 28721, 28738, 28728, 28735, 28730, 28729, 28736, 28731, 28723, 28737, 29203, 29204, 29352, 29565, 29564, 29882, 30379, 30378, 30398, 30445, 30668, 30670, 30671, 30669, 30706, 31013, 31011, 31015, 31016, 31012, 31017, 31154, 31342, 31340, 31341, 31479, 31817, 31816, 31818, 31815, 31813, 31982, 32379, 32382, 32385, 32384, 32698, 32767, 32889, 33243, 33241, 33291, 33384, 33385, 34338, 34303, 34305, 34302, 34331, 34304, 34294, 34308, 34313, 34309, 34316, 34301, 34841, 34832, 34833, 34839, 34835, 34838, 35171, 35174, 35257, 35319, 35680, 35690, 35677, 35688, 35683, 35685, 35687, 35693, 36270, 36486, 36488, 36484, 36697, 36694, 36695, 36693, 36696, 36698, 37005, 37187, 37185, 37303, 37301, 37298, 37299, 37899, 37907, 37883, 37920, 37903, 37908, 37886, 37909, 37904, 37928, 37913, 37901, 37877, 37888, 37879, 37895, 37902, 37910, 37906, 37882, 37897, 37880, 37898, 37887, 37884, 37900, 37878, 37905, 37894, 38366, 38368, 38367, 38702, 38703, 38841, 38843, 38909, 38910, 39008, 39010, 39011, 39007, 39105, 39106, 39248, 39246, 39257, 39244, 39243, 39251, 39474, 39476, 39473, 39468, 39466, 39478, 39465, 39470, 39480, 39469, 39623, 39626, 39622, 39696, 39698, 39697, 39947, 39944, 39927, 39941, 39954, 39928, 4e4, 39943, 39950, 39942, 39959, 39956, 39945, 40351, 40345, 40356, 40349, 40338, 40344, 40336, 40347, 40352, 40340, 40348, 40362, 40343, 40353, 40346, 40354, 40360, 40350, 40355, 40383, 40361, 40342, 40358, 40359, 40601, 40603, 40602, 40677, 40676, 40679, 40678, 40752, 40750, 40795, 40800, 40798, 40797, 40793, 40849, 20794, 20793, 21144, 21143, 22211, 22205, 22206, 23368, 23367, 24011, 24015, 24305, 25085, 25883, 27394, 27388, 27395, 27384, 27392, 28739, 28740, 28746, 28744, 28745, 28741, 28742, 29213, 29210, 29209, 29566, 29975, 30314, 30672, 31021, 31025, 31023, 31828, 31827, 31986, 32394, 32391, 32392, 32395, 32390, 32397, 32589, 32699, 32816, 33245, 34328, 34346, 34342, 34335, 34339, 34332, 34329, 34343, 34350, 34337, 34336, 34345, 34334, 34341, 34857, 34845, 34843, 34848, 34852, 34844, 34859, 34890, 35181, 35177, 35182, 35179, 35322, 35705, 35704, 35653, 35706, 35707, 36112, 36116, 36271, 36494, 36492, 36702, 36699, 36701, 37190, 37188, 37189, 37305, 37951, 37947, 37942, 37929, 37949, 37948, 37936, 37945, 37930, 37943, 37932, 37952, 37937, 38373, 38372, 38371, 38709, 38714, 38847, 38881, 39012, 39113, 39110, 39104, 39256, 39254, 39481, 39485, 39494, 39492, 39490, 39489, 39482, 39487, 39629, 39701, 39703, 39704, 39702, 39738, 39762, 39979, 39965, 39964, 39980, 39971, 39976, 39977, 39972, 39969, 40375, 40374, 40380, 40385, 40391, 40394, 40399, 40382, 40389, 40387, 40379, 40373, 40398, 40377, 40378, 40364, 40392, 40369, 40365, 40396, 40371, 40397, 40370, 40570, 40604, 40683, 40686, 40685, 40731, 40728, 40730, 40753, 40782, 40805, 40804, 40850, 20153, 22214, 22213, 22219, 22897, 23371, 23372, 24021, 24017, 24306, 25889, 25888, 25894, 25890, 27403, 27400, 27401, 27661, 28757, 28758, 28759, 28754, 29214, 29215, 29353, 29567, 29912, 29909, 29913, 29911, 30317, 30381, 31029, 31156, 31344, 31345, 31831, 31836, 31833, 31835, 31834, 31988, 31985, 32401, 32591, 32647, 33246, 33387, 34356, 34357, 34355, 34348, 34354, 34358, 34860, 34856, 34854, 34858, 34853, 35185, 35263, 35262, 35323, 35710, 35716, 35714, 35718, 35717, 35711, 36117, 36501, 36500, 36506, 36498, 36496, 36502, 36503, 36704, 36706, 37191, 37964, 37968, 37962, 37963, 37967, 37959, 37957, 37960, 37961, 37958, 38719, 38883, 39018, 39017, 39115, 39252, 39259, 39502, 39507, 39508, 39500, 39503, 39496, 39498, 39497, 39506, 39504, 39632, 39705, 39723, 39739, 39766, 39765, 40006, 40008, 39999, 40004, 39993, 39987, 40001, 39996, 39991, 39988, 39986, 39997, 39990, 40411, 40402, 40414, 40410, 40395, 40400, 40412, 40401, 40415, 40425, 40409, 40408, 40406, 40437, 40405, 40413, 40630, 40688, 40757, 40755, 40754, 40770, 40811, 40853, 40866, 20797, 21145, 22760, 22759, 22898, 23373, 24024, 34863, 24399, 25089, 25091, 25092, 25897, 25893, 26006, 26347, 27409, 27410, 27407, 27594, 28763, 28762, 29218, 29570, 29569, 29571, 30320, 30676, 31847, 31846, 32405, 33388, 34362, 34368, 34361, 34364, 34353, 34363, 34366, 34864, 34866, 34862, 34867, 35190, 35188, 35187, 35326, 35724, 35726, 35723, 35720, 35909, 36121, 36504, 36708, 36707, 37308, 37986, 37973, 37981, 37975, 37982, 38852, 38853, 38912, 39510, 39513, 39710, 39711, 39712, 40018, 40024, 40016, 40010, 40013, 40011, 40021, 40025, 40012, 40014, 40443, 40439, 40431, 40419, 40427, 40440, 40420, 40438, 40417, 40430, 40422, 40434, 40432, 40418, 40428, 40436, 40435, 40424, 40429, 40642, 40656, 40690, 40691, 40710, 40732, 40760, 40759, 40758, 40771, 40783, 40817, 40816, 40814, 40815, 22227, 22221, 23374, 23661, 25901, 26349, 26350, 27411, 28767, 28769, 28765, 28768, 29219, 29915, 29925, 30677, 31032, 31159, 31158, 31850, 32407, 32649, 33389, 34371, 34872, 34871, 34869, 34891, 35732, 35733, 36510, 36511, 36512, 36509, 37310, 37309, 37314, 37995, 37992, 37993, 38629, 38726, 38723, 38727, 38855, 38885, 39518, 39637, 39769, 40035, 40039, 40038, 40034, 40030, 40032, 40450, 40446, 40455, 40451, 40454, 40453, 40448, 40449, 40457, 40447, 40445, 40452, 40608, 40734, 40774, 40820, 40821, 40822, 22228, 25902, 26040, 27416, 27417, 27415, 27418, 28770, 29222, 29354, 30680, 30681, 31033, 31849, 31851, 31990, 32410, 32408, 32411, 32409, 33248, 33249, 34374, 34375, 34376, 35193, 35194, 35196, 35195, 35327, 35736, 35737, 36517, 36516, 36515, 37998, 37997, 37999, 38001, 38003, 38729, 39026, 39263, 40040, 40046, 40045, 40459, 40461, 40464, 40463, 40466, 40465, 40609, 40693, 40713, 40775, 40824, 40827, 40826, 40825, 22302, 28774, 31855, 34876, 36274, 36518, 37315, 38004, 38008, 38006, 38005, 39520, 40052, 40051, 40049, 40053, 40468, 40467, 40694, 40714, 40868, 28776, 28773, 31991, 34410, 34878, 34877, 34879, 35742, 35996, 36521, 36553, 38731, 39027, 39028, 39116, 39265, 39339, 39524, 39526, 39527, 39716, 40469, 40471, 40776, 25095, 27422, 29223, 34380, 36520, 38018, 38016, 38017, 39529, 39528, 39726, 40473, 29225, 34379, 35743, 38019, 40057, 40631, 30325, 39531, 40058, 40477, 28777, 28778, 40612, 40830, 40777, 40856, 30849, 37561, 35023, 22715, 24658, 31911, 23290, 9556, 9574, 9559, 9568, 9580, 9571, 9562, 9577, 9565, 9554, 9572, 9557, 9566, 9578, 9569, 9560, 9575, 9563, 9555, 9573, 9558, 9567, 9579, 9570, 9561, 9576, 9564, 9553, 9552, 9581, 9582, 9584, 9583, 65517, 132423, 37595, 132575, 147397, 34124, 17077, 29679, 20917, 13897, 149826, 166372, 37700, 137691, 33518, 146632, 30780, 26436, 25311, 149811, 166314, 131744, 158643, 135941, 20395, 140525, 20488, 159017, 162436, 144896, 150193, 140563, 20521, 131966, 24484, 131968, 131911, 28379, 132127, 20605, 20737, 13434, 20750, 39020, 14147, 33814, 149924, 132231, 20832, 144308, 20842, 134143, 139516, 131813, 140592, 132494, 143923, 137603, 23426, 34685, 132531, 146585, 20914, 20920, 40244, 20937, 20943, 20945, 15580, 20947, 150182, 20915, 20962, 21314, 20973, 33741, 26942, 145197, 24443, 21003, 21030, 21052, 21173, 21079, 21140, 21177, 21189, 31765, 34114, 21216, 34317, 158483, 21253, 166622, 21833, 28377, 147328, 133460, 147436, 21299, 21316, 134114, 27851, 136998, 26651, 29653, 24650, 16042, 14540, 136936, 29149, 17570, 21357, 21364, 165547, 21374, 21375, 136598, 136723, 30694, 21395, 166555, 21408, 21419, 21422, 29607, 153458, 16217, 29596, 21441, 21445, 27721, 20041, 22526, 21465, 15019, 134031, 21472, 147435, 142755, 21494, 134263, 21523, 28793, 21803, 26199, 27995, 21613, 158547, 134516, 21853, 21647, 21668, 18342, 136973, 134877, 15796, 134477, 166332, 140952, 21831, 19693, 21551, 29719, 21894, 21929, 22021, 137431, 147514, 17746, 148533, 26291, 135348, 22071, 26317, 144010, 26276, 26285, 22093, 22095, 30961, 22257, 38791, 21502, 22272, 22255, 22253, 166758, 13859, 135759, 22342, 147877, 27758, 28811, 22338, 14001, 158846, 22502, 136214, 22531, 136276, 148323, 22566, 150517, 22620, 22698, 13665, 22752, 22748, 135740, 22779, 23551, 22339, 172368, 148088, 37843, 13729, 22815, 26790, 14019, 28249, 136766, 23076, 21843, 136850, 34053, 22985, 134478, 158849, 159018, 137180, 23001, 137211, 137138, 159142, 28017, 137256, 136917, 23033, 159301, 23211, 23139, 14054, 149929, 23159, 14088, 23190, 29797, 23251, 159649, 140628, 15749, 137489, 14130, 136888, 24195, 21200, 23414, 25992, 23420, 162318, 16388, 18525, 131588, 23509, 24928, 137780, 154060, 132517, 23539, 23453, 19728, 23557, 138052, 23571, 29646, 23572, 138405, 158504, 23625, 18653, 23685, 23785, 23791, 23947, 138745, 138807, 23824, 23832, 23878, 138916, 23738, 24023, 33532, 14381, 149761, 139337, 139635, 33415, 14390, 15298, 24110, 27274, 24181, 24186, 148668, 134355, 21414, 20151, 24272, 21416, 137073, 24073, 24308, 164994, 24313, 24315, 14496, 24316, 26686, 37915, 24333, 131521, 194708, 15070, 18606, 135994, 24378, 157832, 140240, 24408, 140401, 24419, 38845, 159342, 24434, 37696, 166454, 24487, 23990, 15711, 152144, 139114, 159992, 140904, 37334, 131742, 166441, 24625, 26245, 137335, 14691, 15815, 13881, 22416, 141236, 31089, 15936, 24734, 24740, 24755, 149890, 149903, 162387, 29860, 20705, 23200, 24932, 33828, 24898, 194726, 159442, 24961, 20980, 132694, 24967, 23466, 147383, 141407, 25043, 166813, 170333, 25040, 14642, 141696, 141505, 24611, 24924, 25886, 25483, 131352, 25285, 137072, 25301, 142861, 25452, 149983, 14871, 25656, 25592, 136078, 137212, 25744, 28554, 142902, 38932, 147596, 153373, 25825, 25829, 38011, 14950, 25658, 14935, 25933, 28438, 150056, 150051, 25989, 25965, 25951, 143486, 26037, 149824, 19255, 26065, 16600, 137257, 26080, 26083, 24543, 144384, 26136, 143863, 143864, 26180, 143780, 143781, 26187, 134773, 26215, 152038, 26227, 26228, 138813, 143921, 165364, 143816, 152339, 30661, 141559, 39332, 26370, 148380, 150049, 15147, 27130, 145346, 26462, 26471, 26466, 147917, 168173, 26583, 17641, 26658, 28240, 37436, 26625, 144358, 159136, 26717, 144495, 27105, 27147, 166623, 26995, 26819, 144845, 26881, 26880, 15666, 14849, 144956, 15232, 26540, 26977, 166474, 17148, 26934, 27032, 15265, 132041, 33635, 20624, 27129, 144985, 139562, 27205, 145155, 27293, 15347, 26545, 27336, 168348, 15373, 27421, 133411, 24798, 27445, 27508, 141261, 28341, 146139, 132021, 137560, 14144, 21537, 146266, 27617, 147196, 27612, 27703, 140427, 149745, 158545, 27738, 33318, 27769, 146876, 17605, 146877, 147876, 149772, 149760, 146633, 14053, 15595, 134450, 39811, 143865, 140433, 32655, 26679, 159013, 159137, 159211, 28054, 27996, 28284, 28420, 149887, 147589, 159346, 34099, 159604, 20935, 27804, 28189, 33838, 166689, 28207, 146991, 29779, 147330, 31180, 28239, 23185, 143435, 28664, 14093, 28573, 146992, 28410, 136343, 147517, 17749, 37872, 28484, 28508, 15694, 28532, 168304, 15675, 28575, 147780, 28627, 147601, 147797, 147513, 147440, 147380, 147775, 20959, 147798, 147799, 147776, 156125, 28747, 28798, 28839, 28801, 28876, 28885, 28886, 28895, 16644, 15848, 29108, 29078, 148087, 28971, 28997, 23176, 29002, 29038, 23708, 148325, 29007, 37730, 148161, 28972, 148570, 150055, 150050, 29114, 166888, 28861, 29198, 37954, 29205, 22801, 37955, 29220, 37697, 153093, 29230, 29248, 149876, 26813, 29269, 29271, 15957, 143428, 26637, 28477, 29314, 29482, 29483, 149539, 165931, 18669, 165892, 29480, 29486, 29647, 29610, 134202, 158254, 29641, 29769, 147938, 136935, 150052, 26147, 14021, 149943, 149901, 150011, 29687, 29717, 26883, 150054, 29753, 132547, 16087, 29788, 141485, 29792, 167602, 29767, 29668, 29814, 33721, 29804, 14128, 29812, 37873, 27180, 29826, 18771, 150156, 147807, 150137, 166799, 23366, 166915, 137374, 29896, 137608, 29966, 29929, 29982, 167641, 137803, 23511, 167596, 37765, 30029, 30026, 30055, 30062, 151426, 16132, 150803, 30094, 29789, 30110, 30132, 30210, 30252, 30289, 30287, 30319, 30326, 156661, 30352, 33263, 14328, 157969, 157966, 30369, 30373, 30391, 30412, 159647, 33890, 151709, 151933, 138780, 30494, 30502, 30528, 25775, 152096, 30552, 144044, 30639, 166244, 166248, 136897, 30708, 30729, 136054, 150034, 26826, 30895, 30919, 30931, 38565, 31022, 153056, 30935, 31028, 30897, 161292, 36792, 34948, 166699, 155779, 140828, 31110, 35072, 26882, 31104, 153687, 31133, 162617, 31036, 31145, 28202, 160038, 16040, 31174, 168205, 31188],
        "euc-kr": [44034, 44035, 44037, 44038, 44043, 44044, 44045, 44046, 44047, 44056, 44062, 44063, 44065, 44066, 44067, 44069, 44070, 44071, 44072, 44073, 44074, 44075, 44078, 44082, 44083, 44084, null, null, null, null, null, null, 44085, 44086, 44087, 44090, 44091, 44093, 44094, 44095, 44097, 44098, 44099, 44100, 44101, 44102, 44103, 44104, 44105, 44106, 44108, 44110, 44111, 44112, 44113, 44114, 44115, 44117, null, null, null, null, null, null, 44118, 44119, 44121, 44122, 44123, 44125, 44126, 44127, 44128, 44129, 44130, 44131, 44132, 44133, 44134, 44135, 44136, 44137, 44138, 44139, 44140, 44141, 44142, 44143, 44146, 44147, 44149, 44150, 44153, 44155, 44156, 44157, 44158, 44159, 44162, 44167, 44168, 44173, 44174, 44175, 44177, 44178, 44179, 44181, 44182, 44183, 44184, 44185, 44186, 44187, 44190, 44194, 44195, 44196, 44197, 44198, 44199, 44203, 44205, 44206, 44209, 44210, 44211, 44212, 44213, 44214, 44215, 44218, 44222, 44223, 44224, 44226, 44227, 44229, 44230, 44231, 44233, 44234, 44235, 44237, 44238, 44239, 44240, 44241, 44242, 44243, 44244, 44246, 44248, 44249, 44250, 44251, 44252, 44253, 44254, 44255, 44258, 44259, 44261, 44262, 44265, 44267, 44269, 44270, 44274, 44276, 44279, 44280, 44281, 44282, 44283, 44286, 44287, 44289, 44290, 44291, 44293, 44295, 44296, 44297, 44298, 44299, 44302, 44304, 44306, 44307, 44308, 44309, 44310, 44311, 44313, 44314, 44315, 44317, 44318, 44319, 44321, 44322, 44323, 44324, 44325, 44326, 44327, 44328, 44330, 44331, 44334, 44335, 44336, 44337, 44338, 44339, null, null, null, null, null, null, 44342, 44343, 44345, 44346, 44347, 44349, 44350, 44351, 44352, 44353, 44354, 44355, 44358, 44360, 44362, 44363, 44364, 44365, 44366, 44367, 44369, 44370, 44371, 44373, 44374, 44375, null, null, null, null, null, null, 44377, 44378, 44379, 44380, 44381, 44382, 44383, 44384, 44386, 44388, 44389, 44390, 44391, 44392, 44393, 44394, 44395, 44398, 44399, 44401, 44402, 44407, 44408, 44409, 44410, 44414, 44416, 44419, 44420, 44421, 44422, 44423, 44426, 44427, 44429, 44430, 44431, 44433, 44434, 44435, 44436, 44437, 44438, 44439, 44440, 44441, 44442, 44443, 44446, 44447, 44448, 44449, 44450, 44451, 44453, 44454, 44455, 44456, 44457, 44458, 44459, 44460, 44461, 44462, 44463, 44464, 44465, 44466, 44467, 44468, 44469, 44470, 44472, 44473, 44474, 44475, 44476, 44477, 44478, 44479, 44482, 44483, 44485, 44486, 44487, 44489, 44490, 44491, 44492, 44493, 44494, 44495, 44498, 44500, 44501, 44502, 44503, 44504, 44505, 44506, 44507, 44509, 44510, 44511, 44513, 44514, 44515, 44517, 44518, 44519, 44520, 44521, 44522, 44523, 44524, 44525, 44526, 44527, 44528, 44529, 44530, 44531, 44532, 44533, 44534, 44535, 44538, 44539, 44541, 44542, 44546, 44547, 44548, 44549, 44550, 44551, 44554, 44556, 44558, 44559, 44560, 44561, 44562, 44563, 44565, 44566, 44567, 44568, 44569, 44570, 44571, 44572, null, null, null, null, null, null, 44573, 44574, 44575, 44576, 44577, 44578, 44579, 44580, 44581, 44582, 44583, 44584, 44585, 44586, 44587, 44588, 44589, 44590, 44591, 44594, 44595, 44597, 44598, 44601, 44603, 44604, null, null, null, null, null, null, 44605, 44606, 44607, 44610, 44612, 44615, 44616, 44617, 44619, 44623, 44625, 44626, 44627, 44629, 44631, 44632, 44633, 44634, 44635, 44638, 44642, 44643, 44644, 44646, 44647, 44650, 44651, 44653, 44654, 44655, 44657, 44658, 44659, 44660, 44661, 44662, 44663, 44666, 44670, 44671, 44672, 44673, 44674, 44675, 44678, 44679, 44680, 44681, 44682, 44683, 44685, 44686, 44687, 44688, 44689, 44690, 44691, 44692, 44693, 44694, 44695, 44696, 44697, 44698, 44699, 44700, 44701, 44702, 44703, 44704, 44705, 44706, 44707, 44708, 44709, 44710, 44711, 44712, 44713, 44714, 44715, 44716, 44717, 44718, 44719, 44720, 44721, 44722, 44723, 44724, 44725, 44726, 44727, 44728, 44729, 44730, 44731, 44735, 44737, 44738, 44739, 44741, 44742, 44743, 44744, 44745, 44746, 44747, 44750, 44754, 44755, 44756, 44757, 44758, 44759, 44762, 44763, 44765, 44766, 44767, 44768, 44769, 44770, 44771, 44772, 44773, 44774, 44775, 44777, 44778, 44780, 44782, 44783, 44784, 44785, 44786, 44787, 44789, 44790, 44791, 44793, 44794, 44795, 44797, 44798, 44799, 44800, 44801, 44802, 44803, 44804, 44805, null, null, null, null, null, null, 44806, 44809, 44810, 44811, 44812, 44814, 44815, 44817, 44818, 44819, 44820, 44821, 44822, 44823, 44824, 44825, 44826, 44827, 44828, 44829, 44830, 44831, 44832, 44833, 44834, 44835, null, null, null, null, null, null, 44836, 44837, 44838, 44839, 44840, 44841, 44842, 44843, 44846, 44847, 44849, 44851, 44853, 44854, 44855, 44856, 44857, 44858, 44859, 44862, 44864, 44868, 44869, 44870, 44871, 44874, 44875, 44876, 44877, 44878, 44879, 44881, 44882, 44883, 44884, 44885, 44886, 44887, 44888, 44889, 44890, 44891, 44894, 44895, 44896, 44897, 44898, 44899, 44902, 44903, 44904, 44905, 44906, 44907, 44908, 44909, 44910, 44911, 44912, 44913, 44914, 44915, 44916, 44917, 44918, 44919, 44920, 44922, 44923, 44924, 44925, 44926, 44927, 44929, 44930, 44931, 44933, 44934, 44935, 44937, 44938, 44939, 44940, 44941, 44942, 44943, 44946, 44947, 44948, 44950, 44951, 44952, 44953, 44954, 44955, 44957, 44958, 44959, 44960, 44961, 44962, 44963, 44964, 44965, 44966, 44967, 44968, 44969, 44970, 44971, 44972, 44973, 44974, 44975, 44976, 44977, 44978, 44979, 44980, 44981, 44982, 44983, 44986, 44987, 44989, 44990, 44991, 44993, 44994, 44995, 44996, 44997, 44998, 45002, 45004, 45007, 45008, 45009, 45010, 45011, 45013, 45014, 45015, 45016, 45017, 45018, 45019, 45021, 45022, 45023, 45024, 45025, null, null, null, null, null, null, 45026, 45027, 45028, 45029, 45030, 45031, 45034, 45035, 45036, 45037, 45038, 45039, 45042, 45043, 45045, 45046, 45047, 45049, 45050, 45051, 45052, 45053, 45054, 45055, 45058, 45059, null, null, null, null, null, null, 45061, 45062, 45063, 45064, 45065, 45066, 45067, 45069, 45070, 45071, 45073, 45074, 45075, 45077, 45078, 45079, 45080, 45081, 45082, 45083, 45086, 45087, 45088, 45089, 45090, 45091, 45092, 45093, 45094, 45095, 45097, 45098, 45099, 45100, 45101, 45102, 45103, 45104, 45105, 45106, 45107, 45108, 45109, 45110, 45111, 45112, 45113, 45114, 45115, 45116, 45117, 45118, 45119, 45120, 45121, 45122, 45123, 45126, 45127, 45129, 45131, 45133, 45135, 45136, 45137, 45138, 45142, 45144, 45146, 45147, 45148, 45150, 45151, 45152, 45153, 45154, 45155, 45156, 45157, 45158, 45159, 45160, 45161, 45162, 45163, 45164, 45165, 45166, 45167, 45168, 45169, 45170, 45171, 45172, 45173, 45174, 45175, 45176, 45177, 45178, 45179, 45182, 45183, 45185, 45186, 45187, 45189, 45190, 45191, 45192, 45193, 45194, 45195, 45198, 45200, 45202, 45203, 45204, 45205, 45206, 45207, 45211, 45213, 45214, 45219, 45220, 45221, 45222, 45223, 45226, 45232, 45234, 45238, 45239, 45241, 45242, 45243, 45245, 45246, 45247, 45248, 45249, 45250, 45251, 45254, 45258, 45259, 45260, 45261, 45262, 45263, 45266, null, null, null, null, null, null, 45267, 45269, 45270, 45271, 45273, 45274, 45275, 45276, 45277, 45278, 45279, 45281, 45282, 45283, 45284, 45286, 45287, 45288, 45289, 45290, 45291, 45292, 45293, 45294, 45295, 45296, null, null, null, null, null, null, 45297, 45298, 45299, 45300, 45301, 45302, 45303, 45304, 45305, 45306, 45307, 45308, 45309, 45310, 45311, 45312, 45313, 45314, 45315, 45316, 45317, 45318, 45319, 45322, 45325, 45326, 45327, 45329, 45332, 45333, 45334, 45335, 45338, 45342, 45343, 45344, 45345, 45346, 45350, 45351, 45353, 45354, 45355, 45357, 45358, 45359, 45360, 45361, 45362, 45363, 45366, 45370, 45371, 45372, 45373, 45374, 45375, 45378, 45379, 45381, 45382, 45383, 45385, 45386, 45387, 45388, 45389, 45390, 45391, 45394, 45395, 45398, 45399, 45401, 45402, 45403, 45405, 45406, 45407, 45409, 45410, 45411, 45412, 45413, 45414, 45415, 45416, 45417, 45418, 45419, 45420, 45421, 45422, 45423, 45424, 45425, 45426, 45427, 45428, 45429, 45430, 45431, 45434, 45435, 45437, 45438, 45439, 45441, 45443, 45444, 45445, 45446, 45447, 45450, 45452, 45454, 45455, 45456, 45457, 45461, 45462, 45463, 45465, 45466, 45467, 45469, 45470, 45471, 45472, 45473, 45474, 45475, 45476, 45477, 45478, 45479, 45481, 45482, 45483, 45484, 45485, 45486, 45487, 45488, 45489, 45490, 45491, 45492, 45493, 45494, 45495, 45496, null, null, null, null, null, null, 45497, 45498, 45499, 45500, 45501, 45502, 45503, 45504, 45505, 45506, 45507, 45508, 45509, 45510, 45511, 45512, 45513, 45514, 45515, 45517, 45518, 45519, 45521, 45522, 45523, 45525, null, null, null, null, null, null, 45526, 45527, 45528, 45529, 45530, 45531, 45534, 45536, 45537, 45538, 45539, 45540, 45541, 45542, 45543, 45546, 45547, 45549, 45550, 45551, 45553, 45554, 45555, 45556, 45557, 45558, 45559, 45560, 45562, 45564, 45566, 45567, 45568, 45569, 45570, 45571, 45574, 45575, 45577, 45578, 45581, 45582, 45583, 45584, 45585, 45586, 45587, 45590, 45592, 45594, 45595, 45596, 45597, 45598, 45599, 45601, 45602, 45603, 45604, 45605, 45606, 45607, 45608, 45609, 45610, 45611, 45612, 45613, 45614, 45615, 45616, 45617, 45618, 45619, 45621, 45622, 45623, 45624, 45625, 45626, 45627, 45629, 45630, 45631, 45632, 45633, 45634, 45635, 45636, 45637, 45638, 45639, 45640, 45641, 45642, 45643, 45644, 45645, 45646, 45647, 45648, 45649, 45650, 45651, 45652, 45653, 45654, 45655, 45657, 45658, 45659, 45661, 45662, 45663, 45665, 45666, 45667, 45668, 45669, 45670, 45671, 45674, 45675, 45676, 45677, 45678, 45679, 45680, 45681, 45682, 45683, 45686, 45687, 45688, 45689, 45690, 45691, 45693, 45694, 45695, 45696, 45697, 45698, 45699, 45702, 45703, 45704, 45706, 45707, 45708, 45709, 45710, null, null, null, null, null, null, 45711, 45714, 45715, 45717, 45718, 45719, 45723, 45724, 45725, 45726, 45727, 45730, 45732, 45735, 45736, 45737, 45739, 45741, 45742, 45743, 45745, 45746, 45747, 45749, 45750, 45751, null, null, null, null, null, null, 45752, 45753, 45754, 45755, 45756, 45757, 45758, 45759, 45760, 45761, 45762, 45763, 45764, 45765, 45766, 45767, 45770, 45771, 45773, 45774, 45775, 45777, 45779, 45780, 45781, 45782, 45783, 45786, 45788, 45790, 45791, 45792, 45793, 45795, 45799, 45801, 45802, 45808, 45809, 45810, 45814, 45820, 45821, 45822, 45826, 45827, 45829, 45830, 45831, 45833, 45834, 45835, 45836, 45837, 45838, 45839, 45842, 45846, 45847, 45848, 45849, 45850, 45851, 45853, 45854, 45855, 45856, 45857, 45858, 45859, 45860, 45861, 45862, 45863, 45864, 45865, 45866, 45867, 45868, 45869, 45870, 45871, 45872, 45873, 45874, 45875, 45876, 45877, 45878, 45879, 45880, 45881, 45882, 45883, 45884, 45885, 45886, 45887, 45888, 45889, 45890, 45891, 45892, 45893, 45894, 45895, 45896, 45897, 45898, 45899, 45900, 45901, 45902, 45903, 45904, 45905, 45906, 45907, 45911, 45913, 45914, 45917, 45920, 45921, 45922, 45923, 45926, 45928, 45930, 45932, 45933, 45935, 45938, 45939, 45941, 45942, 45943, 45945, 45946, 45947, 45948, 45949, 45950, 45951, 45954, 45958, 45959, 45960, 45961, 45962, 45963, 45965, null, null, null, null, null, null, 45966, 45967, 45969, 45970, 45971, 45973, 45974, 45975, 45976, 45977, 45978, 45979, 45980, 45981, 45982, 45983, 45986, 45987, 45988, 45989, 45990, 45991, 45993, 45994, 45995, 45997, null, null, null, null, null, null, 45998, 45999, 46e3, 46001, 46002, 46003, 46004, 46005, 46006, 46007, 46008, 46009, 46010, 46011, 46012, 46013, 46014, 46015, 46016, 46017, 46018, 46019, 46022, 46023, 46025, 46026, 46029, 46031, 46033, 46034, 46035, 46038, 46040, 46042, 46044, 46046, 46047, 46049, 46050, 46051, 46053, 46054, 46055, 46057, 46058, 46059, 46060, 46061, 46062, 46063, 46064, 46065, 46066, 46067, 46068, 46069, 46070, 46071, 46072, 46073, 46074, 46075, 46077, 46078, 46079, 46080, 46081, 46082, 46083, 46084, 46085, 46086, 46087, 46088, 46089, 46090, 46091, 46092, 46093, 46094, 46095, 46097, 46098, 46099, 46100, 46101, 46102, 46103, 46105, 46106, 46107, 46109, 46110, 46111, 46113, 46114, 46115, 46116, 46117, 46118, 46119, 46122, 46124, 46125, 46126, 46127, 46128, 46129, 46130, 46131, 46133, 46134, 46135, 46136, 46137, 46138, 46139, 46140, 46141, 46142, 46143, 46144, 46145, 46146, 46147, 46148, 46149, 46150, 46151, 46152, 46153, 46154, 46155, 46156, 46157, 46158, 46159, 46162, 46163, 46165, 46166, 46167, 46169, 46170, 46171, 46172, 46173, 46174, 46175, 46178, 46180, 46182, null, null, null, null, null, null, 46183, 46184, 46185, 46186, 46187, 46189, 46190, 46191, 46192, 46193, 46194, 46195, 46196, 46197, 46198, 46199, 46200, 46201, 46202, 46203, 46204, 46205, 46206, 46207, 46209, 46210, null, null, null, null, null, null, 46211, 46212, 46213, 46214, 46215, 46217, 46218, 46219, 46220, 46221, 46222, 46223, 46224, 46225, 46226, 46227, 46228, 46229, 46230, 46231, 46232, 46233, 46234, 46235, 46236, 46238, 46239, 46240, 46241, 46242, 46243, 46245, 46246, 46247, 46249, 46250, 46251, 46253, 46254, 46255, 46256, 46257, 46258, 46259, 46260, 46262, 46264, 46266, 46267, 46268, 46269, 46270, 46271, 46273, 46274, 46275, 46277, 46278, 46279, 46281, 46282, 46283, 46284, 46285, 46286, 46287, 46289, 46290, 46291, 46292, 46294, 46295, 46296, 46297, 46298, 46299, 46302, 46303, 46305, 46306, 46309, 46311, 46312, 46313, 46314, 46315, 46318, 46320, 46322, 46323, 46324, 46325, 46326, 46327, 46329, 46330, 46331, 46332, 46333, 46334, 46335, 46336, 46337, 46338, 46339, 46340, 46341, 46342, 46343, 46344, 46345, 46346, 46347, 46348, 46349, 46350, 46351, 46352, 46353, 46354, 46355, 46358, 46359, 46361, 46362, 46365, 46366, 46367, 46368, 46369, 46370, 46371, 46374, 46379, 46380, 46381, 46382, 46383, 46386, 46387, 46389, 46390, 46391, 46393, 46394, 46395, 46396, 46397, 46398, 46399, 46402, 46406, null, null, null, null, null, null, 46407, 46408, 46409, 46410, 46414, 46415, 46417, 46418, 46419, 46421, 46422, 46423, 46424, 46425, 46426, 46427, 46430, 46434, 46435, 46436, 46437, 46438, 46439, 46440, 46441, 46442, null, null, null, null, null, null, 46443, 46444, 46445, 46446, 46447, 46448, 46449, 46450, 46451, 46452, 46453, 46454, 46455, 46456, 46457, 46458, 46459, 46460, 46461, 46462, 46463, 46464, 46465, 46466, 46467, 46468, 46469, 46470, 46471, 46472, 46473, 46474, 46475, 46476, 46477, 46478, 46479, 46480, 46481, 46482, 46483, 46484, 46485, 46486, 46487, 46488, 46489, 46490, 46491, 46492, 46493, 46494, 46495, 46498, 46499, 46501, 46502, 46503, 46505, 46508, 46509, 46510, 46511, 46514, 46518, 46519, 46520, 46521, 46522, 46526, 46527, 46529, 46530, 46531, 46533, 46534, 46535, 46536, 46537, 46538, 46539, 46542, 46546, 46547, 46548, 46549, 46550, 46551, 46553, 46554, 46555, 46556, 46557, 46558, 46559, 46560, 46561, 46562, 46563, 46564, 46565, 46566, 46567, 46568, 46569, 46570, 46571, 46573, 46574, 46575, 46576, 46577, 46578, 46579, 46580, 46581, 46582, 46583, 46584, 46585, 46586, 46587, 46588, 46589, 46590, 46591, 46592, 46593, 46594, 46595, 46596, 46597, 46598, 46599, 46600, 46601, 46602, 46603, 46604, 46605, 46606, 46607, 46610, 46611, 46613, 46614, 46615, 46617, 46618, 46619, 46620, 46621, null, null, null, null, null, null, 46622, 46623, 46624, 46625, 46626, 46627, 46628, 46630, 46631, 46632, 46633, 46634, 46635, 46637, 46638, 46639, 46640, 46641, 46642, 46643, 46645, 46646, 46647, 46648, 46649, 46650, null, null, null, null, null, null, 46651, 46652, 46653, 46654, 46655, 46656, 46657, 46658, 46659, 46660, 46661, 46662, 46663, 46665, 46666, 46667, 46668, 46669, 46670, 46671, 46672, 46673, 46674, 46675, 46676, 46677, 46678, 46679, 46680, 46681, 46682, 46683, 46684, 46685, 46686, 46687, 46688, 46689, 46690, 46691, 46693, 46694, 46695, 46697, 46698, 46699, 46700, 46701, 46702, 46703, 46704, 46705, 46706, 46707, 46708, 46709, 46710, 46711, 46712, 46713, 46714, 46715, 46716, 46717, 46718, 46719, 46720, 46721, 46722, 46723, 46724, 46725, 46726, 46727, 46728, 46729, 46730, 46731, 46732, 46733, 46734, 46735, 46736, 46737, 46738, 46739, 46740, 46741, 46742, 46743, 46744, 46745, 46746, 46747, 46750, 46751, 46753, 46754, 46755, 46757, 46758, 46759, 46760, 46761, 46762, 46765, 46766, 46767, 46768, 46770, 46771, 46772, 46773, 46774, 46775, 46776, 46777, 46778, 46779, 46780, 46781, 46782, 46783, 46784, 46785, 46786, 46787, 46788, 46789, 46790, 46791, 46792, 46793, 46794, 46795, 46796, 46797, 46798, 46799, 46800, 46801, 46802, 46803, 46805, 46806, 46807, 46808, 46809, 46810, 46811, 46812, 46813, null, null, null, null, null, null, 46814, 46815, 46816, 46817, 46818, 46819, 46820, 46821, 46822, 46823, 46824, 46825, 46826, 46827, 46828, 46829, 46830, 46831, 46833, 46834, 46835, 46837, 46838, 46839, 46841, 46842, null, null, null, null, null, null, 46843, 46844, 46845, 46846, 46847, 46850, 46851, 46852, 46854, 46855, 46856, 46857, 46858, 46859, 46860, 46861, 46862, 46863, 46864, 46865, 46866, 46867, 46868, 46869, 46870, 46871, 46872, 46873, 46874, 46875, 46876, 46877, 46878, 46879, 46880, 46881, 46882, 46883, 46884, 46885, 46886, 46887, 46890, 46891, 46893, 46894, 46897, 46898, 46899, 46900, 46901, 46902, 46903, 46906, 46908, 46909, 46910, 46911, 46912, 46913, 46914, 46915, 46917, 46918, 46919, 46921, 46922, 46923, 46925, 46926, 46927, 46928, 46929, 46930, 46931, 46934, 46935, 46936, 46937, 46938, 46939, 46940, 46941, 46942, 46943, 46945, 46946, 46947, 46949, 46950, 46951, 46953, 46954, 46955, 46956, 46957, 46958, 46959, 46962, 46964, 46966, 46967, 46968, 46969, 46970, 46971, 46974, 46975, 46977, 46978, 46979, 46981, 46982, 46983, 46984, 46985, 46986, 46987, 46990, 46995, 46996, 46997, 47002, 47003, 47005, 47006, 47007, 47009, 47010, 47011, 47012, 47013, 47014, 47015, 47018, 47022, 47023, 47024, 47025, 47026, 47027, 47030, 47031, 47033, 47034, 47035, 47036, 47037, 47038, 47039, 47040, 47041, null, null, null, null, null, null, 47042, 47043, 47044, 47045, 47046, 47048, 47050, 47051, 47052, 47053, 47054, 47055, 47056, 47057, 47058, 47059, 47060, 47061, 47062, 47063, 47064, 47065, 47066, 47067, 47068, 47069, null, null, null, null, null, null, 47070, 47071, 47072, 47073, 47074, 47075, 47076, 47077, 47078, 47079, 47080, 47081, 47082, 47083, 47086, 47087, 47089, 47090, 47091, 47093, 47094, 47095, 47096, 47097, 47098, 47099, 47102, 47106, 47107, 47108, 47109, 47110, 47114, 47115, 47117, 47118, 47119, 47121, 47122, 47123, 47124, 47125, 47126, 47127, 47130, 47132, 47134, 47135, 47136, 47137, 47138, 47139, 47142, 47143, 47145, 47146, 47147, 47149, 47150, 47151, 47152, 47153, 47154, 47155, 47158, 47162, 47163, 47164, 47165, 47166, 47167, 47169, 47170, 47171, 47173, 47174, 47175, 47176, 47177, 47178, 47179, 47180, 47181, 47182, 47183, 47184, 47186, 47188, 47189, 47190, 47191, 47192, 47193, 47194, 47195, 47198, 47199, 47201, 47202, 47203, 47205, 47206, 47207, 47208, 47209, 47210, 47211, 47214, 47216, 47218, 47219, 47220, 47221, 47222, 47223, 47225, 47226, 47227, 47229, 47230, 47231, 47232, 47233, 47234, 47235, 47236, 47237, 47238, 47239, 47240, 47241, 47242, 47243, 47244, 47246, 47247, 47248, 47249, 47250, 47251, 47252, 47253, 47254, 47255, 47256, 47257, 47258, 47259, 47260, 47261, 47262, 47263, null, null, null, null, null, null, 47264, 47265, 47266, 47267, 47268, 47269, 47270, 47271, 47273, 47274, 47275, 47276, 47277, 47278, 47279, 47281, 47282, 47283, 47285, 47286, 47287, 47289, 47290, 47291, 47292, 47293, null, null, null, null, null, null, 47294, 47295, 47298, 47300, 47302, 47303, 47304, 47305, 47306, 47307, 47309, 47310, 47311, 47313, 47314, 47315, 47317, 47318, 47319, 47320, 47321, 47322, 47323, 47324, 47326, 47328, 47330, 47331, 47332, 47333, 47334, 47335, 47338, 47339, 47341, 47342, 47343, 47345, 47346, 47347, 47348, 47349, 47350, 47351, 47354, 47356, 47358, 47359, 47360, 47361, 47362, 47363, 47365, 47366, 47367, 47368, 47369, 47370, 47371, 47372, 47373, 47374, 47375, 47376, 47377, 47378, 47379, 47380, 47381, 47382, 47383, 47385, 47386, 47387, 47388, 47389, 47390, 47391, 47393, 47394, 47395, 47396, 47397, 47398, 47399, 47400, 47401, 47402, 47403, 47404, 47405, 47406, 47407, 47408, 47409, 47410, 47411, 47412, 47413, 47414, 47415, 47416, 47417, 47418, 47419, 47422, 47423, 47425, 47426, 47427, 47429, 47430, 47431, 47432, 47433, 47434, 47435, 47437, 47438, 47440, 47442, 47443, 47444, 47445, 47446, 47447, 47450, 47451, 47453, 47454, 47455, 47457, 47458, 47459, 47460, 47461, 47462, 47463, 47466, 47468, 47470, 47471, 47472, 47473, 47474, 47475, 47478, 47479, 47481, 47482, 47483, 47485, null, null, null, null, null, null, 47486, 47487, 47488, 47489, 47490, 47491, 47494, 47496, 47499, 47500, 47503, 47504, 47505, 47506, 47507, 47508, 47509, 47510, 47511, 47512, 47513, 47514, 47515, 47516, 47517, 47518, null, null, null, null, null, null, 47519, 47520, 47521, 47522, 47523, 47524, 47525, 47526, 47527, 47528, 47529, 47530, 47531, 47534, 47535, 47537, 47538, 47539, 47541, 47542, 47543, 47544, 47545, 47546, 47547, 47550, 47552, 47554, 47555, 47556, 47557, 47558, 47559, 47562, 47563, 47565, 47571, 47572, 47573, 47574, 47575, 47578, 47580, 47583, 47584, 47586, 47590, 47591, 47593, 47594, 47595, 47597, 47598, 47599, 47600, 47601, 47602, 47603, 47606, 47611, 47612, 47613, 47614, 47615, 47618, 47619, 47620, 47621, 47622, 47623, 47625, 47626, 47627, 47628, 47629, 47630, 47631, 47632, 47633, 47634, 47635, 47636, 47638, 47639, 47640, 47641, 47642, 47643, 47644, 47645, 47646, 47647, 47648, 47649, 47650, 47651, 47652, 47653, 47654, 47655, 47656, 47657, 47658, 47659, 47660, 47661, 47662, 47663, 47664, 47665, 47666, 47667, 47668, 47669, 47670, 47671, 47674, 47675, 47677, 47678, 47679, 47681, 47683, 47684, 47685, 47686, 47687, 47690, 47692, 47695, 47696, 47697, 47698, 47702, 47703, 47705, 47706, 47707, 47709, 47710, 47711, 47712, 47713, 47714, 47715, 47718, 47722, 47723, 47724, 47725, 47726, 47727, null, null, null, null, null, null, 47730, 47731, 47733, 47734, 47735, 47737, 47738, 47739, 47740, 47741, 47742, 47743, 47744, 47745, 47746, 47750, 47752, 47753, 47754, 47755, 47757, 47758, 47759, 47760, 47761, 47762, null, null, null, null, null, null, 47763, 47764, 47765, 47766, 47767, 47768, 47769, 47770, 47771, 47772, 47773, 47774, 47775, 47776, 47777, 47778, 47779, 47780, 47781, 47782, 47783, 47786, 47789, 47790, 47791, 47793, 47795, 47796, 47797, 47798, 47799, 47802, 47804, 47806, 47807, 47808, 47809, 47810, 47811, 47813, 47814, 47815, 47817, 47818, 47819, 47820, 47821, 47822, 47823, 47824, 47825, 47826, 47827, 47828, 47829, 47830, 47831, 47834, 47835, 47836, 47837, 47838, 47839, 47840, 47841, 47842, 47843, 47844, 47845, 47846, 47847, 47848, 47849, 47850, 47851, 47852, 47853, 47854, 47855, 47856, 47857, 47858, 47859, 47860, 47861, 47862, 47863, 47864, 47865, 47866, 47867, 47869, 47870, 47871, 47873, 47874, 47875, 47877, 47878, 47879, 47880, 47881, 47882, 47883, 47884, 47886, 47888, 47890, 47891, 47892, 47893, 47894, 47895, 47897, 47898, 47899, 47901, 47902, 47903, 47905, 47906, 47907, 47908, 47909, 47910, 47911, 47912, 47914, 47916, 47917, 47918, 47919, 47920, 47921, 47922, 47923, 47927, 47929, 47930, 47935, 47936, 47937, 47938, 47939, 47942, 47944, 47946, 47947, 47948, 47950, 47953, 47954, null, null, null, null, null, null, 47955, 47957, 47958, 47959, 47961, 47962, 47963, 47964, 47965, 47966, 47967, 47968, 47970, 47972, 47973, 47974, 47975, 47976, 47977, 47978, 47979, 47981, 47982, 47983, 47984, 47985, null, null, null, null, null, null, 47986, 47987, 47988, 47989, 47990, 47991, 47992, 47993, 47994, 47995, 47996, 47997, 47998, 47999, 48e3, 48001, 48002, 48003, 48004, 48005, 48006, 48007, 48009, 48010, 48011, 48013, 48014, 48015, 48017, 48018, 48019, 48020, 48021, 48022, 48023, 48024, 48025, 48026, 48027, 48028, 48029, 48030, 48031, 48032, 48033, 48034, 48035, 48037, 48038, 48039, 48041, 48042, 48043, 48045, 48046, 48047, 48048, 48049, 48050, 48051, 48053, 48054, 48056, 48057, 48058, 48059, 48060, 48061, 48062, 48063, 48065, 48066, 48067, 48069, 48070, 48071, 48073, 48074, 48075, 48076, 48077, 48078, 48079, 48081, 48082, 48084, 48085, 48086, 48087, 48088, 48089, 48090, 48091, 48092, 48093, 48094, 48095, 48096, 48097, 48098, 48099, 48100, 48101, 48102, 48103, 48104, 48105, 48106, 48107, 48108, 48109, 48110, 48111, 48112, 48113, 48114, 48115, 48116, 48117, 48118, 48119, 48122, 48123, 48125, 48126, 48129, 48131, 48132, 48133, 48134, 48135, 48138, 48142, 48144, 48146, 48147, 48153, 48154, 48160, 48161, 48162, 48163, 48166, 48168, 48170, 48171, 48172, 48174, 48175, 48178, 48179, 48181, null, null, null, null, null, null, 48182, 48183, 48185, 48186, 48187, 48188, 48189, 48190, 48191, 48194, 48198, 48199, 48200, 48202, 48203, 48206, 48207, 48209, 48210, 48211, 48212, 48213, 48214, 48215, 48216, 48217, null, null, null, null, null, null, 48218, 48219, 48220, 48222, 48223, 48224, 48225, 48226, 48227, 48228, 48229, 48230, 48231, 48232, 48233, 48234, 48235, 48236, 48237, 48238, 48239, 48240, 48241, 48242, 48243, 48244, 48245, 48246, 48247, 48248, 48249, 48250, 48251, 48252, 48253, 48254, 48255, 48256, 48257, 48258, 48259, 48262, 48263, 48265, 48266, 48269, 48271, 48272, 48273, 48274, 48275, 48278, 48280, 48283, 48284, 48285, 48286, 48287, 48290, 48291, 48293, 48294, 48297, 48298, 48299, 48300, 48301, 48302, 48303, 48306, 48310, 48311, 48312, 48313, 48314, 48315, 48318, 48319, 48321, 48322, 48323, 48325, 48326, 48327, 48328, 48329, 48330, 48331, 48332, 48334, 48338, 48339, 48340, 48342, 48343, 48345, 48346, 48347, 48349, 48350, 48351, 48352, 48353, 48354, 48355, 48356, 48357, 48358, 48359, 48360, 48361, 48362, 48363, 48364, 48365, 48366, 48367, 48368, 48369, 48370, 48371, 48375, 48377, 48378, 48379, 48381, 48382, 48383, 48384, 48385, 48386, 48387, 48390, 48392, 48394, 48395, 48396, 48397, 48398, 48399, 48401, 48402, 48403, 48405, 48406, 48407, 48408, 48409, 48410, 48411, 48412, 48413, null, null, null, null, null, null, 48414, 48415, 48416, 48417, 48418, 48419, 48421, 48422, 48423, 48424, 48425, 48426, 48427, 48429, 48430, 48431, 48432, 48433, 48434, 48435, 48436, 48437, 48438, 48439, 48440, 48441, null, null, null, null, null, null, 48442, 48443, 48444, 48445, 48446, 48447, 48449, 48450, 48451, 48452, 48453, 48454, 48455, 48458, 48459, 48461, 48462, 48463, 48465, 48466, 48467, 48468, 48469, 48470, 48471, 48474, 48475, 48476, 48477, 48478, 48479, 48480, 48481, 48482, 48483, 48485, 48486, 48487, 48489, 48490, 48491, 48492, 48493, 48494, 48495, 48496, 48497, 48498, 48499, 48500, 48501, 48502, 48503, 48504, 48505, 48506, 48507, 48508, 48509, 48510, 48511, 48514, 48515, 48517, 48518, 48523, 48524, 48525, 48526, 48527, 48530, 48532, 48534, 48535, 48536, 48539, 48541, 48542, 48543, 48544, 48545, 48546, 48547, 48549, 48550, 48551, 48552, 48553, 48554, 48555, 48556, 48557, 48558, 48559, 48561, 48562, 48563, 48564, 48565, 48566, 48567, 48569, 48570, 48571, 48572, 48573, 48574, 48575, 48576, 48577, 48578, 48579, 48580, 48581, 48582, 48583, 48584, 48585, 48586, 48587, 48588, 48589, 48590, 48591, 48592, 48593, 48594, 48595, 48598, 48599, 48601, 48602, 48603, 48605, 48606, 48607, 48608, 48609, 48610, 48611, 48612, 48613, 48614, 48615, 48616, 48618, 48619, 48620, 48621, 48622, 48623, 48625, null, null, null, null, null, null, 48626, 48627, 48629, 48630, 48631, 48633, 48634, 48635, 48636, 48637, 48638, 48639, 48641, 48642, 48644, 48646, 48647, 48648, 48649, 48650, 48651, 48654, 48655, 48657, 48658, 48659, null, null, null, null, null, null, 48661, 48662, 48663, 48664, 48665, 48666, 48667, 48670, 48672, 48673, 48674, 48675, 48676, 48677, 48678, 48679, 48680, 48681, 48682, 48683, 48684, 48685, 48686, 48687, 48688, 48689, 48690, 48691, 48692, 48693, 48694, 48695, 48696, 48697, 48698, 48699, 48700, 48701, 48702, 48703, 48704, 48705, 48706, 48707, 48710, 48711, 48713, 48714, 48715, 48717, 48719, 48720, 48721, 48722, 48723, 48726, 48728, 48732, 48733, 48734, 48735, 48738, 48739, 48741, 48742, 48743, 48745, 48747, 48748, 48749, 48750, 48751, 48754, 48758, 48759, 48760, 48761, 48762, 48766, 48767, 48769, 48770, 48771, 48773, 48774, 48775, 48776, 48777, 48778, 48779, 48782, 48786, 48787, 48788, 48789, 48790, 48791, 48794, 48795, 48796, 48797, 48798, 48799, 48800, 48801, 48802, 48803, 48804, 48805, 48806, 48807, 48809, 48810, 48811, 48812, 48813, 48814, 48815, 48816, 48817, 48818, 48819, 48820, 48821, 48822, 48823, 48824, 48825, 48826, 48827, 48828, 48829, 48830, 48831, 48832, 48833, 48834, 48835, 48836, 48837, 48838, 48839, 48840, 48841, 48842, 48843, 48844, 48845, 48846, 48847, 48850, 48851, null, null, null, null, null, null, 48853, 48854, 48857, 48858, 48859, 48860, 48861, 48862, 48863, 48865, 48866, 48870, 48871, 48872, 48873, 48874, 48875, 48877, 48878, 48879, 48880, 48881, 48882, 48883, 48884, 48885, null, null, null, null, null, null, 48886, 48887, 48888, 48889, 48890, 48891, 48892, 48893, 48894, 48895, 48896, 48898, 48899, 48900, 48901, 48902, 48903, 48906, 48907, 48908, 48909, 48910, 48911, 48912, 48913, 48914, 48915, 48916, 48917, 48918, 48919, 48922, 48926, 48927, 48928, 48929, 48930, 48931, 48932, 48933, 48934, 48935, 48936, 48937, 48938, 48939, 48940, 48941, 48942, 48943, 48944, 48945, 48946, 48947, 48948, 48949, 48950, 48951, 48952, 48953, 48954, 48955, 48956, 48957, 48958, 48959, 48962, 48963, 48965, 48966, 48967, 48969, 48970, 48971, 48972, 48973, 48974, 48975, 48978, 48979, 48980, 48982, 48983, 48984, 48985, 48986, 48987, 48988, 48989, 48990, 48991, 48992, 48993, 48994, 48995, 48996, 48997, 48998, 48999, 49e3, 49001, 49002, 49003, 49004, 49005, 49006, 49007, 49008, 49009, 49010, 49011, 49012, 49013, 49014, 49015, 49016, 49017, 49018, 49019, 49020, 49021, 49022, 49023, 49024, 49025, 49026, 49027, 49028, 49029, 49030, 49031, 49032, 49033, 49034, 49035, 49036, 49037, 49038, 49039, 49040, 49041, 49042, 49043, 49045, 49046, 49047, 49048, 49049, 49050, 49051, 49052, 49053, null, null, null, null, null, null, 49054, 49055, 49056, 49057, 49058, 49059, 49060, 49061, 49062, 49063, 49064, 49065, 49066, 49067, 49068, 49069, 49070, 49071, 49073, 49074, 49075, 49076, 49077, 49078, 49079, 49080, null, null, null, null, null, null, 49081, 49082, 49083, 49084, 49085, 49086, 49087, 49088, 49089, 49090, 49091, 49092, 49094, 49095, 49096, 49097, 49098, 49099, 49102, 49103, 49105, 49106, 49107, 49109, 49110, 49111, 49112, 49113, 49114, 49115, 49117, 49118, 49120, 49122, 49123, 49124, 49125, 49126, 49127, 49128, 49129, 49130, 49131, 49132, 49133, 49134, 49135, 49136, 49137, 49138, 49139, 49140, 49141, 49142, 49143, 49144, 49145, 49146, 49147, 49148, 49149, 49150, 49151, 49152, 49153, 49154, 49155, 49156, 49157, 49158, 49159, 49160, 49161, 49162, 49163, 49164, 49165, 49166, 49167, 49168, 49169, 49170, 49171, 49172, 49173, 49174, 49175, 49176, 49177, 49178, 49179, 49180, 49181, 49182, 49183, 49184, 49185, 49186, 49187, 49188, 49189, 49190, 49191, 49192, 49193, 49194, 49195, 49196, 49197, 49198, 49199, 49200, 49201, 49202, 49203, 49204, 49205, 49206, 49207, 49208, 49209, 49210, 49211, 49213, 49214, 49215, 49216, 49217, 49218, 49219, 49220, 49221, 49222, 49223, 49224, 49225, 49226, 49227, 49228, 49229, 49230, 49231, 49232, 49234, 49235, 49236, 49237, 49238, 49239, 49241, 49242, 49243, null, null, null, null, null, null, 49245, 49246, 49247, 49249, 49250, 49251, 49252, 49253, 49254, 49255, 49258, 49259, 49260, 49261, 49262, 49263, 49264, 49265, 49266, 49267, 49268, 49269, 49270, 49271, 49272, 49273, null, null, null, null, null, null, 49274, 49275, 49276, 49277, 49278, 49279, 49280, 49281, 49282, 49283, 49284, 49285, 49286, 49287, 49288, 49289, 49290, 49291, 49292, 49293, 49294, 49295, 49298, 49299, 49301, 49302, 49303, 49305, 49306, 49307, 49308, 49309, 49310, 49311, 49314, 49316, 49318, 49319, 49320, 49321, 49322, 49323, 49326, 49329, 49330, 49335, 49336, 49337, 49338, 49339, 49342, 49346, 49347, 49348, 49350, 49351, 49354, 49355, 49357, 49358, 49359, 49361, 49362, 49363, 49364, 49365, 49366, 49367, 49370, 49374, 49375, 49376, 49377, 49378, 49379, 49382, 49383, 49385, 49386, 49387, 49389, 49390, 49391, 49392, 49393, 49394, 49395, 49398, 49400, 49402, 49403, 49404, 49405, 49406, 49407, 49409, 49410, 49411, 49413, 49414, 49415, 49417, 49418, 49419, 49420, 49421, 49422, 49423, 49425, 49426, 49427, 49428, 49430, 49431, 49432, 49433, 49434, 49435, 49441, 49442, 49445, 49448, 49449, 49450, 49451, 49454, 49458, 49459, 49460, 49461, 49463, 49466, 49467, 49469, 49470, 49471, 49473, 49474, 49475, 49476, 49477, 49478, 49479, 49482, 49486, 49487, 49488, 49489, 49490, 49491, 49494, 49495, null, null, null, null, null, null, 49497, 49498, 49499, 49501, 49502, 49503, 49504, 49505, 49506, 49507, 49510, 49514, 49515, 49516, 49517, 49518, 49519, 49521, 49522, 49523, 49525, 49526, 49527, 49529, 49530, 49531, null, null, null, null, null, null, 49532, 49533, 49534, 49535, 49536, 49537, 49538, 49539, 49540, 49542, 49543, 49544, 49545, 49546, 49547, 49551, 49553, 49554, 49555, 49557, 49559, 49560, 49561, 49562, 49563, 49566, 49568, 49570, 49571, 49572, 49574, 49575, 49578, 49579, 49581, 49582, 49583, 49585, 49586, 49587, 49588, 49589, 49590, 49591, 49592, 49593, 49594, 49595, 49596, 49598, 49599, 49600, 49601, 49602, 49603, 49605, 49606, 49607, 49609, 49610, 49611, 49613, 49614, 49615, 49616, 49617, 49618, 49619, 49621, 49622, 49625, 49626, 49627, 49628, 49629, 49630, 49631, 49633, 49634, 49635, 49637, 49638, 49639, 49641, 49642, 49643, 49644, 49645, 49646, 49647, 49650, 49652, 49653, 49654, 49655, 49656, 49657, 49658, 49659, 49662, 49663, 49665, 49666, 49667, 49669, 49670, 49671, 49672, 49673, 49674, 49675, 49678, 49680, 49682, 49683, 49684, 49685, 49686, 49687, 49690, 49691, 49693, 49694, 49697, 49698, 49699, 49700, 49701, 49702, 49703, 49706, 49708, 49710, 49712, 49715, 49717, 49718, 49719, 49720, 49721, 49722, 49723, 49724, 49725, 49726, 49727, 49728, 49729, 49730, 49731, 49732, 49733, null, null, null, null, null, null, 49734, 49735, 49737, 49738, 49739, 49740, 49741, 49742, 49743, 49746, 49747, 49749, 49750, 49751, 49753, 49754, 49755, 49756, 49757, 49758, 49759, 49761, 49762, 49763, 49764, 49766, null, null, null, null, null, null, 49767, 49768, 49769, 49770, 49771, 49774, 49775, 49777, 49778, 49779, 49781, 49782, 49783, 49784, 49785, 49786, 49787, 49790, 49792, 49794, 49795, 49796, 49797, 49798, 49799, 49802, 49803, 49804, 49805, 49806, 49807, 49809, 49810, 49811, 49812, 49813, 49814, 49815, 49817, 49818, 49820, 49822, 49823, 49824, 49825, 49826, 49827, 49830, 49831, 49833, 49834, 49835, 49838, 49839, 49840, 49841, 49842, 49843, 49846, 49848, 49850, 49851, 49852, 49853, 49854, 49855, 49856, 49857, 49858, 49859, 49860, 49861, 49862, 49863, 49864, 49865, 49866, 49867, 49868, 49869, 49870, 49871, 49872, 49873, 49874, 49875, 49876, 49877, 49878, 49879, 49880, 49881, 49882, 49883, 49886, 49887, 49889, 49890, 49893, 49894, 49895, 49896, 49897, 49898, 49902, 49904, 49906, 49907, 49908, 49909, 49911, 49914, 49917, 49918, 49919, 49921, 49922, 49923, 49924, 49925, 49926, 49927, 49930, 49931, 49934, 49935, 49936, 49937, 49938, 49942, 49943, 49945, 49946, 49947, 49949, 49950, 49951, 49952, 49953, 49954, 49955, 49958, 49959, 49962, 49963, 49964, 49965, 49966, 49967, 49968, 49969, 49970, null, null, null, null, null, null, 49971, 49972, 49973, 49974, 49975, 49976, 49977, 49978, 49979, 49980, 49981, 49982, 49983, 49984, 49985, 49986, 49987, 49988, 49990, 49991, 49992, 49993, 49994, 49995, 49996, 49997, null, null, null, null, null, null, 49998, 49999, 5e4, 50001, 50002, 50003, 50004, 50005, 50006, 50007, 50008, 50009, 50010, 50011, 50012, 50013, 50014, 50015, 50016, 50017, 50018, 50019, 50020, 50021, 50022, 50023, 50026, 50027, 50029, 50030, 50031, 50033, 50035, 50036, 50037, 50038, 50039, 50042, 50043, 50046, 50047, 50048, 50049, 50050, 50051, 50053, 50054, 50055, 50057, 50058, 50059, 50061, 50062, 50063, 50064, 50065, 50066, 50067, 50068, 50069, 50070, 50071, 50072, 50073, 50074, 50075, 50076, 50077, 50078, 50079, 50080, 50081, 50082, 50083, 50084, 50085, 50086, 50087, 50088, 50089, 50090, 50091, 50092, 50093, 50094, 50095, 50096, 50097, 50098, 50099, 50100, 50101, 50102, 50103, 50104, 50105, 50106, 50107, 50108, 50109, 50110, 50111, 50113, 50114, 50115, 50116, 50117, 50118, 50119, 50120, 50121, 50122, 50123, 50124, 50125, 50126, 50127, 50128, 50129, 50130, 50131, 50132, 50133, 50134, 50135, 50138, 50139, 50141, 50142, 50145, 50147, 50148, 50149, 50150, 50151, 50154, 50155, 50156, 50158, 50159, 50160, 50161, 50162, 50163, 50166, 50167, 50169, 50170, 50171, 50172, 50173, 50174, null, null, null, null, null, null, 50175, 50176, 50177, 50178, 50179, 50180, 50181, 50182, 50183, 50185, 50186, 50187, 50188, 50189, 50190, 50191, 50193, 50194, 50195, 50196, 50197, 50198, 50199, 50200, 50201, 50202, null, null, null, null, null, null, 50203, 50204, 50205, 50206, 50207, 50208, 50209, 50210, 50211, 50213, 50214, 50215, 50216, 50217, 50218, 50219, 50221, 50222, 50223, 50225, 50226, 50227, 50229, 50230, 50231, 50232, 50233, 50234, 50235, 50238, 50239, 50240, 50241, 50242, 50243, 50244, 50245, 50246, 50247, 50249, 50250, 50251, 50252, 50253, 50254, 50255, 50256, 50257, 50258, 50259, 50260, 50261, 50262, 50263, 50264, 50265, 50266, 50267, 50268, 50269, 50270, 50271, 50272, 50273, 50274, 50275, 50278, 50279, 50281, 50282, 50283, 50285, 50286, 50287, 50288, 50289, 50290, 50291, 50294, 50295, 50296, 50298, 50299, 50300, 50301, 50302, 50303, 50305, 50306, 50307, 50308, 50309, 50310, 50311, 50312, 50313, 50314, 50315, 50316, 50317, 50318, 50319, 50320, 50321, 50322, 50323, 50325, 50326, 50327, 50328, 50329, 50330, 50331, 50333, 50334, 50335, 50336, 50337, 50338, 50339, 50340, 50341, 50342, 50343, 50344, 50345, 50346, 50347, 50348, 50349, 50350, 50351, 50352, 50353, 50354, 50355, 50356, 50357, 50358, 50359, 50361, 50362, 50363, 50365, 50366, 50367, 50368, 50369, 50370, 50371, 50372, 50373, null, null, null, null, null, null, 50374, 50375, 50376, 50377, 50378, 50379, 50380, 50381, 50382, 50383, 50384, 50385, 50386, 50387, 50388, 50389, 50390, 50391, 50392, 50393, 50394, 50395, 50396, 50397, 50398, 50399, null, null, null, null, null, null, 50400, 50401, 50402, 50403, 50404, 50405, 50406, 50407, 50408, 50410, 50411, 50412, 50413, 50414, 50415, 50418, 50419, 50421, 50422, 50423, 50425, 50427, 50428, 50429, 50430, 50434, 50435, 50436, 50437, 50438, 50439, 50440, 50441, 50442, 50443, 50445, 50446, 50447, 50449, 50450, 50451, 50453, 50454, 50455, 50456, 50457, 50458, 50459, 50461, 50462, 50463, 50464, 50465, 50466, 50467, 50468, 50469, 50470, 50471, 50474, 50475, 50477, 50478, 50479, 50481, 50482, 50483, 50484, 50485, 50486, 50487, 50490, 50492, 50494, 50495, 50496, 50497, 50498, 50499, 50502, 50503, 50507, 50511, 50512, 50513, 50514, 50518, 50522, 50523, 50524, 50527, 50530, 50531, 50533, 50534, 50535, 50537, 50538, 50539, 50540, 50541, 50542, 50543, 50546, 50550, 50551, 50552, 50553, 50554, 50555, 50558, 50559, 50561, 50562, 50563, 50565, 50566, 50568, 50569, 50570, 50571, 50574, 50576, 50578, 50579, 50580, 50582, 50585, 50586, 50587, 50589, 50590, 50591, 50593, 50594, 50595, 50596, 50597, 50598, 50599, 50600, 50602, 50603, 50604, 50605, 50606, 50607, 50608, 50609, 50610, 50611, 50614, null, null, null, null, null, null, 50615, 50618, 50623, 50624, 50625, 50626, 50627, 50635, 50637, 50639, 50642, 50643, 50645, 50646, 50647, 50649, 50650, 50651, 50652, 50653, 50654, 50655, 50658, 50660, 50662, 50663, null, null, null, null, null, null, 50664, 50665, 50666, 50667, 50671, 50673, 50674, 50675, 50677, 50680, 50681, 50682, 50683, 50690, 50691, 50692, 50697, 50698, 50699, 50701, 50702, 50703, 50705, 50706, 50707, 50708, 50709, 50710, 50711, 50714, 50717, 50718, 50719, 50720, 50721, 50722, 50723, 50726, 50727, 50729, 50730, 50731, 50735, 50737, 50738, 50742, 50744, 50746, 50748, 50749, 50750, 50751, 50754, 50755, 50757, 50758, 50759, 50761, 50762, 50763, 50764, 50765, 50766, 50767, 50770, 50774, 50775, 50776, 50777, 50778, 50779, 50782, 50783, 50785, 50786, 50787, 50788, 50789, 50790, 50791, 50792, 50793, 50794, 50795, 50797, 50798, 50800, 50802, 50803, 50804, 50805, 50806, 50807, 50810, 50811, 50813, 50814, 50815, 50817, 50818, 50819, 50820, 50821, 50822, 50823, 50826, 50828, 50830, 50831, 50832, 50833, 50834, 50835, 50838, 50839, 50841, 50842, 50843, 50845, 50846, 50847, 50848, 50849, 50850, 50851, 50854, 50856, 50858, 50859, 50860, 50861, 50862, 50863, 50866, 50867, 50869, 50870, 50871, 50875, 50876, 50877, 50878, 50879, 50882, 50884, 50886, 50887, 50888, 50889, 50890, 50891, 50894, null, null, null, null, null, null, 50895, 50897, 50898, 50899, 50901, 50902, 50903, 50904, 50905, 50906, 50907, 50910, 50911, 50914, 50915, 50916, 50917, 50918, 50919, 50922, 50923, 50925, 50926, 50927, 50929, 50930, null, null, null, null, null, null, 50931, 50932, 50933, 50934, 50935, 50938, 50939, 50940, 50942, 50943, 50944, 50945, 50946, 50947, 50950, 50951, 50953, 50954, 50955, 50957, 50958, 50959, 50960, 50961, 50962, 50963, 50966, 50968, 50970, 50971, 50972, 50973, 50974, 50975, 50978, 50979, 50981, 50982, 50983, 50985, 50986, 50987, 50988, 50989, 50990, 50991, 50994, 50996, 50998, 51e3, 51001, 51002, 51003, 51006, 51007, 51009, 51010, 51011, 51013, 51014, 51015, 51016, 51017, 51019, 51022, 51024, 51033, 51034, 51035, 51037, 51038, 51039, 51041, 51042, 51043, 51044, 51045, 51046, 51047, 51049, 51050, 51052, 51053, 51054, 51055, 51056, 51057, 51058, 51059, 51062, 51063, 51065, 51066, 51067, 51071, 51072, 51073, 51074, 51078, 51083, 51084, 51085, 51087, 51090, 51091, 51093, 51097, 51099, 51100, 51101, 51102, 51103, 51106, 51111, 51112, 51113, 51114, 51115, 51118, 51119, 51121, 51122, 51123, 51125, 51126, 51127, 51128, 51129, 51130, 51131, 51134, 51138, 51139, 51140, 51141, 51142, 51143, 51146, 51147, 51149, 51151, 51153, 51154, 51155, 51156, 51157, 51158, 51159, 51161, 51162, 51163, 51164, null, null, null, null, null, null, 51166, 51167, 51168, 51169, 51170, 51171, 51173, 51174, 51175, 51177, 51178, 51179, 51181, 51182, 51183, 51184, 51185, 51186, 51187, 51188, 51189, 51190, 51191, 51192, 51193, 51194, null, null, null, null, null, null, 51195, 51196, 51197, 51198, 51199, 51202, 51203, 51205, 51206, 51207, 51209, 51211, 51212, 51213, 51214, 51215, 51218, 51220, 51223, 51224, 51225, 51226, 51227, 51230, 51231, 51233, 51234, 51235, 51237, 51238, 51239, 51240, 51241, 51242, 51243, 51246, 51248, 51250, 51251, 51252, 51253, 51254, 51255, 51257, 51258, 51259, 51261, 51262, 51263, 51265, 51266, 51267, 51268, 51269, 51270, 51271, 51274, 51275, 51278, 51279, 51280, 51281, 51282, 51283, 51285, 51286, 51287, 51288, 51289, 51290, 51291, 51292, 51293, 51294, 51295, 51296, 51297, 51298, 51299, 51300, 51301, 51302, 51303, 51304, 51305, 51306, 51307, 51308, 51309, 51310, 51311, 51314, 51315, 51317, 51318, 51319, 51321, 51323, 51324, 51325, 51326, 51327, 51330, 51332, 51336, 51337, 51338, 51342, 51343, 51344, 51345, 51346, 51347, 51349, 51350, 51351, 51352, 51353, 51354, 51355, 51356, 51358, 51360, 51362, 51363, 51364, 51365, 51366, 51367, 51369, 51370, 51371, 51372, 51373, 51374, 51375, 51376, 51377, 51378, 51379, 51380, 51381, 51382, 51383, 51384, 51385, 51386, 51387, 51390, 51391, 51392, 51393, null, null, null, null, null, null, 51394, 51395, 51397, 51398, 51399, 51401, 51402, 51403, 51405, 51406, 51407, 51408, 51409, 51410, 51411, 51414, 51416, 51418, 51419, 51420, 51421, 51422, 51423, 51426, 51427, 51429, null, null, null, null, null, null, 51430, 51431, 51432, 51433, 51434, 51435, 51436, 51437, 51438, 51439, 51440, 51441, 51442, 51443, 51444, 51446, 51447, 51448, 51449, 51450, 51451, 51454, 51455, 51457, 51458, 51459, 51463, 51464, 51465, 51466, 51467, 51470, 12288, 12289, 12290, 183, 8229, 8230, 168, 12291, 173, 8213, 8741, 65340, 8764, 8216, 8217, 8220, 8221, 12308, 12309, 12296, 12297, 12298, 12299, 12300, 12301, 12302, 12303, 12304, 12305, 177, 215, 247, 8800, 8804, 8805, 8734, 8756, 176, 8242, 8243, 8451, 8491, 65504, 65505, 65509, 9794, 9792, 8736, 8869, 8978, 8706, 8711, 8801, 8786, 167, 8251, 9734, 9733, 9675, 9679, 9678, 9671, 9670, 9633, 9632, 9651, 9650, 9661, 9660, 8594, 8592, 8593, 8595, 8596, 12307, 8810, 8811, 8730, 8765, 8733, 8757, 8747, 8748, 8712, 8715, 8838, 8839, 8834, 8835, 8746, 8745, 8743, 8744, 65506, 51472, 51474, 51475, 51476, 51477, 51478, 51479, 51481, 51482, 51483, 51484, 51485, 51486, 51487, 51488, 51489, 51490, 51491, 51492, 51493, 51494, 51495, 51496, 51497, 51498, 51499, null, null, null, null, null, null, 51501, 51502, 51503, 51504, 51505, 51506, 51507, 51509, 51510, 51511, 51512, 51513, 51514, 51515, 51516, 51517, 51518, 51519, 51520, 51521, 51522, 51523, 51524, 51525, 51526, 51527, null, null, null, null, null, null, 51528, 51529, 51530, 51531, 51532, 51533, 51534, 51535, 51538, 51539, 51541, 51542, 51543, 51545, 51546, 51547, 51548, 51549, 51550, 51551, 51554, 51556, 51557, 51558, 51559, 51560, 51561, 51562, 51563, 51565, 51566, 51567, 8658, 8660, 8704, 8707, 180, 65374, 711, 728, 733, 730, 729, 184, 731, 161, 191, 720, 8750, 8721, 8719, 164, 8457, 8240, 9665, 9664, 9655, 9654, 9828, 9824, 9825, 9829, 9831, 9827, 8857, 9672, 9635, 9680, 9681, 9618, 9636, 9637, 9640, 9639, 9638, 9641, 9832, 9743, 9742, 9756, 9758, 182, 8224, 8225, 8597, 8599, 8601, 8598, 8600, 9837, 9833, 9834, 9836, 12927, 12828, 8470, 13255, 8482, 13250, 13272, 8481, 8364, 174, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 51569, 51570, 51571, 51573, 51574, 51575, 51576, 51577, 51578, 51579, 51581, 51582, 51583, 51584, 51585, 51586, 51587, 51588, 51589, 51590, 51591, 51594, 51595, 51597, 51598, 51599, null, null, null, null, null, null, 51601, 51602, 51603, 51604, 51605, 51606, 51607, 51610, 51612, 51614, 51615, 51616, 51617, 51618, 51619, 51620, 51621, 51622, 51623, 51624, 51625, 51626, 51627, 51628, 51629, 51630, null, null, null, null, null, null, 51631, 51632, 51633, 51634, 51635, 51636, 51637, 51638, 51639, 51640, 51641, 51642, 51643, 51644, 51645, 51646, 51647, 51650, 51651, 51653, 51654, 51657, 51659, 51660, 51661, 51662, 51663, 51666, 51668, 51671, 51672, 51675, 65281, 65282, 65283, 65284, 65285, 65286, 65287, 65288, 65289, 65290, 65291, 65292, 65293, 65294, 65295, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, 65306, 65307, 65308, 65309, 65310, 65311, 65312, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, 65339, 65510, 65341, 65342, 65343, 65344, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 65371, 65372, 65373, 65507, 51678, 51679, 51681, 51683, 51685, 51686, 51688, 51689, 51690, 51691, 51694, 51698, 51699, 51700, 51701, 51702, 51703, 51706, 51707, 51709, 51710, 51711, 51713, 51714, 51715, 51716, null, null, null, null, null, null, 51717, 51718, 51719, 51722, 51726, 51727, 51728, 51729, 51730, 51731, 51733, 51734, 51735, 51737, 51738, 51739, 51740, 51741, 51742, 51743, 51744, 51745, 51746, 51747, 51748, 51749, null, null, null, null, null, null, 51750, 51751, 51752, 51754, 51755, 51756, 51757, 51758, 51759, 51760, 51761, 51762, 51763, 51764, 51765, 51766, 51767, 51768, 51769, 51770, 51771, 51772, 51773, 51774, 51775, 51776, 51777, 51778, 51779, 51780, 51781, 51782, 12593, 12594, 12595, 12596, 12597, 12598, 12599, 12600, 12601, 12602, 12603, 12604, 12605, 12606, 12607, 12608, 12609, 12610, 12611, 12612, 12613, 12614, 12615, 12616, 12617, 12618, 12619, 12620, 12621, 12622, 12623, 12624, 12625, 12626, 12627, 12628, 12629, 12630, 12631, 12632, 12633, 12634, 12635, 12636, 12637, 12638, 12639, 12640, 12641, 12642, 12643, 12644, 12645, 12646, 12647, 12648, 12649, 12650, 12651, 12652, 12653, 12654, 12655, 12656, 12657, 12658, 12659, 12660, 12661, 12662, 12663, 12664, 12665, 12666, 12667, 12668, 12669, 12670, 12671, 12672, 12673, 12674, 12675, 12676, 12677, 12678, 12679, 12680, 12681, 12682, 12683, 12684, 12685, 12686, 51783, 51784, 51785, 51786, 51787, 51790, 51791, 51793, 51794, 51795, 51797, 51798, 51799, 51800, 51801, 51802, 51803, 51806, 51810, 51811, 51812, 51813, 51814, 51815, 51817, 51818, null, null, null, null, null, null, 51819, 51820, 51821, 51822, 51823, 51824, 51825, 51826, 51827, 51828, 51829, 51830, 51831, 51832, 51833, 51834, 51835, 51836, 51838, 51839, 51840, 51841, 51842, 51843, 51845, 51846, null, null, null, null, null, null, 51847, 51848, 51849, 51850, 51851, 51852, 51853, 51854, 51855, 51856, 51857, 51858, 51859, 51860, 51861, 51862, 51863, 51865, 51866, 51867, 51868, 51869, 51870, 51871, 51872, 51873, 51874, 51875, 51876, 51877, 51878, 51879, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, null, null, null, null, null, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, null, null, null, null, null, null, null, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, null, null, null, null, null, null, null, null, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, null, null, null, null, null, null, 51880, 51881, 51882, 51883, 51884, 51885, 51886, 51887, 51888, 51889, 51890, 51891, 51892, 51893, 51894, 51895, 51896, 51897, 51898, 51899, 51902, 51903, 51905, 51906, 51907, 51909, null, null, null, null, null, null, 51910, 51911, 51912, 51913, 51914, 51915, 51918, 51920, 51922, 51924, 51925, 51926, 51927, 51930, 51931, 51932, 51933, 51934, 51935, 51937, 51938, 51939, 51940, 51941, 51942, 51943, null, null, null, null, null, null, 51944, 51945, 51946, 51947, 51949, 51950, 51951, 51952, 51953, 51954, 51955, 51957, 51958, 51959, 51960, 51961, 51962, 51963, 51964, 51965, 51966, 51967, 51968, 51969, 51970, 51971, 51972, 51973, 51974, 51975, 51977, 51978, 9472, 9474, 9484, 9488, 9496, 9492, 9500, 9516, 9508, 9524, 9532, 9473, 9475, 9487, 9491, 9499, 9495, 9507, 9523, 9515, 9531, 9547, 9504, 9519, 9512, 9527, 9535, 9501, 9520, 9509, 9528, 9538, 9490, 9489, 9498, 9497, 9494, 9493, 9486, 9485, 9502, 9503, 9505, 9506, 9510, 9511, 9513, 9514, 9517, 9518, 9521, 9522, 9525, 9526, 9529, 9530, 9533, 9534, 9536, 9537, 9539, 9540, 9541, 9542, 9543, 9544, 9545, 9546, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 51979, 51980, 51981, 51982, 51983, 51985, 51986, 51987, 51989, 51990, 51991, 51993, 51994, 51995, 51996, 51997, 51998, 51999, 52002, 52003, 52004, 52005, 52006, 52007, 52008, 52009, null, null, null, null, null, null, 52010, 52011, 52012, 52013, 52014, 52015, 52016, 52017, 52018, 52019, 52020, 52021, 52022, 52023, 52024, 52025, 52026, 52027, 52028, 52029, 52030, 52031, 52032, 52034, 52035, 52036, null, null, null, null, null, null, 52037, 52038, 52039, 52042, 52043, 52045, 52046, 52047, 52049, 52050, 52051, 52052, 52053, 52054, 52055, 52058, 52059, 52060, 52062, 52063, 52064, 52065, 52066, 52067, 52069, 52070, 52071, 52072, 52073, 52074, 52075, 52076, 13205, 13206, 13207, 8467, 13208, 13252, 13219, 13220, 13221, 13222, 13209, 13210, 13211, 13212, 13213, 13214, 13215, 13216, 13217, 13218, 13258, 13197, 13198, 13199, 13263, 13192, 13193, 13256, 13223, 13224, 13232, 13233, 13234, 13235, 13236, 13237, 13238, 13239, 13240, 13241, 13184, 13185, 13186, 13187, 13188, 13242, 13243, 13244, 13245, 13246, 13247, 13200, 13201, 13202, 13203, 13204, 8486, 13248, 13249, 13194, 13195, 13196, 13270, 13253, 13229, 13230, 13231, 13275, 13225, 13226, 13227, 13228, 13277, 13264, 13267, 13251, 13257, 13276, 13254, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52077, 52078, 52079, 52080, 52081, 52082, 52083, 52084, 52085, 52086, 52087, 52090, 52091, 52092, 52093, 52094, 52095, 52096, 52097, 52098, 52099, 52100, 52101, 52102, 52103, 52104, null, null, null, null, null, null, 52105, 52106, 52107, 52108, 52109, 52110, 52111, 52112, 52113, 52114, 52115, 52116, 52117, 52118, 52119, 52120, 52121, 52122, 52123, 52125, 52126, 52127, 52128, 52129, 52130, 52131, null, null, null, null, null, null, 52132, 52133, 52134, 52135, 52136, 52137, 52138, 52139, 52140, 52141, 52142, 52143, 52144, 52145, 52146, 52147, 52148, 52149, 52150, 52151, 52153, 52154, 52155, 52156, 52157, 52158, 52159, 52160, 52161, 52162, 52163, 52164, 198, 208, 170, 294, null, 306, null, 319, 321, 216, 338, 186, 222, 358, 330, null, 12896, 12897, 12898, 12899, 12900, 12901, 12902, 12903, 12904, 12905, 12906, 12907, 12908, 12909, 12910, 12911, 12912, 12913, 12914, 12915, 12916, 12917, 12918, 12919, 12920, 12921, 12922, 12923, 9424, 9425, 9426, 9427, 9428, 9429, 9430, 9431, 9432, 9433, 9434, 9435, 9436, 9437, 9438, 9439, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9449, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9322, 9323, 9324, 9325, 9326, 189, 8531, 8532, 188, 190, 8539, 8540, 8541, 8542, 52165, 52166, 52167, 52168, 52169, 52170, 52171, 52172, 52173, 52174, 52175, 52176, 52177, 52178, 52179, 52181, 52182, 52183, 52184, 52185, 52186, 52187, 52188, 52189, 52190, 52191, null, null, null, null, null, null, 52192, 52193, 52194, 52195, 52197, 52198, 52200, 52202, 52203, 52204, 52205, 52206, 52207, 52208, 52209, 52210, 52211, 52212, 52213, 52214, 52215, 52216, 52217, 52218, 52219, 52220, null, null, null, null, null, null, 52221, 52222, 52223, 52224, 52225, 52226, 52227, 52228, 52229, 52230, 52231, 52232, 52233, 52234, 52235, 52238, 52239, 52241, 52242, 52243, 52245, 52246, 52247, 52248, 52249, 52250, 52251, 52254, 52255, 52256, 52259, 52260, 230, 273, 240, 295, 305, 307, 312, 320, 322, 248, 339, 223, 254, 359, 331, 329, 12800, 12801, 12802, 12803, 12804, 12805, 12806, 12807, 12808, 12809, 12810, 12811, 12812, 12813, 12814, 12815, 12816, 12817, 12818, 12819, 12820, 12821, 12822, 12823, 12824, 12825, 12826, 12827, 9372, 9373, 9374, 9375, 9376, 9377, 9378, 9379, 9380, 9381, 9382, 9383, 9384, 9385, 9386, 9387, 9388, 9389, 9390, 9391, 9392, 9393, 9394, 9395, 9396, 9397, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 185, 178, 179, 8308, 8319, 8321, 8322, 8323, 8324, 52261, 52262, 52266, 52267, 52269, 52271, 52273, 52274, 52275, 52276, 52277, 52278, 52279, 52282, 52287, 52288, 52289, 52290, 52291, 52294, 52295, 52297, 52298, 52299, 52301, 52302, null, null, null, null, null, null, 52303, 52304, 52305, 52306, 52307, 52310, 52314, 52315, 52316, 52317, 52318, 52319, 52321, 52322, 52323, 52325, 52327, 52329, 52330, 52331, 52332, 52333, 52334, 52335, 52337, 52338, null, null, null, null, null, null, 52339, 52340, 52342, 52343, 52344, 52345, 52346, 52347, 52348, 52349, 52350, 52351, 52352, 52353, 52354, 52355, 52356, 52357, 52358, 52359, 52360, 52361, 52362, 52363, 52364, 52365, 52366, 52367, 52368, 52369, 52370, 52371, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, null, null, null, null, null, null, null, null, null, null, null, 52372, 52373, 52374, 52375, 52378, 52379, 52381, 52382, 52383, 52385, 52386, 52387, 52388, 52389, 52390, 52391, 52394, 52398, 52399, 52400, 52401, 52402, 52403, 52406, 52407, 52409, null, null, null, null, null, null, 52410, 52411, 52413, 52414, 52415, 52416, 52417, 52418, 52419, 52422, 52424, 52426, 52427, 52428, 52429, 52430, 52431, 52433, 52434, 52435, 52437, 52438, 52439, 52440, 52441, 52442, null, null, null, null, null, null, 52443, 52444, 52445, 52446, 52447, 52448, 52449, 52450, 52451, 52453, 52454, 52455, 52456, 52457, 52458, 52459, 52461, 52462, 52463, 52465, 52466, 52467, 52468, 52469, 52470, 52471, 52472, 52473, 52474, 52475, 52476, 52477, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, null, null, null, null, null, null, null, null, 52478, 52479, 52480, 52482, 52483, 52484, 52485, 52486, 52487, 52490, 52491, 52493, 52494, 52495, 52497, 52498, 52499, 52500, 52501, 52502, 52503, 52506, 52508, 52510, 52511, 52512, null, null, null, null, null, null, 52513, 52514, 52515, 52517, 52518, 52519, 52521, 52522, 52523, 52525, 52526, 52527, 52528, 52529, 52530, 52531, 52532, 52533, 52534, 52535, 52536, 52538, 52539, 52540, 52541, 52542, null, null, null, null, null, null, 52543, 52544, 52545, 52546, 52547, 52548, 52549, 52550, 52551, 52552, 52553, 52554, 52555, 52556, 52557, 52558, 52559, 52560, 52561, 52562, 52563, 52564, 52565, 52566, 52567, 52568, 52569, 52570, 52571, 52573, 52574, 52575, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, null, null, null, null, null, null, null, null, null, null, null, null, null, 52577, 52578, 52579, 52581, 52582, 52583, 52584, 52585, 52586, 52587, 52590, 52592, 52594, 52595, 52596, 52597, 52598, 52599, 52601, 52602, 52603, 52604, 52605, 52606, 52607, 52608, null, null, null, null, null, null, 52609, 52610, 52611, 52612, 52613, 52614, 52615, 52617, 52618, 52619, 52620, 52621, 52622, 52623, 52624, 52625, 52626, 52627, 52630, 52631, 52633, 52634, 52635, 52637, 52638, 52639, null, null, null, null, null, null, 52640, 52641, 52642, 52643, 52646, 52648, 52650, 52651, 52652, 52653, 52654, 52655, 52657, 52658, 52659, 52660, 52661, 52662, 52663, 52664, 52665, 52666, 52667, 52668, 52669, 52670, 52671, 52672, 52673, 52674, 52675, 52677, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52678, 52679, 52680, 52681, 52682, 52683, 52685, 52686, 52687, 52689, 52690, 52691, 52692, 52693, 52694, 52695, 52696, 52697, 52698, 52699, 52700, 52701, 52702, 52703, 52704, 52705, null, null, null, null, null, null, 52706, 52707, 52708, 52709, 52710, 52711, 52713, 52714, 52715, 52717, 52718, 52719, 52721, 52722, 52723, 52724, 52725, 52726, 52727, 52730, 52732, 52734, 52735, 52736, 52737, 52738, null, null, null, null, null, null, 52739, 52741, 52742, 52743, 52745, 52746, 52747, 52749, 52750, 52751, 52752, 52753, 52754, 52755, 52757, 52758, 52759, 52760, 52762, 52763, 52764, 52765, 52766, 52767, 52770, 52771, 52773, 52774, 52775, 52777, 52778, 52779, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52780, 52781, 52782, 52783, 52786, 52788, 52790, 52791, 52792, 52793, 52794, 52795, 52796, 52797, 52798, 52799, 52800, 52801, 52802, 52803, 52804, 52805, 52806, 52807, 52808, 52809, null, null, null, null, null, null, 52810, 52811, 52812, 52813, 52814, 52815, 52816, 52817, 52818, 52819, 52820, 52821, 52822, 52823, 52826, 52827, 52829, 52830, 52834, 52835, 52836, 52837, 52838, 52839, 52842, 52844, null, null, null, null, null, null, 52846, 52847, 52848, 52849, 52850, 52851, 52854, 52855, 52857, 52858, 52859, 52861, 52862, 52863, 52864, 52865, 52866, 52867, 52870, 52872, 52874, 52875, 52876, 52877, 52878, 52879, 52882, 52883, 52885, 52886, 52887, 52889, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 52890, 52891, 52892, 52893, 52894, 52895, 52898, 52902, 52903, 52904, 52905, 52906, 52907, 52910, 52911, 52912, 52913, 52914, 52915, 52916, 52917, 52918, 52919, 52920, 52921, 52922, null, null, null, null, null, null, 52923, 52924, 52925, 52926, 52927, 52928, 52930, 52931, 52932, 52933, 52934, 52935, 52936, 52937, 52938, 52939, 52940, 52941, 52942, 52943, 52944, 52945, 52946, 52947, 52948, 52949, null, null, null, null, null, null, 52950, 52951, 52952, 52953, 52954, 52955, 52956, 52957, 52958, 52959, 52960, 52961, 52962, 52963, 52966, 52967, 52969, 52970, 52973, 52974, 52975, 52976, 52977, 52978, 52979, 52982, 52986, 52987, 52988, 52989, 52990, 52991, 44032, 44033, 44036, 44039, 44040, 44041, 44042, 44048, 44049, 44050, 44051, 44052, 44053, 44054, 44055, 44057, 44058, 44059, 44060, 44061, 44064, 44068, 44076, 44077, 44079, 44080, 44081, 44088, 44089, 44092, 44096, 44107, 44109, 44116, 44120, 44124, 44144, 44145, 44148, 44151, 44152, 44154, 44160, 44161, 44163, 44164, 44165, 44166, 44169, 44170, 44171, 44172, 44176, 44180, 44188, 44189, 44191, 44192, 44193, 44200, 44201, 44202, 44204, 44207, 44208, 44216, 44217, 44219, 44220, 44221, 44225, 44228, 44232, 44236, 44245, 44247, 44256, 44257, 44260, 44263, 44264, 44266, 44268, 44271, 44272, 44273, 44275, 44277, 44278, 44284, 44285, 44288, 44292, 44294, 52994, 52995, 52997, 52998, 52999, 53001, 53002, 53003, 53004, 53005, 53006, 53007, 53010, 53012, 53014, 53015, 53016, 53017, 53018, 53019, 53021, 53022, 53023, 53025, 53026, 53027, null, null, null, null, null, null, 53029, 53030, 53031, 53032, 53033, 53034, 53035, 53038, 53042, 53043, 53044, 53045, 53046, 53047, 53049, 53050, 53051, 53052, 53053, 53054, 53055, 53056, 53057, 53058, 53059, 53060, null, null, null, null, null, null, 53061, 53062, 53063, 53064, 53065, 53066, 53067, 53068, 53069, 53070, 53071, 53072, 53073, 53074, 53075, 53078, 53079, 53081, 53082, 53083, 53085, 53086, 53087, 53088, 53089, 53090, 53091, 53094, 53096, 53098, 53099, 53100, 44300, 44301, 44303, 44305, 44312, 44316, 44320, 44329, 44332, 44333, 44340, 44341, 44344, 44348, 44356, 44357, 44359, 44361, 44368, 44372, 44376, 44385, 44387, 44396, 44397, 44400, 44403, 44404, 44405, 44406, 44411, 44412, 44413, 44415, 44417, 44418, 44424, 44425, 44428, 44432, 44444, 44445, 44452, 44471, 44480, 44481, 44484, 44488, 44496, 44497, 44499, 44508, 44512, 44516, 44536, 44537, 44540, 44543, 44544, 44545, 44552, 44553, 44555, 44557, 44564, 44592, 44593, 44596, 44599, 44600, 44602, 44608, 44609, 44611, 44613, 44614, 44618, 44620, 44621, 44622, 44624, 44628, 44630, 44636, 44637, 44639, 44640, 44641, 44645, 44648, 44649, 44652, 44656, 44664, 53101, 53102, 53103, 53106, 53107, 53109, 53110, 53111, 53113, 53114, 53115, 53116, 53117, 53118, 53119, 53121, 53122, 53123, 53124, 53126, 53127, 53128, 53129, 53130, 53131, 53133, null, null, null, null, null, null, 53134, 53135, 53136, 53137, 53138, 53139, 53140, 53141, 53142, 53143, 53144, 53145, 53146, 53147, 53148, 53149, 53150, 53151, 53152, 53154, 53155, 53156, 53157, 53158, 53159, 53161, null, null, null, null, null, null, 53162, 53163, 53164, 53165, 53166, 53167, 53169, 53170, 53171, 53172, 53173, 53174, 53175, 53176, 53177, 53178, 53179, 53180, 53181, 53182, 53183, 53184, 53185, 53186, 53187, 53189, 53190, 53191, 53192, 53193, 53194, 53195, 44665, 44667, 44668, 44669, 44676, 44677, 44684, 44732, 44733, 44734, 44736, 44740, 44748, 44749, 44751, 44752, 44753, 44760, 44761, 44764, 44776, 44779, 44781, 44788, 44792, 44796, 44807, 44808, 44813, 44816, 44844, 44845, 44848, 44850, 44852, 44860, 44861, 44863, 44865, 44866, 44867, 44872, 44873, 44880, 44892, 44893, 44900, 44901, 44921, 44928, 44932, 44936, 44944, 44945, 44949, 44956, 44984, 44985, 44988, 44992, 44999, 45e3, 45001, 45003, 45005, 45006, 45012, 45020, 45032, 45033, 45040, 45041, 45044, 45048, 45056, 45057, 45060, 45068, 45072, 45076, 45084, 45085, 45096, 45124, 45125, 45128, 45130, 45132, 45134, 45139, 45140, 45141, 45143, 45145, 53196, 53197, 53198, 53199, 53200, 53201, 53202, 53203, 53204, 53205, 53206, 53207, 53208, 53209, 53210, 53211, 53212, 53213, 53214, 53215, 53218, 53219, 53221, 53222, 53223, 53225, null, null, null, null, null, null, 53226, 53227, 53228, 53229, 53230, 53231, 53234, 53236, 53238, 53239, 53240, 53241, 53242, 53243, 53245, 53246, 53247, 53249, 53250, 53251, 53253, 53254, 53255, 53256, 53257, 53258, null, null, null, null, null, null, 53259, 53260, 53261, 53262, 53263, 53264, 53266, 53267, 53268, 53269, 53270, 53271, 53273, 53274, 53275, 53276, 53277, 53278, 53279, 53280, 53281, 53282, 53283, 53284, 53285, 53286, 53287, 53288, 53289, 53290, 53291, 53292, 45149, 45180, 45181, 45184, 45188, 45196, 45197, 45199, 45201, 45208, 45209, 45210, 45212, 45215, 45216, 45217, 45218, 45224, 45225, 45227, 45228, 45229, 45230, 45231, 45233, 45235, 45236, 45237, 45240, 45244, 45252, 45253, 45255, 45256, 45257, 45264, 45265, 45268, 45272, 45280, 45285, 45320, 45321, 45323, 45324, 45328, 45330, 45331, 45336, 45337, 45339, 45340, 45341, 45347, 45348, 45349, 45352, 45356, 45364, 45365, 45367, 45368, 45369, 45376, 45377, 45380, 45384, 45392, 45393, 45396, 45397, 45400, 45404, 45408, 45432, 45433, 45436, 45440, 45442, 45448, 45449, 45451, 45453, 45458, 45459, 45460, 45464, 45468, 45480, 45516, 45520, 45524, 45532, 45533, 53294, 53295, 53296, 53297, 53298, 53299, 53302, 53303, 53305, 53306, 53307, 53309, 53310, 53311, 53312, 53313, 53314, 53315, 53318, 53320, 53322, 53323, 53324, 53325, 53326, 53327, null, null, null, null, null, null, 53329, 53330, 53331, 53333, 53334, 53335, 53337, 53338, 53339, 53340, 53341, 53342, 53343, 53345, 53346, 53347, 53348, 53349, 53350, 53351, 53352, 53353, 53354, 53355, 53358, 53359, null, null, null, null, null, null, 53361, 53362, 53363, 53365, 53366, 53367, 53368, 53369, 53370, 53371, 53374, 53375, 53376, 53378, 53379, 53380, 53381, 53382, 53383, 53384, 53385, 53386, 53387, 53388, 53389, 53390, 53391, 53392, 53393, 53394, 53395, 53396, 45535, 45544, 45545, 45548, 45552, 45561, 45563, 45565, 45572, 45573, 45576, 45579, 45580, 45588, 45589, 45591, 45593, 45600, 45620, 45628, 45656, 45660, 45664, 45672, 45673, 45684, 45685, 45692, 45700, 45701, 45705, 45712, 45713, 45716, 45720, 45721, 45722, 45728, 45729, 45731, 45733, 45734, 45738, 45740, 45744, 45748, 45768, 45769, 45772, 45776, 45778, 45784, 45785, 45787, 45789, 45794, 45796, 45797, 45798, 45800, 45803, 45804, 45805, 45806, 45807, 45811, 45812, 45813, 45815, 45816, 45817, 45818, 45819, 45823, 45824, 45825, 45828, 45832, 45840, 45841, 45843, 45844, 45845, 45852, 45908, 45909, 45910, 45912, 45915, 45916, 45918, 45919, 45924, 45925, 53397, 53398, 53399, 53400, 53401, 53402, 53403, 53404, 53405, 53406, 53407, 53408, 53409, 53410, 53411, 53414, 53415, 53417, 53418, 53419, 53421, 53422, 53423, 53424, 53425, 53426, null, null, null, null, null, null, 53427, 53430, 53432, 53434, 53435, 53436, 53437, 53438, 53439, 53442, 53443, 53445, 53446, 53447, 53450, 53451, 53452, 53453, 53454, 53455, 53458, 53462, 53463, 53464, 53465, 53466, null, null, null, null, null, null, 53467, 53470, 53471, 53473, 53474, 53475, 53477, 53478, 53479, 53480, 53481, 53482, 53483, 53486, 53490, 53491, 53492, 53493, 53494, 53495, 53497, 53498, 53499, 53500, 53501, 53502, 53503, 53504, 53505, 53506, 53507, 53508, 45927, 45929, 45931, 45934, 45936, 45937, 45940, 45944, 45952, 45953, 45955, 45956, 45957, 45964, 45968, 45972, 45984, 45985, 45992, 45996, 46020, 46021, 46024, 46027, 46028, 46030, 46032, 46036, 46037, 46039, 46041, 46043, 46045, 46048, 46052, 46056, 46076, 46096, 46104, 46108, 46112, 46120, 46121, 46123, 46132, 46160, 46161, 46164, 46168, 46176, 46177, 46179, 46181, 46188, 46208, 46216, 46237, 46244, 46248, 46252, 46261, 46263, 46265, 46272, 46276, 46280, 46288, 46293, 46300, 46301, 46304, 46307, 46308, 46310, 46316, 46317, 46319, 46321, 46328, 46356, 46357, 46360, 46363, 46364, 46372, 46373, 46375, 46376, 46377, 46378, 46384, 46385, 46388, 46392, 53509, 53510, 53511, 53512, 53513, 53514, 53515, 53516, 53518, 53519, 53520, 53521, 53522, 53523, 53524, 53525, 53526, 53527, 53528, 53529, 53530, 53531, 53532, 53533, 53534, 53535, null, null, null, null, null, null, 53536, 53537, 53538, 53539, 53540, 53541, 53542, 53543, 53544, 53545, 53546, 53547, 53548, 53549, 53550, 53551, 53554, 53555, 53557, 53558, 53559, 53561, 53563, 53564, 53565, 53566, null, null, null, null, null, null, 53567, 53570, 53574, 53575, 53576, 53577, 53578, 53579, 53582, 53583, 53585, 53586, 53587, 53589, 53590, 53591, 53592, 53593, 53594, 53595, 53598, 53600, 53602, 53603, 53604, 53605, 53606, 53607, 53609, 53610, 53611, 53613, 46400, 46401, 46403, 46404, 46405, 46411, 46412, 46413, 46416, 46420, 46428, 46429, 46431, 46432, 46433, 46496, 46497, 46500, 46504, 46506, 46507, 46512, 46513, 46515, 46516, 46517, 46523, 46524, 46525, 46528, 46532, 46540, 46541, 46543, 46544, 46545, 46552, 46572, 46608, 46609, 46612, 46616, 46629, 46636, 46644, 46664, 46692, 46696, 46748, 46749, 46752, 46756, 46763, 46764, 46769, 46804, 46832, 46836, 46840, 46848, 46849, 46853, 46888, 46889, 46892, 46895, 46896, 46904, 46905, 46907, 46916, 46920, 46924, 46932, 46933, 46944, 46948, 46952, 46960, 46961, 46963, 46965, 46972, 46973, 46976, 46980, 46988, 46989, 46991, 46992, 46993, 46994, 46998, 46999, 53614, 53615, 53616, 53617, 53618, 53619, 53620, 53621, 53622, 53623, 53624, 53625, 53626, 53627, 53629, 53630, 53631, 53632, 53633, 53634, 53635, 53637, 53638, 53639, 53641, 53642, null, null, null, null, null, null, 53643, 53644, 53645, 53646, 53647, 53648, 53649, 53650, 53651, 53652, 53653, 53654, 53655, 53656, 53657, 53658, 53659, 53660, 53661, 53662, 53663, 53666, 53667, 53669, 53670, 53671, null, null, null, null, null, null, 53673, 53674, 53675, 53676, 53677, 53678, 53679, 53682, 53684, 53686, 53687, 53688, 53689, 53691, 53693, 53694, 53695, 53697, 53698, 53699, 53700, 53701, 53702, 53703, 53704, 53705, 53706, 53707, 53708, 53709, 53710, 53711, 47e3, 47001, 47004, 47008, 47016, 47017, 47019, 47020, 47021, 47028, 47029, 47032, 47047, 47049, 47084, 47085, 47088, 47092, 47100, 47101, 47103, 47104, 47105, 47111, 47112, 47113, 47116, 47120, 47128, 47129, 47131, 47133, 47140, 47141, 47144, 47148, 47156, 47157, 47159, 47160, 47161, 47168, 47172, 47185, 47187, 47196, 47197, 47200, 47204, 47212, 47213, 47215, 47217, 47224, 47228, 47245, 47272, 47280, 47284, 47288, 47296, 47297, 47299, 47301, 47308, 47312, 47316, 47325, 47327, 47329, 47336, 47337, 47340, 47344, 47352, 47353, 47355, 47357, 47364, 47384, 47392, 47420, 47421, 47424, 47428, 47436, 47439, 47441, 47448, 47449, 47452, 47456, 47464, 47465, 53712, 53713, 53714, 53715, 53716, 53717, 53718, 53719, 53721, 53722, 53723, 53724, 53725, 53726, 53727, 53728, 53729, 53730, 53731, 53732, 53733, 53734, 53735, 53736, 53737, 53738, null, null, null, null, null, null, 53739, 53740, 53741, 53742, 53743, 53744, 53745, 53746, 53747, 53749, 53750, 53751, 53753, 53754, 53755, 53756, 53757, 53758, 53759, 53760, 53761, 53762, 53763, 53764, 53765, 53766, null, null, null, null, null, null, 53768, 53770, 53771, 53772, 53773, 53774, 53775, 53777, 53778, 53779, 53780, 53781, 53782, 53783, 53784, 53785, 53786, 53787, 53788, 53789, 53790, 53791, 53792, 53793, 53794, 53795, 53796, 53797, 53798, 53799, 53800, 53801, 47467, 47469, 47476, 47477, 47480, 47484, 47492, 47493, 47495, 47497, 47498, 47501, 47502, 47532, 47533, 47536, 47540, 47548, 47549, 47551, 47553, 47560, 47561, 47564, 47566, 47567, 47568, 47569, 47570, 47576, 47577, 47579, 47581, 47582, 47585, 47587, 47588, 47589, 47592, 47596, 47604, 47605, 47607, 47608, 47609, 47610, 47616, 47617, 47624, 47637, 47672, 47673, 47676, 47680, 47682, 47688, 47689, 47691, 47693, 47694, 47699, 47700, 47701, 47704, 47708, 47716, 47717, 47719, 47720, 47721, 47728, 47729, 47732, 47736, 47747, 47748, 47749, 47751, 47756, 47784, 47785, 47787, 47788, 47792, 47794, 47800, 47801, 47803, 47805, 47812, 47816, 47832, 47833, 47868, 53802, 53803, 53806, 53807, 53809, 53810, 53811, 53813, 53814, 53815, 53816, 53817, 53818, 53819, 53822, 53824, 53826, 53827, 53828, 53829, 53830, 53831, 53833, 53834, 53835, 53836, null, null, null, null, null, null, 53837, 53838, 53839, 53840, 53841, 53842, 53843, 53844, 53845, 53846, 53847, 53848, 53849, 53850, 53851, 53853, 53854, 53855, 53856, 53857, 53858, 53859, 53861, 53862, 53863, 53864, null, null, null, null, null, null, 53865, 53866, 53867, 53868, 53869, 53870, 53871, 53872, 53873, 53874, 53875, 53876, 53877, 53878, 53879, 53880, 53881, 53882, 53883, 53884, 53885, 53886, 53887, 53890, 53891, 53893, 53894, 53895, 53897, 53898, 53899, 53900, 47872, 47876, 47885, 47887, 47889, 47896, 47900, 47904, 47913, 47915, 47924, 47925, 47926, 47928, 47931, 47932, 47933, 47934, 47940, 47941, 47943, 47945, 47949, 47951, 47952, 47956, 47960, 47969, 47971, 47980, 48008, 48012, 48016, 48036, 48040, 48044, 48052, 48055, 48064, 48068, 48072, 48080, 48083, 48120, 48121, 48124, 48127, 48128, 48130, 48136, 48137, 48139, 48140, 48141, 48143, 48145, 48148, 48149, 48150, 48151, 48152, 48155, 48156, 48157, 48158, 48159, 48164, 48165, 48167, 48169, 48173, 48176, 48177, 48180, 48184, 48192, 48193, 48195, 48196, 48197, 48201, 48204, 48205, 48208, 48221, 48260, 48261, 48264, 48267, 48268, 48270, 48276, 48277, 48279, 53901, 53902, 53903, 53906, 53907, 53908, 53910, 53911, 53912, 53913, 53914, 53915, 53917, 53918, 53919, 53921, 53922, 53923, 53925, 53926, 53927, 53928, 53929, 53930, 53931, 53933, null, null, null, null, null, null, 53934, 53935, 53936, 53938, 53939, 53940, 53941, 53942, 53943, 53946, 53947, 53949, 53950, 53953, 53955, 53956, 53957, 53958, 53959, 53962, 53964, 53965, 53966, 53967, 53968, 53969, null, null, null, null, null, null, 53970, 53971, 53973, 53974, 53975, 53977, 53978, 53979, 53981, 53982, 53983, 53984, 53985, 53986, 53987, 53990, 53991, 53992, 53993, 53994, 53995, 53996, 53997, 53998, 53999, 54002, 54003, 54005, 54006, 54007, 54009, 54010, 48281, 48282, 48288, 48289, 48292, 48295, 48296, 48304, 48305, 48307, 48308, 48309, 48316, 48317, 48320, 48324, 48333, 48335, 48336, 48337, 48341, 48344, 48348, 48372, 48373, 48374, 48376, 48380, 48388, 48389, 48391, 48393, 48400, 48404, 48420, 48428, 48448, 48456, 48457, 48460, 48464, 48472, 48473, 48484, 48488, 48512, 48513, 48516, 48519, 48520, 48521, 48522, 48528, 48529, 48531, 48533, 48537, 48538, 48540, 48548, 48560, 48568, 48596, 48597, 48600, 48604, 48617, 48624, 48628, 48632, 48640, 48643, 48645, 48652, 48653, 48656, 48660, 48668, 48669, 48671, 48708, 48709, 48712, 48716, 48718, 48724, 48725, 48727, 48729, 48730, 48731, 48736, 48737, 48740, 54011, 54012, 54013, 54014, 54015, 54018, 54020, 54022, 54023, 54024, 54025, 54026, 54027, 54031, 54033, 54034, 54035, 54037, 54039, 54040, 54041, 54042, 54043, 54046, 54050, 54051, null, null, null, null, null, null, 54052, 54054, 54055, 54058, 54059, 54061, 54062, 54063, 54065, 54066, 54067, 54068, 54069, 54070, 54071, 54074, 54078, 54079, 54080, 54081, 54082, 54083, 54086, 54087, 54088, 54089, null, null, null, null, null, null, 54090, 54091, 54092, 54093, 54094, 54095, 54096, 54097, 54098, 54099, 54100, 54101, 54102, 54103, 54104, 54105, 54106, 54107, 54108, 54109, 54110, 54111, 54112, 54113, 54114, 54115, 54116, 54117, 54118, 54119, 54120, 54121, 48744, 48746, 48752, 48753, 48755, 48756, 48757, 48763, 48764, 48765, 48768, 48772, 48780, 48781, 48783, 48784, 48785, 48792, 48793, 48808, 48848, 48849, 48852, 48855, 48856, 48864, 48867, 48868, 48869, 48876, 48897, 48904, 48905, 48920, 48921, 48923, 48924, 48925, 48960, 48961, 48964, 48968, 48976, 48977, 48981, 49044, 49072, 49093, 49100, 49101, 49104, 49108, 49116, 49119, 49121, 49212, 49233, 49240, 49244, 49248, 49256, 49257, 49296, 49297, 49300, 49304, 49312, 49313, 49315, 49317, 49324, 49325, 49327, 49328, 49331, 49332, 49333, 49334, 49340, 49341, 49343, 49344, 49345, 49349, 49352, 49353, 49356, 49360, 49368, 49369, 49371, 49372, 49373, 49380, 54122, 54123, 54124, 54125, 54126, 54127, 54128, 54129, 54130, 54131, 54132, 54133, 54134, 54135, 54136, 54137, 54138, 54139, 54142, 54143, 54145, 54146, 54147, 54149, 54150, 54151, null, null, null, null, null, null, 54152, 54153, 54154, 54155, 54158, 54162, 54163, 54164, 54165, 54166, 54167, 54170, 54171, 54173, 54174, 54175, 54177, 54178, 54179, 54180, 54181, 54182, 54183, 54186, 54188, 54190, null, null, null, null, null, null, 54191, 54192, 54193, 54194, 54195, 54197, 54198, 54199, 54201, 54202, 54203, 54205, 54206, 54207, 54208, 54209, 54210, 54211, 54214, 54215, 54218, 54219, 54220, 54221, 54222, 54223, 54225, 54226, 54227, 54228, 54229, 54230, 49381, 49384, 49388, 49396, 49397, 49399, 49401, 49408, 49412, 49416, 49424, 49429, 49436, 49437, 49438, 49439, 49440, 49443, 49444, 49446, 49447, 49452, 49453, 49455, 49456, 49457, 49462, 49464, 49465, 49468, 49472, 49480, 49481, 49483, 49484, 49485, 49492, 49493, 49496, 49500, 49508, 49509, 49511, 49512, 49513, 49520, 49524, 49528, 49541, 49548, 49549, 49550, 49552, 49556, 49558, 49564, 49565, 49567, 49569, 49573, 49576, 49577, 49580, 49584, 49597, 49604, 49608, 49612, 49620, 49623, 49624, 49632, 49636, 49640, 49648, 49649, 49651, 49660, 49661, 49664, 49668, 49676, 49677, 49679, 49681, 49688, 49689, 49692, 49695, 49696, 49704, 49705, 49707, 49709, 54231, 54233, 54234, 54235, 54236, 54237, 54238, 54239, 54240, 54242, 54244, 54245, 54246, 54247, 54248, 54249, 54250, 54251, 54254, 54255, 54257, 54258, 54259, 54261, 54262, 54263, null, null, null, null, null, null, 54264, 54265, 54266, 54267, 54270, 54272, 54274, 54275, 54276, 54277, 54278, 54279, 54281, 54282, 54283, 54284, 54285, 54286, 54287, 54288, 54289, 54290, 54291, 54292, 54293, 54294, null, null, null, null, null, null, 54295, 54296, 54297, 54298, 54299, 54300, 54302, 54303, 54304, 54305, 54306, 54307, 54308, 54309, 54310, 54311, 54312, 54313, 54314, 54315, 54316, 54317, 54318, 54319, 54320, 54321, 54322, 54323, 54324, 54325, 54326, 54327, 49711, 49713, 49714, 49716, 49736, 49744, 49745, 49748, 49752, 49760, 49765, 49772, 49773, 49776, 49780, 49788, 49789, 49791, 49793, 49800, 49801, 49808, 49816, 49819, 49821, 49828, 49829, 49832, 49836, 49837, 49844, 49845, 49847, 49849, 49884, 49885, 49888, 49891, 49892, 49899, 49900, 49901, 49903, 49905, 49910, 49912, 49913, 49915, 49916, 49920, 49928, 49929, 49932, 49933, 49939, 49940, 49941, 49944, 49948, 49956, 49957, 49960, 49961, 49989, 50024, 50025, 50028, 50032, 50034, 50040, 50041, 50044, 50045, 50052, 50056, 50060, 50112, 50136, 50137, 50140, 50143, 50144, 50146, 50152, 50153, 50157, 50164, 50165, 50168, 50184, 50192, 50212, 50220, 50224, 54328, 54329, 54330, 54331, 54332, 54333, 54334, 54335, 54337, 54338, 54339, 54341, 54342, 54343, 54344, 54345, 54346, 54347, 54348, 54349, 54350, 54351, 54352, 54353, 54354, 54355, null, null, null, null, null, null, 54356, 54357, 54358, 54359, 54360, 54361, 54362, 54363, 54365, 54366, 54367, 54369, 54370, 54371, 54373, 54374, 54375, 54376, 54377, 54378, 54379, 54380, 54382, 54384, 54385, 54386, null, null, null, null, null, null, 54387, 54388, 54389, 54390, 54391, 54394, 54395, 54397, 54398, 54401, 54403, 54404, 54405, 54406, 54407, 54410, 54412, 54414, 54415, 54416, 54417, 54418, 54419, 54421, 54422, 54423, 54424, 54425, 54426, 54427, 54428, 54429, 50228, 50236, 50237, 50248, 50276, 50277, 50280, 50284, 50292, 50293, 50297, 50304, 50324, 50332, 50360, 50364, 50409, 50416, 50417, 50420, 50424, 50426, 50431, 50432, 50433, 50444, 50448, 50452, 50460, 50472, 50473, 50476, 50480, 50488, 50489, 50491, 50493, 50500, 50501, 50504, 50505, 50506, 50508, 50509, 50510, 50515, 50516, 50517, 50519, 50520, 50521, 50525, 50526, 50528, 50529, 50532, 50536, 50544, 50545, 50547, 50548, 50549, 50556, 50557, 50560, 50564, 50567, 50572, 50573, 50575, 50577, 50581, 50583, 50584, 50588, 50592, 50601, 50612, 50613, 50616, 50617, 50619, 50620, 50621, 50622, 50628, 50629, 50630, 50631, 50632, 50633, 50634, 50636, 50638, 54430, 54431, 54432, 54433, 54434, 54435, 54436, 54437, 54438, 54439, 54440, 54442, 54443, 54444, 54445, 54446, 54447, 54448, 54449, 54450, 54451, 54452, 54453, 54454, 54455, 54456, null, null, null, null, null, null, 54457, 54458, 54459, 54460, 54461, 54462, 54463, 54464, 54465, 54466, 54467, 54468, 54469, 54470, 54471, 54472, 54473, 54474, 54475, 54477, 54478, 54479, 54481, 54482, 54483, 54485, null, null, null, null, null, null, 54486, 54487, 54488, 54489, 54490, 54491, 54493, 54494, 54496, 54497, 54498, 54499, 54500, 54501, 54502, 54503, 54505, 54506, 54507, 54509, 54510, 54511, 54513, 54514, 54515, 54516, 54517, 54518, 54519, 54521, 54522, 54524, 50640, 50641, 50644, 50648, 50656, 50657, 50659, 50661, 50668, 50669, 50670, 50672, 50676, 50678, 50679, 50684, 50685, 50686, 50687, 50688, 50689, 50693, 50694, 50695, 50696, 50700, 50704, 50712, 50713, 50715, 50716, 50724, 50725, 50728, 50732, 50733, 50734, 50736, 50739, 50740, 50741, 50743, 50745, 50747, 50752, 50753, 50756, 50760, 50768, 50769, 50771, 50772, 50773, 50780, 50781, 50784, 50796, 50799, 50801, 50808, 50809, 50812, 50816, 50824, 50825, 50827, 50829, 50836, 50837, 50840, 50844, 50852, 50853, 50855, 50857, 50864, 50865, 50868, 50872, 50873, 50874, 50880, 50881, 50883, 50885, 50892, 50893, 50896, 50900, 50908, 50909, 50912, 50913, 50920, 54526, 54527, 54528, 54529, 54530, 54531, 54533, 54534, 54535, 54537, 54538, 54539, 54541, 54542, 54543, 54544, 54545, 54546, 54547, 54550, 54552, 54553, 54554, 54555, 54556, 54557, null, null, null, null, null, null, 54558, 54559, 54560, 54561, 54562, 54563, 54564, 54565, 54566, 54567, 54568, 54569, 54570, 54571, 54572, 54573, 54574, 54575, 54576, 54577, 54578, 54579, 54580, 54581, 54582, 54583, null, null, null, null, null, null, 54584, 54585, 54586, 54587, 54590, 54591, 54593, 54594, 54595, 54597, 54598, 54599, 54600, 54601, 54602, 54603, 54606, 54608, 54610, 54611, 54612, 54613, 54614, 54615, 54618, 54619, 54621, 54622, 54623, 54625, 54626, 54627, 50921, 50924, 50928, 50936, 50937, 50941, 50948, 50949, 50952, 50956, 50964, 50965, 50967, 50969, 50976, 50977, 50980, 50984, 50992, 50993, 50995, 50997, 50999, 51004, 51005, 51008, 51012, 51018, 51020, 51021, 51023, 51025, 51026, 51027, 51028, 51029, 51030, 51031, 51032, 51036, 51040, 51048, 51051, 51060, 51061, 51064, 51068, 51069, 51070, 51075, 51076, 51077, 51079, 51080, 51081, 51082, 51086, 51088, 51089, 51092, 51094, 51095, 51096, 51098, 51104, 51105, 51107, 51108, 51109, 51110, 51116, 51117, 51120, 51124, 51132, 51133, 51135, 51136, 51137, 51144, 51145, 51148, 51150, 51152, 51160, 51165, 51172, 51176, 51180, 51200, 51201, 51204, 51208, 51210, 54628, 54630, 54631, 54634, 54636, 54638, 54639, 54640, 54641, 54642, 54643, 54646, 54647, 54649, 54650, 54651, 54653, 54654, 54655, 54656, 54657, 54658, 54659, 54662, 54666, 54667, null, null, null, null, null, null, 54668, 54669, 54670, 54671, 54673, 54674, 54675, 54676, 54677, 54678, 54679, 54680, 54681, 54682, 54683, 54684, 54685, 54686, 54687, 54688, 54689, 54690, 54691, 54692, 54694, 54695, null, null, null, null, null, null, 54696, 54697, 54698, 54699, 54700, 54701, 54702, 54703, 54704, 54705, 54706, 54707, 54708, 54709, 54710, 54711, 54712, 54713, 54714, 54715, 54716, 54717, 54718, 54719, 54720, 54721, 54722, 54723, 54724, 54725, 54726, 54727, 51216, 51217, 51219, 51221, 51222, 51228, 51229, 51232, 51236, 51244, 51245, 51247, 51249, 51256, 51260, 51264, 51272, 51273, 51276, 51277, 51284, 51312, 51313, 51316, 51320, 51322, 51328, 51329, 51331, 51333, 51334, 51335, 51339, 51340, 51341, 51348, 51357, 51359, 51361, 51368, 51388, 51389, 51396, 51400, 51404, 51412, 51413, 51415, 51417, 51424, 51425, 51428, 51445, 51452, 51453, 51456, 51460, 51461, 51462, 51468, 51469, 51471, 51473, 51480, 51500, 51508, 51536, 51537, 51540, 51544, 51552, 51553, 51555, 51564, 51568, 51572, 51580, 51592, 51593, 51596, 51600, 51608, 51609, 51611, 51613, 51648, 51649, 51652, 51655, 51656, 51658, 51664, 51665, 51667, 54730, 54731, 54733, 54734, 54735, 54737, 54739, 54740, 54741, 54742, 54743, 54746, 54748, 54750, 54751, 54752, 54753, 54754, 54755, 54758, 54759, 54761, 54762, 54763, 54765, 54766, null, null, null, null, null, null, 54767, 54768, 54769, 54770, 54771, 54774, 54776, 54778, 54779, 54780, 54781, 54782, 54783, 54786, 54787, 54789, 54790, 54791, 54793, 54794, 54795, 54796, 54797, 54798, 54799, 54802, null, null, null, null, null, null, 54806, 54807, 54808, 54809, 54810, 54811, 54813, 54814, 54815, 54817, 54818, 54819, 54821, 54822, 54823, 54824, 54825, 54826, 54827, 54828, 54830, 54831, 54832, 54833, 54834, 54835, 54836, 54837, 54838, 54839, 54842, 54843, 51669, 51670, 51673, 51674, 51676, 51677, 51680, 51682, 51684, 51687, 51692, 51693, 51695, 51696, 51697, 51704, 51705, 51708, 51712, 51720, 51721, 51723, 51724, 51725, 51732, 51736, 51753, 51788, 51789, 51792, 51796, 51804, 51805, 51807, 51808, 51809, 51816, 51837, 51844, 51864, 51900, 51901, 51904, 51908, 51916, 51917, 51919, 51921, 51923, 51928, 51929, 51936, 51948, 51956, 51976, 51984, 51988, 51992, 52e3, 52001, 52033, 52040, 52041, 52044, 52048, 52056, 52057, 52061, 52068, 52088, 52089, 52124, 52152, 52180, 52196, 52199, 52201, 52236, 52237, 52240, 52244, 52252, 52253, 52257, 52258, 52263, 52264, 52265, 52268, 52270, 52272, 52280, 52281, 52283, 54845, 54846, 54847, 54849, 54850, 54851, 54852, 54854, 54855, 54858, 54860, 54862, 54863, 54864, 54866, 54867, 54870, 54871, 54873, 54874, 54875, 54877, 54878, 54879, 54880, 54881, null, null, null, null, null, null, 54882, 54883, 54884, 54885, 54886, 54888, 54890, 54891, 54892, 54893, 54894, 54895, 54898, 54899, 54901, 54902, 54903, 54904, 54905, 54906, 54907, 54908, 54909, 54910, 54911, 54912, null, null, null, null, null, null, 54913, 54914, 54916, 54918, 54919, 54920, 54921, 54922, 54923, 54926, 54927, 54929, 54930, 54931, 54933, 54934, 54935, 54936, 54937, 54938, 54939, 54940, 54942, 54944, 54946, 54947, 54948, 54949, 54950, 54951, 54953, 54954, 52284, 52285, 52286, 52292, 52293, 52296, 52300, 52308, 52309, 52311, 52312, 52313, 52320, 52324, 52326, 52328, 52336, 52341, 52376, 52377, 52380, 52384, 52392, 52393, 52395, 52396, 52397, 52404, 52405, 52408, 52412, 52420, 52421, 52423, 52425, 52432, 52436, 52452, 52460, 52464, 52481, 52488, 52489, 52492, 52496, 52504, 52505, 52507, 52509, 52516, 52520, 52524, 52537, 52572, 52576, 52580, 52588, 52589, 52591, 52593, 52600, 52616, 52628, 52629, 52632, 52636, 52644, 52645, 52647, 52649, 52656, 52676, 52684, 52688, 52712, 52716, 52720, 52728, 52729, 52731, 52733, 52740, 52744, 52748, 52756, 52761, 52768, 52769, 52772, 52776, 52784, 52785, 52787, 52789, 54955, 54957, 54958, 54959, 54961, 54962, 54963, 54964, 54965, 54966, 54967, 54968, 54970, 54972, 54973, 54974, 54975, 54976, 54977, 54978, 54979, 54982, 54983, 54985, 54986, 54987, null, null, null, null, null, null, 54989, 54990, 54991, 54992, 54994, 54995, 54997, 54998, 55e3, 55002, 55003, 55004, 55005, 55006, 55007, 55009, 55010, 55011, 55013, 55014, 55015, 55017, 55018, 55019, 55020, 55021, null, null, null, null, null, null, 55022, 55023, 55025, 55026, 55027, 55028, 55030, 55031, 55032, 55033, 55034, 55035, 55038, 55039, 55041, 55042, 55043, 55045, 55046, 55047, 55048, 55049, 55050, 55051, 55052, 55053, 55054, 55055, 55056, 55058, 55059, 55060, 52824, 52825, 52828, 52831, 52832, 52833, 52840, 52841, 52843, 52845, 52852, 52853, 52856, 52860, 52868, 52869, 52871, 52873, 52880, 52881, 52884, 52888, 52896, 52897, 52899, 52900, 52901, 52908, 52909, 52929, 52964, 52965, 52968, 52971, 52972, 52980, 52981, 52983, 52984, 52985, 52992, 52993, 52996, 53e3, 53008, 53009, 53011, 53013, 53020, 53024, 53028, 53036, 53037, 53039, 53040, 53041, 53048, 53076, 53077, 53080, 53084, 53092, 53093, 53095, 53097, 53104, 53105, 53108, 53112, 53120, 53125, 53132, 53153, 53160, 53168, 53188, 53216, 53217, 53220, 53224, 53232, 53233, 53235, 53237, 53244, 53248, 53252, 53265, 53272, 53293, 53300, 53301, 53304, 53308, 55061, 55062, 55063, 55066, 55067, 55069, 55070, 55071, 55073, 55074, 55075, 55076, 55077, 55078, 55079, 55082, 55084, 55086, 55087, 55088, 55089, 55090, 55091, 55094, 55095, 55097, null, null, null, null, null, null, 55098, 55099, 55101, 55102, 55103, 55104, 55105, 55106, 55107, 55109, 55110, 55112, 55114, 55115, 55116, 55117, 55118, 55119, 55122, 55123, 55125, 55130, 55131, 55132, 55133, 55134, null, null, null, null, null, null, 55135, 55138, 55140, 55142, 55143, 55144, 55146, 55147, 55149, 55150, 55151, 55153, 55154, 55155, 55157, 55158, 55159, 55160, 55161, 55162, 55163, 55166, 55167, 55168, 55170, 55171, 55172, 55173, 55174, 55175, 55178, 55179, 53316, 53317, 53319, 53321, 53328, 53332, 53336, 53344, 53356, 53357, 53360, 53364, 53372, 53373, 53377, 53412, 53413, 53416, 53420, 53428, 53429, 53431, 53433, 53440, 53441, 53444, 53448, 53449, 53456, 53457, 53459, 53460, 53461, 53468, 53469, 53472, 53476, 53484, 53485, 53487, 53488, 53489, 53496, 53517, 53552, 53553, 53556, 53560, 53562, 53568, 53569, 53571, 53572, 53573, 53580, 53581, 53584, 53588, 53596, 53597, 53599, 53601, 53608, 53612, 53628, 53636, 53640, 53664, 53665, 53668, 53672, 53680, 53681, 53683, 53685, 53690, 53692, 53696, 53720, 53748, 53752, 53767, 53769, 53776, 53804, 53805, 53808, 53812, 53820, 53821, 53823, 53825, 53832, 53852, 55181, 55182, 55183, 55185, 55186, 55187, 55188, 55189, 55190, 55191, 55194, 55196, 55198, 55199, 55200, 55201, 55202, 55203, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 53860, 53888, 53889, 53892, 53896, 53904, 53905, 53909, 53916, 53920, 53924, 53932, 53937, 53944, 53945, 53948, 53951, 53952, 53954, 53960, 53961, 53963, 53972, 53976, 53980, 53988, 53989, 54e3, 54001, 54004, 54008, 54016, 54017, 54019, 54021, 54028, 54029, 54030, 54032, 54036, 54038, 54044, 54045, 54047, 54048, 54049, 54053, 54056, 54057, 54060, 54064, 54072, 54073, 54075, 54076, 54077, 54084, 54085, 54140, 54141, 54144, 54148, 54156, 54157, 54159, 54160, 54161, 54168, 54169, 54172, 54176, 54184, 54185, 54187, 54189, 54196, 54200, 54204, 54212, 54213, 54216, 54217, 54224, 54232, 54241, 54243, 54252, 54253, 54256, 54260, 54268, 54269, 54271, 54273, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 54280, 54301, 54336, 54340, 54364, 54368, 54372, 54381, 54383, 54392, 54393, 54396, 54399, 54400, 54402, 54408, 54409, 54411, 54413, 54420, 54441, 54476, 54480, 54484, 54492, 54495, 54504, 54508, 54512, 54520, 54523, 54525, 54532, 54536, 54540, 54548, 54549, 54551, 54588, 54589, 54592, 54596, 54604, 54605, 54607, 54609, 54616, 54617, 54620, 54624, 54629, 54632, 54633, 54635, 54637, 54644, 54645, 54648, 54652, 54660, 54661, 54663, 54664, 54665, 54672, 54693, 54728, 54729, 54732, 54736, 54738, 54744, 54745, 54747, 54749, 54756, 54757, 54760, 54764, 54772, 54773, 54775, 54777, 54784, 54785, 54788, 54792, 54800, 54801, 54803, 54804, 54805, 54812, 54816, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 54820, 54829, 54840, 54841, 54844, 54848, 54853, 54856, 54857, 54859, 54861, 54865, 54868, 54869, 54872, 54876, 54887, 54889, 54896, 54897, 54900, 54915, 54917, 54924, 54925, 54928, 54932, 54941, 54943, 54945, 54952, 54956, 54960, 54969, 54971, 54980, 54981, 54984, 54988, 54993, 54996, 54999, 55001, 55008, 55012, 55016, 55024, 55029, 55036, 55037, 55040, 55044, 55057, 55064, 55065, 55068, 55072, 55080, 55081, 55083, 55085, 55092, 55093, 55096, 55100, 55108, 55111, 55113, 55120, 55121, 55124, 55126, 55127, 55128, 55129, 55136, 55137, 55139, 55141, 55145, 55148, 55152, 55156, 55164, 55165, 55169, 55176, 55177, 55180, 55184, 55192, 55193, 55195, 55197, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20285, 20339, 20551, 20729, 21152, 21487, 21621, 21733, 22025, 23233, 23478, 26247, 26550, 26551, 26607, 27468, 29634, 30146, 31292, 33499, 33540, 34903, 34952, 35382, 36040, 36303, 36603, 36838, 39381, 21051, 21364, 21508, 24682, 24932, 27580, 29647, 33050, 35258, 35282, 38307, 20355, 21002, 22718, 22904, 23014, 24178, 24185, 25031, 25536, 26438, 26604, 26751, 28567, 30286, 30475, 30965, 31240, 31487, 31777, 32925, 33390, 33393, 35563, 38291, 20075, 21917, 26359, 28212, 30883, 31469, 33883, 35088, 34638, 38824, 21208, 22350, 22570, 23884, 24863, 25022, 25121, 25954, 26577, 27204, 28187, 29976, 30131, 30435, 30640, 32058, 37039, 37969, 37970, 40853, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21283, 23724, 30002, 32987, 37440, 38296, 21083, 22536, 23004, 23713, 23831, 24247, 24378, 24394, 24951, 27743, 30074, 30086, 31968, 32115, 32177, 32652, 33108, 33313, 34193, 35137, 35611, 37628, 38477, 40007, 20171, 20215, 20491, 20977, 22607, 24887, 24894, 24936, 25913, 27114, 28433, 30117, 30342, 30422, 31623, 33445, 33995, 63744, 37799, 38283, 21888, 23458, 22353, 63745, 31923, 32697, 37301, 20520, 21435, 23621, 24040, 25298, 25454, 25818, 25831, 28192, 28844, 31067, 36317, 36382, 63746, 36989, 37445, 37624, 20094, 20214, 20581, 24062, 24314, 24838, 26967, 33137, 34388, 36423, 37749, 39467, 20062, 20625, 26480, 26688, 20745, 21133, 21138, 27298, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 30652, 37392, 40660, 21163, 24623, 36850, 20552, 25001, 25581, 25802, 26684, 27268, 28608, 33160, 35233, 38548, 22533, 29309, 29356, 29956, 32121, 32365, 32937, 35211, 35700, 36963, 40273, 25225, 27770, 28500, 32080, 32570, 35363, 20860, 24906, 31645, 35609, 37463, 37772, 20140, 20435, 20510, 20670, 20742, 21185, 21197, 21375, 22384, 22659, 24218, 24465, 24950, 25004, 25806, 25964, 26223, 26299, 26356, 26775, 28039, 28805, 28913, 29855, 29861, 29898, 30169, 30828, 30956, 31455, 31478, 32069, 32147, 32789, 32831, 33051, 33686, 35686, 36629, 36885, 37857, 38915, 38968, 39514, 39912, 20418, 21843, 22586, 22865, 23395, 23622, 24760, 25106, 26690, 26800, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26856, 28330, 30028, 30328, 30926, 31293, 31995, 32363, 32380, 35336, 35489, 35903, 38542, 40388, 21476, 21481, 21578, 21617, 22266, 22993, 23396, 23611, 24235, 25335, 25911, 25925, 25970, 26272, 26543, 27073, 27837, 30204, 30352, 30590, 31295, 32660, 32771, 32929, 33167, 33510, 33533, 33776, 34241, 34865, 34996, 35493, 63747, 36764, 37678, 38599, 39015, 39640, 40723, 21741, 26011, 26354, 26767, 31296, 35895, 40288, 22256, 22372, 23825, 26118, 26801, 26829, 28414, 29736, 34974, 39908, 27752, 63748, 39592, 20379, 20844, 20849, 21151, 23380, 24037, 24656, 24685, 25329, 25511, 25915, 29657, 31354, 34467, 36002, 38799, 20018, 23521, 25096, 26524, 29916, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31185, 33747, 35463, 35506, 36328, 36942, 37707, 38982, 24275, 27112, 34303, 37101, 63749, 20896, 23448, 23532, 24931, 26874, 27454, 28748, 29743, 29912, 31649, 32592, 33733, 35264, 36011, 38364, 39208, 21038, 24669, 25324, 36866, 20362, 20809, 21281, 22745, 24291, 26336, 27960, 28826, 29378, 29654, 31568, 33009, 37979, 21350, 25499, 32619, 20054, 20608, 22602, 22750, 24618, 24871, 25296, 27088, 39745, 23439, 32024, 32945, 36703, 20132, 20689, 21676, 21932, 23308, 23968, 24039, 25898, 25934, 26657, 27211, 29409, 30350, 30703, 32094, 32761, 33184, 34126, 34527, 36611, 36686, 37066, 39171, 39509, 39851, 19992, 20037, 20061, 20167, 20465, 20855, 21246, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21312, 21475, 21477, 21646, 22036, 22389, 22434, 23495, 23943, 24272, 25084, 25304, 25937, 26552, 26601, 27083, 27472, 27590, 27628, 27714, 28317, 28792, 29399, 29590, 29699, 30655, 30697, 31350, 32127, 32777, 33276, 33285, 33290, 33503, 34914, 35635, 36092, 36544, 36881, 37041, 37476, 37558, 39378, 39493, 40169, 40407, 40860, 22283, 23616, 33738, 38816, 38827, 40628, 21531, 31384, 32676, 35033, 36557, 37089, 22528, 23624, 25496, 31391, 23470, 24339, 31353, 31406, 33422, 36524, 20518, 21048, 21240, 21367, 22280, 25331, 25458, 27402, 28099, 30519, 21413, 29527, 34152, 36470, 38357, 26426, 27331, 28528, 35437, 36556, 39243, 63750, 26231, 27512, 36020, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 39740, 63751, 21483, 22317, 22862, 25542, 27131, 29674, 30789, 31418, 31429, 31998, 33909, 35215, 36211, 36917, 38312, 21243, 22343, 30023, 31584, 33740, 37406, 63752, 27224, 20811, 21067, 21127, 25119, 26840, 26997, 38553, 20677, 21156, 21220, 25027, 26020, 26681, 27135, 29822, 31563, 33465, 33771, 35250, 35641, 36817, 39241, 63753, 20170, 22935, 25810, 26129, 27278, 29748, 31105, 31165, 33449, 34942, 34943, 35167, 63754, 37670, 20235, 21450, 24613, 25201, 27762, 32026, 32102, 20120, 20834, 30684, 32943, 20225, 20238, 20854, 20864, 21980, 22120, 22331, 22522, 22524, 22804, 22855, 22931, 23492, 23696, 23822, 24049, 24190, 24524, 25216, 26071, 26083, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26398, 26399, 26462, 26827, 26820, 27231, 27450, 27683, 27773, 27778, 28103, 29592, 29734, 29738, 29826, 29859, 30072, 30079, 30849, 30959, 31041, 31047, 31048, 31098, 31637, 32e3, 32186, 32648, 32774, 32813, 32908, 35352, 35663, 35912, 36215, 37665, 37668, 39138, 39249, 39438, 39439, 39525, 40594, 32202, 20342, 21513, 25326, 26708, 37329, 21931, 20794, 63755, 63756, 23068, 25062, 63757, 25295, 25343, 63758, 63759, 63760, 63761, 63762, 63763, 37027, 63764, 63765, 63766, 63767, 63768, 35582, 63769, 63770, 63771, 63772, 26262, 63773, 29014, 63774, 63775, 38627, 63776, 25423, 25466, 21335, 63777, 26511, 26976, 28275, 63778, 30007, 63779, 63780, 63781, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32013, 63782, 63783, 34930, 22218, 23064, 63784, 63785, 63786, 63787, 63788, 20035, 63789, 20839, 22856, 26608, 32784, 63790, 22899, 24180, 25754, 31178, 24565, 24684, 25288, 25467, 23527, 23511, 21162, 63791, 22900, 24361, 24594, 63792, 63793, 63794, 29785, 63795, 63796, 63797, 63798, 63799, 63800, 39377, 63801, 63802, 63803, 63804, 63805, 63806, 63807, 63808, 63809, 63810, 63811, 28611, 63812, 63813, 33215, 36786, 24817, 63814, 63815, 33126, 63816, 63817, 23615, 63818, 63819, 63820, 63821, 63822, 63823, 63824, 63825, 23273, 35365, 26491, 32016, 63826, 63827, 63828, 63829, 63830, 63831, 33021, 63832, 63833, 23612, 27877, 21311, 28346, 22810, 33590, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20025, 20150, 20294, 21934, 22296, 22727, 24406, 26039, 26086, 27264, 27573, 28237, 30701, 31471, 31774, 32222, 34507, 34962, 37170, 37723, 25787, 28606, 29562, 30136, 36948, 21846, 22349, 25018, 25812, 26311, 28129, 28251, 28525, 28601, 30192, 32835, 33213, 34113, 35203, 35527, 35674, 37663, 27795, 30035, 31572, 36367, 36957, 21776, 22530, 22616, 24162, 25095, 25758, 26848, 30070, 31958, 34739, 40680, 20195, 22408, 22382, 22823, 23565, 23729, 24118, 24453, 25140, 25825, 29619, 33274, 34955, 36024, 38538, 40667, 23429, 24503, 24755, 20498, 20992, 21040, 22294, 22581, 22615, 23566, 23648, 23798, 23947, 24230, 24466, 24764, 25361, 25481, 25623, 26691, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26873, 27330, 28120, 28193, 28372, 28644, 29182, 30428, 30585, 31153, 31291, 33796, 35241, 36077, 36339, 36424, 36867, 36884, 36947, 37117, 37709, 38518, 38876, 27602, 28678, 29272, 29346, 29544, 30563, 31167, 31716, 32411, 35712, 22697, 24775, 25958, 26109, 26302, 27788, 28958, 29129, 35930, 38931, 20077, 31361, 20189, 20908, 20941, 21205, 21516, 24999, 26481, 26704, 26847, 27934, 28540, 30140, 30643, 31461, 33012, 33891, 37509, 20828, 26007, 26460, 26515, 30168, 31431, 33651, 63834, 35910, 36887, 38957, 23663, 33216, 33434, 36929, 36975, 37389, 24471, 23965, 27225, 29128, 30331, 31561, 34276, 35588, 37159, 39472, 21895, 25078, 63835, 30313, 32645, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 34367, 34746, 35064, 37007, 63836, 27931, 28889, 29662, 32097, 33853, 63837, 37226, 39409, 63838, 20098, 21365, 27396, 27410, 28734, 29211, 34349, 40478, 21068, 36771, 23888, 25829, 25900, 27414, 28651, 31811, 32412, 34253, 35172, 35261, 25289, 33240, 34847, 24266, 26391, 28010, 29436, 29701, 29807, 34690, 37086, 20358, 23821, 24480, 33802, 20919, 25504, 30053, 20142, 20486, 20841, 20937, 26753, 27153, 31918, 31921, 31975, 33391, 35538, 36635, 37327, 20406, 20791, 21237, 21570, 24300, 24942, 25150, 26053, 27354, 28670, 31018, 34268, 34851, 38317, 39522, 39530, 40599, 40654, 21147, 26310, 27511, 28701, 31019, 36706, 38722, 24976, 25088, 25891, 28451, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 29001, 29833, 32244, 32879, 34030, 36646, 36899, 37706, 20925, 21015, 21155, 27916, 28872, 35010, 24265, 25986, 27566, 28610, 31806, 29557, 20196, 20278, 22265, 63839, 23738, 23994, 24604, 29618, 31533, 32666, 32718, 32838, 36894, 37428, 38646, 38728, 38936, 40801, 20363, 28583, 31150, 37300, 38583, 21214, 63840, 25736, 25796, 27347, 28510, 28696, 29200, 30439, 32769, 34310, 34396, 36335, 36613, 38706, 39791, 40442, 40565, 30860, 31103, 32160, 33737, 37636, 40575, 40595, 35542, 22751, 24324, 26407, 28711, 29903, 31840, 32894, 20769, 28712, 29282, 30922, 36034, 36058, 36084, 38647, 20102, 20698, 23534, 24278, 26009, 29134, 30274, 30637, 32842, 34044, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36988, 39719, 40845, 22744, 23105, 23650, 27155, 28122, 28431, 30267, 32047, 32311, 34078, 35128, 37860, 38475, 21129, 26066, 26611, 27060, 27969, 28316, 28687, 29705, 29792, 30041, 30244, 30827, 35628, 39006, 20845, 25134, 38520, 20374, 20523, 23833, 28138, 32184, 36650, 24459, 24900, 26647, 63841, 38534, 21202, 32907, 20956, 20940, 26974, 31260, 32190, 33777, 38517, 20442, 21033, 21400, 21519, 21774, 23653, 24743, 26446, 26792, 28012, 29313, 29432, 29702, 29827, 63842, 30178, 31852, 32633, 32696, 33673, 35023, 35041, 37324, 37328, 38626, 39881, 21533, 28542, 29136, 29848, 34298, 36522, 38563, 40023, 40607, 26519, 28107, 29747, 33256, 38678, 30764, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31435, 31520, 31890, 25705, 29802, 30194, 30908, 30952, 39340, 39764, 40635, 23518, 24149, 28448, 33180, 33707, 37e3, 19975, 21325, 23081, 24018, 24398, 24930, 25405, 26217, 26364, 28415, 28459, 28771, 30622, 33836, 34067, 34875, 36627, 39237, 39995, 21788, 25273, 26411, 27819, 33545, 35178, 38778, 20129, 22916, 24536, 24537, 26395, 32178, 32596, 33426, 33579, 33725, 36638, 37017, 22475, 22969, 23186, 23504, 26151, 26522, 26757, 27599, 29028, 32629, 36023, 36067, 36993, 39749, 33032, 35978, 38476, 39488, 40613, 23391, 27667, 29467, 30450, 30431, 33804, 20906, 35219, 20813, 20885, 21193, 26825, 27796, 30468, 30496, 32191, 32236, 38754, 40629, 28357, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 34065, 20901, 21517, 21629, 26126, 26269, 26919, 28319, 30399, 30609, 33559, 33986, 34719, 37225, 37528, 40180, 34946, 20398, 20882, 21215, 22982, 24125, 24917, 25720, 25721, 26286, 26576, 27169, 27597, 27611, 29279, 29281, 29761, 30520, 30683, 32791, 33468, 33541, 35584, 35624, 35980, 26408, 27792, 29287, 30446, 30566, 31302, 40361, 27519, 27794, 22818, 26406, 33945, 21359, 22675, 22937, 24287, 25551, 26164, 26483, 28218, 29483, 31447, 33495, 37672, 21209, 24043, 25006, 25035, 25098, 25287, 25771, 26080, 26969, 27494, 27595, 28961, 29687, 30045, 32326, 33310, 33538, 34154, 35491, 36031, 38695, 40289, 22696, 40664, 20497, 21006, 21563, 21839, 25991, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 27766, 32010, 32011, 32862, 34442, 38272, 38639, 21247, 27797, 29289, 21619, 23194, 23614, 23883, 24396, 24494, 26410, 26806, 26979, 28220, 28228, 30473, 31859, 32654, 34183, 35598, 36855, 38753, 40692, 23735, 24758, 24845, 25003, 25935, 26107, 26108, 27665, 27887, 29599, 29641, 32225, 38292, 23494, 34588, 35600, 21085, 21338, 25293, 25615, 25778, 26420, 27192, 27850, 29632, 29854, 31636, 31893, 32283, 33162, 33334, 34180, 36843, 38649, 39361, 20276, 21322, 21453, 21467, 25292, 25644, 25856, 26001, 27075, 27886, 28504, 29677, 30036, 30242, 30436, 30460, 30928, 30971, 31020, 32070, 33324, 34784, 36820, 38930, 39151, 21187, 25300, 25765, 28196, 28497, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 30332, 36299, 37297, 37474, 39662, 39747, 20515, 20621, 22346, 22952, 23592, 24135, 24439, 25151, 25918, 26041, 26049, 26121, 26507, 27036, 28354, 30917, 32033, 32938, 33152, 33323, 33459, 33953, 34444, 35370, 35607, 37030, 38450, 40848, 20493, 20467, 63843, 22521, 24472, 25308, 25490, 26479, 28227, 28953, 30403, 32972, 32986, 35060, 35061, 35097, 36064, 36649, 37197, 38506, 20271, 20336, 24091, 26575, 26658, 30333, 30334, 39748, 24161, 27146, 29033, 29140, 30058, 63844, 32321, 34115, 34281, 39132, 20240, 31567, 32624, 38309, 20961, 24070, 26805, 27710, 27726, 27867, 29359, 31684, 33539, 27861, 29754, 20731, 21128, 22721, 25816, 27287, 29863, 30294, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 30887, 34327, 38370, 38713, 63845, 21342, 24321, 35722, 36776, 36783, 37002, 21029, 30629, 40009, 40712, 19993, 20482, 20853, 23643, 24183, 26142, 26170, 26564, 26821, 28851, 29953, 30149, 31177, 31453, 36647, 39200, 39432, 20445, 22561, 22577, 23542, 26222, 27493, 27921, 28282, 28541, 29668, 29995, 33769, 35036, 35091, 35676, 36628, 20239, 20693, 21264, 21340, 23443, 24489, 26381, 31119, 33145, 33583, 34068, 35079, 35206, 36665, 36667, 39333, 39954, 26412, 20086, 20472, 22857, 23553, 23791, 23792, 25447, 26834, 28925, 29090, 29739, 32299, 34028, 34562, 36898, 37586, 40179, 19981, 20184, 20463, 20613, 21078, 21103, 21542, 21648, 22496, 22827, 23142, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 23386, 23413, 23500, 24220, 63846, 25206, 25975, 26023, 28014, 28325, 29238, 31526, 31807, 32566, 33104, 33105, 33178, 33344, 33433, 33705, 35331, 36e3, 36070, 36091, 36212, 36282, 37096, 37340, 38428, 38468, 39385, 40167, 21271, 20998, 21545, 22132, 22707, 22868, 22894, 24575, 24996, 25198, 26128, 27774, 28954, 30406, 31881, 31966, 32027, 33452, 36033, 38640, 63847, 20315, 24343, 24447, 25282, 23849, 26379, 26842, 30844, 32323, 40300, 19989, 20633, 21269, 21290, 21329, 22915, 23138, 24199, 24754, 24970, 25161, 25209, 26e3, 26503, 27047, 27604, 27606, 27607, 27608, 27832, 63848, 29749, 30202, 30738, 30865, 31189, 31192, 31875, 32203, 32737, 32933, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 33086, 33218, 33778, 34586, 35048, 35513, 35692, 36027, 37145, 38750, 39131, 40763, 22188, 23338, 24428, 25996, 27315, 27567, 27996, 28657, 28693, 29277, 29613, 36007, 36051, 38971, 24977, 27703, 32856, 39425, 20045, 20107, 20123, 20181, 20282, 20284, 20351, 20447, 20735, 21490, 21496, 21766, 21987, 22235, 22763, 22882, 23057, 23531, 23546, 23556, 24051, 24107, 24473, 24605, 25448, 26012, 26031, 26614, 26619, 26797, 27515, 27801, 27863, 28195, 28681, 29509, 30722, 31038, 31040, 31072, 31169, 31721, 32023, 32114, 32902, 33293, 33678, 34001, 34503, 35039, 35408, 35422, 35613, 36060, 36198, 36781, 37034, 39164, 39391, 40605, 21066, 63849, 26388, 63850, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20632, 21034, 23665, 25955, 27733, 29642, 29987, 30109, 31639, 33948, 37240, 38704, 20087, 25746, 27578, 29022, 34217, 19977, 63851, 26441, 26862, 28183, 33439, 34072, 34923, 25591, 28545, 37394, 39087, 19978, 20663, 20687, 20767, 21830, 21930, 22039, 23360, 23577, 23776, 24120, 24202, 24224, 24258, 24819, 26705, 27233, 28248, 29245, 29248, 29376, 30456, 31077, 31665, 32724, 35059, 35316, 35443, 35937, 36062, 38684, 22622, 29885, 36093, 21959, 63852, 31329, 32034, 33394, 29298, 29983, 29989, 63853, 31513, 22661, 22779, 23996, 24207, 24246, 24464, 24661, 25234, 25471, 25933, 26257, 26329, 26360, 26646, 26866, 29312, 29790, 31598, 32110, 32214, 32626, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32997, 33298, 34223, 35199, 35475, 36893, 37604, 40653, 40736, 22805, 22893, 24109, 24796, 26132, 26227, 26512, 27728, 28101, 28511, 30707, 30889, 33990, 37323, 37675, 20185, 20682, 20808, 21892, 23307, 23459, 25159, 25982, 26059, 28210, 29053, 29697, 29764, 29831, 29887, 30316, 31146, 32218, 32341, 32680, 33146, 33203, 33337, 34330, 34796, 35445, 36323, 36984, 37521, 37925, 39245, 39854, 21352, 23633, 26964, 27844, 27945, 28203, 33292, 34203, 35131, 35373, 35498, 38634, 40807, 21089, 26297, 27570, 32406, 34814, 36109, 38275, 38493, 25885, 28041, 29166, 63854, 22478, 22995, 23468, 24615, 24826, 25104, 26143, 26207, 29481, 29689, 30427, 30465, 31596, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32854, 32882, 33125, 35488, 37266, 19990, 21218, 27506, 27927, 31237, 31545, 32048, 63855, 36016, 21484, 22063, 22609, 23477, 23567, 23569, 24034, 25152, 25475, 25620, 26157, 26803, 27836, 28040, 28335, 28703, 28836, 29138, 29990, 30095, 30094, 30233, 31505, 31712, 31787, 32032, 32057, 34092, 34157, 34311, 35380, 36877, 36961, 37045, 37559, 38902, 39479, 20439, 23660, 26463, 28049, 31903, 32396, 35606, 36118, 36895, 23403, 24061, 25613, 33984, 36956, 39137, 29575, 23435, 24730, 26494, 28126, 35359, 35494, 36865, 38924, 21047, 63856, 28753, 30862, 37782, 34928, 37335, 20462, 21463, 22013, 22234, 22402, 22781, 23234, 23432, 23723, 23744, 24101, 24833, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 25101, 25163, 25480, 25628, 25910, 25976, 27193, 27530, 27700, 27929, 28465, 29159, 29417, 29560, 29703, 29874, 30246, 30561, 31168, 31319, 31466, 31929, 32143, 32172, 32353, 32670, 33065, 33585, 33936, 34010, 34282, 34966, 35504, 35728, 36664, 36930, 36995, 37228, 37526, 37561, 38539, 38567, 38568, 38614, 38656, 38920, 39318, 39635, 39706, 21460, 22654, 22809, 23408, 23487, 28113, 28506, 29087, 29729, 29881, 32901, 33789, 24033, 24455, 24490, 24642, 26092, 26642, 26991, 27219, 27529, 27957, 28147, 29667, 30462, 30636, 31565, 32020, 33059, 33308, 33600, 34036, 34147, 35426, 35524, 37255, 37662, 38918, 39348, 25100, 34899, 36848, 37477, 23815, 23847, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 23913, 29791, 33181, 34664, 28629, 25342, 32722, 35126, 35186, 19998, 20056, 20711, 21213, 21319, 25215, 26119, 32361, 34821, 38494, 20365, 21273, 22070, 22987, 23204, 23608, 23630, 23629, 24066, 24337, 24643, 26045, 26159, 26178, 26558, 26612, 29468, 30690, 31034, 32709, 33940, 33997, 35222, 35430, 35433, 35553, 35925, 35962, 22516, 23508, 24335, 24687, 25325, 26893, 27542, 28252, 29060, 31698, 34645, 35672, 36606, 39135, 39166, 20280, 20353, 20449, 21627, 23072, 23480, 24892, 26032, 26216, 29180, 30003, 31070, 32051, 33102, 33251, 33688, 34218, 34254, 34563, 35338, 36523, 36763, 63857, 36805, 22833, 23460, 23526, 24713, 23529, 23563, 24515, 27777, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63858, 28145, 28683, 29978, 33455, 35574, 20160, 21313, 63859, 38617, 27663, 20126, 20420, 20818, 21854, 23077, 23784, 25105, 29273, 33469, 33706, 34558, 34905, 35357, 38463, 38597, 39187, 40201, 40285, 22538, 23731, 23997, 24132, 24801, 24853, 25569, 27138, 28197, 37122, 37716, 38990, 39952, 40823, 23433, 23736, 25353, 26191, 26696, 30524, 38593, 38797, 38996, 39839, 26017, 35585, 36555, 38332, 21813, 23721, 24022, 24245, 26263, 30284, 33780, 38343, 22739, 25276, 29390, 40232, 20208, 22830, 24591, 26171, 27523, 31207, 40230, 21395, 21696, 22467, 23830, 24859, 26326, 28079, 30861, 33406, 38552, 38724, 21380, 25212, 25494, 28082, 32266, 33099, 38989, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 27387, 32588, 40367, 40474, 20063, 20539, 20918, 22812, 24825, 25590, 26928, 29242, 32822, 63860, 37326, 24369, 63861, 63862, 32004, 33509, 33903, 33979, 34277, 36493, 63863, 20335, 63864, 63865, 22756, 23363, 24665, 25562, 25880, 25965, 26264, 63866, 26954, 27171, 27915, 28673, 29036, 30162, 30221, 31155, 31344, 63867, 32650, 63868, 35140, 63869, 35731, 37312, 38525, 63870, 39178, 22276, 24481, 26044, 28417, 30208, 31142, 35486, 39341, 39770, 40812, 20740, 25014, 25233, 27277, 33222, 20547, 22576, 24422, 28937, 35328, 35578, 23420, 34326, 20474, 20796, 22196, 22852, 25513, 28153, 23978, 26989, 20870, 20104, 20313, 63871, 63872, 63873, 22914, 63874, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63875, 27487, 27741, 63876, 29877, 30998, 63877, 33287, 33349, 33593, 36671, 36701, 63878, 39192, 63879, 63880, 63881, 20134, 63882, 22495, 24441, 26131, 63883, 63884, 30123, 32377, 35695, 63885, 36870, 39515, 22181, 22567, 23032, 23071, 23476, 63886, 24310, 63887, 63888, 25424, 25403, 63889, 26941, 27783, 27839, 28046, 28051, 28149, 28436, 63890, 28895, 28982, 29017, 63891, 29123, 29141, 63892, 30799, 30831, 63893, 31605, 32227, 63894, 32303, 63895, 34893, 36575, 63896, 63897, 63898, 37467, 63899, 40182, 63900, 63901, 63902, 24709, 28037, 63903, 29105, 63904, 63905, 38321, 21421, 63906, 63907, 63908, 26579, 63909, 28814, 28976, 29744, 33398, 33490, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63910, 38331, 39653, 40573, 26308, 63911, 29121, 33865, 63912, 63913, 22603, 63914, 63915, 23992, 24433, 63916, 26144, 26254, 27001, 27054, 27704, 27891, 28214, 28481, 28634, 28699, 28719, 29008, 29151, 29552, 63917, 29787, 63918, 29908, 30408, 31310, 32403, 63919, 63920, 33521, 35424, 36814, 63921, 37704, 63922, 38681, 63923, 63924, 20034, 20522, 63925, 21e3, 21473, 26355, 27757, 28618, 29450, 30591, 31330, 33454, 34269, 34306, 63926, 35028, 35427, 35709, 35947, 63927, 37555, 63928, 38675, 38928, 20116, 20237, 20425, 20658, 21320, 21566, 21555, 21978, 22626, 22714, 22887, 23067, 23524, 24735, 63929, 25034, 25942, 26111, 26212, 26791, 27738, 28595, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 28879, 29100, 29522, 31613, 34568, 35492, 39986, 40711, 23627, 27779, 29508, 29577, 37434, 28331, 29797, 30239, 31337, 32277, 34314, 20800, 22725, 25793, 29934, 29973, 30320, 32705, 37013, 38605, 39252, 28198, 29926, 31401, 31402, 33253, 34521, 34680, 35355, 23113, 23436, 23451, 26785, 26880, 28003, 29609, 29715, 29740, 30871, 32233, 32747, 33048, 33109, 33694, 35916, 38446, 38929, 26352, 24448, 26106, 26505, 27754, 29579, 20525, 23043, 27498, 30702, 22806, 23916, 24013, 29477, 30031, 63930, 63931, 20709, 20985, 22575, 22829, 22934, 23002, 23525, 63932, 63933, 23970, 25303, 25622, 25747, 25854, 63934, 26332, 63935, 27208, 63936, 29183, 29796, 63937, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31368, 31407, 32327, 32350, 32768, 33136, 63938, 34799, 35201, 35616, 36953, 63939, 36992, 39250, 24958, 27442, 28020, 32287, 35109, 36785, 20433, 20653, 20887, 21191, 22471, 22665, 23481, 24248, 24898, 27029, 28044, 28263, 28342, 29076, 29794, 29992, 29996, 32883, 33592, 33993, 36362, 37780, 37854, 63940, 20110, 20305, 20598, 20778, 21448, 21451, 21491, 23431, 23507, 23588, 24858, 24962, 26100, 29275, 29591, 29760, 30402, 31056, 31121, 31161, 32006, 32701, 33419, 34261, 34398, 36802, 36935, 37109, 37354, 38533, 38632, 38633, 21206, 24423, 26093, 26161, 26671, 29020, 31286, 37057, 38922, 20113, 63941, 27218, 27550, 28560, 29065, 32792, 33464, 34131, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36939, 38549, 38642, 38907, 34074, 39729, 20112, 29066, 38596, 20803, 21407, 21729, 22291, 22290, 22435, 23195, 23236, 23491, 24616, 24895, 25588, 27781, 27961, 28274, 28304, 29232, 29503, 29783, 33489, 34945, 36677, 36960, 63942, 38498, 39e3, 40219, 26376, 36234, 37470, 20301, 20553, 20702, 21361, 22285, 22996, 23041, 23561, 24944, 26256, 28205, 29234, 29771, 32239, 32963, 33806, 33894, 34111, 34655, 34907, 35096, 35586, 36949, 38859, 39759, 20083, 20369, 20754, 20842, 63943, 21807, 21929, 23418, 23461, 24188, 24189, 24254, 24736, 24799, 24840, 24841, 25540, 25912, 26377, 63944, 26580, 26586, 63945, 26977, 26978, 27833, 27943, 63946, 28216, 63947, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 28641, 29494, 29495, 63948, 29788, 30001, 63949, 30290, 63950, 63951, 32173, 33278, 33848, 35029, 35480, 35547, 35565, 36400, 36418, 36938, 36926, 36986, 37193, 37321, 37742, 63952, 63953, 22537, 63954, 27603, 32905, 32946, 63955, 63956, 20801, 22891, 23609, 63957, 63958, 28516, 29607, 32996, 36103, 63959, 37399, 38287, 63960, 63961, 63962, 63963, 32895, 25102, 28700, 32104, 34701, 63964, 22432, 24681, 24903, 27575, 35518, 37504, 38577, 20057, 21535, 28139, 34093, 38512, 38899, 39150, 25558, 27875, 37009, 20957, 25033, 33210, 40441, 20381, 20506, 20736, 23452, 24847, 25087, 25836, 26885, 27589, 30097, 30691, 32681, 33380, 34191, 34811, 34915, 35516, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 35696, 37291, 20108, 20197, 20234, 63965, 63966, 22839, 23016, 63967, 24050, 24347, 24411, 24609, 63968, 63969, 63970, 63971, 29246, 29669, 63972, 30064, 30157, 63973, 31227, 63974, 32780, 32819, 32900, 33505, 33617, 63975, 63976, 36029, 36019, 36999, 63977, 63978, 39156, 39180, 63979, 63980, 28727, 30410, 32714, 32716, 32764, 35610, 20154, 20161, 20995, 21360, 63981, 21693, 22240, 23035, 23493, 24341, 24525, 28270, 63982, 63983, 32106, 33589, 63984, 34451, 35469, 63985, 38765, 38775, 63986, 63987, 19968, 20314, 20350, 22777, 26085, 28322, 36920, 37808, 39353, 20219, 22764, 22922, 23001, 24641, 63988, 63989, 31252, 63990, 33615, 36035, 20837, 21316, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 63991, 63992, 63993, 20173, 21097, 23381, 33471, 20180, 21050, 21672, 22985, 23039, 23376, 23383, 23388, 24675, 24904, 28363, 28825, 29038, 29574, 29943, 30133, 30913, 32043, 32773, 33258, 33576, 34071, 34249, 35566, 36039, 38604, 20316, 21242, 22204, 26027, 26152, 28796, 28856, 29237, 32189, 33421, 37196, 38592, 40306, 23409, 26855, 27544, 28538, 30430, 23697, 26283, 28507, 31668, 31786, 34870, 38620, 19976, 20183, 21280, 22580, 22715, 22767, 22892, 23559, 24115, 24196, 24373, 25484, 26290, 26454, 27167, 27299, 27404, 28479, 29254, 63994, 29520, 29835, 31456, 31911, 33144, 33247, 33255, 33674, 33900, 34083, 34196, 34255, 35037, 36115, 37292, 38263, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 38556, 20877, 21705, 22312, 23472, 25165, 26448, 26685, 26771, 28221, 28371, 28797, 32289, 35009, 36001, 36617, 40779, 40782, 29229, 31631, 35533, 37658, 20295, 20302, 20786, 21632, 22992, 24213, 25269, 26485, 26990, 27159, 27822, 28186, 29401, 29482, 30141, 31672, 32053, 33511, 33785, 33879, 34295, 35419, 36015, 36487, 36889, 37048, 38606, 40799, 21219, 21514, 23265, 23490, 25688, 25973, 28404, 29380, 63995, 30340, 31309, 31515, 31821, 32318, 32735, 33659, 35627, 36042, 36196, 36321, 36447, 36842, 36857, 36969, 37841, 20291, 20346, 20659, 20840, 20856, 21069, 21098, 22625, 22652, 22880, 23560, 23637, 24283, 24731, 25136, 26643, 27583, 27656, 28593, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 29006, 29728, 3e4, 30008, 30033, 30322, 31564, 31627, 31661, 31686, 32399, 35438, 36670, 36681, 37439, 37523, 37666, 37931, 38651, 39002, 39019, 39198, 20999, 25130, 25240, 27993, 30308, 31434, 31680, 32118, 21344, 23742, 24215, 28472, 28857, 31896, 38673, 39822, 40670, 25509, 25722, 34678, 19969, 20117, 20141, 20572, 20597, 21576, 22979, 23450, 24128, 24237, 24311, 24449, 24773, 25402, 25919, 25972, 26060, 26230, 26232, 26622, 26984, 27273, 27491, 27712, 28096, 28136, 28191, 28254, 28702, 28833, 29582, 29693, 30010, 30555, 30855, 31118, 31243, 31357, 31934, 32142, 33351, 35330, 35562, 35998, 37165, 37194, 37336, 37478, 37580, 37664, 38662, 38742, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 38748, 38914, 40718, 21046, 21137, 21884, 22564, 24093, 24351, 24716, 25552, 26799, 28639, 31085, 31532, 33229, 34234, 35069, 35576, 36420, 37261, 38500, 38555, 38717, 38988, 40778, 20430, 20806, 20939, 21161, 22066, 24340, 24427, 25514, 25805, 26089, 26177, 26362, 26361, 26397, 26781, 26839, 27133, 28437, 28526, 29031, 29157, 29226, 29866, 30522, 31062, 31066, 31199, 31264, 31381, 31895, 31967, 32068, 32368, 32903, 34299, 34468, 35412, 35519, 36249, 36481, 36896, 36973, 37347, 38459, 38613, 40165, 26063, 31751, 36275, 37827, 23384, 23562, 21330, 25305, 29469, 20519, 23447, 24478, 24752, 24939, 26837, 28121, 29742, 31278, 32066, 32156, 32305, 33131, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36394, 36405, 37758, 37912, 20304, 22352, 24038, 24231, 25387, 32618, 20027, 20303, 20367, 20570, 23005, 32964, 21610, 21608, 22014, 22863, 23449, 24030, 24282, 26205, 26417, 26609, 26666, 27880, 27954, 28234, 28557, 28855, 29664, 30087, 31820, 32002, 32044, 32162, 33311, 34523, 35387, 35461, 36208, 36490, 36659, 36913, 37198, 37202, 37956, 39376, 31481, 31909, 20426, 20737, 20934, 22472, 23535, 23803, 26201, 27197, 27994, 28310, 28652, 28940, 30063, 31459, 34850, 36897, 36981, 38603, 39423, 33537, 20013, 20210, 34886, 37325, 21373, 27355, 26987, 27713, 33914, 22686, 24974, 26366, 25327, 28893, 29969, 30151, 32338, 33976, 35657, 36104, 20043, 21482, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21675, 22320, 22336, 24535, 25345, 25351, 25711, 25903, 26088, 26234, 26525, 26547, 27490, 27744, 27802, 28460, 30693, 30757, 31049, 31063, 32025, 32930, 33026, 33267, 33437, 33463, 34584, 35468, 63996, 36100, 36286, 36978, 30452, 31257, 31287, 32340, 32887, 21767, 21972, 22645, 25391, 25634, 26185, 26187, 26733, 27035, 27524, 27941, 28337, 29645, 29800, 29857, 30043, 30137, 30433, 30494, 30603, 31206, 32265, 32285, 33275, 34095, 34967, 35386, 36049, 36587, 36784, 36914, 37805, 38499, 38515, 38663, 20356, 21489, 23018, 23241, 24089, 26702, 29894, 30142, 31209, 31378, 33187, 34541, 36074, 36300, 36845, 26015, 26389, 63997, 22519, 28503, 32221, 36655, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 37878, 38598, 24501, 25074, 28548, 19988, 20376, 20511, 21449, 21983, 23919, 24046, 27425, 27492, 30923, 31642, 63998, 36425, 36554, 36974, 25417, 25662, 30528, 31364, 37679, 38015, 40810, 25776, 28591, 29158, 29864, 29914, 31428, 31762, 32386, 31922, 32408, 35738, 36106, 38013, 39184, 39244, 21049, 23519, 25830, 26413, 32046, 20717, 21443, 22649, 24920, 24921, 25082, 26028, 31449, 35730, 35734, 20489, 20513, 21109, 21809, 23100, 24288, 24432, 24884, 25950, 26124, 26166, 26274, 27085, 28356, 28466, 29462, 30241, 31379, 33081, 33369, 33750, 33980, 20661, 22512, 23488, 23528, 24425, 25505, 30758, 32181, 33756, 34081, 37319, 37365, 20874, 26613, 31574, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36012, 20932, 22971, 24765, 34389, 20508, 63999, 21076, 23610, 24957, 25114, 25299, 25842, 26021, 28364, 30240, 33034, 36448, 38495, 38587, 20191, 21315, 21912, 22825, 24029, 25797, 27849, 28154, 29588, 31359, 33307, 34214, 36068, 36368, 36983, 37351, 38369, 38433, 38854, 20984, 21746, 21894, 24505, 25764, 28552, 32180, 36639, 36685, 37941, 20681, 23574, 27838, 28155, 29979, 30651, 31805, 31844, 35449, 35522, 22558, 22974, 24086, 25463, 29266, 30090, 30571, 35548, 36028, 36626, 24307, 26228, 28152, 32893, 33729, 35531, 38737, 39894, 64e3, 21059, 26367, 28053, 28399, 32224, 35558, 36910, 36958, 39636, 21021, 21119, 21736, 24980, 25220, 25307, 26786, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 26898, 26970, 27189, 28818, 28966, 30813, 30977, 30990, 31186, 31245, 32918, 33400, 33493, 33609, 34121, 35970, 36229, 37218, 37259, 37294, 20419, 22225, 29165, 30679, 34560, 35320, 23544, 24534, 26449, 37032, 21474, 22618, 23541, 24740, 24961, 25696, 32317, 32880, 34085, 37507, 25774, 20652, 23828, 26368, 22684, 25277, 25512, 26894, 27e3, 27166, 28267, 30394, 31179, 33467, 33833, 35535, 36264, 36861, 37138, 37195, 37276, 37648, 37656, 37786, 38619, 39478, 39949, 19985, 30044, 31069, 31482, 31569, 31689, 32302, 33988, 36441, 36468, 36600, 36880, 26149, 26943, 29763, 20986, 26414, 40668, 20805, 24544, 27798, 34802, 34909, 34935, 24756, 33205, 33795, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 36101, 21462, 21561, 22068, 23094, 23601, 28810, 32736, 32858, 33030, 33261, 36259, 37257, 39519, 40434, 20596, 20164, 21408, 24827, 28204, 23652, 20360, 20516, 21988, 23769, 24159, 24677, 26772, 27835, 28100, 29118, 30164, 30196, 30305, 31258, 31305, 32199, 32251, 32622, 33268, 34473, 36636, 38601, 39347, 40786, 21063, 21189, 39149, 35242, 19971, 26578, 28422, 20405, 23522, 26517, 27784, 28024, 29723, 30759, 37341, 37756, 34756, 31204, 31281, 24555, 20182, 21668, 21822, 22702, 22949, 24816, 25171, 25302, 26422, 26965, 33333, 38464, 39345, 39389, 20524, 21331, 21828, 22396, 64001, 25176, 64002, 25826, 26219, 26589, 28609, 28655, 29730, 29752, 35351, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 37944, 21585, 22022, 22374, 24392, 24986, 27470, 28760, 28845, 32187, 35477, 22890, 33067, 25506, 30472, 32829, 36010, 22612, 25645, 27067, 23445, 24081, 28271, 64003, 34153, 20812, 21488, 22826, 24608, 24907, 27526, 27760, 27888, 31518, 32974, 33492, 36294, 37040, 39089, 64004, 25799, 28580, 25745, 25860, 20814, 21520, 22303, 35342, 24927, 26742, 64005, 30171, 31570, 32113, 36890, 22534, 27084, 33151, 35114, 36864, 38969, 20600, 22871, 22956, 25237, 36879, 39722, 24925, 29305, 38358, 22369, 23110, 24052, 25226, 25773, 25850, 26487, 27874, 27966, 29228, 29750, 30772, 32631, 33453, 36315, 38935, 21028, 22338, 26495, 29256, 29923, 36009, 36774, 37393, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 38442, 20843, 21485, 25420, 20329, 21764, 24726, 25943, 27803, 28031, 29260, 29437, 31255, 35207, 35997, 24429, 28558, 28921, 33192, 24846, 20415, 20559, 25153, 29255, 31687, 32232, 32745, 36941, 38829, 39449, 36022, 22378, 24179, 26544, 33805, 35413, 21536, 23318, 24163, 24290, 24330, 25987, 32954, 34109, 38281, 38491, 20296, 21253, 21261, 21263, 21638, 21754, 22275, 24067, 24598, 25243, 25265, 25429, 64006, 27873, 28006, 30129, 30770, 32990, 33071, 33502, 33889, 33970, 34957, 35090, 36875, 37610, 39165, 39825, 24133, 26292, 26333, 28689, 29190, 64007, 20469, 21117, 24426, 24915, 26451, 27161, 28418, 29922, 31080, 34920, 35961, 39111, 39108, 39491, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 21697, 31263, 26963, 35575, 35914, 39080, 39342, 24444, 25259, 30130, 30382, 34987, 36991, 38466, 21305, 24380, 24517, 27852, 29644, 30050, 30091, 31558, 33534, 39325, 20047, 36924, 19979, 20309, 21414, 22799, 24264, 26160, 27827, 29781, 33655, 34662, 36032, 36944, 38686, 39957, 22737, 23416, 34384, 35604, 40372, 23506, 24680, 24717, 26097, 27735, 28450, 28579, 28698, 32597, 32752, 38289, 38290, 38480, 38867, 21106, 36676, 20989, 21547, 21688, 21859, 21898, 27323, 28085, 32216, 33382, 37532, 38519, 40569, 21512, 21704, 30418, 34532, 38308, 38356, 38492, 20130, 20233, 23022, 23270, 24055, 24658, 25239, 26477, 26689, 27782, 28207, 32568, 32923, 33322, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 64008, 64009, 38917, 20133, 20565, 21683, 22419, 22874, 23401, 23475, 25032, 26999, 28023, 28707, 34809, 35299, 35442, 35559, 36994, 39405, 39608, 21182, 26680, 20502, 24184, 26447, 33607, 34892, 20139, 21521, 22190, 29670, 37141, 38911, 39177, 39255, 39321, 22099, 22687, 34395, 35377, 25010, 27382, 29563, 36562, 27463, 38570, 39511, 22869, 29184, 36203, 38761, 20436, 23796, 24358, 25080, 26203, 27883, 28843, 29572, 29625, 29694, 30505, 30541, 32067, 32098, 32291, 33335, 34898, 64010, 36066, 37449, 39023, 23377, 31348, 34880, 38913, 23244, 20448, 21332, 22846, 23805, 25406, 28025, 29433, 33029, 33031, 33698, 37583, 38960, 20136, 20804, 21009, 22411, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 24418, 27842, 28366, 28677, 28752, 28847, 29074, 29673, 29801, 33610, 34722, 34913, 36872, 37026, 37795, 39336, 20846, 24407, 24800, 24935, 26291, 34137, 36426, 37295, 38795, 20046, 20114, 21628, 22741, 22778, 22909, 23733, 24359, 25142, 25160, 26122, 26215, 27627, 28009, 28111, 28246, 28408, 28564, 28640, 28649, 28765, 29392, 29733, 29786, 29920, 30355, 31068, 31946, 32286, 32993, 33446, 33899, 33983, 34382, 34399, 34676, 35703, 35946, 37804, 38912, 39013, 24785, 25110, 37239, 23130, 26127, 28151, 28222, 29759, 39746, 24573, 24794, 31503, 21700, 24344, 27742, 27859, 27946, 28888, 32005, 34425, 35340, 40251, 21270, 21644, 23301, 27194, 28779, 30069, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 31117, 31166, 33457, 33775, 35441, 35649, 36008, 38772, 64011, 25844, 25899, 30906, 30907, 31339, 20024, 21914, 22864, 23462, 24187, 24739, 25563, 27489, 26213, 26707, 28185, 29029, 29872, 32008, 36996, 39529, 39973, 27963, 28369, 29502, 35905, 38346, 20976, 24140, 24488, 24653, 24822, 24880, 24908, 26179, 26180, 27045, 27841, 28255, 28361, 28514, 29004, 29852, 30343, 31681, 31783, 33618, 34647, 36945, 38541, 40643, 21295, 22238, 24315, 24458, 24674, 24724, 25079, 26214, 26371, 27292, 28142, 28590, 28784, 29546, 32362, 33214, 33588, 34516, 35496, 36036, 21123, 29554, 23446, 27243, 37892, 21742, 22150, 23389, 25928, 25989, 26313, 26783, 28045, 28102, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 29243, 32948, 37237, 39501, 20399, 20505, 21402, 21518, 21564, 21897, 21957, 24127, 24460, 26429, 29030, 29661, 36869, 21211, 21235, 22628, 22734, 28932, 29071, 29179, 34224, 35347, 26248, 34216, 21927, 26244, 29002, 33841, 21321, 21913, 27585, 24409, 24509, 25582, 26249, 28999, 35569, 36637, 40638, 20241, 25658, 28875, 30054, 34407, 24676, 35662, 40440, 20807, 20982, 21256, 27958, 33016, 40657, 26133, 27427, 28824, 30165, 21507, 23673, 32007, 35350, 27424, 27453, 27462, 21560, 24688, 27965, 32725, 33288, 20694, 20958, 21916, 22123, 22221, 23020, 23305, 24076, 24985, 24984, 25137, 26206, 26342, 29081, 29113, 29114, 29351, 31143, 31232, 32690, 35440, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "gb18030": [19970, 19972, 19973, 19974, 19983, 19986, 19991, 19999, 2e4, 20001, 20003, 20006, 20009, 20014, 20015, 20017, 20019, 20021, 20023, 20028, 20032, 20033, 20034, 20036, 20038, 20042, 20049, 20053, 20055, 20058, 20059, 20066, 20067, 20068, 20069, 20071, 20072, 20074, 20075, 20076, 20077, 20078, 20079, 20082, 20084, 20085, 20086, 20087, 20088, 20089, 20090, 20091, 20092, 20093, 20095, 20096, 20097, 20098, 20099, 20100, 20101, 20103, 20106, 20112, 20118, 20119, 20121, 20124, 20125, 20126, 20131, 20138, 20143, 20144, 20145, 20148, 20150, 20151, 20152, 20153, 20156, 20157, 20158, 20168, 20172, 20175, 20176, 20178, 20186, 20187, 20188, 20192, 20194, 20198, 20199, 20201, 20205, 20206, 20207, 20209, 20212, 20216, 20217, 20218, 20220, 20222, 20224, 20226, 20227, 20228, 20229, 20230, 20231, 20232, 20235, 20236, 20242, 20243, 20244, 20245, 20246, 20252, 20253, 20257, 20259, 20264, 20265, 20268, 20269, 20270, 20273, 20275, 20277, 20279, 20281, 20283, 20286, 20287, 20288, 20289, 20290, 20292, 20293, 20295, 20296, 20297, 20298, 20299, 20300, 20306, 20308, 20310, 20321, 20322, 20326, 20328, 20330, 20331, 20333, 20334, 20337, 20338, 20341, 20343, 20344, 20345, 20346, 20349, 20352, 20353, 20354, 20357, 20358, 20359, 20362, 20364, 20366, 20368, 20370, 20371, 20373, 20374, 20376, 20377, 20378, 20380, 20382, 20383, 20385, 20386, 20388, 20395, 20397, 20400, 20401, 20402, 20403, 20404, 20406, 20407, 20408, 20409, 20410, 20411, 20412, 20413, 20414, 20416, 20417, 20418, 20422, 20423, 20424, 20425, 20427, 20428, 20429, 20434, 20435, 20436, 20437, 20438, 20441, 20443, 20448, 20450, 20452, 20453, 20455, 20459, 20460, 20464, 20466, 20468, 20469, 20470, 20471, 20473, 20475, 20476, 20477, 20479, 20480, 20481, 20482, 20483, 20484, 20485, 20486, 20487, 20488, 20489, 20490, 20491, 20494, 20496, 20497, 20499, 20501, 20502, 20503, 20507, 20509, 20510, 20512, 20514, 20515, 20516, 20519, 20523, 20527, 20528, 20529, 20530, 20531, 20532, 20533, 20534, 20535, 20536, 20537, 20539, 20541, 20543, 20544, 20545, 20546, 20548, 20549, 20550, 20553, 20554, 20555, 20557, 20560, 20561, 20562, 20563, 20564, 20566, 20567, 20568, 20569, 20571, 20573, 20574, 20575, 20576, 20577, 20578, 20579, 20580, 20582, 20583, 20584, 20585, 20586, 20587, 20589, 20590, 20591, 20592, 20593, 20594, 20595, 20596, 20597, 20600, 20601, 20602, 20604, 20605, 20609, 20610, 20611, 20612, 20614, 20615, 20617, 20618, 20619, 20620, 20622, 20623, 20624, 20625, 20626, 20627, 20628, 20629, 20630, 20631, 20632, 20633, 20634, 20635, 20636, 20637, 20638, 20639, 20640, 20641, 20642, 20644, 20646, 20650, 20651, 20653, 20654, 20655, 20656, 20657, 20659, 20660, 20661, 20662, 20663, 20664, 20665, 20668, 20669, 20670, 20671, 20672, 20673, 20674, 20675, 20676, 20677, 20678, 20679, 20680, 20681, 20682, 20683, 20684, 20685, 20686, 20688, 20689, 20690, 20691, 20692, 20693, 20695, 20696, 20697, 20699, 20700, 20701, 20702, 20703, 20704, 20705, 20706, 20707, 20708, 20709, 20712, 20713, 20714, 20715, 20719, 20720, 20721, 20722, 20724, 20726, 20727, 20728, 20729, 20730, 20732, 20733, 20734, 20735, 20736, 20737, 20738, 20739, 20740, 20741, 20744, 20745, 20746, 20748, 20749, 20750, 20751, 20752, 20753, 20755, 20756, 20757, 20758, 20759, 20760, 20761, 20762, 20763, 20764, 20765, 20766, 20767, 20768, 20770, 20771, 20772, 20773, 20774, 20775, 20776, 20777, 20778, 20779, 20780, 20781, 20782, 20783, 20784, 20785, 20786, 20787, 20788, 20789, 20790, 20791, 20792, 20793, 20794, 20795, 20796, 20797, 20798, 20802, 20807, 20810, 20812, 20814, 20815, 20816, 20818, 20819, 20823, 20824, 20825, 20827, 20829, 20830, 20831, 20832, 20833, 20835, 20836, 20838, 20839, 20841, 20842, 20847, 20850, 20858, 20862, 20863, 20867, 20868, 20870, 20871, 20874, 20875, 20878, 20879, 20880, 20881, 20883, 20884, 20888, 20890, 20893, 20894, 20895, 20897, 20899, 20902, 20903, 20904, 20905, 20906, 20909, 20910, 20916, 20920, 20921, 20922, 20926, 20927, 20929, 20930, 20931, 20933, 20936, 20938, 20941, 20942, 20944, 20946, 20947, 20948, 20949, 20950, 20951, 20952, 20953, 20954, 20956, 20958, 20959, 20962, 20963, 20965, 20966, 20967, 20968, 20969, 20970, 20972, 20974, 20977, 20978, 20980, 20983, 20990, 20996, 20997, 21001, 21003, 21004, 21007, 21008, 21011, 21012, 21013, 21020, 21022, 21023, 21025, 21026, 21027, 21029, 21030, 21031, 21034, 21036, 21039, 21041, 21042, 21044, 21045, 21052, 21054, 21060, 21061, 21062, 21063, 21064, 21065, 21067, 21070, 21071, 21074, 21075, 21077, 21079, 21080, 21081, 21082, 21083, 21085, 21087, 21088, 21090, 21091, 21092, 21094, 21096, 21099, 21100, 21101, 21102, 21104, 21105, 21107, 21108, 21109, 21110, 21111, 21112, 21113, 21114, 21115, 21116, 21118, 21120, 21123, 21124, 21125, 21126, 21127, 21129, 21130, 21131, 21132, 21133, 21134, 21135, 21137, 21138, 21140, 21141, 21142, 21143, 21144, 21145, 21146, 21148, 21156, 21157, 21158, 21159, 21166, 21167, 21168, 21172, 21173, 21174, 21175, 21176, 21177, 21178, 21179, 21180, 21181, 21184, 21185, 21186, 21188, 21189, 21190, 21192, 21194, 21196, 21197, 21198, 21199, 21201, 21203, 21204, 21205, 21207, 21209, 21210, 21211, 21212, 21213, 21214, 21216, 21217, 21218, 21219, 21221, 21222, 21223, 21224, 21225, 21226, 21227, 21228, 21229, 21230, 21231, 21233, 21234, 21235, 21236, 21237, 21238, 21239, 21240, 21243, 21244, 21245, 21249, 21250, 21251, 21252, 21255, 21257, 21258, 21259, 21260, 21262, 21265, 21266, 21267, 21268, 21272, 21275, 21276, 21278, 21279, 21282, 21284, 21285, 21287, 21288, 21289, 21291, 21292, 21293, 21295, 21296, 21297, 21298, 21299, 21300, 21301, 21302, 21303, 21304, 21308, 21309, 21312, 21314, 21316, 21318, 21323, 21324, 21325, 21328, 21332, 21336, 21337, 21339, 21341, 21349, 21352, 21354, 21356, 21357, 21362, 21366, 21369, 21371, 21372, 21373, 21374, 21376, 21377, 21379, 21383, 21384, 21386, 21390, 21391, 21392, 21393, 21394, 21395, 21396, 21398, 21399, 21401, 21403, 21404, 21406, 21408, 21409, 21412, 21415, 21418, 21419, 21420, 21421, 21423, 21424, 21425, 21426, 21427, 21428, 21429, 21431, 21432, 21433, 21434, 21436, 21437, 21438, 21440, 21443, 21444, 21445, 21446, 21447, 21454, 21455, 21456, 21458, 21459, 21461, 21466, 21468, 21469, 21470, 21473, 21474, 21479, 21492, 21498, 21502, 21503, 21504, 21506, 21509, 21511, 21515, 21524, 21528, 21529, 21530, 21532, 21538, 21540, 21541, 21546, 21552, 21555, 21558, 21559, 21562, 21565, 21567, 21569, 21570, 21572, 21573, 21575, 21577, 21580, 21581, 21582, 21583, 21585, 21594, 21597, 21598, 21599, 21600, 21601, 21603, 21605, 21607, 21609, 21610, 21611, 21612, 21613, 21614, 21615, 21616, 21620, 21625, 21626, 21630, 21631, 21633, 21635, 21637, 21639, 21640, 21641, 21642, 21645, 21649, 21651, 21655, 21656, 21660, 21662, 21663, 21664, 21665, 21666, 21669, 21678, 21680, 21682, 21685, 21686, 21687, 21689, 21690, 21692, 21694, 21699, 21701, 21706, 21707, 21718, 21720, 21723, 21728, 21729, 21730, 21731, 21732, 21739, 21740, 21743, 21744, 21745, 21748, 21749, 21750, 21751, 21752, 21753, 21755, 21758, 21760, 21762, 21763, 21764, 21765, 21768, 21770, 21771, 21772, 21773, 21774, 21778, 21779, 21781, 21782, 21783, 21784, 21785, 21786, 21788, 21789, 21790, 21791, 21793, 21797, 21798, 21800, 21801, 21803, 21805, 21810, 21812, 21813, 21814, 21816, 21817, 21818, 21819, 21821, 21824, 21826, 21829, 21831, 21832, 21835, 21836, 21837, 21838, 21839, 21841, 21842, 21843, 21844, 21847, 21848, 21849, 21850, 21851, 21853, 21854, 21855, 21856, 21858, 21859, 21864, 21865, 21867, 21871, 21872, 21873, 21874, 21875, 21876, 21881, 21882, 21885, 21887, 21893, 21894, 21900, 21901, 21902, 21904, 21906, 21907, 21909, 21910, 21911, 21914, 21915, 21918, 21920, 21921, 21922, 21923, 21924, 21925, 21926, 21928, 21929, 21930, 21931, 21932, 21933, 21934, 21935, 21936, 21938, 21940, 21942, 21944, 21946, 21948, 21951, 21952, 21953, 21954, 21955, 21958, 21959, 21960, 21962, 21963, 21966, 21967, 21968, 21973, 21975, 21976, 21977, 21978, 21979, 21982, 21984, 21986, 21991, 21993, 21997, 21998, 22e3, 22001, 22004, 22006, 22008, 22009, 22010, 22011, 22012, 22015, 22018, 22019, 22020, 22021, 22022, 22023, 22026, 22027, 22029, 22032, 22033, 22034, 22035, 22036, 22037, 22038, 22039, 22041, 22042, 22044, 22045, 22048, 22049, 22050, 22053, 22054, 22056, 22057, 22058, 22059, 22062, 22063, 22064, 22067, 22069, 22071, 22072, 22074, 22076, 22077, 22078, 22080, 22081, 22082, 22083, 22084, 22085, 22086, 22087, 22088, 22089, 22090, 22091, 22095, 22096, 22097, 22098, 22099, 22101, 22102, 22106, 22107, 22109, 22110, 22111, 22112, 22113, 22115, 22117, 22118, 22119, 22125, 22126, 22127, 22128, 22130, 22131, 22132, 22133, 22135, 22136, 22137, 22138, 22141, 22142, 22143, 22144, 22145, 22146, 22147, 22148, 22151, 22152, 22153, 22154, 22155, 22156, 22157, 22160, 22161, 22162, 22164, 22165, 22166, 22167, 22168, 22169, 22170, 22171, 22172, 22173, 22174, 22175, 22176, 22177, 22178, 22180, 22181, 22182, 22183, 22184, 22185, 22186, 22187, 22188, 22189, 22190, 22192, 22193, 22194, 22195, 22196, 22197, 22198, 22200, 22201, 22202, 22203, 22205, 22206, 22207, 22208, 22209, 22210, 22211, 22212, 22213, 22214, 22215, 22216, 22217, 22219, 22220, 22221, 22222, 22223, 22224, 22225, 22226, 22227, 22229, 22230, 22232, 22233, 22236, 22243, 22245, 22246, 22247, 22248, 22249, 22250, 22252, 22254, 22255, 22258, 22259, 22262, 22263, 22264, 22267, 22268, 22272, 22273, 22274, 22277, 22279, 22283, 22284, 22285, 22286, 22287, 22288, 22289, 22290, 22291, 22292, 22293, 22294, 22295, 22296, 22297, 22298, 22299, 22301, 22302, 22304, 22305, 22306, 22308, 22309, 22310, 22311, 22315, 22321, 22322, 22324, 22325, 22326, 22327, 22328, 22332, 22333, 22335, 22337, 22339, 22340, 22341, 22342, 22344, 22345, 22347, 22354, 22355, 22356, 22357, 22358, 22360, 22361, 22370, 22371, 22373, 22375, 22380, 22382, 22384, 22385, 22386, 22388, 22389, 22392, 22393, 22394, 22397, 22398, 22399, 22400, 22401, 22407, 22408, 22409, 22410, 22413, 22414, 22415, 22416, 22417, 22420, 22421, 22422, 22423, 22424, 22425, 22426, 22428, 22429, 22430, 22431, 22437, 22440, 22442, 22444, 22447, 22448, 22449, 22451, 22453, 22454, 22455, 22457, 22458, 22459, 22460, 22461, 22462, 22463, 22464, 22465, 22468, 22469, 22470, 22471, 22472, 22473, 22474, 22476, 22477, 22480, 22481, 22483, 22486, 22487, 22491, 22492, 22494, 22497, 22498, 22499, 22501, 22502, 22503, 22504, 22505, 22506, 22507, 22508, 22510, 22512, 22513, 22514, 22515, 22517, 22518, 22519, 22523, 22524, 22526, 22527, 22529, 22531, 22532, 22533, 22536, 22537, 22538, 22540, 22542, 22543, 22544, 22546, 22547, 22548, 22550, 22551, 22552, 22554, 22555, 22556, 22557, 22559, 22562, 22563, 22565, 22566, 22567, 22568, 22569, 22571, 22572, 22573, 22574, 22575, 22577, 22578, 22579, 22580, 22582, 22583, 22584, 22585, 22586, 22587, 22588, 22589, 22590, 22591, 22592, 22593, 22594, 22595, 22597, 22598, 22599, 22600, 22601, 22602, 22603, 22606, 22607, 22608, 22610, 22611, 22613, 22614, 22615, 22617, 22618, 22619, 22620, 22621, 22623, 22624, 22625, 22626, 22627, 22628, 22630, 22631, 22632, 22633, 22634, 22637, 22638, 22639, 22640, 22641, 22642, 22643, 22644, 22645, 22646, 22647, 22648, 22649, 22650, 22651, 22652, 22653, 22655, 22658, 22660, 22662, 22663, 22664, 22666, 22667, 22668, 22669, 22670, 22671, 22672, 22673, 22676, 22677, 22678, 22679, 22680, 22683, 22684, 22685, 22688, 22689, 22690, 22691, 22692, 22693, 22694, 22695, 22698, 22699, 22700, 22701, 22702, 22703, 22704, 22705, 22706, 22707, 22708, 22709, 22710, 22711, 22712, 22713, 22714, 22715, 22717, 22718, 22719, 22720, 22722, 22723, 22724, 22726, 22727, 22728, 22729, 22730, 22731, 22732, 22733, 22734, 22735, 22736, 22738, 22739, 22740, 22742, 22743, 22744, 22745, 22746, 22747, 22748, 22749, 22750, 22751, 22752, 22753, 22754, 22755, 22757, 22758, 22759, 22760, 22761, 22762, 22765, 22767, 22769, 22770, 22772, 22773, 22775, 22776, 22778, 22779, 22780, 22781, 22782, 22783, 22784, 22785, 22787, 22789, 22790, 22792, 22793, 22794, 22795, 22796, 22798, 22800, 22801, 22802, 22803, 22807, 22808, 22811, 22813, 22814, 22816, 22817, 22818, 22819, 22822, 22824, 22828, 22832, 22834, 22835, 22837, 22838, 22843, 22845, 22846, 22847, 22848, 22851, 22853, 22854, 22858, 22860, 22861, 22864, 22866, 22867, 22873, 22875, 22876, 22877, 22878, 22879, 22881, 22883, 22884, 22886, 22887, 22888, 22889, 22890, 22891, 22892, 22893, 22894, 22895, 22896, 22897, 22898, 22901, 22903, 22906, 22907, 22908, 22910, 22911, 22912, 22917, 22921, 22923, 22924, 22926, 22927, 22928, 22929, 22932, 22933, 22936, 22938, 22939, 22940, 22941, 22943, 22944, 22945, 22946, 22950, 22951, 22956, 22957, 22960, 22961, 22963, 22964, 22965, 22966, 22967, 22968, 22970, 22972, 22973, 22975, 22976, 22977, 22978, 22979, 22980, 22981, 22983, 22984, 22985, 22988, 22989, 22990, 22991, 22997, 22998, 23001, 23003, 23006, 23007, 23008, 23009, 23010, 23012, 23014, 23015, 23017, 23018, 23019, 23021, 23022, 23023, 23024, 23025, 23026, 23027, 23028, 23029, 23030, 23031, 23032, 23034, 23036, 23037, 23038, 23040, 23042, 23050, 23051, 23053, 23054, 23055, 23056, 23058, 23060, 23061, 23062, 23063, 23065, 23066, 23067, 23069, 23070, 23073, 23074, 23076, 23078, 23079, 23080, 23082, 23083, 23084, 23085, 23086, 23087, 23088, 23091, 23093, 23095, 23096, 23097, 23098, 23099, 23101, 23102, 23103, 23105, 23106, 23107, 23108, 23109, 23111, 23112, 23115, 23116, 23117, 23118, 23119, 23120, 23121, 23122, 23123, 23124, 23126, 23127, 23128, 23129, 23131, 23132, 23133, 23134, 23135, 23136, 23137, 23139, 23140, 23141, 23142, 23144, 23145, 23147, 23148, 23149, 23150, 23151, 23152, 23153, 23154, 23155, 23160, 23161, 23163, 23164, 23165, 23166, 23168, 23169, 23170, 23171, 23172, 23173, 23174, 23175, 23176, 23177, 23178, 23179, 23180, 23181, 23182, 23183, 23184, 23185, 23187, 23188, 23189, 23190, 23191, 23192, 23193, 23196, 23197, 23198, 23199, 23200, 23201, 23202, 23203, 23204, 23205, 23206, 23207, 23208, 23209, 23211, 23212, 23213, 23214, 23215, 23216, 23217, 23220, 23222, 23223, 23225, 23226, 23227, 23228, 23229, 23231, 23232, 23235, 23236, 23237, 23238, 23239, 23240, 23242, 23243, 23245, 23246, 23247, 23248, 23249, 23251, 23253, 23255, 23257, 23258, 23259, 23261, 23262, 23263, 23266, 23268, 23269, 23271, 23272, 23274, 23276, 23277, 23278, 23279, 23280, 23282, 23283, 23284, 23285, 23286, 23287, 23288, 23289, 23290, 23291, 23292, 23293, 23294, 23295, 23296, 23297, 23298, 23299, 23300, 23301, 23302, 23303, 23304, 23306, 23307, 23308, 23309, 23310, 23311, 23312, 23313, 23314, 23315, 23316, 23317, 23320, 23321, 23322, 23323, 23324, 23325, 23326, 23327, 23328, 23329, 23330, 23331, 23332, 23333, 23334, 23335, 23336, 23337, 23338, 23339, 23340, 23341, 23342, 23343, 23344, 23345, 23347, 23349, 23350, 23352, 23353, 23354, 23355, 23356, 23357, 23358, 23359, 23361, 23362, 23363, 23364, 23365, 23366, 23367, 23368, 23369, 23370, 23371, 23372, 23373, 23374, 23375, 23378, 23382, 23390, 23392, 23393, 23399, 23400, 23403, 23405, 23406, 23407, 23410, 23412, 23414, 23415, 23416, 23417, 23419, 23420, 23422, 23423, 23426, 23430, 23434, 23437, 23438, 23440, 23441, 23442, 23444, 23446, 23455, 23463, 23464, 23465, 23468, 23469, 23470, 23471, 23473, 23474, 23479, 23482, 23483, 23484, 23488, 23489, 23491, 23496, 23497, 23498, 23499, 23501, 23502, 23503, 23505, 23508, 23509, 23510, 23511, 23512, 23513, 23514, 23515, 23516, 23520, 23522, 23523, 23526, 23527, 23529, 23530, 23531, 23532, 23533, 23535, 23537, 23538, 23539, 23540, 23541, 23542, 23543, 23549, 23550, 23552, 23554, 23555, 23557, 23559, 23560, 23563, 23564, 23565, 23566, 23568, 23570, 23571, 23575, 23577, 23579, 23582, 23583, 23584, 23585, 23587, 23590, 23592, 23593, 23594, 23595, 23597, 23598, 23599, 23600, 23602, 23603, 23605, 23606, 23607, 23619, 23620, 23622, 23623, 23628, 23629, 23634, 23635, 23636, 23638, 23639, 23640, 23642, 23643, 23644, 23645, 23647, 23650, 23652, 23655, 23656, 23657, 23658, 23659, 23660, 23661, 23664, 23666, 23667, 23668, 23669, 23670, 23671, 23672, 23675, 23676, 23677, 23678, 23680, 23683, 23684, 23685, 23686, 23687, 23689, 23690, 23691, 23694, 23695, 23698, 23699, 23701, 23709, 23710, 23711, 23712, 23713, 23716, 23717, 23718, 23719, 23720, 23722, 23726, 23727, 23728, 23730, 23732, 23734, 23737, 23738, 23739, 23740, 23742, 23744, 23746, 23747, 23749, 23750, 23751, 23752, 23753, 23754, 23756, 23757, 23758, 23759, 23760, 23761, 23763, 23764, 23765, 23766, 23767, 23768, 23770, 23771, 23772, 23773, 23774, 23775, 23776, 23778, 23779, 23783, 23785, 23787, 23788, 23790, 23791, 23793, 23794, 23795, 23796, 23797, 23798, 23799, 23800, 23801, 23802, 23804, 23805, 23806, 23807, 23808, 23809, 23812, 23813, 23816, 23817, 23818, 23819, 23820, 23821, 23823, 23824, 23825, 23826, 23827, 23829, 23831, 23832, 23833, 23834, 23836, 23837, 23839, 23840, 23841, 23842, 23843, 23845, 23848, 23850, 23851, 23852, 23855, 23856, 23857, 23858, 23859, 23861, 23862, 23863, 23864, 23865, 23866, 23867, 23868, 23871, 23872, 23873, 23874, 23875, 23876, 23877, 23878, 23880, 23881, 23885, 23886, 23887, 23888, 23889, 23890, 23891, 23892, 23893, 23894, 23895, 23897, 23898, 23900, 23902, 23903, 23904, 23905, 23906, 23907, 23908, 23909, 23910, 23911, 23912, 23914, 23917, 23918, 23920, 23921, 23922, 23923, 23925, 23926, 23927, 23928, 23929, 23930, 23931, 23932, 23933, 23934, 23935, 23936, 23937, 23939, 23940, 23941, 23942, 23943, 23944, 23945, 23946, 23947, 23948, 23949, 23950, 23951, 23952, 23953, 23954, 23955, 23956, 23957, 23958, 23959, 23960, 23962, 23963, 23964, 23966, 23967, 23968, 23969, 23970, 23971, 23972, 23973, 23974, 23975, 23976, 23977, 23978, 23979, 23980, 23981, 23982, 23983, 23984, 23985, 23986, 23987, 23988, 23989, 23990, 23992, 23993, 23994, 23995, 23996, 23997, 23998, 23999, 24e3, 24001, 24002, 24003, 24004, 24006, 24007, 24008, 24009, 24010, 24011, 24012, 24014, 24015, 24016, 24017, 24018, 24019, 24020, 24021, 24022, 24023, 24024, 24025, 24026, 24028, 24031, 24032, 24035, 24036, 24042, 24044, 24045, 24048, 24053, 24054, 24056, 24057, 24058, 24059, 24060, 24063, 24064, 24068, 24071, 24073, 24074, 24075, 24077, 24078, 24082, 24083, 24087, 24094, 24095, 24096, 24097, 24098, 24099, 24100, 24101, 24104, 24105, 24106, 24107, 24108, 24111, 24112, 24114, 24115, 24116, 24117, 24118, 24121, 24122, 24126, 24127, 24128, 24129, 24131, 24134, 24135, 24136, 24137, 24138, 24139, 24141, 24142, 24143, 24144, 24145, 24146, 24147, 24150, 24151, 24152, 24153, 24154, 24156, 24157, 24159, 24160, 24163, 24164, 24165, 24166, 24167, 24168, 24169, 24170, 24171, 24172, 24173, 24174, 24175, 24176, 24177, 24181, 24183, 24185, 24190, 24193, 24194, 24195, 24197, 24200, 24201, 24204, 24205, 24206, 24210, 24216, 24219, 24221, 24225, 24226, 24227, 24228, 24232, 24233, 24234, 24235, 24236, 24238, 24239, 24240, 24241, 24242, 24244, 24250, 24251, 24252, 24253, 24255, 24256, 24257, 24258, 24259, 24260, 24261, 24262, 24263, 24264, 24267, 24268, 24269, 24270, 24271, 24272, 24276, 24277, 24279, 24280, 24281, 24282, 24284, 24285, 24286, 24287, 24288, 24289, 24290, 24291, 24292, 24293, 24294, 24295, 24297, 24299, 24300, 24301, 24302, 24303, 24304, 24305, 24306, 24307, 24309, 24312, 24313, 24315, 24316, 24317, 24325, 24326, 24327, 24329, 24332, 24333, 24334, 24336, 24338, 24340, 24342, 24345, 24346, 24348, 24349, 24350, 24353, 24354, 24355, 24356, 24360, 24363, 24364, 24366, 24368, 24370, 24371, 24372, 24373, 24374, 24375, 24376, 24379, 24381, 24382, 24383, 24385, 24386, 24387, 24388, 24389, 24390, 24391, 24392, 24393, 24394, 24395, 24396, 24397, 24398, 24399, 24401, 24404, 24409, 24410, 24411, 24412, 24414, 24415, 24416, 24419, 24421, 24423, 24424, 24427, 24430, 24431, 24434, 24436, 24437, 24438, 24440, 24442, 24445, 24446, 24447, 24451, 24454, 24461, 24462, 24463, 24465, 24467, 24468, 24470, 24474, 24475, 24477, 24478, 24479, 24480, 24482, 24483, 24484, 24485, 24486, 24487, 24489, 24491, 24492, 24495, 24496, 24497, 24498, 24499, 24500, 24502, 24504, 24505, 24506, 24507, 24510, 24511, 24512, 24513, 24514, 24519, 24520, 24522, 24523, 24526, 24531, 24532, 24533, 24538, 24539, 24540, 24542, 24543, 24546, 24547, 24549, 24550, 24552, 24553, 24556, 24559, 24560, 24562, 24563, 24564, 24566, 24567, 24569, 24570, 24572, 24583, 24584, 24585, 24587, 24588, 24592, 24593, 24595, 24599, 24600, 24602, 24606, 24607, 24610, 24611, 24612, 24620, 24621, 24622, 24624, 24625, 24626, 24627, 24628, 24630, 24631, 24632, 24633, 24634, 24637, 24638, 24640, 24644, 24645, 24646, 24647, 24648, 24649, 24650, 24652, 24654, 24655, 24657, 24659, 24660, 24662, 24663, 24664, 24667, 24668, 24670, 24671, 24672, 24673, 24677, 24678, 24686, 24689, 24690, 24692, 24693, 24695, 24702, 24704, 24705, 24706, 24709, 24710, 24711, 24712, 24714, 24715, 24718, 24719, 24720, 24721, 24723, 24725, 24727, 24728, 24729, 24732, 24734, 24737, 24738, 24740, 24741, 24743, 24745, 24746, 24750, 24752, 24755, 24757, 24758, 24759, 24761, 24762, 24765, 24766, 24767, 24768, 24769, 24770, 24771, 24772, 24775, 24776, 24777, 24780, 24781, 24782, 24783, 24784, 24786, 24787, 24788, 24790, 24791, 24793, 24795, 24798, 24801, 24802, 24803, 24804, 24805, 24810, 24817, 24818, 24821, 24823, 24824, 24827, 24828, 24829, 24830, 24831, 24834, 24835, 24836, 24837, 24839, 24842, 24843, 24844, 24848, 24849, 24850, 24851, 24852, 24854, 24855, 24856, 24857, 24859, 24860, 24861, 24862, 24865, 24866, 24869, 24872, 24873, 24874, 24876, 24877, 24878, 24879, 24880, 24881, 24882, 24883, 24884, 24885, 24886, 24887, 24888, 24889, 24890, 24891, 24892, 24893, 24894, 24896, 24897, 24898, 24899, 24900, 24901, 24902, 24903, 24905, 24907, 24909, 24911, 24912, 24914, 24915, 24916, 24918, 24919, 24920, 24921, 24922, 24923, 24924, 24926, 24927, 24928, 24929, 24931, 24932, 24933, 24934, 24937, 24938, 24939, 24940, 24941, 24942, 24943, 24945, 24946, 24947, 24948, 24950, 24952, 24953, 24954, 24955, 24956, 24957, 24958, 24959, 24960, 24961, 24962, 24963, 24964, 24965, 24966, 24967, 24968, 24969, 24970, 24972, 24973, 24975, 24976, 24977, 24978, 24979, 24981, 24982, 24983, 24984, 24985, 24986, 24987, 24988, 24990, 24991, 24992, 24993, 24994, 24995, 24996, 24997, 24998, 25002, 25003, 25005, 25006, 25007, 25008, 25009, 25010, 25011, 25012, 25013, 25014, 25016, 25017, 25018, 25019, 25020, 25021, 25023, 25024, 25025, 25027, 25028, 25029, 25030, 25031, 25033, 25036, 25037, 25038, 25039, 25040, 25043, 25045, 25046, 25047, 25048, 25049, 25050, 25051, 25052, 25053, 25054, 25055, 25056, 25057, 25058, 25059, 25060, 25061, 25063, 25064, 25065, 25066, 25067, 25068, 25069, 25070, 25071, 25072, 25073, 25074, 25075, 25076, 25078, 25079, 25080, 25081, 25082, 25083, 25084, 25085, 25086, 25088, 25089, 25090, 25091, 25092, 25093, 25095, 25097, 25107, 25108, 25113, 25116, 25117, 25118, 25120, 25123, 25126, 25127, 25128, 25129, 25131, 25133, 25135, 25136, 25137, 25138, 25141, 25142, 25144, 25145, 25146, 25147, 25148, 25154, 25156, 25157, 25158, 25162, 25167, 25168, 25173, 25174, 25175, 25177, 25178, 25180, 25181, 25182, 25183, 25184, 25185, 25186, 25188, 25189, 25192, 25201, 25202, 25204, 25205, 25207, 25208, 25210, 25211, 25213, 25217, 25218, 25219, 25221, 25222, 25223, 25224, 25227, 25228, 25229, 25230, 25231, 25232, 25236, 25241, 25244, 25245, 25246, 25251, 25254, 25255, 25257, 25258, 25261, 25262, 25263, 25264, 25266, 25267, 25268, 25270, 25271, 25272, 25274, 25278, 25280, 25281, 25283, 25291, 25295, 25297, 25301, 25309, 25310, 25312, 25313, 25316, 25322, 25323, 25328, 25330, 25333, 25336, 25337, 25338, 25339, 25344, 25347, 25348, 25349, 25350, 25354, 25355, 25356, 25357, 25359, 25360, 25362, 25363, 25364, 25365, 25367, 25368, 25369, 25372, 25382, 25383, 25385, 25388, 25389, 25390, 25392, 25393, 25395, 25396, 25397, 25398, 25399, 25400, 25403, 25404, 25406, 25407, 25408, 25409, 25412, 25415, 25416, 25418, 25425, 25426, 25427, 25428, 25430, 25431, 25432, 25433, 25434, 25435, 25436, 25437, 25440, 25444, 25445, 25446, 25448, 25450, 25451, 25452, 25455, 25456, 25458, 25459, 25460, 25461, 25464, 25465, 25468, 25469, 25470, 25471, 25473, 25475, 25476, 25477, 25478, 25483, 25485, 25489, 25491, 25492, 25493, 25495, 25497, 25498, 25499, 25500, 25501, 25502, 25503, 25505, 25508, 25510, 25515, 25519, 25521, 25522, 25525, 25526, 25529, 25531, 25533, 25535, 25536, 25537, 25538, 25539, 25541, 25543, 25544, 25546, 25547, 25548, 25553, 25555, 25556, 25557, 25559, 25560, 25561, 25562, 25563, 25564, 25565, 25567, 25570, 25572, 25573, 25574, 25575, 25576, 25579, 25580, 25582, 25583, 25584, 25585, 25587, 25589, 25591, 25593, 25594, 25595, 25596, 25598, 25603, 25604, 25606, 25607, 25608, 25609, 25610, 25613, 25614, 25617, 25618, 25621, 25622, 25623, 25624, 25625, 25626, 25629, 25631, 25634, 25635, 25636, 25637, 25639, 25640, 25641, 25643, 25646, 25647, 25648, 25649, 25650, 25651, 25653, 25654, 25655, 25656, 25657, 25659, 25660, 25662, 25664, 25666, 25667, 25673, 25675, 25676, 25677, 25678, 25679, 25680, 25681, 25683, 25685, 25686, 25687, 25689, 25690, 25691, 25692, 25693, 25695, 25696, 25697, 25698, 25699, 25700, 25701, 25702, 25704, 25706, 25707, 25708, 25710, 25711, 25712, 25713, 25714, 25715, 25716, 25717, 25718, 25719, 25723, 25724, 25725, 25726, 25727, 25728, 25729, 25731, 25734, 25736, 25737, 25738, 25739, 25740, 25741, 25742, 25743, 25744, 25747, 25748, 25751, 25752, 25754, 25755, 25756, 25757, 25759, 25760, 25761, 25762, 25763, 25765, 25766, 25767, 25768, 25770, 25771, 25775, 25777, 25778, 25779, 25780, 25782, 25785, 25787, 25789, 25790, 25791, 25793, 25795, 25796, 25798, 25799, 25800, 25801, 25802, 25803, 25804, 25807, 25809, 25811, 25812, 25813, 25814, 25817, 25818, 25819, 25820, 25821, 25823, 25824, 25825, 25827, 25829, 25831, 25832, 25833, 25834, 25835, 25836, 25837, 25838, 25839, 25840, 25841, 25842, 25843, 25844, 25845, 25846, 25847, 25848, 25849, 25850, 25851, 25852, 25853, 25854, 25855, 25857, 25858, 25859, 25860, 25861, 25862, 25863, 25864, 25866, 25867, 25868, 25869, 25870, 25871, 25872, 25873, 25875, 25876, 25877, 25878, 25879, 25881, 25882, 25883, 25884, 25885, 25886, 25887, 25888, 25889, 25890, 25891, 25892, 25894, 25895, 25896, 25897, 25898, 25900, 25901, 25904, 25905, 25906, 25907, 25911, 25914, 25916, 25917, 25920, 25921, 25922, 25923, 25924, 25926, 25927, 25930, 25931, 25933, 25934, 25936, 25938, 25939, 25940, 25943, 25944, 25946, 25948, 25951, 25952, 25953, 25956, 25957, 25959, 25960, 25961, 25962, 25965, 25966, 25967, 25969, 25971, 25973, 25974, 25976, 25977, 25978, 25979, 25980, 25981, 25982, 25983, 25984, 25985, 25986, 25987, 25988, 25989, 25990, 25992, 25993, 25994, 25997, 25998, 25999, 26002, 26004, 26005, 26006, 26008, 26010, 26013, 26014, 26016, 26018, 26019, 26022, 26024, 26026, 26028, 26030, 26033, 26034, 26035, 26036, 26037, 26038, 26039, 26040, 26042, 26043, 26046, 26047, 26048, 26050, 26055, 26056, 26057, 26058, 26061, 26064, 26065, 26067, 26068, 26069, 26072, 26073, 26074, 26075, 26076, 26077, 26078, 26079, 26081, 26083, 26084, 26090, 26091, 26098, 26099, 26100, 26101, 26104, 26105, 26107, 26108, 26109, 26110, 26111, 26113, 26116, 26117, 26119, 26120, 26121, 26123, 26125, 26128, 26129, 26130, 26134, 26135, 26136, 26138, 26139, 26140, 26142, 26145, 26146, 26147, 26148, 26150, 26153, 26154, 26155, 26156, 26158, 26160, 26162, 26163, 26167, 26168, 26169, 26170, 26171, 26173, 26175, 26176, 26178, 26180, 26181, 26182, 26183, 26184, 26185, 26186, 26189, 26190, 26192, 26193, 26200, 26201, 26203, 26204, 26205, 26206, 26208, 26210, 26211, 26213, 26215, 26217, 26218, 26219, 26220, 26221, 26225, 26226, 26227, 26229, 26232, 26233, 26235, 26236, 26237, 26239, 26240, 26241, 26243, 26245, 26246, 26248, 26249, 26250, 26251, 26253, 26254, 26255, 26256, 26258, 26259, 26260, 26261, 26264, 26265, 26266, 26267, 26268, 26270, 26271, 26272, 26273, 26274, 26275, 26276, 26277, 26278, 26281, 26282, 26283, 26284, 26285, 26287, 26288, 26289, 26290, 26291, 26293, 26294, 26295, 26296, 26298, 26299, 26300, 26301, 26303, 26304, 26305, 26306, 26307, 26308, 26309, 26310, 26311, 26312, 26313, 26314, 26315, 26316, 26317, 26318, 26319, 26320, 26321, 26322, 26323, 26324, 26325, 26326, 26327, 26328, 26330, 26334, 26335, 26336, 26337, 26338, 26339, 26340, 26341, 26343, 26344, 26346, 26347, 26348, 26349, 26350, 26351, 26353, 26357, 26358, 26360, 26362, 26363, 26365, 26369, 26370, 26371, 26372, 26373, 26374, 26375, 26380, 26382, 26383, 26385, 26386, 26387, 26390, 26392, 26393, 26394, 26396, 26398, 26400, 26401, 26402, 26403, 26404, 26405, 26407, 26409, 26414, 26416, 26418, 26419, 26422, 26423, 26424, 26425, 26427, 26428, 26430, 26431, 26433, 26436, 26437, 26439, 26442, 26443, 26445, 26450, 26452, 26453, 26455, 26456, 26457, 26458, 26459, 26461, 26466, 26467, 26468, 26470, 26471, 26475, 26476, 26478, 26481, 26484, 26486, 26488, 26489, 26490, 26491, 26493, 26496, 26498, 26499, 26501, 26502, 26504, 26506, 26508, 26509, 26510, 26511, 26513, 26514, 26515, 26516, 26518, 26521, 26523, 26527, 26528, 26529, 26532, 26534, 26537, 26540, 26542, 26545, 26546, 26548, 26553, 26554, 26555, 26556, 26557, 26558, 26559, 26560, 26562, 26565, 26566, 26567, 26568, 26569, 26570, 26571, 26572, 26573, 26574, 26581, 26582, 26583, 26587, 26591, 26593, 26595, 26596, 26598, 26599, 26600, 26602, 26603, 26605, 26606, 26610, 26613, 26614, 26615, 26616, 26617, 26618, 26619, 26620, 26622, 26625, 26626, 26627, 26628, 26630, 26637, 26640, 26642, 26644, 26645, 26648, 26649, 26650, 26651, 26652, 26654, 26655, 26656, 26658, 26659, 26660, 26661, 26662, 26663, 26664, 26667, 26668, 26669, 26670, 26671, 26672, 26673, 26676, 26677, 26678, 26682, 26683, 26687, 26695, 26699, 26701, 26703, 26706, 26710, 26711, 26712, 26713, 26714, 26715, 26716, 26717, 26718, 26719, 26730, 26732, 26733, 26734, 26735, 26736, 26737, 26738, 26739, 26741, 26744, 26745, 26746, 26747, 26748, 26749, 26750, 26751, 26752, 26754, 26756, 26759, 26760, 26761, 26762, 26763, 26764, 26765, 26766, 26768, 26769, 26770, 26772, 26773, 26774, 26776, 26777, 26778, 26779, 26780, 26781, 26782, 26783, 26784, 26785, 26787, 26788, 26789, 26793, 26794, 26795, 26796, 26798, 26801, 26802, 26804, 26806, 26807, 26808, 26809, 26810, 26811, 26812, 26813, 26814, 26815, 26817, 26819, 26820, 26821, 26822, 26823, 26824, 26826, 26828, 26830, 26831, 26832, 26833, 26835, 26836, 26838, 26839, 26841, 26843, 26844, 26845, 26846, 26847, 26849, 26850, 26852, 26853, 26854, 26855, 26856, 26857, 26858, 26859, 26860, 26861, 26863, 26866, 26867, 26868, 26870, 26871, 26872, 26875, 26877, 26878, 26879, 26880, 26882, 26883, 26884, 26886, 26887, 26888, 26889, 26890, 26892, 26895, 26897, 26899, 26900, 26901, 26902, 26903, 26904, 26905, 26906, 26907, 26908, 26909, 26910, 26913, 26914, 26915, 26917, 26918, 26919, 26920, 26921, 26922, 26923, 26924, 26926, 26927, 26929, 26930, 26931, 26933, 26934, 26935, 26936, 26938, 26939, 26940, 26942, 26944, 26945, 26947, 26948, 26949, 26950, 26951, 26952, 26953, 26954, 26955, 26956, 26957, 26958, 26959, 26960, 26961, 26962, 26963, 26965, 26966, 26968, 26969, 26971, 26972, 26975, 26977, 26978, 26980, 26981, 26983, 26984, 26985, 26986, 26988, 26989, 26991, 26992, 26994, 26995, 26996, 26997, 26998, 27002, 27003, 27005, 27006, 27007, 27009, 27011, 27013, 27018, 27019, 27020, 27022, 27023, 27024, 27025, 27026, 27027, 27030, 27031, 27033, 27034, 27037, 27038, 27039, 27040, 27041, 27042, 27043, 27044, 27045, 27046, 27049, 27050, 27052, 27054, 27055, 27056, 27058, 27059, 27061, 27062, 27064, 27065, 27066, 27068, 27069, 27070, 27071, 27072, 27074, 27075, 27076, 27077, 27078, 27079, 27080, 27081, 27083, 27085, 27087, 27089, 27090, 27091, 27093, 27094, 27095, 27096, 27097, 27098, 27100, 27101, 27102, 27105, 27106, 27107, 27108, 27109, 27110, 27111, 27112, 27113, 27114, 27115, 27116, 27118, 27119, 27120, 27121, 27123, 27124, 27125, 27126, 27127, 27128, 27129, 27130, 27131, 27132, 27134, 27136, 27137, 27138, 27139, 27140, 27141, 27142, 27143, 27144, 27145, 27147, 27148, 27149, 27150, 27151, 27152, 27153, 27154, 27155, 27156, 27157, 27158, 27161, 27162, 27163, 27164, 27165, 27166, 27168, 27170, 27171, 27172, 27173, 27174, 27175, 27177, 27179, 27180, 27181, 27182, 27184, 27186, 27187, 27188, 27190, 27191, 27192, 27193, 27194, 27195, 27196, 27199, 27200, 27201, 27202, 27203, 27205, 27206, 27208, 27209, 27210, 27211, 27212, 27213, 27214, 27215, 27217, 27218, 27219, 27220, 27221, 27222, 27223, 27226, 27228, 27229, 27230, 27231, 27232, 27234, 27235, 27236, 27238, 27239, 27240, 27241, 27242, 27243, 27244, 27245, 27246, 27247, 27248, 27250, 27251, 27252, 27253, 27254, 27255, 27256, 27258, 27259, 27261, 27262, 27263, 27265, 27266, 27267, 27269, 27270, 27271, 27272, 27273, 27274, 27275, 27276, 27277, 27279, 27282, 27283, 27284, 27285, 27286, 27288, 27289, 27290, 27291, 27292, 27293, 27294, 27295, 27297, 27298, 27299, 27300, 27301, 27302, 27303, 27304, 27306, 27309, 27310, 27311, 27312, 27313, 27314, 27315, 27316, 27317, 27318, 27319, 27320, 27321, 27322, 27323, 27324, 27325, 27326, 27327, 27328, 27329, 27330, 27331, 27332, 27333, 27334, 27335, 27336, 27337, 27338, 27339, 27340, 27341, 27342, 27343, 27344, 27345, 27346, 27347, 27348, 27349, 27350, 27351, 27352, 27353, 27354, 27355, 27356, 27357, 27358, 27359, 27360, 27361, 27362, 27363, 27364, 27365, 27366, 27367, 27368, 27369, 27370, 27371, 27372, 27373, 27374, 27375, 27376, 27377, 27378, 27379, 27380, 27381, 27382, 27383, 27384, 27385, 27386, 27387, 27388, 27389, 27390, 27391, 27392, 27393, 27394, 27395, 27396, 27397, 27398, 27399, 27400, 27401, 27402, 27403, 27404, 27405, 27406, 27407, 27408, 27409, 27410, 27411, 27412, 27413, 27414, 27415, 27416, 27417, 27418, 27419, 27420, 27421, 27422, 27423, 27429, 27430, 27432, 27433, 27434, 27435, 27436, 27437, 27438, 27439, 27440, 27441, 27443, 27444, 27445, 27446, 27448, 27451, 27452, 27453, 27455, 27456, 27457, 27458, 27460, 27461, 27464, 27466, 27467, 27469, 27470, 27471, 27472, 27473, 27474, 27475, 27476, 27477, 27478, 27479, 27480, 27482, 27483, 27484, 27485, 27486, 27487, 27488, 27489, 27496, 27497, 27499, 27500, 27501, 27502, 27503, 27504, 27505, 27506, 27507, 27508, 27509, 27510, 27511, 27512, 27514, 27517, 27518, 27519, 27520, 27525, 27528, 27532, 27534, 27535, 27536, 27537, 27540, 27541, 27543, 27544, 27545, 27548, 27549, 27550, 27551, 27552, 27554, 27555, 27556, 27557, 27558, 27559, 27560, 27561, 27563, 27564, 27565, 27566, 27567, 27568, 27569, 27570, 27574, 27576, 27577, 27578, 27579, 27580, 27581, 27582, 27584, 27587, 27588, 27590, 27591, 27592, 27593, 27594, 27596, 27598, 27600, 27601, 27608, 27610, 27612, 27613, 27614, 27615, 27616, 27618, 27619, 27620, 27621, 27622, 27623, 27624, 27625, 27628, 27629, 27630, 27632, 27633, 27634, 27636, 27638, 27639, 27640, 27642, 27643, 27644, 27646, 27647, 27648, 27649, 27650, 27651, 27652, 27656, 27657, 27658, 27659, 27660, 27662, 27666, 27671, 27676, 27677, 27678, 27680, 27683, 27685, 27691, 27692, 27693, 27697, 27699, 27702, 27703, 27705, 27706, 27707, 27708, 27710, 27711, 27715, 27716, 27717, 27720, 27723, 27724, 27725, 27726, 27727, 27729, 27730, 27731, 27734, 27736, 27737, 27738, 27746, 27747, 27749, 27750, 27751, 27755, 27756, 27757, 27758, 27759, 27761, 27763, 27765, 27767, 27768, 27770, 27771, 27772, 27775, 27776, 27780, 27783, 27786, 27787, 27789, 27790, 27793, 27794, 27797, 27798, 27799, 27800, 27802, 27804, 27805, 27806, 27808, 27810, 27816, 27820, 27823, 27824, 27828, 27829, 27830, 27831, 27834, 27840, 27841, 27842, 27843, 27846, 27847, 27848, 27851, 27853, 27854, 27855, 27857, 27858, 27864, 27865, 27866, 27868, 27869, 27871, 27876, 27878, 27879, 27881, 27884, 27885, 27890, 27892, 27897, 27903, 27904, 27906, 27907, 27909, 27910, 27912, 27913, 27914, 27917, 27919, 27920, 27921, 27923, 27924, 27925, 27926, 27928, 27932, 27933, 27935, 27936, 27937, 27938, 27939, 27940, 27942, 27944, 27945, 27948, 27949, 27951, 27952, 27956, 27958, 27959, 27960, 27962, 27967, 27968, 27970, 27972, 27977, 27980, 27984, 27989, 27990, 27991, 27992, 27995, 27997, 27999, 28001, 28002, 28004, 28005, 28007, 28008, 28011, 28012, 28013, 28016, 28017, 28018, 28019, 28021, 28022, 28025, 28026, 28027, 28029, 28030, 28031, 28032, 28033, 28035, 28036, 28038, 28039, 28042, 28043, 28045, 28047, 28048, 28050, 28054, 28055, 28056, 28057, 28058, 28060, 28066, 28069, 28076, 28077, 28080, 28081, 28083, 28084, 28086, 28087, 28089, 28090, 28091, 28092, 28093, 28094, 28097, 28098, 28099, 28104, 28105, 28106, 28109, 28110, 28111, 28112, 28114, 28115, 28116, 28117, 28119, 28122, 28123, 28124, 28127, 28130, 28131, 28133, 28135, 28136, 28137, 28138, 28141, 28143, 28144, 28146, 28148, 28149, 28150, 28152, 28154, 28157, 28158, 28159, 28160, 28161, 28162, 28163, 28164, 28166, 28167, 28168, 28169, 28171, 28175, 28178, 28179, 28181, 28184, 28185, 28187, 28188, 28190, 28191, 28194, 28198, 28199, 28200, 28202, 28204, 28206, 28208, 28209, 28211, 28213, 28214, 28215, 28217, 28219, 28220, 28221, 28222, 28223, 28224, 28225, 28226, 28229, 28230, 28231, 28232, 28233, 28234, 28235, 28236, 28239, 28240, 28241, 28242, 28245, 28247, 28249, 28250, 28252, 28253, 28254, 28256, 28257, 28258, 28259, 28260, 28261, 28262, 28263, 28264, 28265, 28266, 28268, 28269, 28271, 28272, 28273, 28274, 28275, 28276, 28277, 28278, 28279, 28280, 28281, 28282, 28283, 28284, 28285, 28288, 28289, 28290, 28292, 28295, 28296, 28298, 28299, 28300, 28301, 28302, 28305, 28306, 28307, 28308, 28309, 28310, 28311, 28313, 28314, 28315, 28317, 28318, 28320, 28321, 28323, 28324, 28326, 28328, 28329, 28331, 28332, 28333, 28334, 28336, 28339, 28341, 28344, 28345, 28348, 28350, 28351, 28352, 28355, 28356, 28357, 28358, 28360, 28361, 28362, 28364, 28365, 28366, 28368, 28370, 28374, 28376, 28377, 28379, 28380, 28381, 28387, 28391, 28394, 28395, 28396, 28397, 28398, 28399, 28400, 28401, 28402, 28403, 28405, 28406, 28407, 28408, 28410, 28411, 28412, 28413, 28414, 28415, 28416, 28417, 28419, 28420, 28421, 28423, 28424, 28426, 28427, 28428, 28429, 28430, 28432, 28433, 28434, 28438, 28439, 28440, 28441, 28442, 28443, 28444, 28445, 28446, 28447, 28449, 28450, 28451, 28453, 28454, 28455, 28456, 28460, 28462, 28464, 28466, 28468, 28469, 28471, 28472, 28473, 28474, 28475, 28476, 28477, 28479, 28480, 28481, 28482, 28483, 28484, 28485, 28488, 28489, 28490, 28492, 28494, 28495, 28496, 28497, 28498, 28499, 28500, 28501, 28502, 28503, 28505, 28506, 28507, 28509, 28511, 28512, 28513, 28515, 28516, 28517, 28519, 28520, 28521, 28522, 28523, 28524, 28527, 28528, 28529, 28531, 28533, 28534, 28535, 28537, 28539, 28541, 28542, 28543, 28544, 28545, 28546, 28547, 28549, 28550, 28551, 28554, 28555, 28559, 28560, 28561, 28562, 28563, 28564, 28565, 28566, 28567, 28568, 28569, 28570, 28571, 28573, 28574, 28575, 28576, 28578, 28579, 28580, 28581, 28582, 28584, 28585, 28586, 28587, 28588, 28589, 28590, 28591, 28592, 28593, 28594, 28596, 28597, 28599, 28600, 28602, 28603, 28604, 28605, 28606, 28607, 28609, 28611, 28612, 28613, 28614, 28615, 28616, 28618, 28619, 28620, 28621, 28622, 28623, 28624, 28627, 28628, 28629, 28630, 28631, 28632, 28633, 28634, 28635, 28636, 28637, 28639, 28642, 28643, 28644, 28645, 28646, 28647, 28648, 28649, 28650, 28651, 28652, 28653, 28656, 28657, 28658, 28659, 28660, 28661, 28662, 28663, 28664, 28665, 28666, 28667, 28668, 28669, 28670, 28671, 28672, 28673, 28674, 28675, 28676, 28677, 28678, 28679, 28680, 28681, 28682, 28683, 28684, 28685, 28686, 28687, 28688, 28690, 28691, 28692, 28693, 28694, 28695, 28696, 28697, 28700, 28701, 28702, 28703, 28704, 28705, 28706, 28708, 28709, 28710, 28711, 28712, 28713, 28714, 28715, 28716, 28717, 28718, 28719, 28720, 28721, 28722, 28723, 28724, 28726, 28727, 28728, 28730, 28731, 28732, 28733, 28734, 28735, 28736, 28737, 28738, 28739, 28740, 28741, 28742, 28743, 28744, 28745, 28746, 28747, 28749, 28750, 28752, 28753, 28754, 28755, 28756, 28757, 28758, 28759, 28760, 28761, 28762, 28763, 28764, 28765, 28767, 28768, 28769, 28770, 28771, 28772, 28773, 28774, 28775, 28776, 28777, 28778, 28782, 28785, 28786, 28787, 28788, 28791, 28793, 28794, 28795, 28797, 28801, 28802, 28803, 28804, 28806, 28807, 28808, 28811, 28812, 28813, 28815, 28816, 28817, 28819, 28823, 28824, 28826, 28827, 28830, 28831, 28832, 28833, 28834, 28835, 28836, 28837, 28838, 28839, 28840, 28841, 28842, 28848, 28850, 28852, 28853, 28854, 28858, 28862, 28863, 28868, 28869, 28870, 28871, 28873, 28875, 28876, 28877, 28878, 28879, 28880, 28881, 28882, 28883, 28884, 28885, 28886, 28887, 28890, 28892, 28893, 28894, 28896, 28897, 28898, 28899, 28901, 28906, 28910, 28912, 28913, 28914, 28915, 28916, 28917, 28918, 28920, 28922, 28923, 28924, 28926, 28927, 28928, 28929, 28930, 28931, 28932, 28933, 28934, 28935, 28936, 28939, 28940, 28941, 28942, 28943, 28945, 28946, 28948, 28951, 28955, 28956, 28957, 28958, 28959, 28960, 28961, 28962, 28963, 28964, 28965, 28967, 28968, 28969, 28970, 28971, 28972, 28973, 28974, 28978, 28979, 28980, 28981, 28983, 28984, 28985, 28986, 28987, 28988, 28989, 28990, 28991, 28992, 28993, 28994, 28995, 28996, 28998, 28999, 29e3, 29001, 29003, 29005, 29007, 29008, 29009, 29010, 29011, 29012, 29013, 29014, 29015, 29016, 29017, 29018, 29019, 29021, 29023, 29024, 29025, 29026, 29027, 29029, 29033, 29034, 29035, 29036, 29037, 29039, 29040, 29041, 29044, 29045, 29046, 29047, 29049, 29051, 29052, 29054, 29055, 29056, 29057, 29058, 29059, 29061, 29062, 29063, 29064, 29065, 29067, 29068, 29069, 29070, 29072, 29073, 29074, 29075, 29077, 29078, 29079, 29082, 29083, 29084, 29085, 29086, 29089, 29090, 29091, 29092, 29093, 29094, 29095, 29097, 29098, 29099, 29101, 29102, 29103, 29104, 29105, 29106, 29108, 29110, 29111, 29112, 29114, 29115, 29116, 29117, 29118, 29119, 29120, 29121, 29122, 29124, 29125, 29126, 29127, 29128, 29129, 29130, 29131, 29132, 29133, 29135, 29136, 29137, 29138, 29139, 29142, 29143, 29144, 29145, 29146, 29147, 29148, 29149, 29150, 29151, 29153, 29154, 29155, 29156, 29158, 29160, 29161, 29162, 29163, 29164, 29165, 29167, 29168, 29169, 29170, 29171, 29172, 29173, 29174, 29175, 29176, 29178, 29179, 29180, 29181, 29182, 29183, 29184, 29185, 29186, 29187, 29188, 29189, 29191, 29192, 29193, 29194, 29195, 29196, 29197, 29198, 29199, 29200, 29201, 29202, 29203, 29204, 29205, 29206, 29207, 29208, 29209, 29210, 29211, 29212, 29214, 29215, 29216, 29217, 29218, 29219, 29220, 29221, 29222, 29223, 29225, 29227, 29229, 29230, 29231, 29234, 29235, 29236, 29242, 29244, 29246, 29248, 29249, 29250, 29251, 29252, 29253, 29254, 29257, 29258, 29259, 29262, 29263, 29264, 29265, 29267, 29268, 29269, 29271, 29272, 29274, 29276, 29278, 29280, 29283, 29284, 29285, 29288, 29290, 29291, 29292, 29293, 29296, 29297, 29299, 29300, 29302, 29303, 29304, 29307, 29308, 29309, 29314, 29315, 29317, 29318, 29319, 29320, 29321, 29324, 29326, 29328, 29329, 29331, 29332, 29333, 29334, 29335, 29336, 29337, 29338, 29339, 29340, 29341, 29342, 29344, 29345, 29346, 29347, 29348, 29349, 29350, 29351, 29352, 29353, 29354, 29355, 29358, 29361, 29362, 29363, 29365, 29370, 29371, 29372, 29373, 29374, 29375, 29376, 29381, 29382, 29383, 29385, 29386, 29387, 29388, 29391, 29393, 29395, 29396, 29397, 29398, 29400, 29402, 29403, 58566, 58567, 58568, 58569, 58570, 58571, 58572, 58573, 58574, 58575, 58576, 58577, 58578, 58579, 58580, 58581, 58582, 58583, 58584, 58585, 58586, 58587, 58588, 58589, 58590, 58591, 58592, 58593, 58594, 58595, 58596, 58597, 58598, 58599, 58600, 58601, 58602, 58603, 58604, 58605, 58606, 58607, 58608, 58609, 58610, 58611, 58612, 58613, 58614, 58615, 58616, 58617, 58618, 58619, 58620, 58621, 58622, 58623, 58624, 58625, 58626, 58627, 58628, 58629, 58630, 58631, 58632, 58633, 58634, 58635, 58636, 58637, 58638, 58639, 58640, 58641, 58642, 58643, 58644, 58645, 58646, 58647, 58648, 58649, 58650, 58651, 58652, 58653, 58654, 58655, 58656, 58657, 58658, 58659, 58660, 58661, 12288, 12289, 12290, 183, 713, 711, 168, 12291, 12293, 8212, 65374, 8214, 8230, 8216, 8217, 8220, 8221, 12308, 12309, 12296, 12297, 12298, 12299, 12300, 12301, 12302, 12303, 12310, 12311, 12304, 12305, 177, 215, 247, 8758, 8743, 8744, 8721, 8719, 8746, 8745, 8712, 8759, 8730, 8869, 8741, 8736, 8978, 8857, 8747, 8750, 8801, 8780, 8776, 8765, 8733, 8800, 8814, 8815, 8804, 8805, 8734, 8757, 8756, 9794, 9792, 176, 8242, 8243, 8451, 65284, 164, 65504, 65505, 8240, 167, 8470, 9734, 9733, 9675, 9679, 9678, 9671, 9670, 9633, 9632, 9651, 9650, 8251, 8594, 8592, 8593, 8595, 12307, 58662, 58663, 58664, 58665, 58666, 58667, 58668, 58669, 58670, 58671, 58672, 58673, 58674, 58675, 58676, 58677, 58678, 58679, 58680, 58681, 58682, 58683, 58684, 58685, 58686, 58687, 58688, 58689, 58690, 58691, 58692, 58693, 58694, 58695, 58696, 58697, 58698, 58699, 58700, 58701, 58702, 58703, 58704, 58705, 58706, 58707, 58708, 58709, 58710, 58711, 58712, 58713, 58714, 58715, 58716, 58717, 58718, 58719, 58720, 58721, 58722, 58723, 58724, 58725, 58726, 58727, 58728, 58729, 58730, 58731, 58732, 58733, 58734, 58735, 58736, 58737, 58738, 58739, 58740, 58741, 58742, 58743, 58744, 58745, 58746, 58747, 58748, 58749, 58750, 58751, 58752, 58753, 58754, 58755, 58756, 58757, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 59238, 59239, 59240, 59241, 59242, 59243, 9352, 9353, 9354, 9355, 9356, 9357, 9358, 9359, 9360, 9361, 9362, 9363, 9364, 9365, 9366, 9367, 9368, 9369, 9370, 9371, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349, 9350, 9351, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 8364, 59245, 12832, 12833, 12834, 12835, 12836, 12837, 12838, 12839, 12840, 12841, 59246, 59247, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 8554, 8555, 59248, 59249, 58758, 58759, 58760, 58761, 58762, 58763, 58764, 58765, 58766, 58767, 58768, 58769, 58770, 58771, 58772, 58773, 58774, 58775, 58776, 58777, 58778, 58779, 58780, 58781, 58782, 58783, 58784, 58785, 58786, 58787, 58788, 58789, 58790, 58791, 58792, 58793, 58794, 58795, 58796, 58797, 58798, 58799, 58800, 58801, 58802, 58803, 58804, 58805, 58806, 58807, 58808, 58809, 58810, 58811, 58812, 58813, 58814, 58815, 58816, 58817, 58818, 58819, 58820, 58821, 58822, 58823, 58824, 58825, 58826, 58827, 58828, 58829, 58830, 58831, 58832, 58833, 58834, 58835, 58836, 58837, 58838, 58839, 58840, 58841, 58842, 58843, 58844, 58845, 58846, 58847, 58848, 58849, 58850, 58851, 58852, 12288, 65281, 65282, 65283, 65509, 65285, 65286, 65287, 65288, 65289, 65290, 65291, 65292, 65293, 65294, 65295, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, 65306, 65307, 65308, 65309, 65310, 65311, 65312, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, 65339, 65340, 65341, 65342, 65343, 65344, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 65371, 65372, 65373, 65507, 58854, 58855, 58856, 58857, 58858, 58859, 58860, 58861, 58862, 58863, 58864, 58865, 58866, 58867, 58868, 58869, 58870, 58871, 58872, 58873, 58874, 58875, 58876, 58877, 58878, 58879, 58880, 58881, 58882, 58883, 58884, 58885, 58886, 58887, 58888, 58889, 58890, 58891, 58892, 58893, 58894, 58895, 58896, 58897, 58898, 58899, 58900, 58901, 58902, 58903, 58904, 58905, 58906, 58907, 58908, 58909, 58910, 58911, 58912, 58913, 58914, 58915, 58916, 58917, 58918, 58919, 58920, 58921, 58922, 58923, 58924, 58925, 58926, 58927, 58928, 58929, 58930, 58931, 58932, 58933, 58934, 58935, 58936, 58937, 58938, 58939, 58940, 58941, 58942, 58943, 58944, 58945, 58946, 58947, 58948, 58949, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, 59250, 59251, 59252, 59253, 59254, 59255, 59256, 59257, 59258, 59259, 59260, 58950, 58951, 58952, 58953, 58954, 58955, 58956, 58957, 58958, 58959, 58960, 58961, 58962, 58963, 58964, 58965, 58966, 58967, 58968, 58969, 58970, 58971, 58972, 58973, 58974, 58975, 58976, 58977, 58978, 58979, 58980, 58981, 58982, 58983, 58984, 58985, 58986, 58987, 58988, 58989, 58990, 58991, 58992, 58993, 58994, 58995, 58996, 58997, 58998, 58999, 59e3, 59001, 59002, 59003, 59004, 59005, 59006, 59007, 59008, 59009, 59010, 59011, 59012, 59013, 59014, 59015, 59016, 59017, 59018, 59019, 59020, 59021, 59022, 59023, 59024, 59025, 59026, 59027, 59028, 59029, 59030, 59031, 59032, 59033, 59034, 59035, 59036, 59037, 59038, 59039, 59040, 59041, 59042, 59043, 59044, 59045, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, 59261, 59262, 59263, 59264, 59265, 59266, 59267, 59268, 59046, 59047, 59048, 59049, 59050, 59051, 59052, 59053, 59054, 59055, 59056, 59057, 59058, 59059, 59060, 59061, 59062, 59063, 59064, 59065, 59066, 59067, 59068, 59069, 59070, 59071, 59072, 59073, 59074, 59075, 59076, 59077, 59078, 59079, 59080, 59081, 59082, 59083, 59084, 59085, 59086, 59087, 59088, 59089, 59090, 59091, 59092, 59093, 59094, 59095, 59096, 59097, 59098, 59099, 59100, 59101, 59102, 59103, 59104, 59105, 59106, 59107, 59108, 59109, 59110, 59111, 59112, 59113, 59114, 59115, 59116, 59117, 59118, 59119, 59120, 59121, 59122, 59123, 59124, 59125, 59126, 59127, 59128, 59129, 59130, 59131, 59132, 59133, 59134, 59135, 59136, 59137, 59138, 59139, 59140, 59141, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 59269, 59270, 59271, 59272, 59273, 59274, 59275, 59276, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, 59277, 59278, 59279, 59280, 59281, 59282, 59283, 65077, 65078, 65081, 65082, 65087, 65088, 65085, 65086, 65089, 65090, 65091, 65092, 59284, 59285, 65083, 65084, 65079, 65080, 65073, 59286, 65075, 65076, 59287, 59288, 59289, 59290, 59291, 59292, 59293, 59294, 59295, 59142, 59143, 59144, 59145, 59146, 59147, 59148, 59149, 59150, 59151, 59152, 59153, 59154, 59155, 59156, 59157, 59158, 59159, 59160, 59161, 59162, 59163, 59164, 59165, 59166, 59167, 59168, 59169, 59170, 59171, 59172, 59173, 59174, 59175, 59176, 59177, 59178, 59179, 59180, 59181, 59182, 59183, 59184, 59185, 59186, 59187, 59188, 59189, 59190, 59191, 59192, 59193, 59194, 59195, 59196, 59197, 59198, 59199, 59200, 59201, 59202, 59203, 59204, 59205, 59206, 59207, 59208, 59209, 59210, 59211, 59212, 59213, 59214, 59215, 59216, 59217, 59218, 59219, 59220, 59221, 59222, 59223, 59224, 59225, 59226, 59227, 59228, 59229, 59230, 59231, 59232, 59233, 59234, 59235, 59236, 59237, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 59296, 59297, 59298, 59299, 59300, 59301, 59302, 59303, 59304, 59305, 59306, 59307, 59308, 59309, 59310, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 59311, 59312, 59313, 59314, 59315, 59316, 59317, 59318, 59319, 59320, 59321, 59322, 59323, 714, 715, 729, 8211, 8213, 8229, 8245, 8453, 8457, 8598, 8599, 8600, 8601, 8725, 8735, 8739, 8786, 8806, 8807, 8895, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9581, 9582, 9583, 9584, 9585, 9586, 9587, 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608, 9609, 9610, 9611, 9612, 9613, 9614, 9615, 9619, 9620, 9621, 9660, 9661, 9698, 9699, 9700, 9701, 9737, 8853, 12306, 12317, 12318, 59324, 59325, 59326, 59327, 59328, 59329, 59330, 59331, 59332, 59333, 59334, 257, 225, 462, 224, 275, 233, 283, 232, 299, 237, 464, 236, 333, 243, 466, 242, 363, 250, 468, 249, 470, 472, 474, 476, 252, 234, 593, 7743, 324, 328, 505, 609, 59337, 59338, 59339, 59340, 12549, 12550, 12551, 12552, 12553, 12554, 12555, 12556, 12557, 12558, 12559, 12560, 12561, 12562, 12563, 12564, 12565, 12566, 12567, 12568, 12569, 12570, 12571, 12572, 12573, 12574, 12575, 12576, 12577, 12578, 12579, 12580, 12581, 12582, 12583, 12584, 12585, 59341, 59342, 59343, 59344, 59345, 59346, 59347, 59348, 59349, 59350, 59351, 59352, 59353, 59354, 59355, 59356, 59357, 59358, 59359, 59360, 59361, 12321, 12322, 12323, 12324, 12325, 12326, 12327, 12328, 12329, 12963, 13198, 13199, 13212, 13213, 13214, 13217, 13252, 13262, 13265, 13266, 13269, 65072, 65506, 65508, 59362, 8481, 12849, 59363, 8208, 59364, 59365, 59366, 12540, 12443, 12444, 12541, 12542, 12294, 12445, 12446, 65097, 65098, 65099, 65100, 65101, 65102, 65103, 65104, 65105, 65106, 65108, 65109, 65110, 65111, 65113, 65114, 65115, 65116, 65117, 65118, 65119, 65120, 65121, 65122, 65123, 65124, 65125, 65126, 65128, 65129, 65130, 65131, 12350, 12272, 12273, 12274, 12275, 12276, 12277, 12278, 12279, 12280, 12281, 12282, 12283, 12295, 59380, 59381, 59382, 59383, 59384, 59385, 59386, 59387, 59388, 59389, 59390, 59391, 59392, 9472, 9473, 9474, 9475, 9476, 9477, 9478, 9479, 9480, 9481, 9482, 9483, 9484, 9485, 9486, 9487, 9488, 9489, 9490, 9491, 9492, 9493, 9494, 9495, 9496, 9497, 9498, 9499, 9500, 9501, 9502, 9503, 9504, 9505, 9506, 9507, 9508, 9509, 9510, 9511, 9512, 9513, 9514, 9515, 9516, 9517, 9518, 9519, 9520, 9521, 9522, 9523, 9524, 9525, 9526, 9527, 9528, 9529, 9530, 9531, 9532, 9533, 9534, 9535, 9536, 9537, 9538, 9539, 9540, 9541, 9542, 9543, 9544, 9545, 9546, 9547, 59393, 59394, 59395, 59396, 59397, 59398, 59399, 59400, 59401, 59402, 59403, 59404, 59405, 59406, 59407, 29404, 29405, 29407, 29410, 29411, 29412, 29413, 29414, 29415, 29418, 29419, 29429, 29430, 29433, 29437, 29438, 29439, 29440, 29442, 29444, 29445, 29446, 29447, 29448, 29449, 29451, 29452, 29453, 29455, 29456, 29457, 29458, 29460, 29464, 29465, 29466, 29471, 29472, 29475, 29476, 29478, 29479, 29480, 29485, 29487, 29488, 29490, 29491, 29493, 29494, 29498, 29499, 29500, 29501, 29504, 29505, 29506, 29507, 29508, 29509, 29510, 29511, 29512, 29513, 29514, 29515, 29516, 29518, 29519, 29521, 29523, 29524, 29525, 29526, 29528, 29529, 29530, 29531, 29532, 29533, 29534, 29535, 29537, 29538, 29539, 29540, 29541, 29542, 29543, 29544, 29545, 29546, 29547, 29550, 29552, 29553, 57344, 57345, 57346, 57347, 57348, 57349, 57350, 57351, 57352, 57353, 57354, 57355, 57356, 57357, 57358, 57359, 57360, 57361, 57362, 57363, 57364, 57365, 57366, 57367, 57368, 57369, 57370, 57371, 57372, 57373, 57374, 57375, 57376, 57377, 57378, 57379, 57380, 57381, 57382, 57383, 57384, 57385, 57386, 57387, 57388, 57389, 57390, 57391, 57392, 57393, 57394, 57395, 57396, 57397, 57398, 57399, 57400, 57401, 57402, 57403, 57404, 57405, 57406, 57407, 57408, 57409, 57410, 57411, 57412, 57413, 57414, 57415, 57416, 57417, 57418, 57419, 57420, 57421, 57422, 57423, 57424, 57425, 57426, 57427, 57428, 57429, 57430, 57431, 57432, 57433, 57434, 57435, 57436, 57437, 29554, 29555, 29556, 29557, 29558, 29559, 29560, 29561, 29562, 29563, 29564, 29565, 29567, 29568, 29569, 29570, 29571, 29573, 29574, 29576, 29578, 29580, 29581, 29583, 29584, 29586, 29587, 29588, 29589, 29591, 29592, 29593, 29594, 29596, 29597, 29598, 29600, 29601, 29603, 29604, 29605, 29606, 29607, 29608, 29610, 29612, 29613, 29617, 29620, 29621, 29622, 29624, 29625, 29628, 29629, 29630, 29631, 29633, 29635, 29636, 29637, 29638, 29639, 29643, 29644, 29646, 29650, 29651, 29652, 29653, 29654, 29655, 29656, 29658, 29659, 29660, 29661, 29663, 29665, 29666, 29667, 29668, 29670, 29672, 29674, 29675, 29676, 29678, 29679, 29680, 29681, 29683, 29684, 29685, 29686, 29687, 57438, 57439, 57440, 57441, 57442, 57443, 57444, 57445, 57446, 57447, 57448, 57449, 57450, 57451, 57452, 57453, 57454, 57455, 57456, 57457, 57458, 57459, 57460, 57461, 57462, 57463, 57464, 57465, 57466, 57467, 57468, 57469, 57470, 57471, 57472, 57473, 57474, 57475, 57476, 57477, 57478, 57479, 57480, 57481, 57482, 57483, 57484, 57485, 57486, 57487, 57488, 57489, 57490, 57491, 57492, 57493, 57494, 57495, 57496, 57497, 57498, 57499, 57500, 57501, 57502, 57503, 57504, 57505, 57506, 57507, 57508, 57509, 57510, 57511, 57512, 57513, 57514, 57515, 57516, 57517, 57518, 57519, 57520, 57521, 57522, 57523, 57524, 57525, 57526, 57527, 57528, 57529, 57530, 57531, 29688, 29689, 29690, 29691, 29692, 29693, 29694, 29695, 29696, 29697, 29698, 29700, 29703, 29704, 29707, 29708, 29709, 29710, 29713, 29714, 29715, 29716, 29717, 29718, 29719, 29720, 29721, 29724, 29725, 29726, 29727, 29728, 29729, 29731, 29732, 29735, 29737, 29739, 29741, 29743, 29745, 29746, 29751, 29752, 29753, 29754, 29755, 29757, 29758, 29759, 29760, 29762, 29763, 29764, 29765, 29766, 29767, 29768, 29769, 29770, 29771, 29772, 29773, 29774, 29775, 29776, 29777, 29778, 29779, 29780, 29782, 29784, 29789, 29792, 29793, 29794, 29795, 29796, 29797, 29798, 29799, 29800, 29801, 29802, 29803, 29804, 29806, 29807, 29809, 29810, 29811, 29812, 29813, 29816, 29817, 29818, 57532, 57533, 57534, 57535, 57536, 57537, 57538, 57539, 57540, 57541, 57542, 57543, 57544, 57545, 57546, 57547, 57548, 57549, 57550, 57551, 57552, 57553, 57554, 57555, 57556, 57557, 57558, 57559, 57560, 57561, 57562, 57563, 57564, 57565, 57566, 57567, 57568, 57569, 57570, 57571, 57572, 57573, 57574, 57575, 57576, 57577, 57578, 57579, 57580, 57581, 57582, 57583, 57584, 57585, 57586, 57587, 57588, 57589, 57590, 57591, 57592, 57593, 57594, 57595, 57596, 57597, 57598, 57599, 57600, 57601, 57602, 57603, 57604, 57605, 57606, 57607, 57608, 57609, 57610, 57611, 57612, 57613, 57614, 57615, 57616, 57617, 57618, 57619, 57620, 57621, 57622, 57623, 57624, 57625, 29819, 29820, 29821, 29823, 29826, 29828, 29829, 29830, 29832, 29833, 29834, 29836, 29837, 29839, 29841, 29842, 29843, 29844, 29845, 29846, 29847, 29848, 29849, 29850, 29851, 29853, 29855, 29856, 29857, 29858, 29859, 29860, 29861, 29862, 29866, 29867, 29868, 29869, 29870, 29871, 29872, 29873, 29874, 29875, 29876, 29877, 29878, 29879, 29880, 29881, 29883, 29884, 29885, 29886, 29887, 29888, 29889, 29890, 29891, 29892, 29893, 29894, 29895, 29896, 29897, 29898, 29899, 29900, 29901, 29902, 29903, 29904, 29905, 29907, 29908, 29909, 29910, 29911, 29912, 29913, 29914, 29915, 29917, 29919, 29921, 29925, 29927, 29928, 29929, 29930, 29931, 29932, 29933, 29936, 29937, 29938, 57626, 57627, 57628, 57629, 57630, 57631, 57632, 57633, 57634, 57635, 57636, 57637, 57638, 57639, 57640, 57641, 57642, 57643, 57644, 57645, 57646, 57647, 57648, 57649, 57650, 57651, 57652, 57653, 57654, 57655, 57656, 57657, 57658, 57659, 57660, 57661, 57662, 57663, 57664, 57665, 57666, 57667, 57668, 57669, 57670, 57671, 57672, 57673, 57674, 57675, 57676, 57677, 57678, 57679, 57680, 57681, 57682, 57683, 57684, 57685, 57686, 57687, 57688, 57689, 57690, 57691, 57692, 57693, 57694, 57695, 57696, 57697, 57698, 57699, 57700, 57701, 57702, 57703, 57704, 57705, 57706, 57707, 57708, 57709, 57710, 57711, 57712, 57713, 57714, 57715, 57716, 57717, 57718, 57719, 29939, 29941, 29944, 29945, 29946, 29947, 29948, 29949, 29950, 29952, 29953, 29954, 29955, 29957, 29958, 29959, 29960, 29961, 29962, 29963, 29964, 29966, 29968, 29970, 29972, 29973, 29974, 29975, 29979, 29981, 29982, 29984, 29985, 29986, 29987, 29988, 29990, 29991, 29994, 29998, 30004, 30006, 30009, 30012, 30013, 30015, 30017, 30018, 30019, 30020, 30022, 30023, 30025, 30026, 30029, 30032, 30033, 30034, 30035, 30037, 30038, 30039, 30040, 30045, 30046, 30047, 30048, 30049, 30050, 30051, 30052, 30055, 30056, 30057, 30059, 30060, 30061, 30062, 30063, 30064, 30065, 30067, 30069, 30070, 30071, 30074, 30075, 30076, 30077, 30078, 30080, 30081, 30082, 30084, 30085, 30087, 57720, 57721, 57722, 57723, 57724, 57725, 57726, 57727, 57728, 57729, 57730, 57731, 57732, 57733, 57734, 57735, 57736, 57737, 57738, 57739, 57740, 57741, 57742, 57743, 57744, 57745, 57746, 57747, 57748, 57749, 57750, 57751, 57752, 57753, 57754, 57755, 57756, 57757, 57758, 57759, 57760, 57761, 57762, 57763, 57764, 57765, 57766, 57767, 57768, 57769, 57770, 57771, 57772, 57773, 57774, 57775, 57776, 57777, 57778, 57779, 57780, 57781, 57782, 57783, 57784, 57785, 57786, 57787, 57788, 57789, 57790, 57791, 57792, 57793, 57794, 57795, 57796, 57797, 57798, 57799, 57800, 57801, 57802, 57803, 57804, 57805, 57806, 57807, 57808, 57809, 57810, 57811, 57812, 57813, 30088, 30089, 30090, 30092, 30093, 30094, 30096, 30099, 30101, 30104, 30107, 30108, 30110, 30114, 30118, 30119, 30120, 30121, 30122, 30125, 30134, 30135, 30138, 30139, 30143, 30144, 30145, 30150, 30155, 30156, 30158, 30159, 30160, 30161, 30163, 30167, 30169, 30170, 30172, 30173, 30175, 30176, 30177, 30181, 30185, 30188, 30189, 30190, 30191, 30194, 30195, 30197, 30198, 30199, 30200, 30202, 30203, 30205, 30206, 30210, 30212, 30214, 30215, 30216, 30217, 30219, 30221, 30222, 30223, 30225, 30226, 30227, 30228, 30230, 30234, 30236, 30237, 30238, 30241, 30243, 30247, 30248, 30252, 30254, 30255, 30257, 30258, 30262, 30263, 30265, 30266, 30267, 30269, 30273, 30274, 30276, 57814, 57815, 57816, 57817, 57818, 57819, 57820, 57821, 57822, 57823, 57824, 57825, 57826, 57827, 57828, 57829, 57830, 57831, 57832, 57833, 57834, 57835, 57836, 57837, 57838, 57839, 57840, 57841, 57842, 57843, 57844, 57845, 57846, 57847, 57848, 57849, 57850, 57851, 57852, 57853, 57854, 57855, 57856, 57857, 57858, 57859, 57860, 57861, 57862, 57863, 57864, 57865, 57866, 57867, 57868, 57869, 57870, 57871, 57872, 57873, 57874, 57875, 57876, 57877, 57878, 57879, 57880, 57881, 57882, 57883, 57884, 57885, 57886, 57887, 57888, 57889, 57890, 57891, 57892, 57893, 57894, 57895, 57896, 57897, 57898, 57899, 57900, 57901, 57902, 57903, 57904, 57905, 57906, 57907, 30277, 30278, 30279, 30280, 30281, 30282, 30283, 30286, 30287, 30288, 30289, 30290, 30291, 30293, 30295, 30296, 30297, 30298, 30299, 30301, 30303, 30304, 30305, 30306, 30308, 30309, 30310, 30311, 30312, 30313, 30314, 30316, 30317, 30318, 30320, 30321, 30322, 30323, 30324, 30325, 30326, 30327, 30329, 30330, 30332, 30335, 30336, 30337, 30339, 30341, 30345, 30346, 30348, 30349, 30351, 30352, 30354, 30356, 30357, 30359, 30360, 30362, 30363, 30364, 30365, 30366, 30367, 30368, 30369, 30370, 30371, 30373, 30374, 30375, 30376, 30377, 30378, 30379, 30380, 30381, 30383, 30384, 30387, 30389, 30390, 30391, 30392, 30393, 30394, 30395, 30396, 30397, 30398, 30400, 30401, 30403, 21834, 38463, 22467, 25384, 21710, 21769, 21696, 30353, 30284, 34108, 30702, 33406, 30861, 29233, 38552, 38797, 27688, 23433, 20474, 25353, 26263, 23736, 33018, 26696, 32942, 26114, 30414, 20985, 25942, 29100, 32753, 34948, 20658, 22885, 25034, 28595, 33453, 25420, 25170, 21485, 21543, 31494, 20843, 30116, 24052, 25300, 36299, 38774, 25226, 32793, 22365, 38712, 32610, 29240, 30333, 26575, 30334, 25670, 20336, 36133, 25308, 31255, 26001, 29677, 25644, 25203, 33324, 39041, 26495, 29256, 25198, 25292, 20276, 29923, 21322, 21150, 32458, 37030, 24110, 26758, 27036, 33152, 32465, 26834, 30917, 34444, 38225, 20621, 35876, 33502, 32990, 21253, 35090, 21093, 30404, 30407, 30409, 30411, 30412, 30419, 30421, 30425, 30426, 30428, 30429, 30430, 30432, 30433, 30434, 30435, 30436, 30438, 30439, 30440, 30441, 30442, 30443, 30444, 30445, 30448, 30451, 30453, 30454, 30455, 30458, 30459, 30461, 30463, 30464, 30466, 30467, 30469, 30470, 30474, 30476, 30478, 30479, 30480, 30481, 30482, 30483, 30484, 30485, 30486, 30487, 30488, 30491, 30492, 30493, 30494, 30497, 30499, 30500, 30501, 30503, 30506, 30507, 30508, 30510, 30512, 30513, 30514, 30515, 30516, 30521, 30523, 30525, 30526, 30527, 30530, 30532, 30533, 30534, 30536, 30537, 30538, 30539, 30540, 30541, 30542, 30543, 30546, 30547, 30548, 30549, 30550, 30551, 30552, 30553, 30556, 34180, 38649, 20445, 22561, 39281, 23453, 25265, 25253, 26292, 35961, 40077, 29190, 26479, 30865, 24754, 21329, 21271, 36744, 32972, 36125, 38049, 20493, 29384, 22791, 24811, 28953, 34987, 22868, 33519, 26412, 31528, 23849, 32503, 29997, 27893, 36454, 36856, 36924, 40763, 27604, 37145, 31508, 24444, 30887, 34006, 34109, 27605, 27609, 27606, 24065, 24199, 30201, 38381, 25949, 24330, 24517, 36767, 22721, 33218, 36991, 38491, 38829, 36793, 32534, 36140, 25153, 20415, 21464, 21342, 36776, 36777, 36779, 36941, 26631, 24426, 33176, 34920, 40150, 24971, 21035, 30250, 24428, 25996, 28626, 28392, 23486, 25672, 20853, 20912, 26564, 19993, 31177, 39292, 28851, 30557, 30558, 30559, 30560, 30564, 30567, 30569, 30570, 30573, 30574, 30575, 30576, 30577, 30578, 30579, 30580, 30581, 30582, 30583, 30584, 30586, 30587, 30588, 30593, 30594, 30595, 30598, 30599, 30600, 30601, 30602, 30603, 30607, 30608, 30611, 30612, 30613, 30614, 30615, 30616, 30617, 30618, 30619, 30620, 30621, 30622, 30625, 30627, 30628, 30630, 30632, 30635, 30637, 30638, 30639, 30641, 30642, 30644, 30646, 30647, 30648, 30649, 30650, 30652, 30654, 30656, 30657, 30658, 30659, 30660, 30661, 30662, 30663, 30664, 30665, 30666, 30667, 30668, 30670, 30671, 30672, 30673, 30674, 30675, 30676, 30677, 30678, 30680, 30681, 30682, 30685, 30686, 30687, 30688, 30689, 30692, 30149, 24182, 29627, 33760, 25773, 25320, 38069, 27874, 21338, 21187, 25615, 38082, 31636, 20271, 24091, 33334, 33046, 33162, 28196, 27850, 39539, 25429, 21340, 21754, 34917, 22496, 19981, 24067, 27493, 31807, 37096, 24598, 25830, 29468, 35009, 26448, 25165, 36130, 30572, 36393, 37319, 24425, 33756, 34081, 39184, 21442, 34453, 27531, 24813, 24808, 28799, 33485, 33329, 20179, 27815, 34255, 25805, 31961, 27133, 26361, 33609, 21397, 31574, 20391, 20876, 27979, 23618, 36461, 25554, 21449, 33580, 33590, 26597, 30900, 25661, 23519, 23700, 24046, 35815, 25286, 26612, 35962, 25600, 25530, 34633, 39307, 35863, 32544, 38130, 20135, 38416, 39076, 26124, 29462, 30694, 30696, 30698, 30703, 30704, 30705, 30706, 30708, 30709, 30711, 30713, 30714, 30715, 30716, 30723, 30724, 30725, 30726, 30727, 30728, 30730, 30731, 30734, 30735, 30736, 30739, 30741, 30745, 30747, 30750, 30752, 30753, 30754, 30756, 30760, 30762, 30763, 30766, 30767, 30769, 30770, 30771, 30773, 30774, 30781, 30783, 30785, 30786, 30787, 30788, 30790, 30792, 30793, 30794, 30795, 30797, 30799, 30801, 30803, 30804, 30808, 30809, 30810, 30811, 30812, 30814, 30815, 30816, 30817, 30818, 30819, 30820, 30821, 30822, 30823, 30824, 30825, 30831, 30832, 30833, 30834, 30835, 30836, 30837, 30838, 30840, 30841, 30842, 30843, 30845, 30846, 30847, 30848, 30849, 30850, 30851, 22330, 23581, 24120, 38271, 20607, 32928, 21378, 25950, 30021, 21809, 20513, 36229, 25220, 38046, 26397, 22066, 28526, 24034, 21557, 28818, 36710, 25199, 25764, 25507, 24443, 28552, 37108, 33251, 36784, 23576, 26216, 24561, 27785, 38472, 36225, 34924, 25745, 31216, 22478, 27225, 25104, 21576, 20056, 31243, 24809, 28548, 35802, 25215, 36894, 39563, 31204, 21507, 30196, 25345, 21273, 27744, 36831, 24347, 39536, 32827, 40831, 20360, 23610, 36196, 32709, 26021, 28861, 20805, 20914, 34411, 23815, 23456, 25277, 37228, 30068, 36364, 31264, 24833, 31609, 20167, 32504, 30597, 19985, 33261, 21021, 20986, 27249, 21416, 36487, 38148, 38607, 28353, 38500, 26970, 30852, 30853, 30854, 30856, 30858, 30859, 30863, 30864, 30866, 30868, 30869, 30870, 30873, 30877, 30878, 30880, 30882, 30884, 30886, 30888, 30889, 30890, 30891, 30892, 30893, 30894, 30895, 30901, 30902, 30903, 30904, 30906, 30907, 30908, 30909, 30911, 30912, 30914, 30915, 30916, 30918, 30919, 30920, 30924, 30925, 30926, 30927, 30929, 30930, 30931, 30934, 30935, 30936, 30938, 30939, 30940, 30941, 30942, 30943, 30944, 30945, 30946, 30947, 30948, 30949, 30950, 30951, 30953, 30954, 30955, 30957, 30958, 30959, 30960, 30961, 30963, 30965, 30966, 30968, 30969, 30971, 30972, 30973, 30974, 30975, 30976, 30978, 30979, 30980, 30982, 30983, 30984, 30985, 30986, 30987, 30988, 30784, 20648, 30679, 25616, 35302, 22788, 25571, 24029, 31359, 26941, 20256, 33337, 21912, 20018, 30126, 31383, 24162, 24202, 38383, 21019, 21561, 28810, 25462, 38180, 22402, 26149, 26943, 37255, 21767, 28147, 32431, 34850, 25139, 32496, 30133, 33576, 30913, 38604, 36766, 24904, 29943, 35789, 27492, 21050, 36176, 27425, 32874, 33905, 22257, 21254, 20174, 19995, 20945, 31895, 37259, 31751, 20419, 36479, 31713, 31388, 25703, 23828, 20652, 33030, 30209, 31929, 28140, 32736, 26449, 23384, 23544, 30923, 25774, 25619, 25514, 25387, 38169, 25645, 36798, 31572, 30249, 25171, 22823, 21574, 27513, 20643, 25140, 24102, 27526, 20195, 36151, 34955, 24453, 36910, 30989, 30990, 30991, 30992, 30993, 30994, 30996, 30997, 30998, 30999, 31e3, 31001, 31002, 31003, 31004, 31005, 31007, 31008, 31009, 31010, 31011, 31013, 31014, 31015, 31016, 31017, 31018, 31019, 31020, 31021, 31022, 31023, 31024, 31025, 31026, 31027, 31029, 31030, 31031, 31032, 31033, 31037, 31039, 31042, 31043, 31044, 31045, 31047, 31050, 31051, 31052, 31053, 31054, 31055, 31056, 31057, 31058, 31060, 31061, 31064, 31065, 31073, 31075, 31076, 31078, 31081, 31082, 31083, 31084, 31086, 31088, 31089, 31090, 31091, 31092, 31093, 31094, 31097, 31099, 31100, 31101, 31102, 31103, 31106, 31107, 31110, 31111, 31112, 31113, 31115, 31116, 31117, 31118, 31120, 31121, 31122, 24608, 32829, 25285, 20025, 21333, 37112, 25528, 32966, 26086, 27694, 20294, 24814, 28129, 35806, 24377, 34507, 24403, 25377, 20826, 33633, 26723, 20992, 25443, 36424, 20498, 23707, 31095, 23548, 21040, 31291, 24764, 36947, 30423, 24503, 24471, 30340, 36460, 28783, 30331, 31561, 30634, 20979, 37011, 22564, 20302, 28404, 36842, 25932, 31515, 29380, 28068, 32735, 23265, 25269, 24213, 22320, 33922, 31532, 24093, 24351, 36882, 32532, 39072, 25474, 28359, 30872, 28857, 20856, 38747, 22443, 30005, 20291, 30008, 24215, 24806, 22880, 28096, 27583, 30857, 21500, 38613, 20939, 20993, 25481, 21514, 38035, 35843, 36300, 29241, 30879, 34678, 36845, 35853, 21472, 31123, 31124, 31125, 31126, 31127, 31128, 31129, 31131, 31132, 31133, 31134, 31135, 31136, 31137, 31138, 31139, 31140, 31141, 31142, 31144, 31145, 31146, 31147, 31148, 31149, 31150, 31151, 31152, 31153, 31154, 31156, 31157, 31158, 31159, 31160, 31164, 31167, 31170, 31172, 31173, 31175, 31176, 31178, 31180, 31182, 31183, 31184, 31187, 31188, 31190, 31191, 31193, 31194, 31195, 31196, 31197, 31198, 31200, 31201, 31202, 31205, 31208, 31210, 31212, 31214, 31217, 31218, 31219, 31220, 31221, 31222, 31223, 31225, 31226, 31228, 31230, 31231, 31233, 31236, 31237, 31239, 31240, 31241, 31242, 31244, 31247, 31248, 31249, 31250, 31251, 31253, 31254, 31256, 31257, 31259, 31260, 19969, 30447, 21486, 38025, 39030, 40718, 38189, 23450, 35746, 20002, 19996, 20908, 33891, 25026, 21160, 26635, 20375, 24683, 20923, 27934, 20828, 25238, 26007, 38497, 35910, 36887, 30168, 37117, 30563, 27602, 29322, 29420, 35835, 22581, 30585, 36172, 26460, 38208, 32922, 24230, 28193, 22930, 31471, 30701, 38203, 27573, 26029, 32526, 22534, 20817, 38431, 23545, 22697, 21544, 36466, 25958, 39039, 22244, 38045, 30462, 36929, 25479, 21702, 22810, 22842, 22427, 36530, 26421, 36346, 33333, 21057, 24816, 22549, 34558, 23784, 40517, 20420, 39069, 35769, 23077, 24694, 21380, 25212, 36943, 37122, 39295, 24681, 32780, 20799, 32819, 23572, 39285, 27953, 20108, 31261, 31263, 31265, 31266, 31268, 31269, 31270, 31271, 31272, 31273, 31274, 31275, 31276, 31277, 31278, 31279, 31280, 31281, 31282, 31284, 31285, 31286, 31288, 31290, 31294, 31296, 31297, 31298, 31299, 31300, 31301, 31303, 31304, 31305, 31306, 31307, 31308, 31309, 31310, 31311, 31312, 31314, 31315, 31316, 31317, 31318, 31320, 31321, 31322, 31323, 31324, 31325, 31326, 31327, 31328, 31329, 31330, 31331, 31332, 31333, 31334, 31335, 31336, 31337, 31338, 31339, 31340, 31341, 31342, 31343, 31345, 31346, 31347, 31349, 31355, 31356, 31357, 31358, 31362, 31365, 31367, 31369, 31370, 31371, 31372, 31374, 31375, 31376, 31379, 31380, 31385, 31386, 31387, 31390, 31393, 31394, 36144, 21457, 32602, 31567, 20240, 20047, 38400, 27861, 29648, 34281, 24070, 30058, 32763, 27146, 30718, 38034, 32321, 20961, 28902, 21453, 36820, 33539, 36137, 29359, 39277, 27867, 22346, 33459, 26041, 32938, 25151, 38450, 22952, 20223, 35775, 32442, 25918, 33778, 38750, 21857, 39134, 32933, 21290, 35837, 21536, 32954, 24223, 27832, 36153, 33452, 37210, 21545, 27675, 20998, 32439, 22367, 28954, 27774, 31881, 22859, 20221, 24575, 24868, 31914, 20016, 23553, 26539, 34562, 23792, 38155, 39118, 30127, 28925, 36898, 20911, 32541, 35773, 22857, 20964, 20315, 21542, 22827, 25975, 32932, 23413, 25206, 25282, 36752, 24133, 27679, 31526, 20239, 20440, 26381, 31395, 31396, 31399, 31401, 31402, 31403, 31406, 31407, 31408, 31409, 31410, 31412, 31413, 31414, 31415, 31416, 31417, 31418, 31419, 31420, 31421, 31422, 31424, 31425, 31426, 31427, 31428, 31429, 31430, 31431, 31432, 31433, 31434, 31436, 31437, 31438, 31439, 31440, 31441, 31442, 31443, 31444, 31445, 31447, 31448, 31450, 31451, 31452, 31453, 31457, 31458, 31460, 31463, 31464, 31465, 31466, 31467, 31468, 31470, 31472, 31473, 31474, 31475, 31476, 31477, 31478, 31479, 31480, 31483, 31484, 31486, 31488, 31489, 31490, 31493, 31495, 31497, 31500, 31501, 31502, 31504, 31506, 31507, 31510, 31511, 31512, 31514, 31516, 31517, 31519, 31521, 31522, 31523, 31527, 31529, 31533, 28014, 28074, 31119, 34993, 24343, 29995, 25242, 36741, 20463, 37340, 26023, 33071, 33105, 24220, 33104, 36212, 21103, 35206, 36171, 22797, 20613, 20184, 38428, 29238, 33145, 36127, 23500, 35747, 38468, 22919, 32538, 21648, 22134, 22030, 35813, 25913, 27010, 38041, 30422, 28297, 24178, 29976, 26438, 26577, 31487, 32925, 36214, 24863, 31174, 25954, 36195, 20872, 21018, 38050, 32568, 32923, 32434, 23703, 28207, 26464, 31705, 30347, 39640, 33167, 32660, 31957, 25630, 38224, 31295, 21578, 21733, 27468, 25601, 25096, 40509, 33011, 30105, 21106, 38761, 33883, 26684, 34532, 38401, 38548, 38124, 20010, 21508, 32473, 26681, 36319, 32789, 26356, 24218, 32697, 31535, 31536, 31538, 31540, 31541, 31542, 31543, 31545, 31547, 31549, 31551, 31552, 31553, 31554, 31555, 31556, 31558, 31560, 31562, 31565, 31566, 31571, 31573, 31575, 31577, 31580, 31582, 31583, 31585, 31587, 31588, 31589, 31590, 31591, 31592, 31593, 31594, 31595, 31596, 31597, 31599, 31600, 31603, 31604, 31606, 31608, 31610, 31612, 31613, 31615, 31617, 31618, 31619, 31620, 31622, 31623, 31624, 31625, 31626, 31627, 31628, 31630, 31631, 31633, 31634, 31635, 31638, 31640, 31641, 31642, 31643, 31646, 31647, 31648, 31651, 31652, 31653, 31662, 31663, 31664, 31666, 31667, 31669, 31670, 31671, 31673, 31674, 31675, 31676, 31677, 31678, 31679, 31680, 31682, 31683, 31684, 22466, 32831, 26775, 24037, 25915, 21151, 24685, 40858, 20379, 36524, 20844, 23467, 24339, 24041, 27742, 25329, 36129, 20849, 38057, 21246, 27807, 33503, 29399, 22434, 26500, 36141, 22815, 36764, 33735, 21653, 31629, 20272, 27837, 23396, 22993, 40723, 21476, 34506, 39592, 35895, 32929, 25925, 39038, 22266, 38599, 21038, 29916, 21072, 23521, 25346, 35074, 20054, 25296, 24618, 26874, 20851, 23448, 20896, 35266, 31649, 39302, 32592, 24815, 28748, 36143, 20809, 24191, 36891, 29808, 35268, 22317, 30789, 24402, 40863, 38394, 36712, 39740, 35809, 30328, 26690, 26588, 36330, 36149, 21053, 36746, 28378, 26829, 38149, 37101, 22269, 26524, 35065, 36807, 21704, 31685, 31688, 31689, 31690, 31691, 31693, 31694, 31695, 31696, 31698, 31700, 31701, 31702, 31703, 31704, 31707, 31708, 31710, 31711, 31712, 31714, 31715, 31716, 31719, 31720, 31721, 31723, 31724, 31725, 31727, 31728, 31730, 31731, 31732, 31733, 31734, 31736, 31737, 31738, 31739, 31741, 31743, 31744, 31745, 31746, 31747, 31748, 31749, 31750, 31752, 31753, 31754, 31757, 31758, 31760, 31761, 31762, 31763, 31764, 31765, 31767, 31768, 31769, 31770, 31771, 31772, 31773, 31774, 31776, 31777, 31778, 31779, 31780, 31781, 31784, 31785, 31787, 31788, 31789, 31790, 31791, 31792, 31793, 31794, 31795, 31796, 31797, 31798, 31799, 31801, 31802, 31803, 31804, 31805, 31806, 31810, 39608, 23401, 28023, 27686, 20133, 23475, 39559, 37219, 25e3, 37039, 38889, 21547, 28085, 23506, 20989, 21898, 32597, 32752, 25788, 25421, 26097, 25022, 24717, 28938, 27735, 27721, 22831, 26477, 33322, 22741, 22158, 35946, 27627, 37085, 22909, 32791, 21495, 28009, 21621, 21917, 33655, 33743, 26680, 31166, 21644, 20309, 21512, 30418, 35977, 38402, 27827, 28088, 36203, 35088, 40548, 36154, 22079, 40657, 30165, 24456, 29408, 24680, 21756, 20136, 27178, 34913, 24658, 36720, 21700, 28888, 34425, 40511, 27946, 23439, 24344, 32418, 21897, 20399, 29492, 21564, 21402, 20505, 21518, 21628, 20046, 24573, 29786, 22774, 33899, 32993, 34676, 29392, 31946, 28246, 31811, 31812, 31813, 31814, 31815, 31816, 31817, 31818, 31819, 31820, 31822, 31823, 31824, 31825, 31826, 31827, 31828, 31829, 31830, 31831, 31832, 31833, 31834, 31835, 31836, 31837, 31838, 31839, 31840, 31841, 31842, 31843, 31844, 31845, 31846, 31847, 31848, 31849, 31850, 31851, 31852, 31853, 31854, 31855, 31856, 31857, 31858, 31861, 31862, 31863, 31864, 31865, 31866, 31870, 31871, 31872, 31873, 31874, 31875, 31876, 31877, 31878, 31879, 31880, 31882, 31883, 31884, 31885, 31886, 31887, 31888, 31891, 31892, 31894, 31897, 31898, 31899, 31904, 31905, 31907, 31910, 31911, 31912, 31913, 31915, 31916, 31917, 31919, 31920, 31924, 31925, 31926, 31927, 31928, 31930, 31931, 24359, 34382, 21804, 25252, 20114, 27818, 25143, 33457, 21719, 21326, 29502, 28369, 30011, 21010, 21270, 35805, 27088, 24458, 24576, 28142, 22351, 27426, 29615, 26707, 36824, 32531, 25442, 24739, 21796, 30186, 35938, 28949, 28067, 23462, 24187, 33618, 24908, 40644, 30970, 34647, 31783, 30343, 20976, 24822, 29004, 26179, 24140, 24653, 35854, 28784, 25381, 36745, 24509, 24674, 34516, 22238, 27585, 24724, 24935, 21321, 24800, 26214, 36159, 31229, 20250, 28905, 27719, 35763, 35826, 32472, 33636, 26127, 23130, 39746, 27985, 28151, 35905, 27963, 20249, 28779, 33719, 25110, 24785, 38669, 36135, 31096, 20987, 22334, 22522, 26426, 30072, 31293, 31215, 31637, 31935, 31936, 31938, 31939, 31940, 31942, 31945, 31947, 31950, 31951, 31952, 31953, 31954, 31955, 31956, 31960, 31962, 31963, 31965, 31966, 31969, 31970, 31971, 31972, 31973, 31974, 31975, 31977, 31978, 31979, 31980, 31981, 31982, 31984, 31985, 31986, 31987, 31988, 31989, 31990, 31991, 31993, 31994, 31996, 31997, 31998, 31999, 32e3, 32001, 32002, 32003, 32004, 32005, 32006, 32007, 32008, 32009, 32011, 32012, 32013, 32014, 32015, 32016, 32017, 32018, 32019, 32020, 32021, 32022, 32023, 32024, 32025, 32026, 32027, 32028, 32029, 32030, 32031, 32033, 32035, 32036, 32037, 32038, 32040, 32041, 32042, 32044, 32045, 32046, 32048, 32049, 32050, 32051, 32052, 32053, 32054, 32908, 39269, 36857, 28608, 35749, 40481, 23020, 32489, 32521, 21513, 26497, 26840, 36753, 31821, 38598, 21450, 24613, 30142, 27762, 21363, 23241, 32423, 25380, 20960, 33034, 24049, 34015, 25216, 20864, 23395, 20238, 31085, 21058, 24760, 27982, 23492, 23490, 35745, 35760, 26082, 24524, 38469, 22931, 32487, 32426, 22025, 26551, 22841, 20339, 23478, 21152, 33626, 39050, 36158, 30002, 38078, 20551, 31292, 20215, 26550, 39550, 23233, 27516, 30417, 22362, 23574, 31546, 38388, 29006, 20860, 32937, 33392, 22904, 32516, 33575, 26816, 26604, 30897, 30839, 25315, 25441, 31616, 20461, 21098, 20943, 33616, 27099, 37492, 36341, 36145, 35265, 38190, 31661, 20214, 32055, 32056, 32057, 32058, 32059, 32060, 32061, 32062, 32063, 32064, 32065, 32066, 32067, 32068, 32069, 32070, 32071, 32072, 32073, 32074, 32075, 32076, 32077, 32078, 32079, 32080, 32081, 32082, 32083, 32084, 32085, 32086, 32087, 32088, 32089, 32090, 32091, 32092, 32093, 32094, 32095, 32096, 32097, 32098, 32099, 32100, 32101, 32102, 32103, 32104, 32105, 32106, 32107, 32108, 32109, 32111, 32112, 32113, 32114, 32115, 32116, 32117, 32118, 32120, 32121, 32122, 32123, 32124, 32125, 32126, 32127, 32128, 32129, 32130, 32131, 32132, 32133, 32134, 32135, 32136, 32137, 32138, 32139, 32140, 32141, 32142, 32143, 32144, 32145, 32146, 32147, 32148, 32149, 32150, 32151, 32152, 20581, 33328, 21073, 39279, 28176, 28293, 28071, 24314, 20725, 23004, 23558, 27974, 27743, 30086, 33931, 26728, 22870, 35762, 21280, 37233, 38477, 34121, 26898, 30977, 28966, 33014, 20132, 37066, 27975, 39556, 23047, 22204, 25605, 38128, 30699, 20389, 33050, 29409, 35282, 39290, 32564, 32478, 21119, 25945, 37237, 36735, 36739, 21483, 31382, 25581, 25509, 30342, 31224, 34903, 38454, 25130, 21163, 33410, 26708, 26480, 25463, 30571, 31469, 27905, 32467, 35299, 22992, 25106, 34249, 33445, 30028, 20511, 20171, 30117, 35819, 23626, 24062, 31563, 26020, 37329, 20170, 27941, 35167, 32039, 38182, 20165, 35880, 36827, 38771, 26187, 31105, 36817, 28908, 28024, 32153, 32154, 32155, 32156, 32157, 32158, 32159, 32160, 32161, 32162, 32163, 32164, 32165, 32167, 32168, 32169, 32170, 32171, 32172, 32173, 32175, 32176, 32177, 32178, 32179, 32180, 32181, 32182, 32183, 32184, 32185, 32186, 32187, 32188, 32189, 32190, 32191, 32192, 32193, 32194, 32195, 32196, 32197, 32198, 32199, 32200, 32201, 32202, 32203, 32204, 32205, 32206, 32207, 32208, 32209, 32210, 32211, 32212, 32213, 32214, 32215, 32216, 32217, 32218, 32219, 32220, 32221, 32222, 32223, 32224, 32225, 32226, 32227, 32228, 32229, 32230, 32231, 32232, 32233, 32234, 32235, 32236, 32237, 32238, 32239, 32240, 32241, 32242, 32243, 32244, 32245, 32246, 32247, 32248, 32249, 32250, 23613, 21170, 33606, 20834, 33550, 30555, 26230, 40120, 20140, 24778, 31934, 31923, 32463, 20117, 35686, 26223, 39048, 38745, 22659, 25964, 38236, 24452, 30153, 38742, 31455, 31454, 20928, 28847, 31384, 25578, 31350, 32416, 29590, 38893, 20037, 28792, 20061, 37202, 21417, 25937, 26087, 33276, 33285, 21646, 23601, 30106, 38816, 25304, 29401, 30141, 23621, 39545, 33738, 23616, 21632, 30697, 20030, 27822, 32858, 25298, 25454, 24040, 20855, 36317, 36382, 38191, 20465, 21477, 24807, 28844, 21095, 25424, 40515, 23071, 20518, 30519, 21367, 32482, 25733, 25899, 25225, 25496, 20500, 29237, 35273, 20915, 35776, 32477, 22343, 33740, 38055, 20891, 21531, 23803, 32251, 32252, 32253, 32254, 32255, 32256, 32257, 32258, 32259, 32260, 32261, 32262, 32263, 32264, 32265, 32266, 32267, 32268, 32269, 32270, 32271, 32272, 32273, 32274, 32275, 32276, 32277, 32278, 32279, 32280, 32281, 32282, 32283, 32284, 32285, 32286, 32287, 32288, 32289, 32290, 32291, 32292, 32293, 32294, 32295, 32296, 32297, 32298, 32299, 32300, 32301, 32302, 32303, 32304, 32305, 32306, 32307, 32308, 32309, 32310, 32311, 32312, 32313, 32314, 32316, 32317, 32318, 32319, 32320, 32322, 32323, 32324, 32325, 32326, 32328, 32329, 32330, 32331, 32332, 32333, 32334, 32335, 32336, 32337, 32338, 32339, 32340, 32341, 32342, 32343, 32344, 32345, 32346, 32347, 32348, 32349, 20426, 31459, 27994, 37089, 39567, 21888, 21654, 21345, 21679, 24320, 25577, 26999, 20975, 24936, 21002, 22570, 21208, 22350, 30733, 30475, 24247, 24951, 31968, 25179, 25239, 20130, 28821, 32771, 25335, 28900, 38752, 22391, 33499, 26607, 26869, 30933, 39063, 31185, 22771, 21683, 21487, 28212, 20811, 21051, 23458, 35838, 32943, 21827, 22438, 24691, 22353, 21549, 31354, 24656, 23380, 25511, 25248, 21475, 25187, 23495, 26543, 21741, 31391, 33510, 37239, 24211, 35044, 22840, 22446, 25358, 36328, 33007, 22359, 31607, 20393, 24555, 23485, 27454, 21281, 31568, 29378, 26694, 30719, 30518, 26103, 20917, 20111, 30420, 23743, 31397, 33909, 22862, 39745, 20608, 32350, 32351, 32352, 32353, 32354, 32355, 32356, 32357, 32358, 32359, 32360, 32361, 32362, 32363, 32364, 32365, 32366, 32367, 32368, 32369, 32370, 32371, 32372, 32373, 32374, 32375, 32376, 32377, 32378, 32379, 32380, 32381, 32382, 32383, 32384, 32385, 32387, 32388, 32389, 32390, 32391, 32392, 32393, 32394, 32395, 32396, 32397, 32398, 32399, 32400, 32401, 32402, 32403, 32404, 32405, 32406, 32407, 32408, 32409, 32410, 32412, 32413, 32414, 32430, 32436, 32443, 32444, 32470, 32484, 32492, 32505, 32522, 32528, 32542, 32567, 32569, 32571, 32572, 32573, 32574, 32575, 32576, 32577, 32579, 32582, 32583, 32584, 32585, 32586, 32587, 32588, 32589, 32590, 32591, 32594, 32595, 39304, 24871, 28291, 22372, 26118, 25414, 22256, 25324, 25193, 24275, 38420, 22403, 25289, 21895, 34593, 33098, 36771, 21862, 33713, 26469, 36182, 34013, 23146, 26639, 25318, 31726, 38417, 20848, 28572, 35888, 25597, 35272, 25042, 32518, 28866, 28389, 29701, 27028, 29436, 24266, 37070, 26391, 28010, 25438, 21171, 29282, 32769, 20332, 23013, 37226, 28889, 28061, 21202, 20048, 38647, 38253, 34174, 30922, 32047, 20769, 22418, 25794, 32907, 31867, 27882, 26865, 26974, 20919, 21400, 26792, 29313, 40654, 31729, 29432, 31163, 28435, 29702, 26446, 37324, 40100, 31036, 33673, 33620, 21519, 26647, 20029, 21385, 21169, 30782, 21382, 21033, 20616, 20363, 20432, 32598, 32601, 32603, 32604, 32605, 32606, 32608, 32611, 32612, 32613, 32614, 32615, 32619, 32620, 32621, 32623, 32624, 32627, 32629, 32630, 32631, 32632, 32634, 32635, 32636, 32637, 32639, 32640, 32642, 32643, 32644, 32645, 32646, 32647, 32648, 32649, 32651, 32653, 32655, 32656, 32657, 32658, 32659, 32661, 32662, 32663, 32664, 32665, 32667, 32668, 32672, 32674, 32675, 32677, 32678, 32680, 32681, 32682, 32683, 32684, 32685, 32686, 32689, 32691, 32692, 32693, 32694, 32695, 32698, 32699, 32702, 32704, 32706, 32707, 32708, 32710, 32711, 32712, 32713, 32715, 32717, 32719, 32720, 32721, 32722, 32723, 32726, 32727, 32729, 32730, 32731, 32732, 32733, 32734, 32738, 32739, 30178, 31435, 31890, 27813, 38582, 21147, 29827, 21737, 20457, 32852, 33714, 36830, 38256, 24265, 24604, 28063, 24088, 25947, 33080, 38142, 24651, 28860, 32451, 31918, 20937, 26753, 31921, 33391, 20004, 36742, 37327, 26238, 20142, 35845, 25769, 32842, 20698, 30103, 29134, 23525, 36797, 28518, 20102, 25730, 38243, 24278, 26009, 21015, 35010, 28872, 21155, 29454, 29747, 26519, 30967, 38678, 20020, 37051, 40158, 28107, 20955, 36161, 21533, 25294, 29618, 33777, 38646, 40836, 38083, 20278, 32666, 20940, 28789, 38517, 23725, 39046, 21478, 20196, 28316, 29705, 27060, 30827, 39311, 30041, 21016, 30244, 27969, 26611, 20845, 40857, 32843, 21657, 31548, 31423, 32740, 32743, 32744, 32746, 32747, 32748, 32749, 32751, 32754, 32756, 32757, 32758, 32759, 32760, 32761, 32762, 32765, 32766, 32767, 32770, 32775, 32776, 32777, 32778, 32782, 32783, 32785, 32787, 32794, 32795, 32797, 32798, 32799, 32801, 32803, 32804, 32811, 32812, 32813, 32814, 32815, 32816, 32818, 32820, 32825, 32826, 32828, 32830, 32832, 32833, 32836, 32837, 32839, 32840, 32841, 32846, 32847, 32848, 32849, 32851, 32853, 32854, 32855, 32857, 32859, 32860, 32861, 32862, 32863, 32864, 32865, 32866, 32867, 32868, 32869, 32870, 32871, 32872, 32875, 32876, 32877, 32878, 32879, 32880, 32882, 32883, 32884, 32885, 32886, 32887, 32888, 32889, 32890, 32891, 32892, 32893, 38534, 22404, 25314, 38471, 27004, 23044, 25602, 31699, 28431, 38475, 33446, 21346, 39045, 24208, 28809, 25523, 21348, 34383, 40065, 40595, 30860, 38706, 36335, 36162, 40575, 28510, 31108, 24405, 38470, 25134, 39540, 21525, 38109, 20387, 26053, 23653, 23649, 32533, 34385, 27695, 24459, 29575, 28388, 32511, 23782, 25371, 23402, 28390, 21365, 20081, 25504, 30053, 25249, 36718, 20262, 20177, 27814, 32438, 35770, 33821, 34746, 32599, 36923, 38179, 31657, 39585, 35064, 33853, 27931, 39558, 32476, 22920, 40635, 29595, 30721, 34434, 39532, 39554, 22043, 21527, 22475, 20080, 40614, 21334, 36808, 33033, 30610, 39314, 34542, 28385, 34067, 26364, 24930, 28459, 32894, 32897, 32898, 32901, 32904, 32906, 32909, 32910, 32911, 32912, 32913, 32914, 32916, 32917, 32919, 32921, 32926, 32931, 32934, 32935, 32936, 32940, 32944, 32947, 32949, 32950, 32952, 32953, 32955, 32965, 32967, 32968, 32969, 32970, 32971, 32975, 32976, 32977, 32978, 32979, 32980, 32981, 32984, 32991, 32992, 32994, 32995, 32998, 33006, 33013, 33015, 33017, 33019, 33022, 33023, 33024, 33025, 33027, 33028, 33029, 33031, 33032, 33035, 33036, 33045, 33047, 33049, 33051, 33052, 33053, 33055, 33056, 33057, 33058, 33059, 33060, 33061, 33062, 33063, 33064, 33065, 33066, 33067, 33069, 33070, 33072, 33075, 33076, 33077, 33079, 33081, 33082, 33083, 33084, 33085, 33087, 35881, 33426, 33579, 30450, 27667, 24537, 33725, 29483, 33541, 38170, 27611, 30683, 38086, 21359, 33538, 20882, 24125, 35980, 36152, 20040, 29611, 26522, 26757, 37238, 38665, 29028, 27809, 30473, 23186, 38209, 27599, 32654, 26151, 23504, 22969, 23194, 38376, 38391, 20204, 33804, 33945, 27308, 30431, 38192, 29467, 26790, 23391, 30511, 37274, 38753, 31964, 36855, 35868, 24357, 31859, 31192, 35269, 27852, 34588, 23494, 24130, 26825, 30496, 32501, 20885, 20813, 21193, 23081, 32517, 38754, 33495, 25551, 30596, 34256, 31186, 28218, 24217, 22937, 34065, 28781, 27665, 25279, 30399, 25935, 24751, 38397, 26126, 34719, 40483, 38125, 21517, 21629, 35884, 25720, 33088, 33089, 33090, 33091, 33092, 33093, 33095, 33097, 33101, 33102, 33103, 33106, 33110, 33111, 33112, 33115, 33116, 33117, 33118, 33119, 33121, 33122, 33123, 33124, 33126, 33128, 33130, 33131, 33132, 33135, 33138, 33139, 33141, 33142, 33143, 33144, 33153, 33155, 33156, 33157, 33158, 33159, 33161, 33163, 33164, 33165, 33166, 33168, 33170, 33171, 33172, 33173, 33174, 33175, 33177, 33178, 33182, 33183, 33184, 33185, 33186, 33188, 33189, 33191, 33193, 33195, 33196, 33197, 33198, 33199, 33200, 33201, 33202, 33204, 33205, 33206, 33207, 33208, 33209, 33212, 33213, 33214, 33215, 33220, 33221, 33223, 33224, 33225, 33227, 33229, 33230, 33231, 33232, 33233, 33234, 33235, 25721, 34321, 27169, 33180, 30952, 25705, 39764, 25273, 26411, 33707, 22696, 40664, 27819, 28448, 23518, 38476, 35851, 29279, 26576, 25287, 29281, 20137, 22982, 27597, 22675, 26286, 24149, 21215, 24917, 26408, 30446, 30566, 29287, 31302, 25343, 21738, 21584, 38048, 37027, 23068, 32435, 27670, 20035, 22902, 32784, 22856, 21335, 30007, 38590, 22218, 25376, 33041, 24700, 38393, 28118, 21602, 39297, 20869, 23273, 33021, 22958, 38675, 20522, 27877, 23612, 25311, 20320, 21311, 33147, 36870, 28346, 34091, 25288, 24180, 30910, 25781, 25467, 24565, 23064, 37247, 40479, 23615, 25423, 32834, 23421, 21870, 38218, 38221, 28037, 24744, 26592, 29406, 20957, 23425, 33236, 33237, 33238, 33239, 33240, 33241, 33242, 33243, 33244, 33245, 33246, 33247, 33248, 33249, 33250, 33252, 33253, 33254, 33256, 33257, 33259, 33262, 33263, 33264, 33265, 33266, 33269, 33270, 33271, 33272, 33273, 33274, 33277, 33279, 33283, 33287, 33288, 33289, 33290, 33291, 33294, 33295, 33297, 33299, 33301, 33302, 33303, 33304, 33305, 33306, 33309, 33312, 33316, 33317, 33318, 33319, 33321, 33326, 33330, 33338, 33340, 33341, 33343, 33344, 33345, 33346, 33347, 33349, 33350, 33352, 33354, 33356, 33357, 33358, 33360, 33361, 33362, 33363, 33364, 33365, 33366, 33367, 33369, 33371, 33372, 33373, 33374, 33376, 33377, 33378, 33379, 33380, 33381, 33382, 33383, 33385, 25319, 27870, 29275, 25197, 38062, 32445, 33043, 27987, 20892, 24324, 22900, 21162, 24594, 22899, 26262, 34384, 30111, 25386, 25062, 31983, 35834, 21734, 27431, 40485, 27572, 34261, 21589, 20598, 27812, 21866, 36276, 29228, 24085, 24597, 29750, 25293, 25490, 29260, 24472, 28227, 27966, 25856, 28504, 30424, 30928, 30460, 30036, 21028, 21467, 20051, 24222, 26049, 32810, 32982, 25243, 21638, 21032, 28846, 34957, 36305, 27873, 21624, 32986, 22521, 35060, 36180, 38506, 37197, 20329, 27803, 21943, 30406, 30768, 25256, 28921, 28558, 24429, 34028, 26842, 30844, 31735, 33192, 26379, 40527, 25447, 30896, 22383, 30738, 38713, 25209, 25259, 21128, 29749, 27607, 33386, 33387, 33388, 33389, 33393, 33397, 33398, 33399, 33400, 33403, 33404, 33408, 33409, 33411, 33413, 33414, 33415, 33417, 33420, 33424, 33427, 33428, 33429, 33430, 33434, 33435, 33438, 33440, 33442, 33443, 33447, 33458, 33461, 33462, 33466, 33467, 33468, 33471, 33472, 33474, 33475, 33477, 33478, 33481, 33488, 33494, 33497, 33498, 33501, 33506, 33511, 33512, 33513, 33514, 33516, 33517, 33518, 33520, 33522, 33523, 33525, 33526, 33528, 33530, 33532, 33533, 33534, 33535, 33536, 33546, 33547, 33549, 33552, 33554, 33555, 33558, 33560, 33561, 33565, 33566, 33567, 33568, 33569, 33570, 33571, 33572, 33573, 33574, 33577, 33578, 33582, 33584, 33586, 33591, 33595, 33597, 21860, 33086, 30130, 30382, 21305, 30174, 20731, 23617, 35692, 31687, 20559, 29255, 39575, 39128, 28418, 29922, 31080, 25735, 30629, 25340, 39057, 36139, 21697, 32856, 20050, 22378, 33529, 33805, 24179, 20973, 29942, 35780, 23631, 22369, 27900, 39047, 23110, 30772, 39748, 36843, 31893, 21078, 25169, 38138, 20166, 33670, 33889, 33769, 33970, 22484, 26420, 22275, 26222, 28006, 35889, 26333, 28689, 26399, 27450, 26646, 25114, 22971, 19971, 20932, 28422, 26578, 27791, 20854, 26827, 22855, 27495, 30054, 23822, 33040, 40784, 26071, 31048, 31041, 39569, 36215, 23682, 20062, 20225, 21551, 22865, 30732, 22120, 27668, 36804, 24323, 27773, 27875, 35755, 25488, 33598, 33599, 33601, 33602, 33604, 33605, 33608, 33610, 33611, 33612, 33613, 33614, 33619, 33621, 33622, 33623, 33624, 33625, 33629, 33634, 33648, 33649, 33650, 33651, 33652, 33653, 33654, 33657, 33658, 33662, 33663, 33664, 33665, 33666, 33667, 33668, 33671, 33672, 33674, 33675, 33676, 33677, 33679, 33680, 33681, 33684, 33685, 33686, 33687, 33689, 33690, 33693, 33695, 33697, 33698, 33699, 33700, 33701, 33702, 33703, 33708, 33709, 33710, 33711, 33717, 33723, 33726, 33727, 33730, 33731, 33732, 33734, 33736, 33737, 33739, 33741, 33742, 33744, 33745, 33746, 33747, 33749, 33751, 33753, 33754, 33755, 33758, 33762, 33763, 33764, 33766, 33767, 33768, 33771, 33772, 33773, 24688, 27965, 29301, 25190, 38030, 38085, 21315, 36801, 31614, 20191, 35878, 20094, 40660, 38065, 38067, 21069, 28508, 36963, 27973, 35892, 22545, 23884, 27424, 27465, 26538, 21595, 33108, 32652, 22681, 34103, 24378, 25250, 27207, 38201, 25970, 24708, 26725, 30631, 20052, 20392, 24039, 38808, 25772, 32728, 23789, 20431, 31373, 20999, 33540, 19988, 24623, 31363, 38054, 20405, 20146, 31206, 29748, 21220, 33465, 25810, 31165, 23517, 27777, 38738, 36731, 27682, 20542, 21375, 28165, 25806, 26228, 27696, 24773, 39031, 35831, 24198, 29756, 31351, 31179, 19992, 37041, 29699, 27714, 22234, 37195, 27845, 36235, 21306, 34502, 26354, 36527, 23624, 39537, 28192, 33774, 33775, 33779, 33780, 33781, 33782, 33783, 33786, 33787, 33788, 33790, 33791, 33792, 33794, 33797, 33799, 33800, 33801, 33802, 33808, 33810, 33811, 33812, 33813, 33814, 33815, 33817, 33818, 33819, 33822, 33823, 33824, 33825, 33826, 33827, 33833, 33834, 33835, 33836, 33837, 33838, 33839, 33840, 33842, 33843, 33844, 33845, 33846, 33847, 33849, 33850, 33851, 33854, 33855, 33856, 33857, 33858, 33859, 33860, 33861, 33863, 33864, 33865, 33866, 33867, 33868, 33869, 33870, 33871, 33872, 33874, 33875, 33876, 33877, 33878, 33880, 33885, 33886, 33887, 33888, 33890, 33892, 33893, 33894, 33895, 33896, 33898, 33902, 33903, 33904, 33906, 33908, 33911, 33913, 33915, 33916, 21462, 23094, 40843, 36259, 21435, 22280, 39079, 26435, 37275, 27849, 20840, 30154, 25331, 29356, 21048, 21149, 32570, 28820, 30264, 21364, 40522, 27063, 30830, 38592, 35033, 32676, 28982, 29123, 20873, 26579, 29924, 22756, 25880, 22199, 35753, 39286, 25200, 32469, 24825, 28909, 22764, 20161, 20154, 24525, 38887, 20219, 35748, 20995, 22922, 32427, 25172, 20173, 26085, 25102, 33592, 33993, 33635, 34701, 29076, 28342, 23481, 32466, 20887, 25545, 26580, 32905, 33593, 34837, 20754, 23418, 22914, 36785, 20083, 27741, 20837, 35109, 36719, 38446, 34122, 29790, 38160, 38384, 28070, 33509, 24369, 25746, 27922, 33832, 33134, 40131, 22622, 36187, 19977, 21441, 33917, 33918, 33919, 33920, 33921, 33923, 33924, 33925, 33926, 33930, 33933, 33935, 33936, 33937, 33938, 33939, 33940, 33941, 33942, 33944, 33946, 33947, 33949, 33950, 33951, 33952, 33954, 33955, 33956, 33957, 33958, 33959, 33960, 33961, 33962, 33963, 33964, 33965, 33966, 33968, 33969, 33971, 33973, 33974, 33975, 33979, 33980, 33982, 33984, 33986, 33987, 33989, 33990, 33991, 33992, 33995, 33996, 33998, 33999, 34002, 34004, 34005, 34007, 34008, 34009, 34010, 34011, 34012, 34014, 34017, 34018, 34020, 34023, 34024, 34025, 34026, 34027, 34029, 34030, 34031, 34033, 34034, 34035, 34036, 34037, 34038, 34039, 34040, 34041, 34042, 34043, 34045, 34046, 34048, 34049, 34050, 20254, 25955, 26705, 21971, 20007, 25620, 39578, 25195, 23234, 29791, 33394, 28073, 26862, 20711, 33678, 30722, 26432, 21049, 27801, 32433, 20667, 21861, 29022, 31579, 26194, 29642, 33515, 26441, 23665, 21024, 29053, 34923, 38378, 38485, 25797, 36193, 33203, 21892, 27733, 25159, 32558, 22674, 20260, 21830, 36175, 26188, 19978, 23578, 35059, 26786, 25422, 31245, 28903, 33421, 21242, 38902, 23569, 21736, 37045, 32461, 22882, 36170, 34503, 33292, 33293, 36198, 25668, 23556, 24913, 28041, 31038, 35774, 30775, 30003, 21627, 20280, 36523, 28145, 23072, 32453, 31070, 27784, 23457, 23158, 29978, 32958, 24910, 28183, 22768, 29983, 29989, 29298, 21319, 32499, 34051, 34052, 34053, 34054, 34055, 34056, 34057, 34058, 34059, 34061, 34062, 34063, 34064, 34066, 34068, 34069, 34070, 34072, 34073, 34075, 34076, 34077, 34078, 34080, 34082, 34083, 34084, 34085, 34086, 34087, 34088, 34089, 34090, 34093, 34094, 34095, 34096, 34097, 34098, 34099, 34100, 34101, 34102, 34110, 34111, 34112, 34113, 34114, 34116, 34117, 34118, 34119, 34123, 34124, 34125, 34126, 34127, 34128, 34129, 34130, 34131, 34132, 34133, 34135, 34136, 34138, 34139, 34140, 34141, 34143, 34144, 34145, 34146, 34147, 34149, 34150, 34151, 34153, 34154, 34155, 34156, 34157, 34158, 34159, 34160, 34161, 34163, 34165, 34166, 34167, 34168, 34172, 34173, 34175, 34176, 34177, 30465, 30427, 21097, 32988, 22307, 24072, 22833, 29422, 26045, 28287, 35799, 23608, 34417, 21313, 30707, 25342, 26102, 20160, 39135, 34432, 23454, 35782, 21490, 30690, 20351, 23630, 39542, 22987, 24335, 31034, 22763, 19990, 26623, 20107, 25325, 35475, 36893, 21183, 26159, 21980, 22124, 36866, 20181, 20365, 37322, 39280, 27663, 24066, 24643, 23460, 35270, 35797, 25910, 25163, 39318, 23432, 23551, 25480, 21806, 21463, 30246, 20861, 34092, 26530, 26803, 27530, 25234, 36755, 21460, 33298, 28113, 30095, 20070, 36174, 23408, 29087, 34223, 26257, 26329, 32626, 34560, 40653, 40736, 23646, 26415, 36848, 26641, 26463, 25101, 31446, 22661, 24246, 25968, 28465, 34178, 34179, 34182, 34184, 34185, 34186, 34187, 34188, 34189, 34190, 34192, 34193, 34194, 34195, 34196, 34197, 34198, 34199, 34200, 34201, 34202, 34205, 34206, 34207, 34208, 34209, 34210, 34211, 34213, 34214, 34215, 34217, 34219, 34220, 34221, 34225, 34226, 34227, 34228, 34229, 34230, 34232, 34234, 34235, 34236, 34237, 34238, 34239, 34240, 34242, 34243, 34244, 34245, 34246, 34247, 34248, 34250, 34251, 34252, 34253, 34254, 34257, 34258, 34260, 34262, 34263, 34264, 34265, 34266, 34267, 34269, 34270, 34271, 34272, 34273, 34274, 34275, 34277, 34278, 34279, 34280, 34282, 34283, 34284, 34285, 34286, 34287, 34288, 34289, 34290, 34291, 34292, 34293, 34294, 34295, 34296, 24661, 21047, 32781, 25684, 34928, 29993, 24069, 26643, 25332, 38684, 21452, 29245, 35841, 27700, 30561, 31246, 21550, 30636, 39034, 33308, 35828, 30805, 26388, 28865, 26031, 25749, 22070, 24605, 31169, 21496, 19997, 27515, 32902, 23546, 21987, 22235, 20282, 20284, 39282, 24051, 26494, 32824, 24578, 39042, 36865, 23435, 35772, 35829, 25628, 33368, 25822, 22013, 33487, 37221, 20439, 32032, 36895, 31903, 20723, 22609, 28335, 23487, 35785, 32899, 37240, 33948, 31639, 34429, 38539, 38543, 32485, 39635, 30862, 23681, 31319, 36930, 38567, 31071, 23385, 25439, 31499, 34001, 26797, 21766, 32553, 29712, 32034, 38145, 25152, 22604, 20182, 23427, 22905, 22612, 34297, 34298, 34300, 34301, 34302, 34304, 34305, 34306, 34307, 34308, 34310, 34311, 34312, 34313, 34314, 34315, 34316, 34317, 34318, 34319, 34320, 34322, 34323, 34324, 34325, 34327, 34328, 34329, 34330, 34331, 34332, 34333, 34334, 34335, 34336, 34337, 34338, 34339, 34340, 34341, 34342, 34344, 34346, 34347, 34348, 34349, 34350, 34351, 34352, 34353, 34354, 34355, 34356, 34357, 34358, 34359, 34361, 34362, 34363, 34365, 34366, 34367, 34368, 34369, 34370, 34371, 34372, 34373, 34374, 34375, 34376, 34377, 34378, 34379, 34380, 34386, 34387, 34389, 34390, 34391, 34392, 34393, 34395, 34396, 34397, 34399, 34400, 34401, 34403, 34404, 34405, 34406, 34407, 34408, 34409, 34410, 29549, 25374, 36427, 36367, 32974, 33492, 25260, 21488, 27888, 37214, 22826, 24577, 27760, 22349, 25674, 36138, 30251, 28393, 22363, 27264, 30192, 28525, 35885, 35848, 22374, 27631, 34962, 30899, 25506, 21497, 28845, 27748, 22616, 25642, 22530, 26848, 33179, 21776, 31958, 20504, 36538, 28108, 36255, 28907, 25487, 28059, 28372, 32486, 33796, 26691, 36867, 28120, 38518, 35752, 22871, 29305, 34276, 33150, 30140, 35466, 26799, 21076, 36386, 38161, 25552, 39064, 36420, 21884, 20307, 26367, 22159, 24789, 28053, 21059, 23625, 22825, 28155, 22635, 3e4, 29980, 24684, 33300, 33094, 25361, 26465, 36834, 30522, 36339, 36148, 38081, 24086, 21381, 21548, 28867, 34413, 34415, 34416, 34418, 34419, 34420, 34421, 34422, 34423, 34424, 34435, 34436, 34437, 34438, 34439, 34440, 34441, 34446, 34447, 34448, 34449, 34450, 34452, 34454, 34455, 34456, 34457, 34458, 34459, 34462, 34463, 34464, 34465, 34466, 34469, 34470, 34475, 34477, 34478, 34482, 34483, 34487, 34488, 34489, 34491, 34492, 34493, 34494, 34495, 34497, 34498, 34499, 34501, 34504, 34508, 34509, 34514, 34515, 34517, 34518, 34519, 34522, 34524, 34525, 34528, 34529, 34530, 34531, 34533, 34534, 34535, 34536, 34538, 34539, 34540, 34543, 34549, 34550, 34551, 34554, 34555, 34556, 34557, 34559, 34561, 34564, 34565, 34566, 34571, 34572, 34574, 34575, 34576, 34577, 34580, 34582, 27712, 24311, 20572, 20141, 24237, 25402, 33351, 36890, 26704, 37230, 30643, 21516, 38108, 24420, 31461, 26742, 25413, 31570, 32479, 30171, 20599, 25237, 22836, 36879, 20984, 31171, 31361, 22270, 24466, 36884, 28034, 23648, 22303, 21520, 20820, 28237, 22242, 25512, 39059, 33151, 34581, 35114, 36864, 21534, 23663, 33216, 25302, 25176, 33073, 40501, 38464, 39534, 39548, 26925, 22949, 25299, 21822, 25366, 21703, 34521, 27964, 23043, 29926, 34972, 27498, 22806, 35916, 24367, 28286, 29609, 39037, 20024, 28919, 23436, 30871, 25405, 26202, 30358, 24779, 23451, 23113, 19975, 33109, 27754, 29579, 20129, 26505, 32593, 24448, 26106, 26395, 24536, 22916, 23041, 34585, 34587, 34589, 34591, 34592, 34596, 34598, 34599, 34600, 34602, 34603, 34604, 34605, 34607, 34608, 34610, 34611, 34613, 34614, 34616, 34617, 34618, 34620, 34621, 34624, 34625, 34626, 34627, 34628, 34629, 34630, 34634, 34635, 34637, 34639, 34640, 34641, 34642, 34644, 34645, 34646, 34648, 34650, 34651, 34652, 34653, 34654, 34655, 34657, 34658, 34662, 34663, 34664, 34665, 34666, 34667, 34668, 34669, 34671, 34673, 34674, 34675, 34677, 34679, 34680, 34681, 34682, 34687, 34688, 34689, 34692, 34694, 34695, 34697, 34698, 34700, 34702, 34703, 34704, 34705, 34706, 34708, 34709, 34710, 34712, 34713, 34714, 34715, 34716, 34717, 34718, 34720, 34721, 34722, 34723, 34724, 24013, 24494, 21361, 38886, 36829, 26693, 22260, 21807, 24799, 20026, 28493, 32500, 33479, 33806, 22996, 20255, 20266, 23614, 32428, 26410, 34074, 21619, 30031, 32963, 21890, 39759, 20301, 28205, 35859, 23561, 24944, 21355, 30239, 28201, 34442, 25991, 38395, 32441, 21563, 31283, 32010, 38382, 21985, 32705, 29934, 25373, 34583, 28065, 31389, 25105, 26017, 21351, 25569, 27779, 24043, 21596, 38056, 20044, 27745, 35820, 23627, 26080, 33436, 26791, 21566, 21556, 27595, 27494, 20116, 25410, 21320, 33310, 20237, 20398, 22366, 25098, 38654, 26212, 29289, 21247, 21153, 24735, 35823, 26132, 29081, 26512, 35199, 30802, 30717, 26224, 22075, 21560, 38177, 29306, 34725, 34726, 34727, 34729, 34730, 34734, 34736, 34737, 34738, 34740, 34742, 34743, 34744, 34745, 34747, 34748, 34750, 34751, 34753, 34754, 34755, 34756, 34757, 34759, 34760, 34761, 34764, 34765, 34766, 34767, 34768, 34772, 34773, 34774, 34775, 34776, 34777, 34778, 34780, 34781, 34782, 34783, 34785, 34786, 34787, 34788, 34790, 34791, 34792, 34793, 34795, 34796, 34797, 34799, 34800, 34801, 34802, 34803, 34804, 34805, 34806, 34807, 34808, 34810, 34811, 34812, 34813, 34815, 34816, 34817, 34818, 34820, 34821, 34822, 34823, 34824, 34825, 34827, 34828, 34829, 34830, 34831, 34832, 34833, 34834, 34836, 34839, 34840, 34841, 34842, 34844, 34845, 34846, 34847, 34848, 34851, 31232, 24687, 24076, 24713, 33181, 22805, 24796, 29060, 28911, 28330, 27728, 29312, 27268, 34989, 24109, 20064, 23219, 21916, 38115, 27927, 31995, 38553, 25103, 32454, 30606, 34430, 21283, 38686, 36758, 26247, 23777, 20384, 29421, 19979, 21414, 22799, 21523, 25472, 38184, 20808, 20185, 40092, 32420, 21688, 36132, 34900, 33335, 38386, 28046, 24358, 23244, 26174, 38505, 29616, 29486, 21439, 33146, 39301, 32673, 23466, 38519, 38480, 32447, 30456, 21410, 38262, 39321, 31665, 35140, 28248, 20065, 32724, 31077, 35814, 24819, 21709, 20139, 39033, 24055, 27233, 20687, 21521, 35937, 33831, 30813, 38660, 21066, 21742, 22179, 38144, 28040, 23477, 28102, 26195, 34852, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34867, 34868, 34869, 34870, 34871, 34872, 34874, 34875, 34877, 34878, 34879, 34881, 34882, 34883, 34886, 34887, 34888, 34889, 34890, 34891, 34894, 34895, 34896, 34897, 34898, 34899, 34901, 34902, 34904, 34906, 34907, 34908, 34909, 34910, 34911, 34912, 34918, 34919, 34922, 34925, 34927, 34929, 34931, 34932, 34933, 34934, 34936, 34937, 34938, 34939, 34940, 34944, 34947, 34950, 34951, 34953, 34954, 34956, 34958, 34959, 34960, 34961, 34963, 34964, 34965, 34967, 34968, 34969, 34970, 34971, 34973, 34974, 34975, 34976, 34977, 34979, 34981, 34982, 34983, 34984, 34985, 34986, 23567, 23389, 26657, 32918, 21880, 31505, 25928, 26964, 20123, 27463, 34638, 38795, 21327, 25375, 25658, 37034, 26012, 32961, 35856, 20889, 26800, 21368, 34809, 25032, 27844, 27899, 35874, 23633, 34218, 33455, 38156, 27427, 36763, 26032, 24571, 24515, 20449, 34885, 26143, 33125, 29481, 24826, 20852, 21009, 22411, 24418, 37026, 34892, 37266, 24184, 26447, 24615, 22995, 20804, 20982, 33016, 21256, 27769, 38596, 29066, 20241, 20462, 32670, 26429, 21957, 38152, 31168, 34966, 32483, 22687, 25100, 38656, 34394, 22040, 39035, 24464, 35768, 33988, 37207, 21465, 26093, 24207, 30044, 24676, 32110, 23167, 32490, 32493, 36713, 21927, 23459, 24748, 26059, 29572, 34988, 34990, 34991, 34992, 34994, 34995, 34996, 34997, 34998, 35e3, 35001, 35002, 35003, 35005, 35006, 35007, 35008, 35011, 35012, 35015, 35016, 35018, 35019, 35020, 35021, 35023, 35024, 35025, 35027, 35030, 35031, 35034, 35035, 35036, 35037, 35038, 35040, 35041, 35046, 35047, 35049, 35050, 35051, 35052, 35053, 35054, 35055, 35058, 35061, 35062, 35063, 35066, 35067, 35069, 35071, 35072, 35073, 35075, 35076, 35077, 35078, 35079, 35080, 35081, 35083, 35084, 35085, 35086, 35087, 35089, 35092, 35093, 35094, 35095, 35096, 35100, 35101, 35102, 35103, 35104, 35106, 35107, 35108, 35110, 35111, 35112, 35113, 35116, 35117, 35118, 35119, 35121, 35122, 35123, 35125, 35127, 36873, 30307, 30505, 32474, 38772, 34203, 23398, 31348, 38634, 34880, 21195, 29071, 24490, 26092, 35810, 23547, 39535, 24033, 27529, 27739, 35757, 35759, 36874, 36805, 21387, 25276, 40486, 40493, 21568, 20011, 33469, 29273, 34460, 23830, 34905, 28079, 38597, 21713, 20122, 35766, 28937, 21693, 38409, 28895, 28153, 30416, 20005, 30740, 34578, 23721, 24310, 35328, 39068, 38414, 28814, 27839, 22852, 25513, 30524, 34893, 28436, 33395, 22576, 29141, 21388, 30746, 38593, 21761, 24422, 28976, 23476, 35866, 39564, 27523, 22830, 40495, 31207, 26472, 25196, 20335, 30113, 32650, 27915, 38451, 27687, 20208, 30162, 20859, 26679, 28478, 36992, 33136, 22934, 29814, 35128, 35129, 35130, 35131, 35132, 35133, 35134, 35135, 35136, 35138, 35139, 35141, 35142, 35143, 35144, 35145, 35146, 35147, 35148, 35149, 35150, 35151, 35152, 35153, 35154, 35155, 35156, 35157, 35158, 35159, 35160, 35161, 35162, 35163, 35164, 35165, 35168, 35169, 35170, 35171, 35172, 35173, 35175, 35176, 35177, 35178, 35179, 35180, 35181, 35182, 35183, 35184, 35185, 35186, 35187, 35188, 35189, 35190, 35191, 35192, 35193, 35194, 35196, 35197, 35198, 35200, 35202, 35204, 35205, 35207, 35208, 35209, 35210, 35211, 35212, 35213, 35214, 35215, 35216, 35217, 35218, 35219, 35220, 35221, 35222, 35223, 35224, 35225, 35226, 35227, 35228, 35229, 35230, 35231, 35232, 35233, 25671, 23591, 36965, 31377, 35875, 23002, 21676, 33280, 33647, 35201, 32768, 26928, 22094, 32822, 29239, 37326, 20918, 20063, 39029, 25494, 19994, 21494, 26355, 33099, 22812, 28082, 19968, 22777, 21307, 25558, 38129, 20381, 20234, 34915, 39056, 22839, 36951, 31227, 20202, 33008, 30097, 27778, 23452, 23016, 24413, 26885, 34433, 20506, 24050, 20057, 30691, 20197, 33402, 25233, 26131, 37009, 23673, 20159, 24441, 33222, 36920, 32900, 30123, 20134, 35028, 24847, 27589, 24518, 20041, 30410, 28322, 35811, 35758, 35850, 35793, 24322, 32764, 32716, 32462, 33589, 33643, 22240, 27575, 38899, 38452, 23035, 21535, 38134, 28139, 23493, 39278, 23609, 24341, 38544, 35234, 35235, 35236, 35237, 35238, 35239, 35240, 35241, 35242, 35243, 35244, 35245, 35246, 35247, 35248, 35249, 35250, 35251, 35252, 35253, 35254, 35255, 35256, 35257, 35258, 35259, 35260, 35261, 35262, 35263, 35264, 35267, 35277, 35283, 35284, 35285, 35287, 35288, 35289, 35291, 35293, 35295, 35296, 35297, 35298, 35300, 35303, 35304, 35305, 35306, 35308, 35309, 35310, 35312, 35313, 35314, 35316, 35317, 35318, 35319, 35320, 35321, 35322, 35323, 35324, 35325, 35326, 35327, 35329, 35330, 35331, 35332, 35333, 35334, 35336, 35337, 35338, 35339, 35340, 35341, 35342, 35343, 35344, 35345, 35346, 35347, 35348, 35349, 35350, 35351, 35352, 35353, 35354, 35355, 35356, 35357, 21360, 33521, 27185, 23156, 40560, 24212, 32552, 33721, 33828, 33829, 33639, 34631, 36814, 36194, 30408, 24433, 39062, 30828, 26144, 21727, 25317, 20323, 33219, 30152, 24248, 38605, 36362, 34553, 21647, 27891, 28044, 27704, 24703, 21191, 29992, 24189, 20248, 24736, 24551, 23588, 30001, 37038, 38080, 29369, 27833, 28216, 37193, 26377, 21451, 21491, 20305, 37321, 35825, 21448, 24188, 36802, 28132, 20110, 30402, 27014, 34398, 24858, 33286, 20313, 20446, 36926, 40060, 24841, 28189, 28180, 38533, 20104, 23089, 38632, 19982, 23679, 31161, 23431, 35821, 32701, 29577, 22495, 33419, 37057, 21505, 36935, 21947, 23786, 24481, 24840, 27442, 29425, 32946, 35465, 35358, 35359, 35360, 35361, 35362, 35363, 35364, 35365, 35366, 35367, 35368, 35369, 35370, 35371, 35372, 35373, 35374, 35375, 35376, 35377, 35378, 35379, 35380, 35381, 35382, 35383, 35384, 35385, 35386, 35387, 35388, 35389, 35391, 35392, 35393, 35394, 35395, 35396, 35397, 35398, 35399, 35401, 35402, 35403, 35404, 35405, 35406, 35407, 35408, 35409, 35410, 35411, 35412, 35413, 35414, 35415, 35416, 35417, 35418, 35419, 35420, 35421, 35422, 35423, 35424, 35425, 35426, 35427, 35428, 35429, 35430, 35431, 35432, 35433, 35434, 35435, 35436, 35437, 35438, 35439, 35440, 35441, 35442, 35443, 35444, 35445, 35446, 35447, 35448, 35450, 35451, 35452, 35453, 35454, 35455, 35456, 28020, 23507, 35029, 39044, 35947, 39533, 40499, 28170, 20900, 20803, 22435, 34945, 21407, 25588, 36757, 22253, 21592, 22278, 29503, 28304, 32536, 36828, 33489, 24895, 24616, 38498, 26352, 32422, 36234, 36291, 38053, 23731, 31908, 26376, 24742, 38405, 32792, 20113, 37095, 21248, 38504, 20801, 36816, 34164, 37213, 26197, 38901, 23381, 21277, 30776, 26434, 26685, 21705, 28798, 23472, 36733, 20877, 22312, 21681, 25874, 26242, 36190, 36163, 33039, 33900, 36973, 31967, 20991, 34299, 26531, 26089, 28577, 34468, 36481, 22122, 36896, 30338, 28790, 29157, 36131, 25321, 21017, 27901, 36156, 24590, 22686, 24974, 26366, 36192, 25166, 21939, 28195, 26413, 36711, 35457, 35458, 35459, 35460, 35461, 35462, 35463, 35464, 35467, 35468, 35469, 35470, 35471, 35472, 35473, 35474, 35476, 35477, 35478, 35479, 35480, 35481, 35482, 35483, 35484, 35485, 35486, 35487, 35488, 35489, 35490, 35491, 35492, 35493, 35494, 35495, 35496, 35497, 35498, 35499, 35500, 35501, 35502, 35503, 35504, 35505, 35506, 35507, 35508, 35509, 35510, 35511, 35512, 35513, 35514, 35515, 35516, 35517, 35518, 35519, 35520, 35521, 35522, 35523, 35524, 35525, 35526, 35527, 35528, 35529, 35530, 35531, 35532, 35533, 35534, 35535, 35536, 35537, 35538, 35539, 35540, 35541, 35542, 35543, 35544, 35545, 35546, 35547, 35548, 35549, 35550, 35551, 35552, 35553, 35554, 35555, 38113, 38392, 30504, 26629, 27048, 21643, 20045, 28856, 35784, 25688, 25995, 23429, 31364, 20538, 23528, 30651, 27617, 35449, 31896, 27838, 30415, 26025, 36759, 23853, 23637, 34360, 26632, 21344, 25112, 31449, 28251, 32509, 27167, 31456, 24432, 28467, 24352, 25484, 28072, 26454, 19976, 24080, 36134, 20183, 32960, 30260, 38556, 25307, 26157, 25214, 27836, 36213, 29031, 32617, 20806, 32903, 21484, 36974, 25240, 21746, 34544, 36761, 32773, 38167, 34071, 36825, 27993, 29645, 26015, 30495, 29956, 30759, 33275, 36126, 38024, 20390, 26517, 30137, 35786, 38663, 25391, 38215, 38453, 33976, 25379, 30529, 24449, 29424, 20105, 24596, 25972, 25327, 27491, 25919, 35556, 35557, 35558, 35559, 35560, 35561, 35562, 35563, 35564, 35565, 35566, 35567, 35568, 35569, 35570, 35571, 35572, 35573, 35574, 35575, 35576, 35577, 35578, 35579, 35580, 35581, 35582, 35583, 35584, 35585, 35586, 35587, 35588, 35589, 35590, 35592, 35593, 35594, 35595, 35596, 35597, 35598, 35599, 35600, 35601, 35602, 35603, 35604, 35605, 35606, 35607, 35608, 35609, 35610, 35611, 35612, 35613, 35614, 35615, 35616, 35617, 35618, 35619, 35620, 35621, 35623, 35624, 35625, 35626, 35627, 35628, 35629, 35630, 35631, 35632, 35633, 35634, 35635, 35636, 35637, 35638, 35639, 35640, 35641, 35642, 35643, 35644, 35645, 35646, 35647, 35648, 35649, 35650, 35651, 35652, 35653, 24103, 30151, 37073, 35777, 33437, 26525, 25903, 21553, 34584, 30693, 32930, 33026, 27713, 20043, 32455, 32844, 30452, 26893, 27542, 25191, 20540, 20356, 22336, 25351, 27490, 36286, 21482, 26088, 32440, 24535, 25370, 25527, 33267, 33268, 32622, 24092, 23769, 21046, 26234, 31209, 31258, 36136, 28825, 30164, 28382, 27835, 31378, 20013, 30405, 24544, 38047, 34935, 32456, 31181, 32959, 37325, 20210, 20247, 33311, 21608, 24030, 27954, 35788, 31909, 36724, 32920, 24090, 21650, 30385, 23449, 26172, 39588, 29664, 26666, 34523, 26417, 29482, 35832, 35803, 36880, 31481, 28891, 29038, 25284, 30633, 22065, 20027, 33879, 26609, 21161, 34496, 36142, 38136, 31569, 35654, 35655, 35656, 35657, 35658, 35659, 35660, 35661, 35662, 35663, 35664, 35665, 35666, 35667, 35668, 35669, 35670, 35671, 35672, 35673, 35674, 35675, 35676, 35677, 35678, 35679, 35680, 35681, 35682, 35683, 35684, 35685, 35687, 35688, 35689, 35690, 35691, 35693, 35694, 35695, 35696, 35697, 35698, 35699, 35700, 35701, 35702, 35703, 35704, 35705, 35706, 35707, 35708, 35709, 35710, 35711, 35712, 35713, 35714, 35715, 35716, 35717, 35718, 35719, 35720, 35721, 35722, 35723, 35724, 35725, 35726, 35727, 35728, 35729, 35730, 35731, 35732, 35733, 35734, 35735, 35736, 35737, 35738, 35739, 35740, 35741, 35742, 35743, 35756, 35761, 35771, 35783, 35792, 35818, 35849, 35870, 20303, 27880, 31069, 39547, 25235, 29226, 25341, 19987, 30742, 36716, 25776, 36186, 31686, 26729, 24196, 35013, 22918, 25758, 22766, 29366, 26894, 38181, 36861, 36184, 22368, 32512, 35846, 20934, 25417, 25305, 21331, 26700, 29730, 33537, 37196, 21828, 30528, 28796, 27978, 20857, 21672, 36164, 23039, 28363, 28100, 23388, 32043, 20180, 31869, 28371, 23376, 33258, 28173, 23383, 39683, 26837, 36394, 23447, 32508, 24635, 32437, 37049, 36208, 22863, 25549, 31199, 36275, 21330, 26063, 31062, 35781, 38459, 32452, 38075, 32386, 22068, 37257, 26368, 32618, 23562, 36981, 26152, 24038, 20304, 26590, 20570, 20316, 22352, 24231, 59408, 59409, 59410, 59411, 59412, 35896, 35897, 35898, 35899, 35900, 35901, 35902, 35903, 35904, 35906, 35907, 35908, 35909, 35912, 35914, 35915, 35917, 35918, 35919, 35920, 35921, 35922, 35923, 35924, 35926, 35927, 35928, 35929, 35931, 35932, 35933, 35934, 35935, 35936, 35939, 35940, 35941, 35942, 35943, 35944, 35945, 35948, 35949, 35950, 35951, 35952, 35953, 35954, 35956, 35957, 35958, 35959, 35963, 35964, 35965, 35966, 35967, 35968, 35969, 35971, 35972, 35974, 35975, 35976, 35979, 35981, 35982, 35983, 35984, 35985, 35986, 35987, 35989, 35990, 35991, 35993, 35994, 35995, 35996, 35997, 35998, 35999, 36e3, 36001, 36002, 36003, 36004, 36005, 36006, 36007, 36008, 36009, 36010, 36011, 36012, 36013, 20109, 19980, 20800, 19984, 24319, 21317, 19989, 20120, 19998, 39730, 23404, 22121, 20008, 31162, 20031, 21269, 20039, 22829, 29243, 21358, 27664, 22239, 32996, 39319, 27603, 30590, 40727, 20022, 20127, 40720, 20060, 20073, 20115, 33416, 23387, 21868, 22031, 20164, 21389, 21405, 21411, 21413, 21422, 38757, 36189, 21274, 21493, 21286, 21294, 21310, 36188, 21350, 21347, 20994, 21e3, 21006, 21037, 21043, 21055, 21056, 21068, 21086, 21089, 21084, 33967, 21117, 21122, 21121, 21136, 21139, 20866, 32596, 20155, 20163, 20169, 20162, 20200, 20193, 20203, 20190, 20251, 20211, 20258, 20324, 20213, 20261, 20263, 20233, 20267, 20318, 20327, 25912, 20314, 20317, 36014, 36015, 36016, 36017, 36018, 36019, 36020, 36021, 36022, 36023, 36024, 36025, 36026, 36027, 36028, 36029, 36030, 36031, 36032, 36033, 36034, 36035, 36036, 36037, 36038, 36039, 36040, 36041, 36042, 36043, 36044, 36045, 36046, 36047, 36048, 36049, 36050, 36051, 36052, 36053, 36054, 36055, 36056, 36057, 36058, 36059, 36060, 36061, 36062, 36063, 36064, 36065, 36066, 36067, 36068, 36069, 36070, 36071, 36072, 36073, 36074, 36075, 36076, 36077, 36078, 36079, 36080, 36081, 36082, 36083, 36084, 36085, 36086, 36087, 36088, 36089, 36090, 36091, 36092, 36093, 36094, 36095, 36096, 36097, 36098, 36099, 36100, 36101, 36102, 36103, 36104, 36105, 36106, 36107, 36108, 36109, 20319, 20311, 20274, 20285, 20342, 20340, 20369, 20361, 20355, 20367, 20350, 20347, 20394, 20348, 20396, 20372, 20454, 20456, 20458, 20421, 20442, 20451, 20444, 20433, 20447, 20472, 20521, 20556, 20467, 20524, 20495, 20526, 20525, 20478, 20508, 20492, 20517, 20520, 20606, 20547, 20565, 20552, 20558, 20588, 20603, 20645, 20647, 20649, 20666, 20694, 20742, 20717, 20716, 20710, 20718, 20743, 20747, 20189, 27709, 20312, 20325, 20430, 40864, 27718, 31860, 20846, 24061, 40649, 39320, 20865, 22804, 21241, 21261, 35335, 21264, 20971, 22809, 20821, 20128, 20822, 20147, 34926, 34980, 20149, 33044, 35026, 31104, 23348, 34819, 32696, 20907, 20913, 20925, 20924, 36110, 36111, 36112, 36113, 36114, 36115, 36116, 36117, 36118, 36119, 36120, 36121, 36122, 36123, 36124, 36128, 36177, 36178, 36183, 36191, 36197, 36200, 36201, 36202, 36204, 36206, 36207, 36209, 36210, 36216, 36217, 36218, 36219, 36220, 36221, 36222, 36223, 36224, 36226, 36227, 36230, 36231, 36232, 36233, 36236, 36237, 36238, 36239, 36240, 36242, 36243, 36245, 36246, 36247, 36248, 36249, 36250, 36251, 36252, 36253, 36254, 36256, 36257, 36258, 36260, 36261, 36262, 36263, 36264, 36265, 36266, 36267, 36268, 36269, 36270, 36271, 36272, 36274, 36278, 36279, 36281, 36283, 36285, 36288, 36289, 36290, 36293, 36295, 36296, 36297, 36298, 36301, 36304, 36306, 36307, 36308, 20935, 20886, 20898, 20901, 35744, 35750, 35751, 35754, 35764, 35765, 35767, 35778, 35779, 35787, 35791, 35790, 35794, 35795, 35796, 35798, 35800, 35801, 35804, 35807, 35808, 35812, 35816, 35817, 35822, 35824, 35827, 35830, 35833, 35836, 35839, 35840, 35842, 35844, 35847, 35852, 35855, 35857, 35858, 35860, 35861, 35862, 35865, 35867, 35864, 35869, 35871, 35872, 35873, 35877, 35879, 35882, 35883, 35886, 35887, 35890, 35891, 35893, 35894, 21353, 21370, 38429, 38434, 38433, 38449, 38442, 38461, 38460, 38466, 38473, 38484, 38495, 38503, 38508, 38514, 38516, 38536, 38541, 38551, 38576, 37015, 37019, 37021, 37017, 37036, 37025, 37044, 37043, 37046, 37050, 36309, 36312, 36313, 36316, 36320, 36321, 36322, 36325, 36326, 36327, 36329, 36333, 36334, 36336, 36337, 36338, 36340, 36342, 36348, 36350, 36351, 36352, 36353, 36354, 36355, 36356, 36358, 36359, 36360, 36363, 36365, 36366, 36368, 36369, 36370, 36371, 36373, 36374, 36375, 36376, 36377, 36378, 36379, 36380, 36384, 36385, 36388, 36389, 36390, 36391, 36392, 36395, 36397, 36400, 36402, 36403, 36404, 36406, 36407, 36408, 36411, 36412, 36414, 36415, 36419, 36421, 36422, 36428, 36429, 36430, 36431, 36432, 36435, 36436, 36437, 36438, 36439, 36440, 36442, 36443, 36444, 36445, 36446, 36447, 36448, 36449, 36450, 36451, 36452, 36453, 36455, 36456, 36458, 36459, 36462, 36465, 37048, 37040, 37071, 37061, 37054, 37072, 37060, 37063, 37075, 37094, 37090, 37084, 37079, 37083, 37099, 37103, 37118, 37124, 37154, 37150, 37155, 37169, 37167, 37177, 37187, 37190, 21005, 22850, 21154, 21164, 21165, 21182, 21759, 21200, 21206, 21232, 21471, 29166, 30669, 24308, 20981, 20988, 39727, 21430, 24321, 30042, 24047, 22348, 22441, 22433, 22654, 22716, 22725, 22737, 22313, 22316, 22314, 22323, 22329, 22318, 22319, 22364, 22331, 22338, 22377, 22405, 22379, 22406, 22396, 22395, 22376, 22381, 22390, 22387, 22445, 22436, 22412, 22450, 22479, 22439, 22452, 22419, 22432, 22485, 22488, 22490, 22489, 22482, 22456, 22516, 22511, 22520, 22500, 22493, 36467, 36469, 36471, 36472, 36473, 36474, 36475, 36477, 36478, 36480, 36482, 36483, 36484, 36486, 36488, 36489, 36490, 36491, 36492, 36493, 36494, 36497, 36498, 36499, 36501, 36502, 36503, 36504, 36505, 36506, 36507, 36509, 36511, 36512, 36513, 36514, 36515, 36516, 36517, 36518, 36519, 36520, 36521, 36522, 36525, 36526, 36528, 36529, 36531, 36532, 36533, 36534, 36535, 36536, 36537, 36539, 36540, 36541, 36542, 36543, 36544, 36545, 36546, 36547, 36548, 36549, 36550, 36551, 36552, 36553, 36554, 36555, 36556, 36557, 36559, 36560, 36561, 36562, 36563, 36564, 36565, 36566, 36567, 36568, 36569, 36570, 36571, 36572, 36573, 36574, 36575, 36576, 36577, 36578, 36579, 36580, 22539, 22541, 22525, 22509, 22528, 22558, 22553, 22596, 22560, 22629, 22636, 22657, 22665, 22682, 22656, 39336, 40729, 25087, 33401, 33405, 33407, 33423, 33418, 33448, 33412, 33422, 33425, 33431, 33433, 33451, 33464, 33470, 33456, 33480, 33482, 33507, 33432, 33463, 33454, 33483, 33484, 33473, 33449, 33460, 33441, 33450, 33439, 33476, 33486, 33444, 33505, 33545, 33527, 33508, 33551, 33543, 33500, 33524, 33490, 33496, 33548, 33531, 33491, 33553, 33562, 33542, 33556, 33557, 33504, 33493, 33564, 33617, 33627, 33628, 33544, 33682, 33596, 33588, 33585, 33691, 33630, 33583, 33615, 33607, 33603, 33631, 33600, 33559, 33632, 33581, 33594, 33587, 33638, 33637, 36581, 36582, 36583, 36584, 36585, 36586, 36587, 36588, 36589, 36590, 36591, 36592, 36593, 36594, 36595, 36596, 36597, 36598, 36599, 36600, 36601, 36602, 36603, 36604, 36605, 36606, 36607, 36608, 36609, 36610, 36611, 36612, 36613, 36614, 36615, 36616, 36617, 36618, 36619, 36620, 36621, 36622, 36623, 36624, 36625, 36626, 36627, 36628, 36629, 36630, 36631, 36632, 36633, 36634, 36635, 36636, 36637, 36638, 36639, 36640, 36641, 36642, 36643, 36644, 36645, 36646, 36647, 36648, 36649, 36650, 36651, 36652, 36653, 36654, 36655, 36656, 36657, 36658, 36659, 36660, 36661, 36662, 36663, 36664, 36665, 36666, 36667, 36668, 36669, 36670, 36671, 36672, 36673, 36674, 36675, 36676, 33640, 33563, 33641, 33644, 33642, 33645, 33646, 33712, 33656, 33715, 33716, 33696, 33706, 33683, 33692, 33669, 33660, 33718, 33705, 33661, 33720, 33659, 33688, 33694, 33704, 33722, 33724, 33729, 33793, 33765, 33752, 22535, 33816, 33803, 33757, 33789, 33750, 33820, 33848, 33809, 33798, 33748, 33759, 33807, 33795, 33784, 33785, 33770, 33733, 33728, 33830, 33776, 33761, 33884, 33873, 33882, 33881, 33907, 33927, 33928, 33914, 33929, 33912, 33852, 33862, 33897, 33910, 33932, 33934, 33841, 33901, 33985, 33997, 34e3, 34022, 33981, 34003, 33994, 33983, 33978, 34016, 33953, 33977, 33972, 33943, 34021, 34019, 34060, 29965, 34104, 34032, 34105, 34079, 34106, 36677, 36678, 36679, 36680, 36681, 36682, 36683, 36684, 36685, 36686, 36687, 36688, 36689, 36690, 36691, 36692, 36693, 36694, 36695, 36696, 36697, 36698, 36699, 36700, 36701, 36702, 36703, 36704, 36705, 36706, 36707, 36708, 36709, 36714, 36736, 36748, 36754, 36765, 36768, 36769, 36770, 36772, 36773, 36774, 36775, 36778, 36780, 36781, 36782, 36783, 36786, 36787, 36788, 36789, 36791, 36792, 36794, 36795, 36796, 36799, 36800, 36803, 36806, 36809, 36810, 36811, 36812, 36813, 36815, 36818, 36822, 36823, 36826, 36832, 36833, 36835, 36839, 36844, 36847, 36849, 36850, 36852, 36853, 36854, 36858, 36859, 36860, 36862, 36863, 36871, 36872, 36876, 36878, 36883, 36885, 36888, 34134, 34107, 34047, 34044, 34137, 34120, 34152, 34148, 34142, 34170, 30626, 34115, 34162, 34171, 34212, 34216, 34183, 34191, 34169, 34222, 34204, 34181, 34233, 34231, 34224, 34259, 34241, 34268, 34303, 34343, 34309, 34345, 34326, 34364, 24318, 24328, 22844, 22849, 32823, 22869, 22874, 22872, 21263, 23586, 23589, 23596, 23604, 25164, 25194, 25247, 25275, 25290, 25306, 25303, 25326, 25378, 25334, 25401, 25419, 25411, 25517, 25590, 25457, 25466, 25486, 25524, 25453, 25516, 25482, 25449, 25518, 25532, 25586, 25592, 25568, 25599, 25540, 25566, 25550, 25682, 25542, 25534, 25669, 25665, 25611, 25627, 25632, 25612, 25638, 25633, 25694, 25732, 25709, 25750, 36889, 36892, 36899, 36900, 36901, 36903, 36904, 36905, 36906, 36907, 36908, 36912, 36913, 36914, 36915, 36916, 36919, 36921, 36922, 36925, 36927, 36928, 36931, 36933, 36934, 36936, 36937, 36938, 36939, 36940, 36942, 36948, 36949, 36950, 36953, 36954, 36956, 36957, 36958, 36959, 36960, 36961, 36964, 36966, 36967, 36969, 36970, 36971, 36972, 36975, 36976, 36977, 36978, 36979, 36982, 36983, 36984, 36985, 36986, 36987, 36988, 36990, 36993, 36996, 36997, 36998, 36999, 37001, 37002, 37004, 37005, 37006, 37007, 37008, 37010, 37012, 37014, 37016, 37018, 37020, 37022, 37023, 37024, 37028, 37029, 37031, 37032, 37033, 37035, 37037, 37042, 37047, 37052, 37053, 37055, 37056, 25722, 25783, 25784, 25753, 25786, 25792, 25808, 25815, 25828, 25826, 25865, 25893, 25902, 24331, 24530, 29977, 24337, 21343, 21489, 21501, 21481, 21480, 21499, 21522, 21526, 21510, 21579, 21586, 21587, 21588, 21590, 21571, 21537, 21591, 21593, 21539, 21554, 21634, 21652, 21623, 21617, 21604, 21658, 21659, 21636, 21622, 21606, 21661, 21712, 21677, 21698, 21684, 21714, 21671, 21670, 21715, 21716, 21618, 21667, 21717, 21691, 21695, 21708, 21721, 21722, 21724, 21673, 21674, 21668, 21725, 21711, 21726, 21787, 21735, 21792, 21757, 21780, 21747, 21794, 21795, 21775, 21777, 21799, 21802, 21863, 21903, 21941, 21833, 21869, 21825, 21845, 21823, 21840, 21820, 37058, 37059, 37062, 37064, 37065, 37067, 37068, 37069, 37074, 37076, 37077, 37078, 37080, 37081, 37082, 37086, 37087, 37088, 37091, 37092, 37093, 37097, 37098, 37100, 37102, 37104, 37105, 37106, 37107, 37109, 37110, 37111, 37113, 37114, 37115, 37116, 37119, 37120, 37121, 37123, 37125, 37126, 37127, 37128, 37129, 37130, 37131, 37132, 37133, 37134, 37135, 37136, 37137, 37138, 37139, 37140, 37141, 37142, 37143, 37144, 37146, 37147, 37148, 37149, 37151, 37152, 37153, 37156, 37157, 37158, 37159, 37160, 37161, 37162, 37163, 37164, 37165, 37166, 37168, 37170, 37171, 37172, 37173, 37174, 37175, 37176, 37178, 37179, 37180, 37181, 37182, 37183, 37184, 37185, 37186, 37188, 21815, 21846, 21877, 21878, 21879, 21811, 21808, 21852, 21899, 21970, 21891, 21937, 21945, 21896, 21889, 21919, 21886, 21974, 21905, 21883, 21983, 21949, 21950, 21908, 21913, 21994, 22007, 21961, 22047, 21969, 21995, 21996, 21972, 21990, 21981, 21956, 21999, 21989, 22002, 22003, 21964, 21965, 21992, 22005, 21988, 36756, 22046, 22024, 22028, 22017, 22052, 22051, 22014, 22016, 22055, 22061, 22104, 22073, 22103, 22060, 22093, 22114, 22105, 22108, 22092, 22100, 22150, 22116, 22129, 22123, 22139, 22140, 22149, 22163, 22191, 22228, 22231, 22237, 22241, 22261, 22251, 22265, 22271, 22276, 22282, 22281, 22300, 24079, 24089, 24084, 24081, 24113, 24123, 24124, 37189, 37191, 37192, 37201, 37203, 37204, 37205, 37206, 37208, 37209, 37211, 37212, 37215, 37216, 37222, 37223, 37224, 37227, 37229, 37235, 37242, 37243, 37244, 37248, 37249, 37250, 37251, 37252, 37254, 37256, 37258, 37262, 37263, 37267, 37268, 37269, 37270, 37271, 37272, 37273, 37276, 37277, 37278, 37279, 37280, 37281, 37284, 37285, 37286, 37287, 37288, 37289, 37291, 37292, 37296, 37297, 37298, 37299, 37302, 37303, 37304, 37305, 37307, 37308, 37309, 37310, 37311, 37312, 37313, 37314, 37315, 37316, 37317, 37318, 37320, 37323, 37328, 37330, 37331, 37332, 37333, 37334, 37335, 37336, 37337, 37338, 37339, 37341, 37342, 37343, 37344, 37345, 37346, 37347, 37348, 37349, 24119, 24132, 24148, 24155, 24158, 24161, 23692, 23674, 23693, 23696, 23702, 23688, 23704, 23705, 23697, 23706, 23708, 23733, 23714, 23741, 23724, 23723, 23729, 23715, 23745, 23735, 23748, 23762, 23780, 23755, 23781, 23810, 23811, 23847, 23846, 23854, 23844, 23838, 23814, 23835, 23896, 23870, 23860, 23869, 23916, 23899, 23919, 23901, 23915, 23883, 23882, 23913, 23924, 23938, 23961, 23965, 35955, 23991, 24005, 24435, 24439, 24450, 24455, 24457, 24460, 24469, 24473, 24476, 24488, 24493, 24501, 24508, 34914, 24417, 29357, 29360, 29364, 29367, 29368, 29379, 29377, 29390, 29389, 29394, 29416, 29423, 29417, 29426, 29428, 29431, 29441, 29427, 29443, 29434, 37350, 37351, 37352, 37353, 37354, 37355, 37356, 37357, 37358, 37359, 37360, 37361, 37362, 37363, 37364, 37365, 37366, 37367, 37368, 37369, 37370, 37371, 37372, 37373, 37374, 37375, 37376, 37377, 37378, 37379, 37380, 37381, 37382, 37383, 37384, 37385, 37386, 37387, 37388, 37389, 37390, 37391, 37392, 37393, 37394, 37395, 37396, 37397, 37398, 37399, 37400, 37401, 37402, 37403, 37404, 37405, 37406, 37407, 37408, 37409, 37410, 37411, 37412, 37413, 37414, 37415, 37416, 37417, 37418, 37419, 37420, 37421, 37422, 37423, 37424, 37425, 37426, 37427, 37428, 37429, 37430, 37431, 37432, 37433, 37434, 37435, 37436, 37437, 37438, 37439, 37440, 37441, 37442, 37443, 37444, 37445, 29435, 29463, 29459, 29473, 29450, 29470, 29469, 29461, 29474, 29497, 29477, 29484, 29496, 29489, 29520, 29517, 29527, 29536, 29548, 29551, 29566, 33307, 22821, 39143, 22820, 22786, 39267, 39271, 39272, 39273, 39274, 39275, 39276, 39284, 39287, 39293, 39296, 39300, 39303, 39306, 39309, 39312, 39313, 39315, 39316, 39317, 24192, 24209, 24203, 24214, 24229, 24224, 24249, 24245, 24254, 24243, 36179, 24274, 24273, 24283, 24296, 24298, 33210, 24516, 24521, 24534, 24527, 24579, 24558, 24580, 24545, 24548, 24574, 24581, 24582, 24554, 24557, 24568, 24601, 24629, 24614, 24603, 24591, 24589, 24617, 24619, 24586, 24639, 24609, 24696, 24697, 24699, 24698, 24642, 37446, 37447, 37448, 37449, 37450, 37451, 37452, 37453, 37454, 37455, 37456, 37457, 37458, 37459, 37460, 37461, 37462, 37463, 37464, 37465, 37466, 37467, 37468, 37469, 37470, 37471, 37472, 37473, 37474, 37475, 37476, 37477, 37478, 37479, 37480, 37481, 37482, 37483, 37484, 37485, 37486, 37487, 37488, 37489, 37490, 37491, 37493, 37494, 37495, 37496, 37497, 37498, 37499, 37500, 37501, 37502, 37503, 37504, 37505, 37506, 37507, 37508, 37509, 37510, 37511, 37512, 37513, 37514, 37515, 37516, 37517, 37519, 37520, 37521, 37522, 37523, 37524, 37525, 37526, 37527, 37528, 37529, 37530, 37531, 37532, 37533, 37534, 37535, 37536, 37537, 37538, 37539, 37540, 37541, 37542, 37543, 24682, 24701, 24726, 24730, 24749, 24733, 24707, 24722, 24716, 24731, 24812, 24763, 24753, 24797, 24792, 24774, 24794, 24756, 24864, 24870, 24853, 24867, 24820, 24832, 24846, 24875, 24906, 24949, 25004, 24980, 24999, 25015, 25044, 25077, 24541, 38579, 38377, 38379, 38385, 38387, 38389, 38390, 38396, 38398, 38403, 38404, 38406, 38408, 38410, 38411, 38412, 38413, 38415, 38418, 38421, 38422, 38423, 38425, 38426, 20012, 29247, 25109, 27701, 27732, 27740, 27722, 27811, 27781, 27792, 27796, 27788, 27752, 27753, 27764, 27766, 27782, 27817, 27856, 27860, 27821, 27895, 27896, 27889, 27863, 27826, 27872, 27862, 27898, 27883, 27886, 27825, 27859, 27887, 27902, 37544, 37545, 37546, 37547, 37548, 37549, 37551, 37552, 37553, 37554, 37555, 37556, 37557, 37558, 37559, 37560, 37561, 37562, 37563, 37564, 37565, 37566, 37567, 37568, 37569, 37570, 37571, 37572, 37573, 37574, 37575, 37577, 37578, 37579, 37580, 37581, 37582, 37583, 37584, 37585, 37586, 37587, 37588, 37589, 37590, 37591, 37592, 37593, 37594, 37595, 37596, 37597, 37598, 37599, 37600, 37601, 37602, 37603, 37604, 37605, 37606, 37607, 37608, 37609, 37610, 37611, 37612, 37613, 37614, 37615, 37616, 37617, 37618, 37619, 37620, 37621, 37622, 37623, 37624, 37625, 37626, 37627, 37628, 37629, 37630, 37631, 37632, 37633, 37634, 37635, 37636, 37637, 37638, 37639, 37640, 37641, 27961, 27943, 27916, 27971, 27976, 27911, 27908, 27929, 27918, 27947, 27981, 27950, 27957, 27930, 27983, 27986, 27988, 27955, 28049, 28015, 28062, 28064, 27998, 28051, 28052, 27996, 28e3, 28028, 28003, 28186, 28103, 28101, 28126, 28174, 28095, 28128, 28177, 28134, 28125, 28121, 28182, 28075, 28172, 28078, 28203, 28270, 28238, 28267, 28338, 28255, 28294, 28243, 28244, 28210, 28197, 28228, 28383, 28337, 28312, 28384, 28461, 28386, 28325, 28327, 28349, 28347, 28343, 28375, 28340, 28367, 28303, 28354, 28319, 28514, 28486, 28487, 28452, 28437, 28409, 28463, 28470, 28491, 28532, 28458, 28425, 28457, 28553, 28557, 28556, 28536, 28530, 28540, 28538, 28625, 37642, 37643, 37644, 37645, 37646, 37647, 37648, 37649, 37650, 37651, 37652, 37653, 37654, 37655, 37656, 37657, 37658, 37659, 37660, 37661, 37662, 37663, 37664, 37665, 37666, 37667, 37668, 37669, 37670, 37671, 37672, 37673, 37674, 37675, 37676, 37677, 37678, 37679, 37680, 37681, 37682, 37683, 37684, 37685, 37686, 37687, 37688, 37689, 37690, 37691, 37692, 37693, 37695, 37696, 37697, 37698, 37699, 37700, 37701, 37702, 37703, 37704, 37705, 37706, 37707, 37708, 37709, 37710, 37711, 37712, 37713, 37714, 37715, 37716, 37717, 37718, 37719, 37720, 37721, 37722, 37723, 37724, 37725, 37726, 37727, 37728, 37729, 37730, 37731, 37732, 37733, 37734, 37735, 37736, 37737, 37739, 28617, 28583, 28601, 28598, 28610, 28641, 28654, 28638, 28640, 28655, 28698, 28707, 28699, 28729, 28725, 28751, 28766, 23424, 23428, 23445, 23443, 23461, 23480, 29999, 39582, 25652, 23524, 23534, 35120, 23536, 36423, 35591, 36790, 36819, 36821, 36837, 36846, 36836, 36841, 36838, 36851, 36840, 36869, 36868, 36875, 36902, 36881, 36877, 36886, 36897, 36917, 36918, 36909, 36911, 36932, 36945, 36946, 36944, 36968, 36952, 36962, 36955, 26297, 36980, 36989, 36994, 37e3, 36995, 37003, 24400, 24407, 24406, 24408, 23611, 21675, 23632, 23641, 23409, 23651, 23654, 32700, 24362, 24361, 24365, 33396, 24380, 39739, 23662, 22913, 22915, 22925, 22953, 22954, 22947, 37740, 37741, 37742, 37743, 37744, 37745, 37746, 37747, 37748, 37749, 37750, 37751, 37752, 37753, 37754, 37755, 37756, 37757, 37758, 37759, 37760, 37761, 37762, 37763, 37764, 37765, 37766, 37767, 37768, 37769, 37770, 37771, 37772, 37773, 37774, 37776, 37777, 37778, 37779, 37780, 37781, 37782, 37783, 37784, 37785, 37786, 37787, 37788, 37789, 37790, 37791, 37792, 37793, 37794, 37795, 37796, 37797, 37798, 37799, 37800, 37801, 37802, 37803, 37804, 37805, 37806, 37807, 37808, 37809, 37810, 37811, 37812, 37813, 37814, 37815, 37816, 37817, 37818, 37819, 37820, 37821, 37822, 37823, 37824, 37825, 37826, 37827, 37828, 37829, 37830, 37831, 37832, 37833, 37835, 37836, 37837, 22935, 22986, 22955, 22942, 22948, 22994, 22962, 22959, 22999, 22974, 23045, 23046, 23005, 23048, 23011, 23e3, 23033, 23052, 23049, 23090, 23092, 23057, 23075, 23059, 23104, 23143, 23114, 23125, 23100, 23138, 23157, 33004, 23210, 23195, 23159, 23162, 23230, 23275, 23218, 23250, 23252, 23224, 23264, 23267, 23281, 23254, 23270, 23256, 23260, 23305, 23319, 23318, 23346, 23351, 23360, 23573, 23580, 23386, 23397, 23411, 23377, 23379, 23394, 39541, 39543, 39544, 39546, 39551, 39549, 39552, 39553, 39557, 39560, 39562, 39568, 39570, 39571, 39574, 39576, 39579, 39580, 39581, 39583, 39584, 39586, 39587, 39589, 39591, 32415, 32417, 32419, 32421, 32424, 32425, 37838, 37839, 37840, 37841, 37842, 37843, 37844, 37845, 37847, 37848, 37849, 37850, 37851, 37852, 37853, 37854, 37855, 37856, 37857, 37858, 37859, 37860, 37861, 37862, 37863, 37864, 37865, 37866, 37867, 37868, 37869, 37870, 37871, 37872, 37873, 37874, 37875, 37876, 37877, 37878, 37879, 37880, 37881, 37882, 37883, 37884, 37885, 37886, 37887, 37888, 37889, 37890, 37891, 37892, 37893, 37894, 37895, 37896, 37897, 37898, 37899, 37900, 37901, 37902, 37903, 37904, 37905, 37906, 37907, 37908, 37909, 37910, 37911, 37912, 37913, 37914, 37915, 37916, 37917, 37918, 37919, 37920, 37921, 37922, 37923, 37924, 37925, 37926, 37927, 37928, 37929, 37930, 37931, 37932, 37933, 37934, 32429, 32432, 32446, 32448, 32449, 32450, 32457, 32459, 32460, 32464, 32468, 32471, 32475, 32480, 32481, 32488, 32491, 32494, 32495, 32497, 32498, 32525, 32502, 32506, 32507, 32510, 32513, 32514, 32515, 32519, 32520, 32523, 32524, 32527, 32529, 32530, 32535, 32537, 32540, 32539, 32543, 32545, 32546, 32547, 32548, 32549, 32550, 32551, 32554, 32555, 32556, 32557, 32559, 32560, 32561, 32562, 32563, 32565, 24186, 30079, 24027, 30014, 37013, 29582, 29585, 29614, 29602, 29599, 29647, 29634, 29649, 29623, 29619, 29632, 29641, 29640, 29669, 29657, 39036, 29706, 29673, 29671, 29662, 29626, 29682, 29711, 29738, 29787, 29734, 29733, 29736, 29744, 29742, 29740, 37935, 37936, 37937, 37938, 37939, 37940, 37941, 37942, 37943, 37944, 37945, 37946, 37947, 37948, 37949, 37951, 37952, 37953, 37954, 37955, 37956, 37957, 37958, 37959, 37960, 37961, 37962, 37963, 37964, 37965, 37966, 37967, 37968, 37969, 37970, 37971, 37972, 37973, 37974, 37975, 37976, 37977, 37978, 37979, 37980, 37981, 37982, 37983, 37984, 37985, 37986, 37987, 37988, 37989, 37990, 37991, 37992, 37993, 37994, 37996, 37997, 37998, 37999, 38e3, 38001, 38002, 38003, 38004, 38005, 38006, 38007, 38008, 38009, 38010, 38011, 38012, 38013, 38014, 38015, 38016, 38017, 38018, 38019, 38020, 38033, 38038, 38040, 38087, 38095, 38099, 38100, 38106, 38118, 38139, 38172, 38176, 29723, 29722, 29761, 29788, 29783, 29781, 29785, 29815, 29805, 29822, 29852, 29838, 29824, 29825, 29831, 29835, 29854, 29864, 29865, 29840, 29863, 29906, 29882, 38890, 38891, 38892, 26444, 26451, 26462, 26440, 26473, 26533, 26503, 26474, 26483, 26520, 26535, 26485, 26536, 26526, 26541, 26507, 26487, 26492, 26608, 26633, 26584, 26634, 26601, 26544, 26636, 26585, 26549, 26586, 26547, 26589, 26624, 26563, 26552, 26594, 26638, 26561, 26621, 26674, 26675, 26720, 26721, 26702, 26722, 26692, 26724, 26755, 26653, 26709, 26726, 26689, 26727, 26688, 26686, 26698, 26697, 26665, 26805, 26767, 26740, 26743, 26771, 26731, 26818, 26990, 26876, 26911, 26912, 26873, 38183, 38195, 38205, 38211, 38216, 38219, 38229, 38234, 38240, 38254, 38260, 38261, 38263, 38264, 38265, 38266, 38267, 38268, 38269, 38270, 38272, 38273, 38274, 38275, 38276, 38277, 38278, 38279, 38280, 38281, 38282, 38283, 38284, 38285, 38286, 38287, 38288, 38289, 38290, 38291, 38292, 38293, 38294, 38295, 38296, 38297, 38298, 38299, 38300, 38301, 38302, 38303, 38304, 38305, 38306, 38307, 38308, 38309, 38310, 38311, 38312, 38313, 38314, 38315, 38316, 38317, 38318, 38319, 38320, 38321, 38322, 38323, 38324, 38325, 38326, 38327, 38328, 38329, 38330, 38331, 38332, 38333, 38334, 38335, 38336, 38337, 38338, 38339, 38340, 38341, 38342, 38343, 38344, 38345, 38346, 38347, 26916, 26864, 26891, 26881, 26967, 26851, 26896, 26993, 26937, 26976, 26946, 26973, 27012, 26987, 27008, 27032, 27e3, 26932, 27084, 27015, 27016, 27086, 27017, 26982, 26979, 27001, 27035, 27047, 27067, 27051, 27053, 27092, 27057, 27073, 27082, 27103, 27029, 27104, 27021, 27135, 27183, 27117, 27159, 27160, 27237, 27122, 27204, 27198, 27296, 27216, 27227, 27189, 27278, 27257, 27197, 27176, 27224, 27260, 27281, 27280, 27305, 27287, 27307, 29495, 29522, 27521, 27522, 27527, 27524, 27538, 27539, 27533, 27546, 27547, 27553, 27562, 36715, 36717, 36721, 36722, 36723, 36725, 36726, 36728, 36727, 36729, 36730, 36732, 36734, 36737, 36738, 36740, 36743, 36747, 38348, 38349, 38350, 38351, 38352, 38353, 38354, 38355, 38356, 38357, 38358, 38359, 38360, 38361, 38362, 38363, 38364, 38365, 38366, 38367, 38368, 38369, 38370, 38371, 38372, 38373, 38374, 38375, 38380, 38399, 38407, 38419, 38424, 38427, 38430, 38432, 38435, 38436, 38437, 38438, 38439, 38440, 38441, 38443, 38444, 38445, 38447, 38448, 38455, 38456, 38457, 38458, 38462, 38465, 38467, 38474, 38478, 38479, 38481, 38482, 38483, 38486, 38487, 38488, 38489, 38490, 38492, 38493, 38494, 38496, 38499, 38501, 38502, 38507, 38509, 38510, 38511, 38512, 38513, 38515, 38520, 38521, 38522, 38523, 38524, 38525, 38526, 38527, 38528, 38529, 38530, 38531, 38532, 38535, 38537, 38538, 36749, 36750, 36751, 36760, 36762, 36558, 25099, 25111, 25115, 25119, 25122, 25121, 25125, 25124, 25132, 33255, 29935, 29940, 29951, 29967, 29969, 29971, 25908, 26094, 26095, 26096, 26122, 26137, 26482, 26115, 26133, 26112, 28805, 26359, 26141, 26164, 26161, 26166, 26165, 32774, 26207, 26196, 26177, 26191, 26198, 26209, 26199, 26231, 26244, 26252, 26279, 26269, 26302, 26331, 26332, 26342, 26345, 36146, 36147, 36150, 36155, 36157, 36160, 36165, 36166, 36168, 36169, 36167, 36173, 36181, 36185, 35271, 35274, 35275, 35276, 35278, 35279, 35280, 35281, 29294, 29343, 29277, 29286, 29295, 29310, 29311, 29316, 29323, 29325, 29327, 29330, 25352, 25394, 25520, 38540, 38542, 38545, 38546, 38547, 38549, 38550, 38554, 38555, 38557, 38558, 38559, 38560, 38561, 38562, 38563, 38564, 38565, 38566, 38568, 38569, 38570, 38571, 38572, 38573, 38574, 38575, 38577, 38578, 38580, 38581, 38583, 38584, 38586, 38587, 38591, 38594, 38595, 38600, 38602, 38603, 38608, 38609, 38611, 38612, 38614, 38615, 38616, 38617, 38618, 38619, 38620, 38621, 38622, 38623, 38625, 38626, 38627, 38628, 38629, 38630, 38631, 38635, 38636, 38637, 38638, 38640, 38641, 38642, 38644, 38645, 38648, 38650, 38651, 38652, 38653, 38655, 38658, 38659, 38661, 38666, 38667, 38668, 38672, 38673, 38674, 38676, 38677, 38679, 38680, 38681, 38682, 38683, 38685, 38687, 38688, 25663, 25816, 32772, 27626, 27635, 27645, 27637, 27641, 27653, 27655, 27654, 27661, 27669, 27672, 27673, 27674, 27681, 27689, 27684, 27690, 27698, 25909, 25941, 25963, 29261, 29266, 29270, 29232, 34402, 21014, 32927, 32924, 32915, 32956, 26378, 32957, 32945, 32939, 32941, 32948, 32951, 32999, 33e3, 33001, 33002, 32987, 32962, 32964, 32985, 32973, 32983, 26384, 32989, 33003, 33009, 33012, 33005, 33037, 33038, 33010, 33020, 26389, 33042, 35930, 33078, 33054, 33068, 33048, 33074, 33096, 33100, 33107, 33140, 33113, 33114, 33137, 33120, 33129, 33148, 33149, 33133, 33127, 22605, 23221, 33160, 33154, 33169, 28373, 33187, 33194, 33228, 26406, 33226, 33211, 38689, 38690, 38691, 38692, 38693, 38694, 38695, 38696, 38697, 38699, 38700, 38702, 38703, 38705, 38707, 38708, 38709, 38710, 38711, 38714, 38715, 38716, 38717, 38719, 38720, 38721, 38722, 38723, 38724, 38725, 38726, 38727, 38728, 38729, 38730, 38731, 38732, 38733, 38734, 38735, 38736, 38737, 38740, 38741, 38743, 38744, 38746, 38748, 38749, 38751, 38755, 38756, 38758, 38759, 38760, 38762, 38763, 38764, 38765, 38766, 38767, 38768, 38769, 38770, 38773, 38775, 38776, 38777, 38778, 38779, 38781, 38782, 38783, 38784, 38785, 38786, 38787, 38788, 38790, 38791, 38792, 38793, 38794, 38796, 38798, 38799, 38800, 38803, 38805, 38806, 38807, 38809, 38810, 38811, 38812, 38813, 33217, 33190, 27428, 27447, 27449, 27459, 27462, 27481, 39121, 39122, 39123, 39125, 39129, 39130, 27571, 24384, 27586, 35315, 26e3, 40785, 26003, 26044, 26054, 26052, 26051, 26060, 26062, 26066, 26070, 28800, 28828, 28822, 28829, 28859, 28864, 28855, 28843, 28849, 28904, 28874, 28944, 28947, 28950, 28975, 28977, 29043, 29020, 29032, 28997, 29042, 29002, 29048, 29050, 29080, 29107, 29109, 29096, 29088, 29152, 29140, 29159, 29177, 29213, 29224, 28780, 28952, 29030, 29113, 25150, 25149, 25155, 25160, 25161, 31035, 31040, 31046, 31049, 31067, 31068, 31059, 31066, 31074, 31063, 31072, 31087, 31079, 31098, 31109, 31114, 31130, 31143, 31155, 24529, 24528, 38814, 38815, 38817, 38818, 38820, 38821, 38822, 38823, 38824, 38825, 38826, 38828, 38830, 38832, 38833, 38835, 38837, 38838, 38839, 38840, 38841, 38842, 38843, 38844, 38845, 38846, 38847, 38848, 38849, 38850, 38851, 38852, 38853, 38854, 38855, 38856, 38857, 38858, 38859, 38860, 38861, 38862, 38863, 38864, 38865, 38866, 38867, 38868, 38869, 38870, 38871, 38872, 38873, 38874, 38875, 38876, 38877, 38878, 38879, 38880, 38881, 38882, 38883, 38884, 38885, 38888, 38894, 38895, 38896, 38897, 38898, 38900, 38903, 38904, 38905, 38906, 38907, 38908, 38909, 38910, 38911, 38912, 38913, 38914, 38915, 38916, 38917, 38918, 38919, 38920, 38921, 38922, 38923, 38924, 38925, 38926, 24636, 24669, 24666, 24679, 24641, 24665, 24675, 24747, 24838, 24845, 24925, 25001, 24989, 25035, 25041, 25094, 32896, 32895, 27795, 27894, 28156, 30710, 30712, 30720, 30729, 30743, 30744, 30737, 26027, 30765, 30748, 30749, 30777, 30778, 30779, 30751, 30780, 30757, 30764, 30755, 30761, 30798, 30829, 30806, 30807, 30758, 30800, 30791, 30796, 30826, 30875, 30867, 30874, 30855, 30876, 30881, 30883, 30898, 30905, 30885, 30932, 30937, 30921, 30956, 30962, 30981, 30964, 30995, 31012, 31006, 31028, 40859, 40697, 40699, 40700, 30449, 30468, 30477, 30457, 30471, 30472, 30490, 30498, 30489, 30509, 30502, 30517, 30520, 30544, 30545, 30535, 30531, 30554, 30568, 38927, 38928, 38929, 38930, 38931, 38932, 38933, 38934, 38935, 38936, 38937, 38938, 38939, 38940, 38941, 38942, 38943, 38944, 38945, 38946, 38947, 38948, 38949, 38950, 38951, 38952, 38953, 38954, 38955, 38956, 38957, 38958, 38959, 38960, 38961, 38962, 38963, 38964, 38965, 38966, 38967, 38968, 38969, 38970, 38971, 38972, 38973, 38974, 38975, 38976, 38977, 38978, 38979, 38980, 38981, 38982, 38983, 38984, 38985, 38986, 38987, 38988, 38989, 38990, 38991, 38992, 38993, 38994, 38995, 38996, 38997, 38998, 38999, 39e3, 39001, 39002, 39003, 39004, 39005, 39006, 39007, 39008, 39009, 39010, 39011, 39012, 39013, 39014, 39015, 39016, 39017, 39018, 39019, 39020, 39021, 39022, 30562, 30565, 30591, 30605, 30589, 30592, 30604, 30609, 30623, 30624, 30640, 30645, 30653, 30010, 30016, 30030, 30027, 30024, 30043, 30066, 30073, 30083, 32600, 32609, 32607, 35400, 32616, 32628, 32625, 32633, 32641, 32638, 30413, 30437, 34866, 38021, 38022, 38023, 38027, 38026, 38028, 38029, 38031, 38032, 38036, 38039, 38037, 38042, 38043, 38044, 38051, 38052, 38059, 38058, 38061, 38060, 38063, 38064, 38066, 38068, 38070, 38071, 38072, 38073, 38074, 38076, 38077, 38079, 38084, 38088, 38089, 38090, 38091, 38092, 38093, 38094, 38096, 38097, 38098, 38101, 38102, 38103, 38105, 38104, 38107, 38110, 38111, 38112, 38114, 38116, 38117, 38119, 38120, 38122, 39023, 39024, 39025, 39026, 39027, 39028, 39051, 39054, 39058, 39061, 39065, 39075, 39080, 39081, 39082, 39083, 39084, 39085, 39086, 39087, 39088, 39089, 39090, 39091, 39092, 39093, 39094, 39095, 39096, 39097, 39098, 39099, 39100, 39101, 39102, 39103, 39104, 39105, 39106, 39107, 39108, 39109, 39110, 39111, 39112, 39113, 39114, 39115, 39116, 39117, 39119, 39120, 39124, 39126, 39127, 39131, 39132, 39133, 39136, 39137, 39138, 39139, 39140, 39141, 39142, 39145, 39146, 39147, 39148, 39149, 39150, 39151, 39152, 39153, 39154, 39155, 39156, 39157, 39158, 39159, 39160, 39161, 39162, 39163, 39164, 39165, 39166, 39167, 39168, 39169, 39170, 39171, 39172, 39173, 39174, 39175, 38121, 38123, 38126, 38127, 38131, 38132, 38133, 38135, 38137, 38140, 38141, 38143, 38147, 38146, 38150, 38151, 38153, 38154, 38157, 38158, 38159, 38162, 38163, 38164, 38165, 38166, 38168, 38171, 38173, 38174, 38175, 38178, 38186, 38187, 38185, 38188, 38193, 38194, 38196, 38198, 38199, 38200, 38204, 38206, 38207, 38210, 38197, 38212, 38213, 38214, 38217, 38220, 38222, 38223, 38226, 38227, 38228, 38230, 38231, 38232, 38233, 38235, 38238, 38239, 38237, 38241, 38242, 38244, 38245, 38246, 38247, 38248, 38249, 38250, 38251, 38252, 38255, 38257, 38258, 38259, 38202, 30695, 30700, 38601, 31189, 31213, 31203, 31211, 31238, 23879, 31235, 31234, 31262, 31252, 39176, 39177, 39178, 39179, 39180, 39182, 39183, 39185, 39186, 39187, 39188, 39189, 39190, 39191, 39192, 39193, 39194, 39195, 39196, 39197, 39198, 39199, 39200, 39201, 39202, 39203, 39204, 39205, 39206, 39207, 39208, 39209, 39210, 39211, 39212, 39213, 39215, 39216, 39217, 39218, 39219, 39220, 39221, 39222, 39223, 39224, 39225, 39226, 39227, 39228, 39229, 39230, 39231, 39232, 39233, 39234, 39235, 39236, 39237, 39238, 39239, 39240, 39241, 39242, 39243, 39244, 39245, 39246, 39247, 39248, 39249, 39250, 39251, 39254, 39255, 39256, 39257, 39258, 39259, 39260, 39261, 39262, 39263, 39264, 39265, 39266, 39268, 39270, 39283, 39288, 39289, 39291, 39294, 39298, 39299, 39305, 31289, 31287, 31313, 40655, 39333, 31344, 30344, 30350, 30355, 30361, 30372, 29918, 29920, 29996, 40480, 40482, 40488, 40489, 40490, 40491, 40492, 40498, 40497, 40502, 40504, 40503, 40505, 40506, 40510, 40513, 40514, 40516, 40518, 40519, 40520, 40521, 40523, 40524, 40526, 40529, 40533, 40535, 40538, 40539, 40540, 40542, 40547, 40550, 40551, 40552, 40553, 40554, 40555, 40556, 40561, 40557, 40563, 30098, 30100, 30102, 30112, 30109, 30124, 30115, 30131, 30132, 30136, 30148, 30129, 30128, 30147, 30146, 30166, 30157, 30179, 30184, 30182, 30180, 30187, 30183, 30211, 30193, 30204, 30207, 30224, 30208, 30213, 30220, 30231, 30218, 30245, 30232, 30229, 30233, 39308, 39310, 39322, 39323, 39324, 39325, 39326, 39327, 39328, 39329, 39330, 39331, 39332, 39334, 39335, 39337, 39338, 39339, 39340, 39341, 39342, 39343, 39344, 39345, 39346, 39347, 39348, 39349, 39350, 39351, 39352, 39353, 39354, 39355, 39356, 39357, 39358, 39359, 39360, 39361, 39362, 39363, 39364, 39365, 39366, 39367, 39368, 39369, 39370, 39371, 39372, 39373, 39374, 39375, 39376, 39377, 39378, 39379, 39380, 39381, 39382, 39383, 39384, 39385, 39386, 39387, 39388, 39389, 39390, 39391, 39392, 39393, 39394, 39395, 39396, 39397, 39398, 39399, 39400, 39401, 39402, 39403, 39404, 39405, 39406, 39407, 39408, 39409, 39410, 39411, 39412, 39413, 39414, 39415, 39416, 39417, 30235, 30268, 30242, 30240, 30272, 30253, 30256, 30271, 30261, 30275, 30270, 30259, 30285, 30302, 30292, 30300, 30294, 30315, 30319, 32714, 31462, 31352, 31353, 31360, 31366, 31368, 31381, 31398, 31392, 31404, 31400, 31405, 31411, 34916, 34921, 34930, 34941, 34943, 34946, 34978, 35014, 34999, 35004, 35017, 35042, 35022, 35043, 35045, 35057, 35098, 35068, 35048, 35070, 35056, 35105, 35097, 35091, 35099, 35082, 35124, 35115, 35126, 35137, 35174, 35195, 30091, 32997, 30386, 30388, 30684, 32786, 32788, 32790, 32796, 32800, 32802, 32805, 32806, 32807, 32809, 32808, 32817, 32779, 32821, 32835, 32838, 32845, 32850, 32873, 32881, 35203, 39032, 39040, 39043, 39418, 39419, 39420, 39421, 39422, 39423, 39424, 39425, 39426, 39427, 39428, 39429, 39430, 39431, 39432, 39433, 39434, 39435, 39436, 39437, 39438, 39439, 39440, 39441, 39442, 39443, 39444, 39445, 39446, 39447, 39448, 39449, 39450, 39451, 39452, 39453, 39454, 39455, 39456, 39457, 39458, 39459, 39460, 39461, 39462, 39463, 39464, 39465, 39466, 39467, 39468, 39469, 39470, 39471, 39472, 39473, 39474, 39475, 39476, 39477, 39478, 39479, 39480, 39481, 39482, 39483, 39484, 39485, 39486, 39487, 39488, 39489, 39490, 39491, 39492, 39493, 39494, 39495, 39496, 39497, 39498, 39499, 39500, 39501, 39502, 39503, 39504, 39505, 39506, 39507, 39508, 39509, 39510, 39511, 39512, 39513, 39049, 39052, 39053, 39055, 39060, 39066, 39067, 39070, 39071, 39073, 39074, 39077, 39078, 34381, 34388, 34412, 34414, 34431, 34426, 34428, 34427, 34472, 34445, 34443, 34476, 34461, 34471, 34467, 34474, 34451, 34473, 34486, 34500, 34485, 34510, 34480, 34490, 34481, 34479, 34505, 34511, 34484, 34537, 34545, 34546, 34541, 34547, 34512, 34579, 34526, 34548, 34527, 34520, 34513, 34563, 34567, 34552, 34568, 34570, 34573, 34569, 34595, 34619, 34590, 34597, 34606, 34586, 34622, 34632, 34612, 34609, 34601, 34615, 34623, 34690, 34594, 34685, 34686, 34683, 34656, 34672, 34636, 34670, 34699, 34643, 34659, 34684, 34660, 34649, 34661, 34707, 34735, 34728, 34770, 39514, 39515, 39516, 39517, 39518, 39519, 39520, 39521, 39522, 39523, 39524, 39525, 39526, 39527, 39528, 39529, 39530, 39531, 39538, 39555, 39561, 39565, 39566, 39572, 39573, 39577, 39590, 39593, 39594, 39595, 39596, 39597, 39598, 39599, 39602, 39603, 39604, 39605, 39609, 39611, 39613, 39614, 39615, 39619, 39620, 39622, 39623, 39624, 39625, 39626, 39629, 39630, 39631, 39632, 39634, 39636, 39637, 39638, 39639, 39641, 39642, 39643, 39644, 39645, 39646, 39648, 39650, 39651, 39652, 39653, 39655, 39656, 39657, 39658, 39660, 39662, 39664, 39665, 39666, 39667, 39668, 39669, 39670, 39671, 39672, 39674, 39676, 39677, 39678, 39679, 39680, 39681, 39682, 39684, 39685, 39686, 34758, 34696, 34693, 34733, 34711, 34691, 34731, 34789, 34732, 34741, 34739, 34763, 34771, 34749, 34769, 34752, 34762, 34779, 34794, 34784, 34798, 34838, 34835, 34814, 34826, 34843, 34849, 34873, 34876, 32566, 32578, 32580, 32581, 33296, 31482, 31485, 31496, 31491, 31492, 31509, 31498, 31531, 31503, 31559, 31544, 31530, 31513, 31534, 31537, 31520, 31525, 31524, 31539, 31550, 31518, 31576, 31578, 31557, 31605, 31564, 31581, 31584, 31598, 31611, 31586, 31602, 31601, 31632, 31654, 31655, 31672, 31660, 31645, 31656, 31621, 31658, 31644, 31650, 31659, 31668, 31697, 31681, 31692, 31709, 31706, 31717, 31718, 31722, 31756, 31742, 31740, 31759, 31766, 31755, 39687, 39689, 39690, 39691, 39692, 39693, 39694, 39696, 39697, 39698, 39700, 39701, 39702, 39703, 39704, 39705, 39706, 39707, 39708, 39709, 39710, 39712, 39713, 39714, 39716, 39717, 39718, 39719, 39720, 39721, 39722, 39723, 39724, 39725, 39726, 39728, 39729, 39731, 39732, 39733, 39734, 39735, 39736, 39737, 39738, 39741, 39742, 39743, 39744, 39750, 39754, 39755, 39756, 39758, 39760, 39762, 39763, 39765, 39766, 39767, 39768, 39769, 39770, 39771, 39772, 39773, 39774, 39775, 39776, 39777, 39778, 39779, 39780, 39781, 39782, 39783, 39784, 39785, 39786, 39787, 39788, 39789, 39790, 39791, 39792, 39793, 39794, 39795, 39796, 39797, 39798, 39799, 39800, 39801, 39802, 39803, 31775, 31786, 31782, 31800, 31809, 31808, 33278, 33281, 33282, 33284, 33260, 34884, 33313, 33314, 33315, 33325, 33327, 33320, 33323, 33336, 33339, 33331, 33332, 33342, 33348, 33353, 33355, 33359, 33370, 33375, 33384, 34942, 34949, 34952, 35032, 35039, 35166, 32669, 32671, 32679, 32687, 32688, 32690, 31868, 25929, 31889, 31901, 31900, 31902, 31906, 31922, 31932, 31933, 31937, 31943, 31948, 31949, 31944, 31941, 31959, 31976, 33390, 26280, 32703, 32718, 32725, 32741, 32737, 32742, 32745, 32750, 32755, 31992, 32119, 32166, 32174, 32327, 32411, 40632, 40628, 36211, 36228, 36244, 36241, 36273, 36199, 36205, 35911, 35913, 37194, 37200, 37198, 37199, 37220, 39804, 39805, 39806, 39807, 39808, 39809, 39810, 39811, 39812, 39813, 39814, 39815, 39816, 39817, 39818, 39819, 39820, 39821, 39822, 39823, 39824, 39825, 39826, 39827, 39828, 39829, 39830, 39831, 39832, 39833, 39834, 39835, 39836, 39837, 39838, 39839, 39840, 39841, 39842, 39843, 39844, 39845, 39846, 39847, 39848, 39849, 39850, 39851, 39852, 39853, 39854, 39855, 39856, 39857, 39858, 39859, 39860, 39861, 39862, 39863, 39864, 39865, 39866, 39867, 39868, 39869, 39870, 39871, 39872, 39873, 39874, 39875, 39876, 39877, 39878, 39879, 39880, 39881, 39882, 39883, 39884, 39885, 39886, 39887, 39888, 39889, 39890, 39891, 39892, 39893, 39894, 39895, 39896, 39897, 39898, 39899, 37218, 37217, 37232, 37225, 37231, 37245, 37246, 37234, 37236, 37241, 37260, 37253, 37264, 37261, 37265, 37282, 37283, 37290, 37293, 37294, 37295, 37301, 37300, 37306, 35925, 40574, 36280, 36331, 36357, 36441, 36457, 36277, 36287, 36284, 36282, 36292, 36310, 36311, 36314, 36318, 36302, 36303, 36315, 36294, 36332, 36343, 36344, 36323, 36345, 36347, 36324, 36361, 36349, 36372, 36381, 36383, 36396, 36398, 36387, 36399, 36410, 36416, 36409, 36405, 36413, 36401, 36425, 36417, 36418, 36433, 36434, 36426, 36464, 36470, 36476, 36463, 36468, 36485, 36495, 36500, 36496, 36508, 36510, 35960, 35970, 35978, 35973, 35992, 35988, 26011, 35286, 35294, 35290, 35292, 39900, 39901, 39902, 39903, 39904, 39905, 39906, 39907, 39908, 39909, 39910, 39911, 39912, 39913, 39914, 39915, 39916, 39917, 39918, 39919, 39920, 39921, 39922, 39923, 39924, 39925, 39926, 39927, 39928, 39929, 39930, 39931, 39932, 39933, 39934, 39935, 39936, 39937, 39938, 39939, 39940, 39941, 39942, 39943, 39944, 39945, 39946, 39947, 39948, 39949, 39950, 39951, 39952, 39953, 39954, 39955, 39956, 39957, 39958, 39959, 39960, 39961, 39962, 39963, 39964, 39965, 39966, 39967, 39968, 39969, 39970, 39971, 39972, 39973, 39974, 39975, 39976, 39977, 39978, 39979, 39980, 39981, 39982, 39983, 39984, 39985, 39986, 39987, 39988, 39989, 39990, 39991, 39992, 39993, 39994, 39995, 35301, 35307, 35311, 35390, 35622, 38739, 38633, 38643, 38639, 38662, 38657, 38664, 38671, 38670, 38698, 38701, 38704, 38718, 40832, 40835, 40837, 40838, 40839, 40840, 40841, 40842, 40844, 40702, 40715, 40717, 38585, 38588, 38589, 38606, 38610, 30655, 38624, 37518, 37550, 37576, 37694, 37738, 37834, 37775, 37950, 37995, 40063, 40066, 40069, 40070, 40071, 40072, 31267, 40075, 40078, 40080, 40081, 40082, 40084, 40085, 40090, 40091, 40094, 40095, 40096, 40097, 40098, 40099, 40101, 40102, 40103, 40104, 40105, 40107, 40109, 40110, 40112, 40113, 40114, 40115, 40116, 40117, 40118, 40119, 40122, 40123, 40124, 40125, 40132, 40133, 40134, 40135, 40138, 40139, 39996, 39997, 39998, 39999, 4e4, 40001, 40002, 40003, 40004, 40005, 40006, 40007, 40008, 40009, 40010, 40011, 40012, 40013, 40014, 40015, 40016, 40017, 40018, 40019, 40020, 40021, 40022, 40023, 40024, 40025, 40026, 40027, 40028, 40029, 40030, 40031, 40032, 40033, 40034, 40035, 40036, 40037, 40038, 40039, 40040, 40041, 40042, 40043, 40044, 40045, 40046, 40047, 40048, 40049, 40050, 40051, 40052, 40053, 40054, 40055, 40056, 40057, 40058, 40059, 40061, 40062, 40064, 40067, 40068, 40073, 40074, 40076, 40079, 40083, 40086, 40087, 40088, 40089, 40093, 40106, 40108, 40111, 40121, 40126, 40127, 40128, 40129, 40130, 40136, 40137, 40145, 40146, 40154, 40155, 40160, 40161, 40140, 40141, 40142, 40143, 40144, 40147, 40148, 40149, 40151, 40152, 40153, 40156, 40157, 40159, 40162, 38780, 38789, 38801, 38802, 38804, 38831, 38827, 38819, 38834, 38836, 39601, 39600, 39607, 40536, 39606, 39610, 39612, 39617, 39616, 39621, 39618, 39627, 39628, 39633, 39749, 39747, 39751, 39753, 39752, 39757, 39761, 39144, 39181, 39214, 39253, 39252, 39647, 39649, 39654, 39663, 39659, 39675, 39661, 39673, 39688, 39695, 39699, 39711, 39715, 40637, 40638, 32315, 40578, 40583, 40584, 40587, 40594, 37846, 40605, 40607, 40667, 40668, 40669, 40672, 40671, 40674, 40681, 40679, 40677, 40682, 40687, 40738, 40748, 40751, 40761, 40759, 40765, 40766, 40772, 40163, 40164, 40165, 40166, 40167, 40168, 40169, 40170, 40171, 40172, 40173, 40174, 40175, 40176, 40177, 40178, 40179, 40180, 40181, 40182, 40183, 40184, 40185, 40186, 40187, 40188, 40189, 40190, 40191, 40192, 40193, 40194, 40195, 40196, 40197, 40198, 40199, 40200, 40201, 40202, 40203, 40204, 40205, 40206, 40207, 40208, 40209, 40210, 40211, 40212, 40213, 40214, 40215, 40216, 40217, 40218, 40219, 40220, 40221, 40222, 40223, 40224, 40225, 40226, 40227, 40228, 40229, 40230, 40231, 40232, 40233, 40234, 40235, 40236, 40237, 40238, 40239, 40240, 40241, 40242, 40243, 40244, 40245, 40246, 40247, 40248, 40249, 40250, 40251, 40252, 40253, 40254, 40255, 40256, 40257, 40258, 57908, 57909, 57910, 57911, 57912, 57913, 57914, 57915, 57916, 57917, 57918, 57919, 57920, 57921, 57922, 57923, 57924, 57925, 57926, 57927, 57928, 57929, 57930, 57931, 57932, 57933, 57934, 57935, 57936, 57937, 57938, 57939, 57940, 57941, 57942, 57943, 57944, 57945, 57946, 57947, 57948, 57949, 57950, 57951, 57952, 57953, 57954, 57955, 57956, 57957, 57958, 57959, 57960, 57961, 57962, 57963, 57964, 57965, 57966, 57967, 57968, 57969, 57970, 57971, 57972, 57973, 57974, 57975, 57976, 57977, 57978, 57979, 57980, 57981, 57982, 57983, 57984, 57985, 57986, 57987, 57988, 57989, 57990, 57991, 57992, 57993, 57994, 57995, 57996, 57997, 57998, 57999, 58e3, 58001, 40259, 40260, 40261, 40262, 40263, 40264, 40265, 40266, 40267, 40268, 40269, 40270, 40271, 40272, 40273, 40274, 40275, 40276, 40277, 40278, 40279, 40280, 40281, 40282, 40283, 40284, 40285, 40286, 40287, 40288, 40289, 40290, 40291, 40292, 40293, 40294, 40295, 40296, 40297, 40298, 40299, 40300, 40301, 40302, 40303, 40304, 40305, 40306, 40307, 40308, 40309, 40310, 40311, 40312, 40313, 40314, 40315, 40316, 40317, 40318, 40319, 40320, 40321, 40322, 40323, 40324, 40325, 40326, 40327, 40328, 40329, 40330, 40331, 40332, 40333, 40334, 40335, 40336, 40337, 40338, 40339, 40340, 40341, 40342, 40343, 40344, 40345, 40346, 40347, 40348, 40349, 40350, 40351, 40352, 40353, 40354, 58002, 58003, 58004, 58005, 58006, 58007, 58008, 58009, 58010, 58011, 58012, 58013, 58014, 58015, 58016, 58017, 58018, 58019, 58020, 58021, 58022, 58023, 58024, 58025, 58026, 58027, 58028, 58029, 58030, 58031, 58032, 58033, 58034, 58035, 58036, 58037, 58038, 58039, 58040, 58041, 58042, 58043, 58044, 58045, 58046, 58047, 58048, 58049, 58050, 58051, 58052, 58053, 58054, 58055, 58056, 58057, 58058, 58059, 58060, 58061, 58062, 58063, 58064, 58065, 58066, 58067, 58068, 58069, 58070, 58071, 58072, 58073, 58074, 58075, 58076, 58077, 58078, 58079, 58080, 58081, 58082, 58083, 58084, 58085, 58086, 58087, 58088, 58089, 58090, 58091, 58092, 58093, 58094, 58095, 40355, 40356, 40357, 40358, 40359, 40360, 40361, 40362, 40363, 40364, 40365, 40366, 40367, 40368, 40369, 40370, 40371, 40372, 40373, 40374, 40375, 40376, 40377, 40378, 40379, 40380, 40381, 40382, 40383, 40384, 40385, 40386, 40387, 40388, 40389, 40390, 40391, 40392, 40393, 40394, 40395, 40396, 40397, 40398, 40399, 40400, 40401, 40402, 40403, 40404, 40405, 40406, 40407, 40408, 40409, 40410, 40411, 40412, 40413, 40414, 40415, 40416, 40417, 40418, 40419, 40420, 40421, 40422, 40423, 40424, 40425, 40426, 40427, 40428, 40429, 40430, 40431, 40432, 40433, 40434, 40435, 40436, 40437, 40438, 40439, 40440, 40441, 40442, 40443, 40444, 40445, 40446, 40447, 40448, 40449, 40450, 58096, 58097, 58098, 58099, 58100, 58101, 58102, 58103, 58104, 58105, 58106, 58107, 58108, 58109, 58110, 58111, 58112, 58113, 58114, 58115, 58116, 58117, 58118, 58119, 58120, 58121, 58122, 58123, 58124, 58125, 58126, 58127, 58128, 58129, 58130, 58131, 58132, 58133, 58134, 58135, 58136, 58137, 58138, 58139, 58140, 58141, 58142, 58143, 58144, 58145, 58146, 58147, 58148, 58149, 58150, 58151, 58152, 58153, 58154, 58155, 58156, 58157, 58158, 58159, 58160, 58161, 58162, 58163, 58164, 58165, 58166, 58167, 58168, 58169, 58170, 58171, 58172, 58173, 58174, 58175, 58176, 58177, 58178, 58179, 58180, 58181, 58182, 58183, 58184, 58185, 58186, 58187, 58188, 58189, 40451, 40452, 40453, 40454, 40455, 40456, 40457, 40458, 40459, 40460, 40461, 40462, 40463, 40464, 40465, 40466, 40467, 40468, 40469, 40470, 40471, 40472, 40473, 40474, 40475, 40476, 40477, 40478, 40484, 40487, 40494, 40496, 40500, 40507, 40508, 40512, 40525, 40528, 40530, 40531, 40532, 40534, 40537, 40541, 40543, 40544, 40545, 40546, 40549, 40558, 40559, 40562, 40564, 40565, 40566, 40567, 40568, 40569, 40570, 40571, 40572, 40573, 40576, 40577, 40579, 40580, 40581, 40582, 40585, 40586, 40588, 40589, 40590, 40591, 40592, 40593, 40596, 40597, 40598, 40599, 40600, 40601, 40602, 40603, 40604, 40606, 40608, 40609, 40610, 40611, 40612, 40613, 40615, 40616, 40617, 40618, 58190, 58191, 58192, 58193, 58194, 58195, 58196, 58197, 58198, 58199, 58200, 58201, 58202, 58203, 58204, 58205, 58206, 58207, 58208, 58209, 58210, 58211, 58212, 58213, 58214, 58215, 58216, 58217, 58218, 58219, 58220, 58221, 58222, 58223, 58224, 58225, 58226, 58227, 58228, 58229, 58230, 58231, 58232, 58233, 58234, 58235, 58236, 58237, 58238, 58239, 58240, 58241, 58242, 58243, 58244, 58245, 58246, 58247, 58248, 58249, 58250, 58251, 58252, 58253, 58254, 58255, 58256, 58257, 58258, 58259, 58260, 58261, 58262, 58263, 58264, 58265, 58266, 58267, 58268, 58269, 58270, 58271, 58272, 58273, 58274, 58275, 58276, 58277, 58278, 58279, 58280, 58281, 58282, 58283, 40619, 40620, 40621, 40622, 40623, 40624, 40625, 40626, 40627, 40629, 40630, 40631, 40633, 40634, 40636, 40639, 40640, 40641, 40642, 40643, 40645, 40646, 40647, 40648, 40650, 40651, 40652, 40656, 40658, 40659, 40661, 40662, 40663, 40665, 40666, 40670, 40673, 40675, 40676, 40678, 40680, 40683, 40684, 40685, 40686, 40688, 40689, 40690, 40691, 40692, 40693, 40694, 40695, 40696, 40698, 40701, 40703, 40704, 40705, 40706, 40707, 40708, 40709, 40710, 40711, 40712, 40713, 40714, 40716, 40719, 40721, 40722, 40724, 40725, 40726, 40728, 40730, 40731, 40732, 40733, 40734, 40735, 40737, 40739, 40740, 40741, 40742, 40743, 40744, 40745, 40746, 40747, 40749, 40750, 40752, 40753, 58284, 58285, 58286, 58287, 58288, 58289, 58290, 58291, 58292, 58293, 58294, 58295, 58296, 58297, 58298, 58299, 58300, 58301, 58302, 58303, 58304, 58305, 58306, 58307, 58308, 58309, 58310, 58311, 58312, 58313, 58314, 58315, 58316, 58317, 58318, 58319, 58320, 58321, 58322, 58323, 58324, 58325, 58326, 58327, 58328, 58329, 58330, 58331, 58332, 58333, 58334, 58335, 58336, 58337, 58338, 58339, 58340, 58341, 58342, 58343, 58344, 58345, 58346, 58347, 58348, 58349, 58350, 58351, 58352, 58353, 58354, 58355, 58356, 58357, 58358, 58359, 58360, 58361, 58362, 58363, 58364, 58365, 58366, 58367, 58368, 58369, 58370, 58371, 58372, 58373, 58374, 58375, 58376, 58377, 40754, 40755, 40756, 40757, 40758, 40760, 40762, 40764, 40767, 40768, 40769, 40770, 40771, 40773, 40774, 40775, 40776, 40777, 40778, 40779, 40780, 40781, 40782, 40783, 40786, 40787, 40788, 40789, 40790, 40791, 40792, 40793, 40794, 40795, 40796, 40797, 40798, 40799, 40800, 40801, 40802, 40803, 40804, 40805, 40806, 40807, 40808, 40809, 40810, 40811, 40812, 40813, 40814, 40815, 40816, 40817, 40818, 40819, 40820, 40821, 40822, 40823, 40824, 40825, 40826, 40827, 40828, 40829, 40830, 40833, 40834, 40845, 40846, 40847, 40848, 40849, 40850, 40851, 40852, 40853, 40854, 40855, 40856, 40860, 40861, 40862, 40865, 40866, 40867, 40868, 40869, 63788, 63865, 63893, 63975, 63985, 58378, 58379, 58380, 58381, 58382, 58383, 58384, 58385, 58386, 58387, 58388, 58389, 58390, 58391, 58392, 58393, 58394, 58395, 58396, 58397, 58398, 58399, 58400, 58401, 58402, 58403, 58404, 58405, 58406, 58407, 58408, 58409, 58410, 58411, 58412, 58413, 58414, 58415, 58416, 58417, 58418, 58419, 58420, 58421, 58422, 58423, 58424, 58425, 58426, 58427, 58428, 58429, 58430, 58431, 58432, 58433, 58434, 58435, 58436, 58437, 58438, 58439, 58440, 58441, 58442, 58443, 58444, 58445, 58446, 58447, 58448, 58449, 58450, 58451, 58452, 58453, 58454, 58455, 58456, 58457, 58458, 58459, 58460, 58461, 58462, 58463, 58464, 58465, 58466, 58467, 58468, 58469, 58470, 58471, 64012, 64013, 64014, 64015, 64017, 64019, 64020, 64024, 64031, 64032, 64033, 64035, 64036, 64039, 64040, 64041, 11905, 59414, 59415, 59416, 11908, 13427, 13383, 11912, 11915, 59422, 13726, 13850, 13838, 11916, 11927, 14702, 14616, 59430, 14799, 14815, 14963, 14800, 59435, 59436, 15182, 15470, 15584, 11943, 59441, 59442, 11946, 16470, 16735, 11950, 17207, 11955, 11958, 11959, 59451, 17329, 17324, 11963, 17373, 17622, 18017, 17996, 59459, 18211, 18217, 18300, 18317, 11978, 18759, 18810, 18813, 18818, 18819, 18821, 18822, 18847, 18843, 18871, 18870, 59476, 59477, 19619, 19615, 19616, 19617, 19575, 19618, 19731, 19732, 19733, 19734, 19735, 19736, 19737, 19886, 59492, 58472, 58473, 58474, 58475, 58476, 58477, 58478, 58479, 58480, 58481, 58482, 58483, 58484, 58485, 58486, 58487, 58488, 58489, 58490, 58491, 58492, 58493, 58494, 58495, 58496, 58497, 58498, 58499, 58500, 58501, 58502, 58503, 58504, 58505, 58506, 58507, 58508, 58509, 58510, 58511, 58512, 58513, 58514, 58515, 58516, 58517, 58518, 58519, 58520, 58521, 58522, 58523, 58524, 58525, 58526, 58527, 58528, 58529, 58530, 58531, 58532, 58533, 58534, 58535, 58536, 58537, 58538, 58539, 58540, 58541, 58542, 58543, 58544, 58545, 58546, 58547, 58548, 58549, 58550, 58551, 58552, 58553, 58554, 58555, 58556, 58557, 58558, 58559, 58560, 58561, 58562, 58563, 58564, 58565],
        "gb18030-ranges": [[0, 128], [36, 165], [38, 169], [45, 178], [50, 184], [81, 216], [89, 226], [95, 235], [96, 238], [100, 244], [103, 248], [104, 251], [105, 253], [109, 258], [126, 276], [133, 284], [148, 300], [172, 325], [175, 329], [179, 334], [208, 364], [306, 463], [307, 465], [308, 467], [309, 469], [310, 471], [311, 473], [312, 475], [313, 477], [341, 506], [428, 594], [443, 610], [544, 712], [545, 716], [558, 730], [741, 930], [742, 938], [749, 962], [750, 970], [805, 1026], [819, 1104], [820, 1106], [7922, 8209], [7924, 8215], [7925, 8218], [7927, 8222], [7934, 8231], [7943, 8241], [7944, 8244], [7945, 8246], [7950, 8252], [8062, 8365], [8148, 8452], [8149, 8454], [8152, 8458], [8164, 8471], [8174, 8482], [8236, 8556], [8240, 8570], [8262, 8596], [8264, 8602], [8374, 8713], [8380, 8720], [8381, 8722], [8384, 8726], [8388, 8731], [8390, 8737], [8392, 8740], [8393, 8742], [8394, 8748], [8396, 8751], [8401, 8760], [8406, 8766], [8416, 8777], [8419, 8781], [8424, 8787], [8437, 8802], [8439, 8808], [8445, 8816], [8482, 8854], [8485, 8858], [8496, 8870], [8521, 8896], [8603, 8979], [8936, 9322], [8946, 9372], [9046, 9548], [9050, 9588], [9063, 9616], [9066, 9622], [9076, 9634], [9092, 9652], [9100, 9662], [9108, 9672], [9111, 9676], [9113, 9680], [9131, 9702], [9162, 9735], [9164, 9738], [9218, 9793], [9219, 9795], [11329, 11906], [11331, 11909], [11334, 11913], [11336, 11917], [11346, 11928], [11361, 11944], [11363, 11947], [11366, 11951], [11370, 11956], [11372, 11960], [11375, 11964], [11389, 11979], [11682, 12284], [11686, 12292], [11687, 12312], [11692, 12319], [11694, 12330], [11714, 12351], [11716, 12436], [11723, 12447], [11725, 12535], [11730, 12543], [11736, 12586], [11982, 12842], [11989, 12850], [12102, 12964], [12336, 13200], [12348, 13215], [12350, 13218], [12384, 13253], [12393, 13263], [12395, 13267], [12397, 13270], [12510, 13384], [12553, 13428], [12851, 13727], [12962, 13839], [12973, 13851], [13738, 14617], [13823, 14703], [13919, 14801], [13933, 14816], [14080, 14964], [14298, 15183], [14585, 15471], [14698, 15585], [15583, 16471], [15847, 16736], [16318, 17208], [16434, 17325], [16438, 17330], [16481, 17374], [16729, 17623], [17102, 17997], [17122, 18018], [17315, 18212], [17320, 18218], [17402, 18301], [17418, 18318], [17859, 18760], [17909, 18811], [17911, 18814], [17915, 18820], [17916, 18823], [17936, 18844], [17939, 18848], [17961, 18872], [18664, 19576], [18703, 19620], [18814, 19738], [18962, 19887], [19043, 40870], [33469, 59244], [33470, 59336], [33471, 59367], [33484, 59413], [33485, 59417], [33490, 59423], [33497, 59431], [33501, 59437], [33505, 59443], [33513, 59452], [33520, 59460], [33536, 59478], [33550, 59493], [37845, 63789], [37921, 63866], [37948, 63894], [38029, 63976], [38038, 63986], [38064, 64016], [38065, 64018], [38066, 64021], [38069, 64025], [38075, 64034], [38076, 64037], [38078, 64042], [39108, 65074], [39109, 65093], [39113, 65107], [39114, 65112], [39115, 65127], [39116, 65132], [39265, 65375], [39394, 65510], [189e3, 65536]],
        "jis0208": [12288, 12289, 12290, 65292, 65294, 12539, 65306, 65307, 65311, 65281, 12443, 12444, 180, 65344, 168, 65342, 65507, 65343, 12541, 12542, 12445, 12446, 12291, 20189, 12293, 12294, 12295, 12540, 8213, 8208, 65295, 65340, 65374, 8741, 65372, 8230, 8229, 8216, 8217, 8220, 8221, 65288, 65289, 12308, 12309, 65339, 65341, 65371, 65373, 12296, 12297, 12298, 12299, 12300, 12301, 12302, 12303, 12304, 12305, 65291, 65293, 177, 215, 247, 65309, 8800, 65308, 65310, 8806, 8807, 8734, 8756, 9794, 9792, 176, 8242, 8243, 8451, 65509, 65284, 65504, 65505, 65285, 65283, 65286, 65290, 65312, 167, 9734, 9733, 9675, 9679, 9678, 9671, 9670, 9633, 9632, 9651, 9650, 9661, 9660, 8251, 12306, 8594, 8592, 8593, 8595, 12307, null, null, null, null, null, null, null, null, null, null, null, 8712, 8715, 8838, 8839, 8834, 8835, 8746, 8745, null, null, null, null, null, null, null, null, 8743, 8744, 65506, 8658, 8660, 8704, 8707, null, null, null, null, null, null, null, null, null, null, null, 8736, 8869, 8978, 8706, 8711, 8801, 8786, 8810, 8811, 8730, 8765, 8733, 8757, 8747, 8748, null, null, null, null, null, null, null, 8491, 8240, 9839, 9837, 9834, 8224, 8225, 182, null, null, null, null, 9711, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305, null, null, null, null, null, null, null, 65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, null, null, null, null, null, null, 65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, null, null, null, null, 12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435, null, null, null, null, null, null, null, null, null, null, null, 12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511, 12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534, null, null, null, null, null, null, null, null, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, null, null, null, null, null, null, null, null, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, null, null, null, null, null, null, null, null, null, null, null, null, null, 9472, 9474, 9484, 9488, 9496, 9492, 9500, 9516, 9508, 9524, 9532, 9473, 9475, 9487, 9491, 9499, 9495, 9507, 9523, 9515, 9531, 9547, 9504, 9519, 9512, 9527, 9535, 9501, 9520, 9509, 9528, 9538, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9322, 9323, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, null, 13129, 13076, 13090, 13133, 13080, 13095, 13059, 13110, 13137, 13143, 13069, 13094, 13091, 13099, 13130, 13115, 13212, 13213, 13214, 13198, 13199, 13252, 13217, null, null, null, null, null, null, null, null, 13179, 12317, 12319, 8470, 13261, 8481, 12964, 12965, 12966, 12967, 12968, 12849, 12850, 12857, 13182, 13181, 13180, 8786, 8801, 8747, 8750, 8721, 8730, 8869, 8736, 8735, 8895, 8757, 8745, 8746, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 20124, 21782, 23043, 38463, 21696, 24859, 25384, 23030, 36898, 33909, 33564, 31312, 24746, 25569, 28197, 26093, 33894, 33446, 39925, 26771, 22311, 26017, 25201, 23451, 22992, 34427, 39156, 32098, 32190, 39822, 25110, 31903, 34999, 23433, 24245, 25353, 26263, 26696, 38343, 38797, 26447, 20197, 20234, 20301, 20381, 20553, 22258, 22839, 22996, 23041, 23561, 24799, 24847, 24944, 26131, 26885, 28858, 30031, 30064, 31227, 32173, 32239, 32963, 33806, 34915, 35586, 36949, 36986, 21307, 20117, 20133, 22495, 32946, 37057, 30959, 19968, 22769, 28322, 36920, 31282, 33576, 33419, 39983, 20801, 21360, 21693, 21729, 22240, 23035, 24341, 39154, 28139, 32996, 34093, 38498, 38512, 38560, 38907, 21515, 21491, 23431, 28879, 32701, 36802, 38632, 21359, 40284, 31418, 19985, 30867, 33276, 28198, 22040, 21764, 27421, 34074, 39995, 23013, 21417, 28006, 29916, 38287, 22082, 20113, 36939, 38642, 33615, 39180, 21473, 21942, 23344, 24433, 26144, 26355, 26628, 27704, 27891, 27945, 29787, 30408, 31310, 38964, 33521, 34907, 35424, 37613, 28082, 30123, 30410, 39365, 24742, 35585, 36234, 38322, 27022, 21421, 20870, 22290, 22576, 22852, 23476, 24310, 24616, 25513, 25588, 27839, 28436, 28814, 28948, 29017, 29141, 29503, 32257, 33398, 33489, 34199, 36960, 37467, 40219, 22633, 26044, 27738, 29989, 20985, 22830, 22885, 24448, 24540, 25276, 26106, 27178, 27431, 27572, 29579, 32705, 35158, 40236, 40206, 40644, 23713, 27798, 33659, 20740, 23627, 25014, 33222, 26742, 29281, 20057, 20474, 21368, 24681, 28201, 31311, 38899, 19979, 21270, 20206, 20309, 20285, 20385, 20339, 21152, 21487, 22025, 22799, 23233, 23478, 23521, 31185, 26247, 26524, 26550, 27468, 27827, 28779, 29634, 31117, 31166, 31292, 31623, 33457, 33499, 33540, 33655, 33775, 33747, 34662, 35506, 22057, 36008, 36838, 36942, 38686, 34442, 20420, 23784, 25105, 29273, 30011, 33253, 33469, 34558, 36032, 38597, 39187, 39381, 20171, 20250, 35299, 22238, 22602, 22730, 24315, 24555, 24618, 24724, 24674, 25040, 25106, 25296, 25913, 39745, 26214, 26800, 28023, 28784, 30028, 30342, 32117, 33445, 34809, 38283, 38542, 35997, 20977, 21182, 22806, 21683, 23475, 23830, 24936, 27010, 28079, 30861, 33995, 34903, 35442, 37799, 39608, 28012, 39336, 34521, 22435, 26623, 34510, 37390, 21123, 22151, 21508, 24275, 25313, 25785, 26684, 26680, 27579, 29554, 30906, 31339, 35226, 35282, 36203, 36611, 37101, 38307, 38548, 38761, 23398, 23731, 27005, 38989, 38990, 25499, 31520, 27179, 27263, 26806, 39949, 28511, 21106, 21917, 24688, 25324, 27963, 28167, 28369, 33883, 35088, 36676, 19988, 39993, 21494, 26907, 27194, 38788, 26666, 20828, 31427, 33970, 37340, 37772, 22107, 40232, 26658, 33541, 33841, 31909, 21e3, 33477, 29926, 20094, 20355, 20896, 23506, 21002, 21208, 21223, 24059, 21914, 22570, 23014, 23436, 23448, 23515, 24178, 24185, 24739, 24863, 24931, 25022, 25563, 25954, 26577, 26707, 26874, 27454, 27475, 27735, 28450, 28567, 28485, 29872, 29976, 30435, 30475, 31487, 31649, 31777, 32233, 32566, 32752, 32925, 33382, 33694, 35251, 35532, 36011, 36996, 37969, 38291, 38289, 38306, 38501, 38867, 39208, 33304, 20024, 21547, 23736, 24012, 29609, 30284, 30524, 23721, 32747, 36107, 38593, 38929, 38996, 39e3, 20225, 20238, 21361, 21916, 22120, 22522, 22855, 23305, 23492, 23696, 24076, 24190, 24524, 25582, 26426, 26071, 26082, 26399, 26827, 26820, 27231, 24112, 27589, 27671, 27773, 30079, 31048, 23395, 31232, 32e3, 24509, 35215, 35352, 36020, 36215, 36556, 36637, 39138, 39438, 39740, 20096, 20605, 20736, 22931, 23452, 25135, 25216, 25836, 27450, 29344, 30097, 31047, 32681, 34811, 35516, 35696, 25516, 33738, 38816, 21513, 21507, 21931, 26708, 27224, 35440, 30759, 26485, 40653, 21364, 23458, 33050, 34384, 36870, 19992, 20037, 20167, 20241, 21450, 21560, 23470, 24339, 24613, 25937, 26429, 27714, 27762, 27875, 28792, 29699, 31350, 31406, 31496, 32026, 31998, 32102, 26087, 29275, 21435, 23621, 24040, 25298, 25312, 25369, 28192, 34394, 35377, 36317, 37624, 28417, 31142, 39770, 20136, 20139, 20140, 20379, 20384, 20689, 20807, 31478, 20849, 20982, 21332, 21281, 21375, 21483, 21932, 22659, 23777, 24375, 24394, 24623, 24656, 24685, 25375, 25945, 27211, 27841, 29378, 29421, 30703, 33016, 33029, 33288, 34126, 37111, 37857, 38911, 39255, 39514, 20208, 20957, 23597, 26241, 26989, 23616, 26354, 26997, 29577, 26704, 31873, 20677, 21220, 22343, 24062, 37670, 26020, 27427, 27453, 29748, 31105, 31165, 31563, 32202, 33465, 33740, 34943, 35167, 35641, 36817, 37329, 21535, 37504, 20061, 20534, 21477, 21306, 29399, 29590, 30697, 33510, 36527, 39366, 39368, 39378, 20855, 24858, 34398, 21936, 31354, 20598, 23507, 36935, 38533, 20018, 27355, 37351, 23633, 23624, 25496, 31391, 27795, 38772, 36705, 31402, 29066, 38536, 31874, 26647, 32368, 26705, 37740, 21234, 21531, 34219, 35347, 32676, 36557, 37089, 21350, 34952, 31041, 20418, 20670, 21009, 20804, 21843, 22317, 29674, 22411, 22865, 24418, 24452, 24693, 24950, 24935, 25001, 25522, 25658, 25964, 26223, 26690, 28179, 30054, 31293, 31995, 32076, 32153, 32331, 32619, 33550, 33610, 34509, 35336, 35427, 35686, 36605, 38938, 40335, 33464, 36814, 39912, 21127, 25119, 25731, 28608, 38553, 26689, 20625, 27424, 27770, 28500, 31348, 32080, 34880, 35363, 26376, 20214, 20537, 20518, 20581, 20860, 21048, 21091, 21927, 22287, 22533, 23244, 24314, 25010, 25080, 25331, 25458, 26908, 27177, 29309, 29356, 29486, 30740, 30831, 32121, 30476, 32937, 35211, 35609, 36066, 36562, 36963, 37749, 38522, 38997, 39443, 40568, 20803, 21407, 21427, 24187, 24358, 28187, 28304, 29572, 29694, 32067, 33335, 35328, 35578, 38480, 20046, 20491, 21476, 21628, 22266, 22993, 23396, 24049, 24235, 24359, 25144, 25925, 26543, 28246, 29392, 31946, 34996, 32929, 32993, 33776, 34382, 35463, 36328, 37431, 38599, 39015, 40723, 20116, 20114, 20237, 21320, 21577, 21566, 23087, 24460, 24481, 24735, 26791, 27278, 29786, 30849, 35486, 35492, 35703, 37264, 20062, 39881, 20132, 20348, 20399, 20505, 20502, 20809, 20844, 21151, 21177, 21246, 21402, 21475, 21521, 21518, 21897, 22353, 22434, 22909, 23380, 23389, 23439, 24037, 24039, 24055, 24184, 24195, 24218, 24247, 24344, 24658, 24908, 25239, 25304, 25511, 25915, 26114, 26179, 26356, 26477, 26657, 26775, 27083, 27743, 27946, 28009, 28207, 28317, 30002, 30343, 30828, 31295, 31968, 32005, 32024, 32094, 32177, 32789, 32771, 32943, 32945, 33108, 33167, 33322, 33618, 34892, 34913, 35611, 36002, 36092, 37066, 37237, 37489, 30783, 37628, 38308, 38477, 38917, 39321, 39640, 40251, 21083, 21163, 21495, 21512, 22741, 25335, 28640, 35946, 36703, 40633, 20811, 21051, 21578, 22269, 31296, 37239, 40288, 40658, 29508, 28425, 33136, 29969, 24573, 24794, 39592, 29403, 36796, 27492, 38915, 20170, 22256, 22372, 22718, 23130, 24680, 25031, 26127, 26118, 26681, 26801, 28151, 30165, 32058, 33390, 39746, 20123, 20304, 21449, 21766, 23919, 24038, 24046, 26619, 27801, 29811, 30722, 35408, 37782, 35039, 22352, 24231, 25387, 20661, 20652, 20877, 26368, 21705, 22622, 22971, 23472, 24425, 25165, 25505, 26685, 27507, 28168, 28797, 37319, 29312, 30741, 30758, 31085, 25998, 32048, 33756, 35009, 36617, 38555, 21092, 22312, 26448, 32618, 36001, 20916, 22338, 38442, 22586, 27018, 32948, 21682, 23822, 22524, 30869, 40442, 20316, 21066, 21643, 25662, 26152, 26388, 26613, 31364, 31574, 32034, 37679, 26716, 39853, 31545, 21273, 20874, 21047, 23519, 25334, 25774, 25830, 26413, 27578, 34217, 38609, 30352, 39894, 25420, 37638, 39851, 30399, 26194, 19977, 20632, 21442, 23665, 24808, 25746, 25955, 26719, 29158, 29642, 29987, 31639, 32386, 34453, 35715, 36059, 37240, 39184, 26028, 26283, 27531, 20181, 20180, 20282, 20351, 21050, 21496, 21490, 21987, 22235, 22763, 22987, 22985, 23039, 23376, 23629, 24066, 24107, 24535, 24605, 25351, 25903, 23388, 26031, 26045, 26088, 26525, 27490, 27515, 27663, 29509, 31049, 31169, 31992, 32025, 32043, 32930, 33026, 33267, 35222, 35422, 35433, 35430, 35468, 35566, 36039, 36060, 38604, 39164, 27503, 20107, 20284, 20365, 20816, 23383, 23546, 24904, 25345, 26178, 27425, 28363, 27835, 29246, 29885, 30164, 30913, 31034, 32780, 32819, 33258, 33940, 36766, 27728, 40575, 24335, 35672, 40235, 31482, 36600, 23437, 38635, 19971, 21489, 22519, 22833, 23241, 23460, 24713, 28287, 28422, 30142, 36074, 23455, 34048, 31712, 20594, 26612, 33437, 23649, 34122, 32286, 33294, 20889, 23556, 25448, 36198, 26012, 29038, 31038, 32023, 32773, 35613, 36554, 36974, 34503, 37034, 20511, 21242, 23610, 26451, 28796, 29237, 37196, 37320, 37675, 33509, 23490, 24369, 24825, 20027, 21462, 23432, 25163, 26417, 27530, 29417, 29664, 31278, 33131, 36259, 37202, 39318, 20754, 21463, 21610, 23551, 25480, 27193, 32172, 38656, 22234, 21454, 21608, 23447, 23601, 24030, 20462, 24833, 25342, 27954, 31168, 31179, 32066, 32333, 32722, 33261, 33311, 33936, 34886, 35186, 35728, 36468, 36655, 36913, 37195, 37228, 38598, 37276, 20160, 20303, 20805, 21313, 24467, 25102, 26580, 27713, 28171, 29539, 32294, 37325, 37507, 21460, 22809, 23487, 28113, 31069, 32302, 31899, 22654, 29087, 20986, 34899, 36848, 20426, 23803, 26149, 30636, 31459, 33308, 39423, 20934, 24490, 26092, 26991, 27529, 28147, 28310, 28516, 30462, 32020, 24033, 36981, 37255, 38918, 20966, 21021, 25152, 26257, 26329, 28186, 24246, 32210, 32626, 26360, 34223, 34295, 35576, 21161, 21465, 22899, 24207, 24464, 24661, 37604, 38500, 20663, 20767, 21213, 21280, 21319, 21484, 21736, 21830, 21809, 22039, 22888, 22974, 23100, 23477, 23558, 23567, 23569, 23578, 24196, 24202, 24288, 24432, 25215, 25220, 25307, 25484, 25463, 26119, 26124, 26157, 26230, 26494, 26786, 27167, 27189, 27836, 28040, 28169, 28248, 28988, 28966, 29031, 30151, 30465, 30813, 30977, 31077, 31216, 31456, 31505, 31911, 32057, 32918, 33750, 33931, 34121, 34909, 35059, 35359, 35388, 35412, 35443, 35937, 36062, 37284, 37478, 37758, 37912, 38556, 38808, 19978, 19976, 19998, 20055, 20887, 21104, 22478, 22580, 22732, 23330, 24120, 24773, 25854, 26465, 26454, 27972, 29366, 30067, 31331, 33976, 35698, 37304, 37664, 22065, 22516, 39166, 25325, 26893, 27542, 29165, 32340, 32887, 33394, 35302, 39135, 34645, 36785, 23611, 20280, 20449, 20405, 21767, 23072, 23517, 23529, 24515, 24910, 25391, 26032, 26187, 26862, 27035, 28024, 28145, 30003, 30137, 30495, 31070, 31206, 32051, 33251, 33455, 34218, 35242, 35386, 36523, 36763, 36914, 37341, 38663, 20154, 20161, 20995, 22645, 22764, 23563, 29978, 23613, 33102, 35338, 36805, 38499, 38765, 31525, 35535, 38920, 37218, 22259, 21416, 36887, 21561, 22402, 24101, 25512, 27700, 28810, 30561, 31883, 32736, 34928, 36930, 37204, 37648, 37656, 38543, 29790, 39620, 23815, 23913, 25968, 26530, 36264, 38619, 25454, 26441, 26905, 33733, 38935, 38592, 35070, 28548, 25722, 23544, 19990, 28716, 30045, 26159, 20932, 21046, 21218, 22995, 24449, 24615, 25104, 25919, 25972, 26143, 26228, 26866, 26646, 27491, 28165, 29298, 29983, 30427, 31934, 32854, 22768, 35069, 35199, 35488, 35475, 35531, 36893, 37266, 38738, 38745, 25993, 31246, 33030, 38587, 24109, 24796, 25114, 26021, 26132, 26512, 30707, 31309, 31821, 32318, 33034, 36012, 36196, 36321, 36447, 30889, 20999, 25305, 25509, 25666, 25240, 35373, 31363, 31680, 35500, 38634, 32118, 33292, 34633, 20185, 20808, 21315, 21344, 23459, 23554, 23574, 24029, 25126, 25159, 25776, 26643, 26676, 27849, 27973, 27927, 26579, 28508, 29006, 29053, 26059, 31359, 31661, 32218, 32330, 32680, 33146, 33307, 33337, 34214, 35438, 36046, 36341, 36984, 36983, 37549, 37521, 38275, 39854, 21069, 21892, 28472, 28982, 20840, 31109, 32341, 33203, 31950, 22092, 22609, 23720, 25514, 26366, 26365, 26970, 29401, 30095, 30094, 30990, 31062, 31199, 31895, 32032, 32068, 34311, 35380, 38459, 36961, 40736, 20711, 21109, 21452, 21474, 20489, 21930, 22766, 22863, 29245, 23435, 23652, 21277, 24803, 24819, 25436, 25475, 25407, 25531, 25805, 26089, 26361, 24035, 27085, 27133, 28437, 29157, 20105, 30185, 30456, 31379, 31967, 32207, 32156, 32865, 33609, 33624, 33900, 33980, 34299, 35013, 36208, 36865, 36973, 37783, 38684, 39442, 20687, 22679, 24974, 33235, 34101, 36104, 36896, 20419, 20596, 21063, 21363, 24687, 25417, 26463, 28204, 36275, 36895, 20439, 23646, 36042, 26063, 32154, 21330, 34966, 20854, 25539, 23384, 23403, 23562, 25613, 26449, 36956, 20182, 22810, 22826, 27760, 35409, 21822, 22549, 22949, 24816, 25171, 26561, 33333, 26965, 38464, 39364, 39464, 20307, 22534, 23550, 32784, 23729, 24111, 24453, 24608, 24907, 25140, 26367, 27888, 28382, 32974, 33151, 33492, 34955, 36024, 36864, 36910, 38538, 40667, 39899, 20195, 21488, 22823, 31532, 37261, 38988, 40441, 28381, 28711, 21331, 21828, 23429, 25176, 25246, 25299, 27810, 28655, 29730, 35351, 37944, 28609, 35582, 33592, 20967, 34552, 21482, 21481, 20294, 36948, 36784, 22890, 33073, 24061, 31466, 36799, 26842, 35895, 29432, 40008, 27197, 35504, 20025, 21336, 22022, 22374, 25285, 25506, 26086, 27470, 28129, 28251, 28845, 30701, 31471, 31658, 32187, 32829, 32966, 34507, 35477, 37723, 22243, 22727, 24382, 26029, 26262, 27264, 27573, 30007, 35527, 20516, 30693, 22320, 24347, 24677, 26234, 27744, 30196, 31258, 32622, 33268, 34584, 36933, 39347, 31689, 30044, 31481, 31569, 33988, 36880, 31209, 31378, 33590, 23265, 30528, 20013, 20210, 23449, 24544, 25277, 26172, 26609, 27880, 34411, 34935, 35387, 37198, 37619, 39376, 27159, 28710, 29482, 33511, 33879, 36015, 19969, 20806, 20939, 21899, 23541, 24086, 24115, 24193, 24340, 24373, 24427, 24500, 25074, 25361, 26274, 26397, 28526, 29266, 30010, 30522, 32884, 33081, 33144, 34678, 35519, 35548, 36229, 36339, 37530, 38263, 38914, 40165, 21189, 25431, 30452, 26389, 27784, 29645, 36035, 37806, 38515, 27941, 22684, 26894, 27084, 36861, 37786, 30171, 36890, 22618, 26626, 25524, 27131, 20291, 28460, 26584, 36795, 34086, 32180, 37716, 26943, 28528, 22378, 22775, 23340, 32044, 29226, 21514, 37347, 40372, 20141, 20302, 20572, 20597, 21059, 35998, 21576, 22564, 23450, 24093, 24213, 24237, 24311, 24351, 24716, 25269, 25402, 25552, 26799, 27712, 30855, 31118, 31243, 32224, 33351, 35330, 35558, 36420, 36883, 37048, 37165, 37336, 40718, 27877, 25688, 25826, 25973, 28404, 30340, 31515, 36969, 37841, 28346, 21746, 24505, 25764, 36685, 36845, 37444, 20856, 22635, 22825, 23637, 24215, 28155, 32399, 29980, 36028, 36578, 39003, 28857, 20253, 27583, 28593, 3e4, 38651, 20814, 21520, 22581, 22615, 22956, 23648, 24466, 26007, 26460, 28193, 30331, 33759, 36077, 36884, 37117, 37709, 30757, 30778, 21162, 24230, 22303, 22900, 24594, 20498, 20826, 20908, 20941, 20992, 21776, 22612, 22616, 22871, 23445, 23798, 23947, 24764, 25237, 25645, 26481, 26691, 26812, 26847, 30423, 28120, 28271, 28059, 28783, 29128, 24403, 30168, 31095, 31561, 31572, 31570, 31958, 32113, 21040, 33891, 34153, 34276, 35342, 35588, 35910, 36367, 36867, 36879, 37913, 38518, 38957, 39472, 38360, 20685, 21205, 21516, 22530, 23566, 24999, 25758, 27934, 30643, 31461, 33012, 33796, 36947, 37509, 23776, 40199, 21311, 24471, 24499, 28060, 29305, 30563, 31167, 31716, 27602, 29420, 35501, 26627, 27233, 20984, 31361, 26932, 23626, 40182, 33515, 23493, 37193, 28702, 22136, 23663, 24775, 25958, 27788, 35930, 36929, 38931, 21585, 26311, 37389, 22856, 37027, 20869, 20045, 20970, 34201, 35598, 28760, 25466, 37707, 26978, 39348, 32260, 30071, 21335, 26976, 36575, 38627, 27741, 20108, 23612, 24336, 36841, 21250, 36049, 32905, 34425, 24319, 26085, 20083, 20837, 22914, 23615, 38894, 20219, 22922, 24525, 35469, 28641, 31152, 31074, 23527, 33905, 29483, 29105, 24180, 24565, 25467, 25754, 29123, 31896, 20035, 24316, 20043, 22492, 22178, 24745, 28611, 32013, 33021, 33075, 33215, 36786, 35223, 34468, 24052, 25226, 25773, 35207, 26487, 27874, 27966, 29750, 30772, 23110, 32629, 33453, 39340, 20467, 24259, 25309, 25490, 25943, 26479, 30403, 29260, 32972, 32954, 36649, 37197, 20493, 22521, 23186, 26757, 26995, 29028, 29437, 36023, 22770, 36064, 38506, 36889, 34687, 31204, 30695, 33833, 20271, 21093, 21338, 25293, 26575, 27850, 30333, 31636, 31893, 33334, 34180, 36843, 26333, 28448, 29190, 32283, 33707, 39361, 40614, 20989, 31665, 30834, 31672, 32903, 31560, 27368, 24161, 32908, 30033, 30048, 20843, 37474, 28300, 30330, 37271, 39658, 20240, 32624, 25244, 31567, 38309, 40169, 22138, 22617, 34532, 38588, 20276, 21028, 21322, 21453, 21467, 24070, 25644, 26001, 26495, 27710, 27726, 29256, 29359, 29677, 30036, 32321, 33324, 34281, 36009, 31684, 37318, 29033, 38930, 39151, 25405, 26217, 30058, 30436, 30928, 34115, 34542, 21290, 21329, 21542, 22915, 24199, 24444, 24754, 25161, 25209, 25259, 26e3, 27604, 27852, 30130, 30382, 30865, 31192, 32203, 32631, 32933, 34987, 35513, 36027, 36991, 38750, 39131, 27147, 31800, 20633, 23614, 24494, 26503, 27608, 29749, 30473, 32654, 40763, 26570, 31255, 21305, 30091, 39661, 24422, 33181, 33777, 32920, 24380, 24517, 30050, 31558, 36924, 26727, 23019, 23195, 32016, 30334, 35628, 20469, 24426, 27161, 27703, 28418, 29922, 31080, 34920, 35413, 35961, 24287, 25551, 30149, 31186, 33495, 37672, 37618, 33948, 34541, 39981, 21697, 24428, 25996, 27996, 28693, 36007, 36051, 38971, 25935, 29942, 19981, 20184, 22496, 22827, 23142, 23500, 20904, 24067, 24220, 24598, 25206, 25975, 26023, 26222, 28014, 29238, 31526, 33104, 33178, 33433, 35676, 36e3, 36070, 36212, 38428, 38468, 20398, 25771, 27494, 33310, 33889, 34154, 37096, 23553, 26963, 39080, 33914, 34135, 20239, 21103, 24489, 24133, 26381, 31119, 33145, 35079, 35206, 28149, 24343, 25173, 27832, 20175, 29289, 39826, 20998, 21563, 22132, 22707, 24996, 25198, 28954, 22894, 31881, 31966, 32027, 38640, 25991, 32862, 19993, 20341, 20853, 22592, 24163, 24179, 24330, 26564, 20006, 34109, 38281, 38491, 31859, 38913, 20731, 22721, 30294, 30887, 21029, 30629, 34065, 31622, 20559, 22793, 29255, 31687, 32232, 36794, 36820, 36941, 20415, 21193, 23081, 24321, 38829, 20445, 33303, 37610, 22275, 25429, 27497, 29995, 35036, 36628, 31298, 21215, 22675, 24917, 25098, 26286, 27597, 31807, 33769, 20515, 20472, 21253, 21574, 22577, 22857, 23453, 23792, 23791, 23849, 24214, 25265, 25447, 25918, 26041, 26379, 27861, 27873, 28921, 30770, 32299, 32990, 33459, 33804, 34028, 34562, 35090, 35370, 35914, 37030, 37586, 39165, 40179, 40300, 20047, 20129, 20621, 21078, 22346, 22952, 24125, 24536, 24537, 25151, 26292, 26395, 26576, 26834, 20882, 32033, 32938, 33192, 35584, 35980, 36031, 37502, 38450, 21536, 38956, 21271, 20693, 21340, 22696, 25778, 26420, 29287, 30566, 31302, 37350, 21187, 27809, 27526, 22528, 24140, 22868, 26412, 32763, 20961, 30406, 25705, 30952, 39764, 40635, 22475, 22969, 26151, 26522, 27598, 21737, 27097, 24149, 33180, 26517, 39850, 26622, 40018, 26717, 20134, 20451, 21448, 25273, 26411, 27819, 36804, 20397, 32365, 40639, 19975, 24930, 28288, 28459, 34067, 21619, 26410, 39749, 24051, 31637, 23724, 23494, 34588, 28234, 34001, 31252, 33032, 22937, 31885, 27665, 30496, 21209, 22818, 28961, 29279, 30683, 38695, 40289, 26891, 23167, 23064, 20901, 21517, 21629, 26126, 30431, 36855, 37528, 40180, 23018, 29277, 28357, 20813, 26825, 32191, 32236, 38754, 40634, 25720, 27169, 33538, 22916, 23391, 27611, 29467, 30450, 32178, 32791, 33945, 20786, 26408, 40665, 30446, 26466, 21247, 39173, 23588, 25147, 31870, 36016, 21839, 24758, 32011, 38272, 21249, 20063, 20918, 22812, 29242, 32822, 37326, 24357, 30690, 21380, 24441, 32004, 34220, 35379, 36493, 38742, 26611, 34222, 37971, 24841, 24840, 27833, 30290, 35565, 36664, 21807, 20305, 20778, 21191, 21451, 23461, 24189, 24736, 24962, 25558, 26377, 26586, 28263, 28044, 29494, 29495, 30001, 31056, 35029, 35480, 36938, 37009, 37109, 38596, 34701, 22805, 20104, 20313, 19982, 35465, 36671, 38928, 20653, 24188, 22934, 23481, 24248, 25562, 25594, 25793, 26332, 26954, 27096, 27915, 28342, 29076, 29992, 31407, 32650, 32768, 33865, 33993, 35201, 35617, 36362, 36965, 38525, 39178, 24958, 25233, 27442, 27779, 28020, 32716, 32764, 28096, 32645, 34746, 35064, 26469, 33713, 38972, 38647, 27931, 32097, 33853, 37226, 20081, 21365, 23888, 27396, 28651, 34253, 34349, 35239, 21033, 21519, 23653, 26446, 26792, 29702, 29827, 30178, 35023, 35041, 37324, 38626, 38520, 24459, 29575, 31435, 33870, 25504, 30053, 21129, 27969, 28316, 29705, 30041, 30827, 31890, 38534, 31452, 40845, 20406, 24942, 26053, 34396, 20102, 20142, 20698, 20001, 20940, 23534, 26009, 26753, 28092, 29471, 30274, 30637, 31260, 31975, 33391, 35538, 36988, 37327, 38517, 38936, 21147, 32209, 20523, 21400, 26519, 28107, 29136, 29747, 33256, 36650, 38563, 40023, 40607, 29792, 22593, 28057, 32047, 39006, 20196, 20278, 20363, 20919, 21169, 23994, 24604, 29618, 31036, 33491, 37428, 38583, 38646, 38666, 40599, 40802, 26278, 27508, 21015, 21155, 28872, 35010, 24265, 24651, 24976, 28451, 29001, 31806, 32244, 32879, 34030, 36899, 37676, 21570, 39791, 27347, 28809, 36034, 36335, 38706, 21172, 23105, 24266, 24324, 26391, 27004, 27028, 28010, 28431, 29282, 29436, 31725, 32769, 32894, 34635, 37070, 20845, 40595, 31108, 32907, 37682, 35542, 20525, 21644, 35441, 27498, 36036, 33031, 24785, 26528, 40434, 20121, 20120, 39952, 35435, 34241, 34152, 26880, 28286, 30871, 33109, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 24332, 19984, 19989, 20010, 20017, 20022, 20028, 20031, 20034, 20054, 20056, 20098, 20101, 35947, 20106, 33298, 24333, 20110, 20126, 20127, 20128, 20130, 20144, 20147, 20150, 20174, 20173, 20164, 20166, 20162, 20183, 20190, 20205, 20191, 20215, 20233, 20314, 20272, 20315, 20317, 20311, 20295, 20342, 20360, 20367, 20376, 20347, 20329, 20336, 20369, 20335, 20358, 20374, 20760, 20436, 20447, 20430, 20440, 20443, 20433, 20442, 20432, 20452, 20453, 20506, 20520, 20500, 20522, 20517, 20485, 20252, 20470, 20513, 20521, 20524, 20478, 20463, 20497, 20486, 20547, 20551, 26371, 20565, 20560, 20552, 20570, 20566, 20588, 20600, 20608, 20634, 20613, 20660, 20658, 20681, 20682, 20659, 20674, 20694, 20702, 20709, 20717, 20707, 20718, 20729, 20725, 20745, 20737, 20738, 20758, 20757, 20756, 20762, 20769, 20794, 20791, 20796, 20795, 20799, 20800, 20818, 20812, 20820, 20834, 31480, 20841, 20842, 20846, 20864, 20866, 22232, 20876, 20873, 20879, 20881, 20883, 20885, 20886, 20900, 20902, 20898, 20905, 20906, 20907, 20915, 20913, 20914, 20912, 20917, 20925, 20933, 20937, 20955, 20960, 34389, 20969, 20973, 20976, 20981, 20990, 20996, 21003, 21012, 21006, 21031, 21034, 21038, 21043, 21049, 21071, 21060, 21067, 21068, 21086, 21076, 21098, 21108, 21097, 21107, 21119, 21117, 21133, 21140, 21138, 21105, 21128, 21137, 36776, 36775, 21164, 21165, 21180, 21173, 21185, 21197, 21207, 21214, 21219, 21222, 39149, 21216, 21235, 21237, 21240, 21241, 21254, 21256, 30008, 21261, 21264, 21263, 21269, 21274, 21283, 21295, 21297, 21299, 21304, 21312, 21318, 21317, 19991, 21321, 21325, 20950, 21342, 21353, 21358, 22808, 21371, 21367, 21378, 21398, 21408, 21414, 21413, 21422, 21424, 21430, 21443, 31762, 38617, 21471, 26364, 29166, 21486, 21480, 21485, 21498, 21505, 21565, 21568, 21548, 21549, 21564, 21550, 21558, 21545, 21533, 21582, 21647, 21621, 21646, 21599, 21617, 21623, 21616, 21650, 21627, 21632, 21622, 21636, 21648, 21638, 21703, 21666, 21688, 21669, 21676, 21700, 21704, 21672, 21675, 21698, 21668, 21694, 21692, 21720, 21733, 21734, 21775, 21780, 21757, 21742, 21741, 21754, 21730, 21817, 21824, 21859, 21836, 21806, 21852, 21829, 21846, 21847, 21816, 21811, 21853, 21913, 21888, 21679, 21898, 21919, 21883, 21886, 21912, 21918, 21934, 21884, 21891, 21929, 21895, 21928, 21978, 21957, 21983, 21956, 21980, 21988, 21972, 22036, 22007, 22038, 22014, 22013, 22043, 22009, 22094, 22096, 29151, 22068, 22070, 22066, 22072, 22123, 22116, 22063, 22124, 22122, 22150, 22144, 22154, 22176, 22164, 22159, 22181, 22190, 22198, 22196, 22210, 22204, 22209, 22211, 22208, 22216, 22222, 22225, 22227, 22231, 22254, 22265, 22272, 22271, 22276, 22281, 22280, 22283, 22285, 22291, 22296, 22294, 21959, 22300, 22310, 22327, 22328, 22350, 22331, 22336, 22351, 22377, 22464, 22408, 22369, 22399, 22409, 22419, 22432, 22451, 22436, 22442, 22448, 22467, 22470, 22484, 22482, 22483, 22538, 22486, 22499, 22539, 22553, 22557, 22642, 22561, 22626, 22603, 22640, 27584, 22610, 22589, 22649, 22661, 22713, 22687, 22699, 22714, 22750, 22715, 22712, 22702, 22725, 22739, 22737, 22743, 22745, 22744, 22757, 22748, 22756, 22751, 22767, 22778, 22777, 22779, 22780, 22781, 22786, 22794, 22800, 22811, 26790, 22821, 22828, 22829, 22834, 22840, 22846, 31442, 22869, 22864, 22862, 22874, 22872, 22882, 22880, 22887, 22892, 22889, 22904, 22913, 22941, 20318, 20395, 22947, 22962, 22982, 23016, 23004, 22925, 23001, 23002, 23077, 23071, 23057, 23068, 23049, 23066, 23104, 23148, 23113, 23093, 23094, 23138, 23146, 23194, 23228, 23230, 23243, 23234, 23229, 23267, 23255, 23270, 23273, 23254, 23290, 23291, 23308, 23307, 23318, 23346, 23248, 23338, 23350, 23358, 23363, 23365, 23360, 23377, 23381, 23386, 23387, 23397, 23401, 23408, 23411, 23413, 23416, 25992, 23418, 23424, 23427, 23462, 23480, 23491, 23495, 23497, 23508, 23504, 23524, 23526, 23522, 23518, 23525, 23531, 23536, 23542, 23539, 23557, 23559, 23560, 23565, 23571, 23584, 23586, 23592, 23608, 23609, 23617, 23622, 23630, 23635, 23632, 23631, 23409, 23660, 23662, 20066, 23670, 23673, 23692, 23697, 23700, 22939, 23723, 23739, 23734, 23740, 23735, 23749, 23742, 23751, 23769, 23785, 23805, 23802, 23789, 23948, 23786, 23819, 23829, 23831, 23900, 23839, 23835, 23825, 23828, 23842, 23834, 23833, 23832, 23884, 23890, 23886, 23883, 23916, 23923, 23926, 23943, 23940, 23938, 23970, 23965, 23980, 23982, 23997, 23952, 23991, 23996, 24009, 24013, 24019, 24018, 24022, 24027, 24043, 24050, 24053, 24075, 24090, 24089, 24081, 24091, 24118, 24119, 24132, 24131, 24128, 24142, 24151, 24148, 24159, 24162, 24164, 24135, 24181, 24182, 24186, 40636, 24191, 24224, 24257, 24258, 24264, 24272, 24271, 24278, 24291, 24285, 24282, 24283, 24290, 24289, 24296, 24297, 24300, 24305, 24307, 24304, 24308, 24312, 24318, 24323, 24329, 24413, 24412, 24331, 24337, 24342, 24361, 24365, 24376, 24385, 24392, 24396, 24398, 24367, 24401, 24406, 24407, 24409, 24417, 24429, 24435, 24439, 24451, 24450, 24447, 24458, 24456, 24465, 24455, 24478, 24473, 24472, 24480, 24488, 24493, 24508, 24534, 24571, 24548, 24568, 24561, 24541, 24755, 24575, 24609, 24672, 24601, 24592, 24617, 24590, 24625, 24603, 24597, 24619, 24614, 24591, 24634, 24666, 24641, 24682, 24695, 24671, 24650, 24646, 24653, 24675, 24643, 24676, 24642, 24684, 24683, 24665, 24705, 24717, 24807, 24707, 24730, 24708, 24731, 24726, 24727, 24722, 24743, 24715, 24801, 24760, 24800, 24787, 24756, 24560, 24765, 24774, 24757, 24792, 24909, 24853, 24838, 24822, 24823, 24832, 24820, 24826, 24835, 24865, 24827, 24817, 24845, 24846, 24903, 24894, 24872, 24871, 24906, 24895, 24892, 24876, 24884, 24893, 24898, 24900, 24947, 24951, 24920, 24921, 24922, 24939, 24948, 24943, 24933, 24945, 24927, 24925, 24915, 24949, 24985, 24982, 24967, 25004, 24980, 24986, 24970, 24977, 25003, 25006, 25036, 25034, 25033, 25079, 25032, 25027, 25030, 25018, 25035, 32633, 25037, 25062, 25059, 25078, 25082, 25076, 25087, 25085, 25084, 25086, 25088, 25096, 25097, 25101, 25100, 25108, 25115, 25118, 25121, 25130, 25134, 25136, 25138, 25139, 25153, 25166, 25182, 25187, 25179, 25184, 25192, 25212, 25218, 25225, 25214, 25234, 25235, 25238, 25300, 25219, 25236, 25303, 25297, 25275, 25295, 25343, 25286, 25812, 25288, 25308, 25292, 25290, 25282, 25287, 25243, 25289, 25356, 25326, 25329, 25383, 25346, 25352, 25327, 25333, 25424, 25406, 25421, 25628, 25423, 25494, 25486, 25472, 25515, 25462, 25507, 25487, 25481, 25503, 25525, 25451, 25449, 25534, 25577, 25536, 25542, 25571, 25545, 25554, 25590, 25540, 25622, 25652, 25606, 25619, 25638, 25654, 25885, 25623, 25640, 25615, 25703, 25711, 25718, 25678, 25898, 25749, 25747, 25765, 25769, 25736, 25788, 25818, 25810, 25797, 25799, 25787, 25816, 25794, 25841, 25831, 33289, 25824, 25825, 25260, 25827, 25839, 25900, 25846, 25844, 25842, 25850, 25856, 25853, 25880, 25884, 25861, 25892, 25891, 25899, 25908, 25909, 25911, 25910, 25912, 30027, 25928, 25942, 25941, 25933, 25944, 25950, 25949, 25970, 25976, 25986, 25987, 35722, 26011, 26015, 26027, 26039, 26051, 26054, 26049, 26052, 26060, 26066, 26075, 26073, 26080, 26081, 26097, 26482, 26122, 26115, 26107, 26483, 26165, 26166, 26164, 26140, 26191, 26180, 26185, 26177, 26206, 26205, 26212, 26215, 26216, 26207, 26210, 26224, 26243, 26248, 26254, 26249, 26244, 26264, 26269, 26305, 26297, 26313, 26302, 26300, 26308, 26296, 26326, 26330, 26336, 26175, 26342, 26345, 26352, 26357, 26359, 26383, 26390, 26398, 26406, 26407, 38712, 26414, 26431, 26422, 26433, 26424, 26423, 26438, 26462, 26464, 26457, 26467, 26468, 26505, 26480, 26537, 26492, 26474, 26508, 26507, 26534, 26529, 26501, 26551, 26607, 26548, 26604, 26547, 26601, 26552, 26596, 26590, 26589, 26594, 26606, 26553, 26574, 26566, 26599, 27292, 26654, 26694, 26665, 26688, 26701, 26674, 26702, 26803, 26667, 26713, 26723, 26743, 26751, 26783, 26767, 26797, 26772, 26781, 26779, 26755, 27310, 26809, 26740, 26805, 26784, 26810, 26895, 26765, 26750, 26881, 26826, 26888, 26840, 26914, 26918, 26849, 26892, 26829, 26836, 26855, 26837, 26934, 26898, 26884, 26839, 26851, 26917, 26873, 26848, 26863, 26920, 26922, 26906, 26915, 26913, 26822, 27001, 26999, 26972, 27e3, 26987, 26964, 27006, 26990, 26937, 26996, 26941, 26969, 26928, 26977, 26974, 26973, 27009, 26986, 27058, 27054, 27088, 27071, 27073, 27091, 27070, 27086, 23528, 27082, 27101, 27067, 27075, 27047, 27182, 27025, 27040, 27036, 27029, 27060, 27102, 27112, 27138, 27163, 27135, 27402, 27129, 27122, 27111, 27141, 27057, 27166, 27117, 27156, 27115, 27146, 27154, 27329, 27171, 27155, 27204, 27148, 27250, 27190, 27256, 27207, 27234, 27225, 27238, 27208, 27192, 27170, 27280, 27277, 27296, 27268, 27298, 27299, 27287, 34327, 27323, 27331, 27330, 27320, 27315, 27308, 27358, 27345, 27359, 27306, 27354, 27370, 27387, 27397, 34326, 27386, 27410, 27414, 39729, 27423, 27448, 27447, 30428, 27449, 39150, 27463, 27459, 27465, 27472, 27481, 27476, 27483, 27487, 27489, 27512, 27513, 27519, 27520, 27524, 27523, 27533, 27544, 27541, 27550, 27556, 27562, 27563, 27567, 27570, 27569, 27571, 27575, 27580, 27590, 27595, 27603, 27615, 27628, 27627, 27635, 27631, 40638, 27656, 27667, 27668, 27675, 27684, 27683, 27742, 27733, 27746, 27754, 27778, 27789, 27802, 27777, 27803, 27774, 27752, 27763, 27794, 27792, 27844, 27889, 27859, 27837, 27863, 27845, 27869, 27822, 27825, 27838, 27834, 27867, 27887, 27865, 27882, 27935, 34893, 27958, 27947, 27965, 27960, 27929, 27957, 27955, 27922, 27916, 28003, 28051, 28004, 27994, 28025, 27993, 28046, 28053, 28644, 28037, 28153, 28181, 28170, 28085, 28103, 28134, 28088, 28102, 28140, 28126, 28108, 28136, 28114, 28101, 28154, 28121, 28132, 28117, 28138, 28142, 28205, 28270, 28206, 28185, 28274, 28255, 28222, 28195, 28267, 28203, 28278, 28237, 28191, 28227, 28218, 28238, 28196, 28415, 28189, 28216, 28290, 28330, 28312, 28361, 28343, 28371, 28349, 28335, 28356, 28338, 28372, 28373, 28303, 28325, 28354, 28319, 28481, 28433, 28748, 28396, 28408, 28414, 28479, 28402, 28465, 28399, 28466, 28364, 28478, 28435, 28407, 28550, 28538, 28536, 28545, 28544, 28527, 28507, 28659, 28525, 28546, 28540, 28504, 28558, 28561, 28610, 28518, 28595, 28579, 28577, 28580, 28601, 28614, 28586, 28639, 28629, 28652, 28628, 28632, 28657, 28654, 28635, 28681, 28683, 28666, 28689, 28673, 28687, 28670, 28699, 28698, 28532, 28701, 28696, 28703, 28720, 28734, 28722, 28753, 28771, 28825, 28818, 28847, 28913, 28844, 28856, 28851, 28846, 28895, 28875, 28893, 28889, 28937, 28925, 28956, 28953, 29029, 29013, 29064, 29030, 29026, 29004, 29014, 29036, 29071, 29179, 29060, 29077, 29096, 29100, 29143, 29113, 29118, 29138, 29129, 29140, 29134, 29152, 29164, 29159, 29173, 29180, 29177, 29183, 29197, 29200, 29211, 29224, 29229, 29228, 29232, 29234, 29243, 29244, 29247, 29248, 29254, 29259, 29272, 29300, 29310, 29314, 29313, 29319, 29330, 29334, 29346, 29351, 29369, 29362, 29379, 29382, 29380, 29390, 29394, 29410, 29408, 29409, 29433, 29431, 20495, 29463, 29450, 29468, 29462, 29469, 29492, 29487, 29481, 29477, 29502, 29518, 29519, 40664, 29527, 29546, 29544, 29552, 29560, 29557, 29563, 29562, 29640, 29619, 29646, 29627, 29632, 29669, 29678, 29662, 29858, 29701, 29807, 29733, 29688, 29746, 29754, 29781, 29759, 29791, 29785, 29761, 29788, 29801, 29808, 29795, 29802, 29814, 29822, 29835, 29854, 29863, 29898, 29903, 29908, 29681, 29920, 29923, 29927, 29929, 29934, 29938, 29936, 29937, 29944, 29943, 29956, 29955, 29957, 29964, 29966, 29965, 29973, 29971, 29982, 29990, 29996, 30012, 30020, 30029, 30026, 30025, 30043, 30022, 30042, 30057, 30052, 30055, 30059, 30061, 30072, 30070, 30086, 30087, 30068, 30090, 30089, 30082, 30100, 30106, 30109, 30117, 30115, 30146, 30131, 30147, 30133, 30141, 30136, 30140, 30129, 30157, 30154, 30162, 30169, 30179, 30174, 30206, 30207, 30204, 30209, 30192, 30202, 30194, 30195, 30219, 30221, 30217, 30239, 30247, 30240, 30241, 30242, 30244, 30260, 30256, 30267, 30279, 30280, 30278, 30300, 30296, 30305, 30306, 30312, 30313, 30314, 30311, 30316, 30320, 30322, 30326, 30328, 30332, 30336, 30339, 30344, 30347, 30350, 30358, 30355, 30361, 30362, 30384, 30388, 30392, 30393, 30394, 30402, 30413, 30422, 30418, 30430, 30433, 30437, 30439, 30442, 34351, 30459, 30472, 30471, 30468, 30505, 30500, 30494, 30501, 30502, 30491, 30519, 30520, 30535, 30554, 30568, 30571, 30555, 30565, 30591, 30590, 30585, 30606, 30603, 30609, 30624, 30622, 30640, 30646, 30649, 30655, 30652, 30653, 30651, 30663, 30669, 30679, 30682, 30684, 30691, 30702, 30716, 30732, 30738, 31014, 30752, 31018, 30789, 30862, 30836, 30854, 30844, 30874, 30860, 30883, 30901, 30890, 30895, 30929, 30918, 30923, 30932, 30910, 30908, 30917, 30922, 30956, 30951, 30938, 30973, 30964, 30983, 30994, 30993, 31001, 31020, 31019, 31040, 31072, 31063, 31071, 31066, 31061, 31059, 31098, 31103, 31114, 31133, 31143, 40779, 31146, 31150, 31155, 31161, 31162, 31177, 31189, 31207, 31212, 31201, 31203, 31240, 31245, 31256, 31257, 31264, 31263, 31104, 31281, 31291, 31294, 31287, 31299, 31319, 31305, 31329, 31330, 31337, 40861, 31344, 31353, 31357, 31368, 31383, 31381, 31384, 31382, 31401, 31432, 31408, 31414, 31429, 31428, 31423, 36995, 31431, 31434, 31437, 31439, 31445, 31443, 31449, 31450, 31453, 31457, 31458, 31462, 31469, 31472, 31490, 31503, 31498, 31494, 31539, 31512, 31513, 31518, 31541, 31528, 31542, 31568, 31610, 31492, 31565, 31499, 31564, 31557, 31605, 31589, 31604, 31591, 31600, 31601, 31596, 31598, 31645, 31640, 31647, 31629, 31644, 31642, 31627, 31634, 31631, 31581, 31641, 31691, 31681, 31692, 31695, 31668, 31686, 31709, 31721, 31761, 31764, 31718, 31717, 31840, 31744, 31751, 31763, 31731, 31735, 31767, 31757, 31734, 31779, 31783, 31786, 31775, 31799, 31787, 31805, 31820, 31811, 31828, 31823, 31808, 31824, 31832, 31839, 31844, 31830, 31845, 31852, 31861, 31875, 31888, 31908, 31917, 31906, 31915, 31905, 31912, 31923, 31922, 31921, 31918, 31929, 31933, 31936, 31941, 31938, 31960, 31954, 31964, 31970, 39739, 31983, 31986, 31988, 31990, 31994, 32006, 32002, 32028, 32021, 32010, 32069, 32075, 32046, 32050, 32063, 32053, 32070, 32115, 32086, 32078, 32114, 32104, 32110, 32079, 32099, 32147, 32137, 32091, 32143, 32125, 32155, 32186, 32174, 32163, 32181, 32199, 32189, 32171, 32317, 32162, 32175, 32220, 32184, 32159, 32176, 32216, 32221, 32228, 32222, 32251, 32242, 32225, 32261, 32266, 32291, 32289, 32274, 32305, 32287, 32265, 32267, 32290, 32326, 32358, 32315, 32309, 32313, 32323, 32311, 32306, 32314, 32359, 32349, 32342, 32350, 32345, 32346, 32377, 32362, 32361, 32380, 32379, 32387, 32213, 32381, 36782, 32383, 32392, 32393, 32396, 32402, 32400, 32403, 32404, 32406, 32398, 32411, 32412, 32568, 32570, 32581, 32588, 32589, 32590, 32592, 32593, 32597, 32596, 32600, 32607, 32608, 32616, 32617, 32615, 32632, 32642, 32646, 32643, 32648, 32647, 32652, 32660, 32670, 32669, 32666, 32675, 32687, 32690, 32697, 32686, 32694, 32696, 35697, 32709, 32710, 32714, 32725, 32724, 32737, 32742, 32745, 32755, 32761, 39132, 32774, 32772, 32779, 32786, 32792, 32793, 32796, 32801, 32808, 32831, 32827, 32842, 32838, 32850, 32856, 32858, 32863, 32866, 32872, 32883, 32882, 32880, 32886, 32889, 32893, 32895, 32900, 32902, 32901, 32923, 32915, 32922, 32941, 20880, 32940, 32987, 32997, 32985, 32989, 32964, 32986, 32982, 33033, 33007, 33009, 33051, 33065, 33059, 33071, 33099, 38539, 33094, 33086, 33107, 33105, 33020, 33137, 33134, 33125, 33126, 33140, 33155, 33160, 33162, 33152, 33154, 33184, 33173, 33188, 33187, 33119, 33171, 33193, 33200, 33205, 33214, 33208, 33213, 33216, 33218, 33210, 33225, 33229, 33233, 33241, 33240, 33224, 33242, 33247, 33248, 33255, 33274, 33275, 33278, 33281, 33282, 33285, 33287, 33290, 33293, 33296, 33302, 33321, 33323, 33336, 33331, 33344, 33369, 33368, 33373, 33370, 33375, 33380, 33378, 33384, 33386, 33387, 33326, 33393, 33399, 33400, 33406, 33421, 33426, 33451, 33439, 33467, 33452, 33505, 33507, 33503, 33490, 33524, 33523, 33530, 33683, 33539, 33531, 33529, 33502, 33542, 33500, 33545, 33497, 33589, 33588, 33558, 33586, 33585, 33600, 33593, 33616, 33605, 33583, 33579, 33559, 33560, 33669, 33690, 33706, 33695, 33698, 33686, 33571, 33678, 33671, 33674, 33660, 33717, 33651, 33653, 33696, 33673, 33704, 33780, 33811, 33771, 33742, 33789, 33795, 33752, 33803, 33729, 33783, 33799, 33760, 33778, 33805, 33826, 33824, 33725, 33848, 34054, 33787, 33901, 33834, 33852, 34138, 33924, 33911, 33899, 33965, 33902, 33922, 33897, 33862, 33836, 33903, 33913, 33845, 33994, 33890, 33977, 33983, 33951, 34009, 33997, 33979, 34010, 34e3, 33985, 33990, 34006, 33953, 34081, 34047, 34036, 34071, 34072, 34092, 34079, 34069, 34068, 34044, 34112, 34147, 34136, 34120, 34113, 34306, 34123, 34133, 34176, 34212, 34184, 34193, 34186, 34216, 34157, 34196, 34203, 34282, 34183, 34204, 34167, 34174, 34192, 34249, 34234, 34255, 34233, 34256, 34261, 34269, 34277, 34268, 34297, 34314, 34323, 34315, 34302, 34298, 34310, 34338, 34330, 34352, 34367, 34381, 20053, 34388, 34399, 34407, 34417, 34451, 34467, 34473, 34474, 34443, 34444, 34486, 34479, 34500, 34502, 34480, 34505, 34851, 34475, 34516, 34526, 34537, 34540, 34527, 34523, 34543, 34578, 34566, 34568, 34560, 34563, 34555, 34577, 34569, 34573, 34553, 34570, 34612, 34623, 34615, 34619, 34597, 34601, 34586, 34656, 34655, 34680, 34636, 34638, 34676, 34647, 34664, 34670, 34649, 34643, 34659, 34666, 34821, 34722, 34719, 34690, 34735, 34763, 34749, 34752, 34768, 38614, 34731, 34756, 34739, 34759, 34758, 34747, 34799, 34802, 34784, 34831, 34829, 34814, 34806, 34807, 34830, 34770, 34833, 34838, 34837, 34850, 34849, 34865, 34870, 34873, 34855, 34875, 34884, 34882, 34898, 34905, 34910, 34914, 34923, 34945, 34942, 34974, 34933, 34941, 34997, 34930, 34946, 34967, 34962, 34990, 34969, 34978, 34957, 34980, 34992, 35007, 34993, 35011, 35012, 35028, 35032, 35033, 35037, 35065, 35074, 35068, 35060, 35048, 35058, 35076, 35084, 35082, 35091, 35139, 35102, 35109, 35114, 35115, 35137, 35140, 35131, 35126, 35128, 35148, 35101, 35168, 35166, 35174, 35172, 35181, 35178, 35183, 35188, 35191, 35198, 35203, 35208, 35210, 35219, 35224, 35233, 35241, 35238, 35244, 35247, 35250, 35258, 35261, 35263, 35264, 35290, 35292, 35293, 35303, 35316, 35320, 35331, 35350, 35344, 35340, 35355, 35357, 35365, 35382, 35393, 35419, 35410, 35398, 35400, 35452, 35437, 35436, 35426, 35461, 35458, 35460, 35496, 35489, 35473, 35493, 35494, 35482, 35491, 35524, 35533, 35522, 35546, 35563, 35571, 35559, 35556, 35569, 35604, 35552, 35554, 35575, 35550, 35547, 35596, 35591, 35610, 35553, 35606, 35600, 35607, 35616, 35635, 38827, 35622, 35627, 35646, 35624, 35649, 35660, 35663, 35662, 35657, 35670, 35675, 35674, 35691, 35679, 35692, 35695, 35700, 35709, 35712, 35724, 35726, 35730, 35731, 35734, 35737, 35738, 35898, 35905, 35903, 35912, 35916, 35918, 35920, 35925, 35938, 35948, 35960, 35962, 35970, 35977, 35973, 35978, 35981, 35982, 35988, 35964, 35992, 25117, 36013, 36010, 36029, 36018, 36019, 36014, 36022, 36040, 36033, 36068, 36067, 36058, 36093, 36090, 36091, 36100, 36101, 36106, 36103, 36111, 36109, 36112, 40782, 36115, 36045, 36116, 36118, 36199, 36205, 36209, 36211, 36225, 36249, 36290, 36286, 36282, 36303, 36314, 36310, 36300, 36315, 36299, 36330, 36331, 36319, 36323, 36348, 36360, 36361, 36351, 36381, 36382, 36368, 36383, 36418, 36405, 36400, 36404, 36426, 36423, 36425, 36428, 36432, 36424, 36441, 36452, 36448, 36394, 36451, 36437, 36470, 36466, 36476, 36481, 36487, 36485, 36484, 36491, 36490, 36499, 36497, 36500, 36505, 36522, 36513, 36524, 36528, 36550, 36529, 36542, 36549, 36552, 36555, 36571, 36579, 36604, 36603, 36587, 36606, 36618, 36613, 36629, 36626, 36633, 36627, 36636, 36639, 36635, 36620, 36646, 36659, 36667, 36665, 36677, 36674, 36670, 36684, 36681, 36678, 36686, 36695, 36700, 36706, 36707, 36708, 36764, 36767, 36771, 36781, 36783, 36791, 36826, 36837, 36834, 36842, 36847, 36999, 36852, 36869, 36857, 36858, 36881, 36885, 36897, 36877, 36894, 36886, 36875, 36903, 36918, 36917, 36921, 36856, 36943, 36944, 36945, 36946, 36878, 36937, 36926, 36950, 36952, 36958, 36968, 36975, 36982, 38568, 36978, 36994, 36989, 36993, 36992, 37002, 37001, 37007, 37032, 37039, 37041, 37045, 37090, 37092, 25160, 37083, 37122, 37138, 37145, 37170, 37168, 37194, 37206, 37208, 37219, 37221, 37225, 37235, 37234, 37259, 37257, 37250, 37282, 37291, 37295, 37290, 37301, 37300, 37306, 37312, 37313, 37321, 37323, 37328, 37334, 37343, 37345, 37339, 37372, 37365, 37366, 37406, 37375, 37396, 37420, 37397, 37393, 37470, 37463, 37445, 37449, 37476, 37448, 37525, 37439, 37451, 37456, 37532, 37526, 37523, 37531, 37466, 37583, 37561, 37559, 37609, 37647, 37626, 37700, 37678, 37657, 37666, 37658, 37667, 37690, 37685, 37691, 37724, 37728, 37756, 37742, 37718, 37808, 37804, 37805, 37780, 37817, 37846, 37847, 37864, 37861, 37848, 37827, 37853, 37840, 37832, 37860, 37914, 37908, 37907, 37891, 37895, 37904, 37942, 37931, 37941, 37921, 37946, 37953, 37970, 37956, 37979, 37984, 37986, 37982, 37994, 37417, 38e3, 38005, 38007, 38013, 37978, 38012, 38014, 38017, 38015, 38274, 38279, 38282, 38292, 38294, 38296, 38297, 38304, 38312, 38311, 38317, 38332, 38331, 38329, 38334, 38346, 28662, 38339, 38349, 38348, 38357, 38356, 38358, 38364, 38369, 38373, 38370, 38433, 38440, 38446, 38447, 38466, 38476, 38479, 38475, 38519, 38492, 38494, 38493, 38495, 38502, 38514, 38508, 38541, 38552, 38549, 38551, 38570, 38567, 38577, 38578, 38576, 38580, 38582, 38584, 38585, 38606, 38603, 38601, 38605, 35149, 38620, 38669, 38613, 38649, 38660, 38662, 38664, 38675, 38670, 38673, 38671, 38678, 38681, 38692, 38698, 38704, 38713, 38717, 38718, 38724, 38726, 38728, 38722, 38729, 38748, 38752, 38756, 38758, 38760, 21202, 38763, 38769, 38777, 38789, 38780, 38785, 38778, 38790, 38795, 38799, 38800, 38812, 38824, 38822, 38819, 38835, 38836, 38851, 38854, 38856, 38859, 38876, 38893, 40783, 38898, 31455, 38902, 38901, 38927, 38924, 38968, 38948, 38945, 38967, 38973, 38982, 38991, 38987, 39019, 39023, 39024, 39025, 39028, 39027, 39082, 39087, 39089, 39094, 39108, 39107, 39110, 39145, 39147, 39171, 39177, 39186, 39188, 39192, 39201, 39197, 39198, 39204, 39200, 39212, 39214, 39229, 39230, 39234, 39241, 39237, 39248, 39243, 39249, 39250, 39244, 39253, 39319, 39320, 39333, 39341, 39342, 39356, 39391, 39387, 39389, 39384, 39377, 39405, 39406, 39409, 39410, 39419, 39416, 39425, 39439, 39429, 39394, 39449, 39467, 39479, 39493, 39490, 39488, 39491, 39486, 39509, 39501, 39515, 39511, 39519, 39522, 39525, 39524, 39529, 39531, 39530, 39597, 39600, 39612, 39616, 39631, 39633, 39635, 39636, 39646, 39647, 39650, 39651, 39654, 39663, 39659, 39662, 39668, 39665, 39671, 39675, 39686, 39704, 39706, 39711, 39714, 39715, 39717, 39719, 39720, 39721, 39722, 39726, 39727, 39730, 39748, 39747, 39759, 39757, 39758, 39761, 39768, 39796, 39827, 39811, 39825, 39830, 39831, 39839, 39840, 39848, 39860, 39872, 39882, 39865, 39878, 39887, 39889, 39890, 39907, 39906, 39908, 39892, 39905, 39994, 39922, 39921, 39920, 39957, 39956, 39945, 39955, 39948, 39942, 39944, 39954, 39946, 39940, 39982, 39963, 39973, 39972, 39969, 39984, 40007, 39986, 40006, 39998, 40026, 40032, 40039, 40054, 40056, 40167, 40172, 40176, 40201, 40200, 40171, 40195, 40198, 40234, 40230, 40367, 40227, 40223, 40260, 40213, 40210, 40257, 40255, 40254, 40262, 40264, 40285, 40286, 40292, 40273, 40272, 40281, 40306, 40329, 40327, 40363, 40303, 40314, 40346, 40356, 40361, 40370, 40388, 40385, 40379, 40376, 40378, 40390, 40399, 40386, 40409, 40403, 40440, 40422, 40429, 40431, 40445, 40474, 40475, 40478, 40565, 40569, 40573, 40577, 40584, 40587, 40588, 40594, 40597, 40593, 40605, 40613, 40617, 40632, 40618, 40621, 38753, 40652, 40654, 40655, 40656, 40660, 40668, 40670, 40669, 40672, 40677, 40680, 40687, 40692, 40694, 40695, 40697, 40699, 40700, 40701, 40711, 40712, 30391, 40725, 40737, 40748, 40766, 40778, 40786, 40788, 40803, 40799, 40800, 40801, 40806, 40807, 40812, 40810, 40823, 40818, 40822, 40853, 40860, 40864, 22575, 27079, 36953, 29796, 20956, 29081, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 32394, 35100, 37704, 37512, 34012, 20425, 28859, 26161, 26824, 37625, 26363, 24389, 20008, 20193, 20220, 20224, 20227, 20281, 20310, 20370, 20362, 20378, 20372, 20429, 20544, 20514, 20479, 20510, 20550, 20592, 20546, 20628, 20724, 20696, 20810, 20836, 20893, 20926, 20972, 21013, 21148, 21158, 21184, 21211, 21248, 21255, 21284, 21362, 21395, 21426, 21469, 64014, 21660, 21642, 21673, 21759, 21894, 22361, 22373, 22444, 22472, 22471, 64015, 64016, 22686, 22706, 22795, 22867, 22875, 22877, 22883, 22948, 22970, 23382, 23488, 29999, 23512, 23532, 23582, 23718, 23738, 23797, 23847, 23891, 64017, 23874, 23917, 23992, 23993, 24016, 24353, 24372, 24423, 24503, 24542, 24669, 24709, 24714, 24798, 24789, 24864, 24818, 24849, 24887, 24880, 24984, 25107, 25254, 25589, 25696, 25757, 25806, 25934, 26112, 26133, 26171, 26121, 26158, 26142, 26148, 26213, 26199, 26201, 64018, 26227, 26265, 26272, 26290, 26303, 26362, 26382, 63785, 26470, 26555, 26706, 26560, 26625, 26692, 26831, 64019, 26984, 64020, 27032, 27106, 27184, 27243, 27206, 27251, 27262, 27362, 27364, 27606, 27711, 27740, 27782, 27759, 27866, 27908, 28039, 28015, 28054, 28076, 28111, 28152, 28146, 28156, 28217, 28252, 28199, 28220, 28351, 28552, 28597, 28661, 28677, 28679, 28712, 28805, 28843, 28943, 28932, 29020, 28998, 28999, 64021, 29121, 29182, 29361, 29374, 29476, 64022, 29559, 29629, 29641, 29654, 29667, 29650, 29703, 29685, 29734, 29738, 29737, 29742, 29794, 29833, 29855, 29953, 30063, 30338, 30364, 30366, 30363, 30374, 64023, 30534, 21167, 30753, 30798, 30820, 30842, 31024, 64024, 64025, 64026, 31124, 64027, 31131, 31441, 31463, 64028, 31467, 31646, 64029, 32072, 32092, 32183, 32160, 32214, 32338, 32583, 32673, 64030, 33537, 33634, 33663, 33735, 33782, 33864, 33972, 34131, 34137, 34155, 64031, 34224, 64032, 64033, 34823, 35061, 35346, 35383, 35449, 35495, 35518, 35551, 64034, 35574, 35667, 35711, 36080, 36084, 36114, 36214, 64035, 36559, 64036, 64037, 36967, 37086, 64038, 37141, 37159, 37338, 37335, 37342, 37357, 37358, 37348, 37349, 37382, 37392, 37386, 37434, 37440, 37436, 37454, 37465, 37457, 37433, 37479, 37543, 37495, 37496, 37607, 37591, 37593, 37584, 64039, 37589, 37600, 37587, 37669, 37665, 37627, 64040, 37662, 37631, 37661, 37634, 37744, 37719, 37796, 37830, 37854, 37880, 37937, 37957, 37960, 38290, 63964, 64041, 38557, 38575, 38707, 38715, 38723, 38733, 38735, 38737, 38741, 38999, 39013, 64042, 64043, 39207, 64044, 39326, 39502, 39641, 39644, 39797, 39794, 39823, 39857, 39867, 39936, 40304, 40299, 64045, 40473, 40657, null, null, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 65506, 65508, 65287, 65282, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 65506, 65508, 65287, 65282, 12849, 8470, 8481, 8757, 32394, 35100, 37704, 37512, 34012, 20425, 28859, 26161, 26824, 37625, 26363, 24389, 20008, 20193, 20220, 20224, 20227, 20281, 20310, 20370, 20362, 20378, 20372, 20429, 20544, 20514, 20479, 20510, 20550, 20592, 20546, 20628, 20724, 20696, 20810, 20836, 20893, 20926, 20972, 21013, 21148, 21158, 21184, 21211, 21248, 21255, 21284, 21362, 21395, 21426, 21469, 64014, 21660, 21642, 21673, 21759, 21894, 22361, 22373, 22444, 22472, 22471, 64015, 64016, 22686, 22706, 22795, 22867, 22875, 22877, 22883, 22948, 22970, 23382, 23488, 29999, 23512, 23532, 23582, 23718, 23738, 23797, 23847, 23891, 64017, 23874, 23917, 23992, 23993, 24016, 24353, 24372, 24423, 24503, 24542, 24669, 24709, 24714, 24798, 24789, 24864, 24818, 24849, 24887, 24880, 24984, 25107, 25254, 25589, 25696, 25757, 25806, 25934, 26112, 26133, 26171, 26121, 26158, 26142, 26148, 26213, 26199, 26201, 64018, 26227, 26265, 26272, 26290, 26303, 26362, 26382, 63785, 26470, 26555, 26706, 26560, 26625, 26692, 26831, 64019, 26984, 64020, 27032, 27106, 27184, 27243, 27206, 27251, 27262, 27362, 27364, 27606, 27711, 27740, 27782, 27759, 27866, 27908, 28039, 28015, 28054, 28076, 28111, 28152, 28146, 28156, 28217, 28252, 28199, 28220, 28351, 28552, 28597, 28661, 28677, 28679, 28712, 28805, 28843, 28943, 28932, 29020, 28998, 28999, 64021, 29121, 29182, 29361, 29374, 29476, 64022, 29559, 29629, 29641, 29654, 29667, 29650, 29703, 29685, 29734, 29738, 29737, 29742, 29794, 29833, 29855, 29953, 30063, 30338, 30364, 30366, 30363, 30374, 64023, 30534, 21167, 30753, 30798, 30820, 30842, 31024, 64024, 64025, 64026, 31124, 64027, 31131, 31441, 31463, 64028, 31467, 31646, 64029, 32072, 32092, 32183, 32160, 32214, 32338, 32583, 32673, 64030, 33537, 33634, 33663, 33735, 33782, 33864, 33972, 34131, 34137, 34155, 64031, 34224, 64032, 64033, 34823, 35061, 35346, 35383, 35449, 35495, 35518, 35551, 64034, 35574, 35667, 35711, 36080, 36084, 36114, 36214, 64035, 36559, 64036, 64037, 36967, 37086, 64038, 37141, 37159, 37338, 37335, 37342, 37357, 37358, 37348, 37349, 37382, 37392, 37386, 37434, 37440, 37436, 37454, 37465, 37457, 37433, 37479, 37543, 37495, 37496, 37607, 37591, 37593, 37584, 64039, 37589, 37600, 37587, 37669, 37665, 37627, 64040, 37662, 37631, 37661, 37634, 37744, 37719, 37796, 37830, 37854, 37880, 37937, 37957, 37960, 38290, 63964, 64041, 38557, 38575, 38707, 38715, 38723, 38733, 38735, 38737, 38741, 38999, 39013, 64042, 64043, 39207, 64044, 39326, 39502, 39641, 39644, 39797, 39794, 39823, 39857, 39867, 39936, 40304, 40299, 64045, 40473, 40657, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "jis0212": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 728, 711, 184, 729, 733, 175, 731, 730, 65374, 900, 901, null, null, null, null, null, null, null, null, 161, 166, 191, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 186, 170, 169, 174, 8482, 164, 8470, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 902, 904, 905, 906, 938, null, 908, null, 910, 939, null, 911, null, null, null, null, 940, 941, 942, 943, 970, 912, 972, 962, 973, 971, 944, 974, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1038, 1039, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1118, 1119, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 198, 272, null, 294, null, 306, null, 321, 319, null, 330, 216, 338, null, 358, 222, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 230, 273, 240, 295, 305, 307, 312, 322, 320, 329, 331, 248, 339, 223, 359, 254, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 193, 192, 196, 194, 258, 461, 256, 260, 197, 195, 262, 264, 268, 199, 266, 270, 201, 200, 203, 202, 282, 278, 274, 280, null, 284, 286, 290, 288, 292, 205, 204, 207, 206, 463, 304, 298, 302, 296, 308, 310, 313, 317, 315, 323, 327, 325, 209, 211, 210, 214, 212, 465, 336, 332, 213, 340, 344, 342, 346, 348, 352, 350, 356, 354, 218, 217, 220, 219, 364, 467, 368, 362, 370, 366, 360, 471, 475, 473, 469, 372, 221, 376, 374, 377, 381, 379, null, null, null, null, null, null, null, 225, 224, 228, 226, 259, 462, 257, 261, 229, 227, 263, 265, 269, 231, 267, 271, 233, 232, 235, 234, 283, 279, 275, 281, 501, 285, 287, null, 289, 293, 237, 236, 239, 238, 464, null, 299, 303, 297, 309, 311, 314, 318, 316, 324, 328, 326, 241, 243, 242, 246, 244, 466, 337, 333, 245, 341, 345, 343, 347, 349, 353, 351, 357, 355, 250, 249, 252, 251, 365, 468, 369, 363, 371, 367, 361, 472, 476, 474, 470, 373, 253, 255, 375, 378, 382, 380, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 19970, 19972, 19973, 19980, 19986, 19999, 20003, 20004, 20008, 20011, 20014, 20015, 20016, 20021, 20032, 20033, 20036, 20039, 20049, 20058, 20060, 20067, 20072, 20073, 20084, 20085, 20089, 20095, 20109, 20118, 20119, 20125, 20143, 20153, 20163, 20176, 20186, 20187, 20192, 20193, 20194, 20200, 20207, 20209, 20211, 20213, 20221, 20222, 20223, 20224, 20226, 20227, 20232, 20235, 20236, 20242, 20245, 20246, 20247, 20249, 20270, 20273, 20320, 20275, 20277, 20279, 20281, 20283, 20286, 20288, 20290, 20296, 20297, 20299, 20300, 20306, 20308, 20310, 20312, 20319, 20323, 20330, 20332, 20334, 20337, 20343, 20344, 20345, 20346, 20349, 20350, 20353, 20354, 20356, 20357, 20361, 20362, 20364, 20366, 20368, 20370, 20371, 20372, 20375, 20377, 20378, 20382, 20383, 20402, 20407, 20409, 20411, 20412, 20413, 20414, 20416, 20417, 20421, 20422, 20424, 20425, 20427, 20428, 20429, 20431, 20434, 20444, 20448, 20450, 20464, 20466, 20476, 20477, 20479, 20480, 20481, 20484, 20487, 20490, 20492, 20494, 20496, 20499, 20503, 20504, 20507, 20508, 20509, 20510, 20514, 20519, 20526, 20528, 20530, 20531, 20533, 20544, 20545, 20546, 20549, 20550, 20554, 20556, 20558, 20561, 20562, 20563, 20567, 20569, 20575, 20576, 20578, 20579, 20582, 20583, 20586, 20589, 20592, 20593, 20539, 20609, 20611, 20612, 20614, 20618, 20622, 20623, 20624, 20626, 20627, 20628, 20630, 20635, 20636, 20638, 20639, 20640, 20641, 20642, 20650, 20655, 20656, 20665, 20666, 20669, 20672, 20675, 20676, 20679, 20684, 20686, 20688, 20691, 20692, 20696, 20700, 20701, 20703, 20706, 20708, 20710, 20712, 20713, 20719, 20721, 20726, 20730, 20734, 20739, 20742, 20743, 20744, 20747, 20748, 20749, 20750, 20722, 20752, 20759, 20761, 20763, 20764, 20765, 20766, 20771, 20775, 20776, 20780, 20781, 20783, 20785, 20787, 20788, 20789, 20792, 20793, 20802, 20810, 20815, 20819, 20821, 20823, 20824, 20831, 20836, 20838, 20862, 20867, 20868, 20875, 20878, 20888, 20893, 20897, 20899, 20909, 20920, 20922, 20924, 20926, 20927, 20930, 20936, 20943, 20945, 20946, 20947, 20949, 20952, 20958, 20962, 20965, 20974, 20978, 20979, 20980, 20983, 20993, 20994, 20997, 21010, 21011, 21013, 21014, 21016, 21026, 21032, 21041, 21042, 21045, 21052, 21061, 21065, 21077, 21079, 21080, 21082, 21084, 21087, 21088, 21089, 21094, 21102, 21111, 21112, 21113, 21120, 21122, 21125, 21130, 21132, 21139, 21141, 21142, 21143, 21144, 21146, 21148, 21156, 21157, 21158, 21159, 21167, 21168, 21174, 21175, 21176, 21178, 21179, 21181, 21184, 21188, 21190, 21192, 21196, 21199, 21201, 21204, 21206, 21211, 21212, 21217, 21221, 21224, 21225, 21226, 21228, 21232, 21233, 21236, 21238, 21239, 21248, 21251, 21258, 21259, 21260, 21265, 21267, 21272, 21275, 21276, 21278, 21279, 21285, 21287, 21288, 21289, 21291, 21292, 21293, 21296, 21298, 21301, 21308, 21309, 21310, 21314, 21324, 21323, 21337, 21339, 21345, 21347, 21349, 21356, 21357, 21362, 21369, 21374, 21379, 21383, 21384, 21390, 21395, 21396, 21401, 21405, 21409, 21412, 21418, 21419, 21423, 21426, 21428, 21429, 21431, 21432, 21434, 21437, 21440, 21445, 21455, 21458, 21459, 21461, 21466, 21469, 21470, 21472, 21478, 21479, 21493, 21506, 21523, 21530, 21537, 21543, 21544, 21546, 21551, 21553, 21556, 21557, 21571, 21572, 21575, 21581, 21583, 21598, 21602, 21604, 21606, 21607, 21609, 21611, 21613, 21614, 21620, 21631, 21633, 21635, 21637, 21640, 21641, 21645, 21649, 21653, 21654, 21660, 21663, 21665, 21670, 21671, 21673, 21674, 21677, 21678, 21681, 21687, 21689, 21690, 21691, 21695, 21702, 21706, 21709, 21710, 21728, 21738, 21740, 21743, 21750, 21756, 21758, 21759, 21760, 21761, 21765, 21768, 21769, 21772, 21773, 21774, 21781, 21802, 21803, 21810, 21813, 21814, 21819, 21820, 21821, 21825, 21831, 21833, 21834, 21837, 21840, 21841, 21848, 21850, 21851, 21854, 21856, 21857, 21860, 21862, 21887, 21889, 21890, 21894, 21896, 21902, 21903, 21905, 21906, 21907, 21908, 21911, 21923, 21924, 21933, 21938, 21951, 21953, 21955, 21958, 21961, 21963, 21964, 21966, 21969, 21970, 21971, 21975, 21976, 21979, 21982, 21986, 21993, 22006, 22015, 22021, 22024, 22026, 22029, 22030, 22031, 22032, 22033, 22034, 22041, 22060, 22064, 22067, 22069, 22071, 22073, 22075, 22076, 22077, 22079, 22080, 22081, 22083, 22084, 22086, 22089, 22091, 22093, 22095, 22100, 22110, 22112, 22113, 22114, 22115, 22118, 22121, 22125, 22127, 22129, 22130, 22133, 22148, 22149, 22152, 22155, 22156, 22165, 22169, 22170, 22173, 22174, 22175, 22182, 22183, 22184, 22185, 22187, 22188, 22189, 22193, 22195, 22199, 22206, 22213, 22217, 22218, 22219, 22223, 22224, 22220, 22221, 22233, 22236, 22237, 22239, 22241, 22244, 22245, 22246, 22247, 22248, 22257, 22251, 22253, 22262, 22263, 22273, 22274, 22279, 22282, 22284, 22289, 22293, 22298, 22299, 22301, 22304, 22306, 22307, 22308, 22309, 22313, 22314, 22316, 22318, 22319, 22323, 22324, 22333, 22334, 22335, 22341, 22342, 22348, 22349, 22354, 22370, 22373, 22375, 22376, 22379, 22381, 22382, 22383, 22384, 22385, 22387, 22388, 22389, 22391, 22393, 22394, 22395, 22396, 22398, 22401, 22403, 22412, 22420, 22423, 22425, 22426, 22428, 22429, 22430, 22431, 22433, 22421, 22439, 22440, 22441, 22444, 22456, 22461, 22471, 22472, 22476, 22479, 22485, 22493, 22494, 22500, 22502, 22503, 22505, 22509, 22512, 22517, 22518, 22520, 22525, 22526, 22527, 22531, 22532, 22536, 22537, 22497, 22540, 22541, 22555, 22558, 22559, 22560, 22566, 22567, 22573, 22578, 22585, 22591, 22601, 22604, 22605, 22607, 22608, 22613, 22623, 22625, 22628, 22631, 22632, 22648, 22652, 22655, 22656, 22657, 22663, 22664, 22665, 22666, 22668, 22669, 22671, 22672, 22676, 22678, 22685, 22688, 22689, 22690, 22694, 22697, 22705, 22706, 22724, 22716, 22722, 22728, 22733, 22734, 22736, 22738, 22740, 22742, 22746, 22749, 22753, 22754, 22761, 22771, 22789, 22790, 22795, 22796, 22802, 22803, 22804, 34369, 22813, 22817, 22819, 22820, 22824, 22831, 22832, 22835, 22837, 22838, 22847, 22851, 22854, 22866, 22867, 22873, 22875, 22877, 22878, 22879, 22881, 22883, 22891, 22893, 22895, 22898, 22901, 22902, 22905, 22907, 22908, 22923, 22924, 22926, 22930, 22933, 22935, 22943, 22948, 22951, 22957, 22958, 22959, 22960, 22963, 22967, 22970, 22972, 22977, 22979, 22980, 22984, 22986, 22989, 22994, 23005, 23006, 23007, 23011, 23012, 23015, 23022, 23023, 23025, 23026, 23028, 23031, 23040, 23044, 23052, 23053, 23054, 23058, 23059, 23070, 23075, 23076, 23079, 23080, 23082, 23085, 23088, 23108, 23109, 23111, 23112, 23116, 23120, 23125, 23134, 23139, 23141, 23143, 23149, 23159, 23162, 23163, 23166, 23179, 23184, 23187, 23190, 23193, 23196, 23198, 23199, 23200, 23202, 23207, 23212, 23217, 23218, 23219, 23221, 23224, 23226, 23227, 23231, 23236, 23238, 23240, 23247, 23258, 23260, 23264, 23269, 23274, 23278, 23285, 23286, 23293, 23296, 23297, 23304, 23319, 23348, 23321, 23323, 23325, 23329, 23333, 23341, 23352, 23361, 23371, 23372, 23378, 23382, 23390, 23400, 23406, 23407, 23420, 23421, 23422, 23423, 23425, 23428, 23430, 23434, 23438, 23440, 23441, 23443, 23444, 23446, 23464, 23465, 23468, 23469, 23471, 23473, 23474, 23479, 23482, 23484, 23488, 23489, 23501, 23503, 23510, 23511, 23512, 23513, 23514, 23520, 23535, 23537, 23540, 23549, 23564, 23575, 23582, 23583, 23587, 23590, 23593, 23595, 23596, 23598, 23600, 23602, 23605, 23606, 23641, 23642, 23644, 23650, 23651, 23655, 23656, 23657, 23661, 23664, 23668, 23669, 23674, 23675, 23676, 23677, 23687, 23688, 23690, 23695, 23698, 23709, 23711, 23712, 23714, 23715, 23718, 23722, 23730, 23732, 23733, 23738, 23753, 23755, 23762, 23773, 23767, 23790, 23793, 23794, 23796, 23809, 23814, 23821, 23826, 23851, 23843, 23844, 23846, 23847, 23857, 23860, 23865, 23869, 23871, 23874, 23875, 23878, 23880, 23893, 23889, 23897, 23882, 23903, 23904, 23905, 23906, 23908, 23914, 23917, 23920, 23929, 23930, 23934, 23935, 23937, 23939, 23944, 23946, 23954, 23955, 23956, 23957, 23961, 23963, 23967, 23968, 23975, 23979, 23984, 23988, 23992, 23993, 24003, 24007, 24011, 24016, 24014, 24024, 24025, 24032, 24036, 24041, 24056, 24057, 24064, 24071, 24077, 24082, 24084, 24085, 24088, 24095, 24096, 24110, 24104, 24114, 24117, 24126, 24139, 24144, 24137, 24145, 24150, 24152, 24155, 24156, 24158, 24168, 24170, 24171, 24172, 24173, 24174, 24176, 24192, 24203, 24206, 24226, 24228, 24229, 24232, 24234, 24236, 24241, 24243, 24253, 24254, 24255, 24262, 24268, 24267, 24270, 24273, 24274, 24276, 24277, 24284, 24286, 24293, 24299, 24322, 24326, 24327, 24328, 24334, 24345, 24348, 24349, 24353, 24354, 24355, 24356, 24360, 24363, 24364, 24366, 24368, 24372, 24374, 24379, 24381, 24383, 24384, 24388, 24389, 24391, 24397, 24400, 24404, 24408, 24411, 24416, 24419, 24420, 24423, 24431, 24434, 24436, 24437, 24440, 24442, 24445, 24446, 24457, 24461, 24463, 24470, 24476, 24477, 24482, 24487, 24491, 24484, 24492, 24495, 24496, 24497, 24504, 24516, 24519, 24520, 24521, 24523, 24528, 24529, 24530, 24531, 24532, 24542, 24545, 24546, 24552, 24553, 24554, 24556, 24557, 24558, 24559, 24562, 24563, 24566, 24570, 24572, 24583, 24586, 24589, 24595, 24596, 24599, 24600, 24602, 24607, 24612, 24621, 24627, 24629, 24640, 24647, 24648, 24649, 24652, 24657, 24660, 24662, 24663, 24669, 24673, 24679, 24689, 24702, 24703, 24706, 24710, 24712, 24714, 24718, 24721, 24723, 24725, 24728, 24733, 24734, 24738, 24740, 24741, 24744, 24752, 24753, 24759, 24763, 24766, 24770, 24772, 24776, 24777, 24778, 24779, 24782, 24783, 24788, 24789, 24793, 24795, 24797, 24798, 24802, 24805, 24818, 24821, 24824, 24828, 24829, 24834, 24839, 24842, 24844, 24848, 24849, 24850, 24851, 24852, 24854, 24855, 24857, 24860, 24862, 24866, 24874, 24875, 24880, 24881, 24885, 24886, 24887, 24889, 24897, 24901, 24902, 24905, 24926, 24928, 24940, 24946, 24952, 24955, 24956, 24959, 24960, 24961, 24963, 24964, 24971, 24973, 24978, 24979, 24983, 24984, 24988, 24989, 24991, 24992, 24997, 25e3, 25002, 25005, 25016, 25017, 25020, 25024, 25025, 25026, 25038, 25039, 25045, 25052, 25053, 25054, 25055, 25057, 25058, 25063, 25065, 25061, 25068, 25069, 25071, 25089, 25091, 25092, 25095, 25107, 25109, 25116, 25120, 25122, 25123, 25127, 25129, 25131, 25145, 25149, 25154, 25155, 25156, 25158, 25164, 25168, 25169, 25170, 25172, 25174, 25178, 25180, 25188, 25197, 25199, 25203, 25210, 25213, 25229, 25230, 25231, 25232, 25254, 25256, 25267, 25270, 25271, 25274, 25278, 25279, 25284, 25294, 25301, 25302, 25306, 25322, 25330, 25332, 25340, 25341, 25347, 25348, 25354, 25355, 25357, 25360, 25363, 25366, 25368, 25385, 25386, 25389, 25397, 25398, 25401, 25404, 25409, 25410, 25411, 25412, 25414, 25418, 25419, 25422, 25426, 25427, 25428, 25432, 25435, 25445, 25446, 25452, 25453, 25457, 25460, 25461, 25464, 25468, 25469, 25471, 25474, 25476, 25479, 25482, 25488, 25492, 25493, 25497, 25498, 25502, 25508, 25510, 25517, 25518, 25519, 25533, 25537, 25541, 25544, 25550, 25553, 25555, 25556, 25557, 25564, 25568, 25573, 25578, 25580, 25586, 25587, 25589, 25592, 25593, 25609, 25610, 25616, 25618, 25620, 25624, 25630, 25632, 25634, 25636, 25637, 25641, 25642, 25647, 25648, 25653, 25661, 25663, 25675, 25679, 25681, 25682, 25683, 25684, 25690, 25691, 25692, 25693, 25695, 25696, 25697, 25699, 25709, 25715, 25716, 25723, 25725, 25733, 25735, 25743, 25744, 25745, 25752, 25753, 25755, 25757, 25759, 25761, 25763, 25766, 25768, 25772, 25779, 25789, 25790, 25791, 25796, 25801, 25802, 25803, 25804, 25806, 25808, 25809, 25813, 25815, 25828, 25829, 25833, 25834, 25837, 25840, 25845, 25847, 25851, 25855, 25857, 25860, 25864, 25865, 25866, 25871, 25875, 25876, 25878, 25881, 25883, 25886, 25887, 25890, 25894, 25897, 25902, 25905, 25914, 25916, 25917, 25923, 25927, 25929, 25936, 25938, 25940, 25951, 25952, 25959, 25963, 25978, 25981, 25985, 25989, 25994, 26002, 26005, 26008, 26013, 26016, 26019, 26022, 26030, 26034, 26035, 26036, 26047, 26050, 26056, 26057, 26062, 26064, 26068, 26070, 26072, 26079, 26096, 26098, 26100, 26101, 26105, 26110, 26111, 26112, 26116, 26120, 26121, 26125, 26129, 26130, 26133, 26134, 26141, 26142, 26145, 26146, 26147, 26148, 26150, 26153, 26154, 26155, 26156, 26158, 26160, 26161, 26163, 26169, 26167, 26176, 26181, 26182, 26186, 26188, 26193, 26190, 26199, 26200, 26201, 26203, 26204, 26208, 26209, 26363, 26218, 26219, 26220, 26238, 26227, 26229, 26239, 26231, 26232, 26233, 26235, 26240, 26236, 26251, 26252, 26253, 26256, 26258, 26265, 26266, 26267, 26268, 26271, 26272, 26276, 26285, 26289, 26290, 26293, 26299, 26303, 26304, 26306, 26307, 26312, 26316, 26318, 26319, 26324, 26331, 26335, 26344, 26347, 26348, 26350, 26362, 26373, 26375, 26382, 26387, 26393, 26396, 26400, 26402, 26419, 26430, 26437, 26439, 26440, 26444, 26452, 26453, 26461, 26470, 26476, 26478, 26484, 26486, 26491, 26497, 26500, 26510, 26511, 26513, 26515, 26518, 26520, 26521, 26523, 26544, 26545, 26546, 26549, 26555, 26556, 26557, 26617, 26560, 26562, 26563, 26565, 26568, 26569, 26578, 26583, 26585, 26588, 26593, 26598, 26608, 26610, 26614, 26615, 26706, 26644, 26649, 26653, 26655, 26664, 26663, 26668, 26669, 26671, 26672, 26673, 26675, 26683, 26687, 26692, 26693, 26698, 26700, 26709, 26711, 26712, 26715, 26731, 26734, 26735, 26736, 26737, 26738, 26741, 26745, 26746, 26747, 26748, 26754, 26756, 26758, 26760, 26774, 26776, 26778, 26780, 26785, 26787, 26789, 26793, 26794, 26798, 26802, 26811, 26821, 26824, 26828, 26831, 26832, 26833, 26835, 26838, 26841, 26844, 26845, 26853, 26856, 26858, 26859, 26860, 26861, 26864, 26865, 26869, 26870, 26875, 26876, 26877, 26886, 26889, 26890, 26896, 26897, 26899, 26902, 26903, 26929, 26931, 26933, 26936, 26939, 26946, 26949, 26953, 26958, 26967, 26971, 26979, 26980, 26981, 26982, 26984, 26985, 26988, 26992, 26993, 26994, 27002, 27003, 27007, 27008, 27021, 27026, 27030, 27032, 27041, 27045, 27046, 27048, 27051, 27053, 27055, 27063, 27064, 27066, 27068, 27077, 27080, 27089, 27094, 27095, 27106, 27109, 27118, 27119, 27121, 27123, 27125, 27134, 27136, 27137, 27139, 27151, 27153, 27157, 27162, 27165, 27168, 27172, 27176, 27184, 27186, 27188, 27191, 27195, 27198, 27199, 27205, 27206, 27209, 27210, 27214, 27216, 27217, 27218, 27221, 27222, 27227, 27236, 27239, 27242, 27249, 27251, 27262, 27265, 27267, 27270, 27271, 27273, 27275, 27281, 27291, 27293, 27294, 27295, 27301, 27307, 27311, 27312, 27313, 27316, 27325, 27326, 27327, 27334, 27337, 27336, 27340, 27344, 27348, 27349, 27350, 27356, 27357, 27364, 27367, 27372, 27376, 27377, 27378, 27388, 27389, 27394, 27395, 27398, 27399, 27401, 27407, 27408, 27409, 27415, 27419, 27422, 27428, 27432, 27435, 27436, 27439, 27445, 27446, 27451, 27455, 27462, 27466, 27469, 27474, 27478, 27480, 27485, 27488, 27495, 27499, 27502, 27504, 27509, 27517, 27518, 27522, 27525, 27543, 27547, 27551, 27552, 27554, 27555, 27560, 27561, 27564, 27565, 27566, 27568, 27576, 27577, 27581, 27582, 27587, 27588, 27593, 27596, 27606, 27610, 27617, 27619, 27622, 27623, 27630, 27633, 27639, 27641, 27647, 27650, 27652, 27653, 27657, 27661, 27662, 27664, 27666, 27673, 27679, 27686, 27687, 27688, 27692, 27694, 27699, 27701, 27702, 27706, 27707, 27711, 27722, 27723, 27725, 27727, 27730, 27732, 27737, 27739, 27740, 27755, 27757, 27759, 27764, 27766, 27768, 27769, 27771, 27781, 27782, 27783, 27785, 27796, 27797, 27799, 27800, 27804, 27807, 27824, 27826, 27828, 27842, 27846, 27853, 27855, 27856, 27857, 27858, 27860, 27862, 27866, 27868, 27872, 27879, 27881, 27883, 27884, 27886, 27890, 27892, 27908, 27911, 27914, 27918, 27919, 27921, 27923, 27930, 27942, 27943, 27944, 27751, 27950, 27951, 27953, 27961, 27964, 27967, 27991, 27998, 27999, 28001, 28005, 28007, 28015, 28016, 28028, 28034, 28039, 28049, 28050, 28052, 28054, 28055, 28056, 28074, 28076, 28084, 28087, 28089, 28093, 28095, 28100, 28104, 28106, 28110, 28111, 28118, 28123, 28125, 28127, 28128, 28130, 28133, 28137, 28143, 28144, 28148, 28150, 28156, 28160, 28164, 28190, 28194, 28199, 28210, 28214, 28217, 28219, 28220, 28228, 28229, 28232, 28233, 28235, 28239, 28241, 28242, 28243, 28244, 28247, 28252, 28253, 28254, 28258, 28259, 28264, 28275, 28283, 28285, 28301, 28307, 28313, 28320, 28327, 28333, 28334, 28337, 28339, 28347, 28351, 28352, 28353, 28355, 28359, 28360, 28362, 28365, 28366, 28367, 28395, 28397, 28398, 28409, 28411, 28413, 28420, 28424, 28426, 28428, 28429, 28438, 28440, 28442, 28443, 28454, 28457, 28458, 28463, 28464, 28467, 28470, 28475, 28476, 28461, 28495, 28497, 28498, 28499, 28503, 28505, 28506, 28509, 28510, 28513, 28514, 28520, 28524, 28541, 28542, 28547, 28551, 28552, 28555, 28556, 28557, 28560, 28562, 28563, 28564, 28566, 28570, 28575, 28576, 28581, 28582, 28583, 28584, 28590, 28591, 28592, 28597, 28598, 28604, 28613, 28615, 28616, 28618, 28634, 28638, 28648, 28649, 28656, 28661, 28665, 28668, 28669, 28672, 28677, 28678, 28679, 28685, 28695, 28704, 28707, 28719, 28724, 28727, 28729, 28732, 28739, 28740, 28744, 28745, 28746, 28747, 28756, 28757, 28765, 28766, 28750, 28772, 28773, 28780, 28782, 28789, 28790, 28798, 28801, 28805, 28806, 28820, 28821, 28822, 28823, 28824, 28827, 28836, 28843, 28848, 28849, 28852, 28855, 28874, 28881, 28883, 28884, 28885, 28886, 28888, 28892, 28900, 28922, 28931, 28932, 28933, 28934, 28935, 28939, 28940, 28943, 28958, 28960, 28971, 28973, 28975, 28976, 28977, 28984, 28993, 28997, 28998, 28999, 29002, 29003, 29008, 29010, 29015, 29018, 29020, 29022, 29024, 29032, 29049, 29056, 29061, 29063, 29068, 29074, 29082, 29083, 29088, 29090, 29103, 29104, 29106, 29107, 29114, 29119, 29120, 29121, 29124, 29131, 29132, 29139, 29142, 29145, 29146, 29148, 29176, 29182, 29184, 29191, 29192, 29193, 29203, 29207, 29210, 29213, 29215, 29220, 29227, 29231, 29236, 29240, 29241, 29249, 29250, 29251, 29253, 29262, 29263, 29264, 29267, 29269, 29270, 29274, 29276, 29278, 29280, 29283, 29288, 29291, 29294, 29295, 29297, 29303, 29304, 29307, 29308, 29311, 29316, 29321, 29325, 29326, 29331, 29339, 29352, 29357, 29358, 29361, 29364, 29374, 29377, 29383, 29385, 29388, 29397, 29398, 29400, 29407, 29413, 29427, 29428, 29434, 29435, 29438, 29442, 29444, 29445, 29447, 29451, 29453, 29458, 29459, 29464, 29465, 29470, 29474, 29476, 29479, 29480, 29484, 29489, 29490, 29493, 29498, 29499, 29501, 29507, 29517, 29520, 29522, 29526, 29528, 29533, 29534, 29535, 29536, 29542, 29543, 29545, 29547, 29548, 29550, 29551, 29553, 29559, 29561, 29564, 29568, 29569, 29571, 29573, 29574, 29582, 29584, 29587, 29589, 29591, 29592, 29596, 29598, 29599, 29600, 29602, 29605, 29606, 29610, 29611, 29613, 29621, 29623, 29625, 29628, 29629, 29631, 29637, 29638, 29641, 29643, 29644, 29647, 29650, 29651, 29654, 29657, 29661, 29665, 29667, 29670, 29671, 29673, 29684, 29685, 29687, 29689, 29690, 29691, 29693, 29695, 29696, 29697, 29700, 29703, 29706, 29713, 29722, 29723, 29732, 29734, 29736, 29737, 29738, 29739, 29740, 29741, 29742, 29743, 29744, 29745, 29753, 29760, 29763, 29764, 29766, 29767, 29771, 29773, 29777, 29778, 29783, 29789, 29794, 29798, 29799, 29800, 29803, 29805, 29806, 29809, 29810, 29824, 29825, 29829, 29830, 29831, 29833, 29839, 29840, 29841, 29842, 29848, 29849, 29850, 29852, 29855, 29856, 29857, 29859, 29862, 29864, 29865, 29866, 29867, 29870, 29871, 29873, 29874, 29877, 29881, 29883, 29887, 29896, 29897, 29900, 29904, 29907, 29912, 29914, 29915, 29918, 29919, 29924, 29928, 29930, 29931, 29935, 29940, 29946, 29947, 29948, 29951, 29958, 29970, 29974, 29975, 29984, 29985, 29988, 29991, 29993, 29994, 29999, 30006, 30009, 30013, 30014, 30015, 30016, 30019, 30023, 30024, 30030, 30032, 30034, 30039, 30046, 30047, 30049, 30063, 30065, 30073, 30074, 30075, 30076, 30077, 30078, 30081, 30085, 30096, 30098, 30099, 30101, 30105, 30108, 30114, 30116, 30132, 30138, 30143, 30144, 30145, 30148, 30150, 30156, 30158, 30159, 30167, 30172, 30175, 30176, 30177, 30180, 30183, 30188, 30190, 30191, 30193, 30201, 30208, 30210, 30211, 30212, 30215, 30216, 30218, 30220, 30223, 30226, 30227, 30229, 30230, 30233, 30235, 30236, 30237, 30238, 30243, 30245, 30246, 30249, 30253, 30258, 30259, 30261, 30264, 30265, 30266, 30268, 30282, 30272, 30273, 30275, 30276, 30277, 30281, 30283, 30293, 30297, 30303, 30308, 30309, 30317, 30318, 30319, 30321, 30324, 30337, 30341, 30348, 30349, 30357, 30363, 30364, 30365, 30367, 30368, 30370, 30371, 30372, 30373, 30374, 30375, 30376, 30378, 30381, 30397, 30401, 30405, 30409, 30411, 30412, 30414, 30420, 30425, 30432, 30438, 30440, 30444, 30448, 30449, 30454, 30457, 30460, 30464, 30470, 30474, 30478, 30482, 30484, 30485, 30487, 30489, 30490, 30492, 30498, 30504, 30509, 30510, 30511, 30516, 30517, 30518, 30521, 30525, 30526, 30530, 30533, 30534, 30538, 30541, 30542, 30543, 30546, 30550, 30551, 30556, 30558, 30559, 30560, 30562, 30564, 30567, 30570, 30572, 30576, 30578, 30579, 30580, 30586, 30589, 30592, 30596, 30604, 30605, 30612, 30613, 30614, 30618, 30623, 30626, 30631, 30634, 30638, 30639, 30641, 30645, 30654, 30659, 30665, 30673, 30674, 30677, 30681, 30686, 30687, 30688, 30692, 30694, 30698, 30700, 30704, 30705, 30708, 30712, 30715, 30725, 30726, 30729, 30733, 30734, 30737, 30749, 30753, 30754, 30755, 30765, 30766, 30768, 30773, 30775, 30787, 30788, 30791, 30792, 30796, 30798, 30802, 30812, 30814, 30816, 30817, 30819, 30820, 30824, 30826, 30830, 30842, 30846, 30858, 30863, 30868, 30872, 30881, 30877, 30878, 30879, 30884, 30888, 30892, 30893, 30896, 30897, 30898, 30899, 30907, 30909, 30911, 30919, 30920, 30921, 30924, 30926, 30930, 30931, 30933, 30934, 30948, 30939, 30943, 30944, 30945, 30950, 30954, 30962, 30963, 30976, 30966, 30967, 30970, 30971, 30975, 30982, 30988, 30992, 31002, 31004, 31006, 31007, 31008, 31013, 31015, 31017, 31021, 31025, 31028, 31029, 31035, 31037, 31039, 31044, 31045, 31046, 31050, 31051, 31055, 31057, 31060, 31064, 31067, 31068, 31079, 31081, 31083, 31090, 31097, 31099, 31100, 31102, 31115, 31116, 31121, 31123, 31124, 31125, 31126, 31128, 31131, 31132, 31137, 31144, 31145, 31147, 31151, 31153, 31156, 31160, 31163, 31170, 31172, 31175, 31176, 31178, 31183, 31188, 31190, 31194, 31197, 31198, 31200, 31202, 31205, 31210, 31211, 31213, 31217, 31224, 31228, 31234, 31235, 31239, 31241, 31242, 31244, 31249, 31253, 31259, 31262, 31265, 31271, 31275, 31277, 31279, 31280, 31284, 31285, 31288, 31289, 31290, 31300, 31301, 31303, 31304, 31308, 31317, 31318, 31321, 31324, 31325, 31327, 31328, 31333, 31335, 31338, 31341, 31349, 31352, 31358, 31360, 31362, 31365, 31366, 31370, 31371, 31376, 31377, 31380, 31390, 31392, 31395, 31404, 31411, 31413, 31417, 31419, 31420, 31430, 31433, 31436, 31438, 31441, 31451, 31464, 31465, 31467, 31468, 31473, 31476, 31483, 31485, 31486, 31495, 31508, 31519, 31523, 31527, 31529, 31530, 31531, 31533, 31534, 31535, 31536, 31537, 31540, 31549, 31551, 31552, 31553, 31559, 31566, 31573, 31584, 31588, 31590, 31593, 31594, 31597, 31599, 31602, 31603, 31607, 31620, 31625, 31630, 31632, 31633, 31638, 31643, 31646, 31648, 31653, 31660, 31663, 31664, 31666, 31669, 31670, 31674, 31675, 31676, 31677, 31682, 31685, 31688, 31690, 31700, 31702, 31703, 31705, 31706, 31707, 31720, 31722, 31730, 31732, 31733, 31736, 31737, 31738, 31740, 31742, 31745, 31746, 31747, 31748, 31750, 31753, 31755, 31756, 31758, 31759, 31769, 31771, 31776, 31781, 31782, 31784, 31788, 31793, 31795, 31796, 31798, 31801, 31802, 31814, 31818, 31829, 31825, 31826, 31827, 31833, 31834, 31835, 31836, 31837, 31838, 31841, 31843, 31847, 31849, 31853, 31854, 31856, 31858, 31865, 31868, 31869, 31878, 31879, 31887, 31892, 31902, 31904, 31910, 31920, 31926, 31927, 31930, 31931, 31932, 31935, 31940, 31943, 31944, 31945, 31949, 31951, 31955, 31956, 31957, 31959, 31961, 31962, 31965, 31974, 31977, 31979, 31989, 32003, 32007, 32008, 32009, 32015, 32017, 32018, 32019, 32022, 32029, 32030, 32035, 32038, 32042, 32045, 32049, 32060, 32061, 32062, 32064, 32065, 32071, 32072, 32077, 32081, 32083, 32087, 32089, 32090, 32092, 32093, 32101, 32103, 32106, 32112, 32120, 32122, 32123, 32127, 32129, 32130, 32131, 32133, 32134, 32136, 32139, 32140, 32141, 32145, 32150, 32151, 32157, 32158, 32166, 32167, 32170, 32179, 32182, 32183, 32185, 32194, 32195, 32196, 32197, 32198, 32204, 32205, 32206, 32215, 32217, 32256, 32226, 32229, 32230, 32234, 32235, 32237, 32241, 32245, 32246, 32249, 32250, 32264, 32272, 32273, 32277, 32279, 32284, 32285, 32288, 32295, 32296, 32300, 32301, 32303, 32307, 32310, 32319, 32324, 32325, 32327, 32334, 32336, 32338, 32344, 32351, 32353, 32354, 32357, 32363, 32366, 32367, 32371, 32376, 32382, 32385, 32390, 32391, 32394, 32397, 32401, 32405, 32408, 32410, 32413, 32414, 32572, 32571, 32573, 32574, 32575, 32579, 32580, 32583, 32591, 32594, 32595, 32603, 32604, 32605, 32609, 32611, 32612, 32613, 32614, 32621, 32625, 32637, 32638, 32639, 32640, 32651, 32653, 32655, 32656, 32657, 32662, 32663, 32668, 32673, 32674, 32678, 32682, 32685, 32692, 32700, 32703, 32704, 32707, 32712, 32718, 32719, 32731, 32735, 32739, 32741, 32744, 32748, 32750, 32751, 32754, 32762, 32765, 32766, 32767, 32775, 32776, 32778, 32781, 32782, 32783, 32785, 32787, 32788, 32790, 32797, 32798, 32799, 32800, 32804, 32806, 32812, 32814, 32816, 32820, 32821, 32823, 32825, 32826, 32828, 32830, 32832, 32836, 32864, 32868, 32870, 32877, 32881, 32885, 32897, 32904, 32910, 32924, 32926, 32934, 32935, 32939, 32952, 32953, 32968, 32973, 32975, 32978, 32980, 32981, 32983, 32984, 32992, 33005, 33006, 33008, 33010, 33011, 33014, 33017, 33018, 33022, 33027, 33035, 33046, 33047, 33048, 33052, 33054, 33056, 33060, 33063, 33068, 33072, 33077, 33082, 33084, 33093, 33095, 33098, 33100, 33106, 33111, 33120, 33121, 33127, 33128, 33129, 33133, 33135, 33143, 33153, 33168, 33156, 33157, 33158, 33163, 33166, 33174, 33176, 33179, 33182, 33186, 33198, 33202, 33204, 33211, 33227, 33219, 33221, 33226, 33230, 33231, 33237, 33239, 33243, 33245, 33246, 33249, 33252, 33259, 33260, 33264, 33265, 33266, 33269, 33270, 33272, 33273, 33277, 33279, 33280, 33283, 33295, 33299, 33300, 33305, 33306, 33309, 33313, 33314, 33320, 33330, 33332, 33338, 33347, 33348, 33349, 33350, 33355, 33358, 33359, 33361, 33366, 33372, 33376, 33379, 33383, 33389, 33396, 33403, 33405, 33407, 33408, 33409, 33411, 33412, 33415, 33417, 33418, 33422, 33425, 33428, 33430, 33432, 33434, 33435, 33440, 33441, 33443, 33444, 33447, 33448, 33449, 33450, 33454, 33456, 33458, 33460, 33463, 33466, 33468, 33470, 33471, 33478, 33488, 33493, 33498, 33504, 33506, 33508, 33512, 33514, 33517, 33519, 33526, 33527, 33533, 33534, 33536, 33537, 33543, 33544, 33546, 33547, 33620, 33563, 33565, 33566, 33567, 33569, 33570, 33580, 33581, 33582, 33584, 33587, 33591, 33594, 33596, 33597, 33602, 33603, 33604, 33607, 33613, 33614, 33617, 33621, 33622, 33623, 33648, 33656, 33661, 33663, 33664, 33666, 33668, 33670, 33677, 33682, 33684, 33685, 33688, 33689, 33691, 33692, 33693, 33702, 33703, 33705, 33708, 33726, 33727, 33728, 33735, 33737, 33743, 33744, 33745, 33748, 33757, 33619, 33768, 33770, 33782, 33784, 33785, 33788, 33793, 33798, 33802, 33807, 33809, 33813, 33817, 33709, 33839, 33849, 33861, 33863, 33864, 33866, 33869, 33871, 33873, 33874, 33878, 33880, 33881, 33882, 33884, 33888, 33892, 33893, 33895, 33898, 33904, 33907, 33908, 33910, 33912, 33916, 33917, 33921, 33925, 33938, 33939, 33941, 33950, 33958, 33960, 33961, 33962, 33967, 33969, 33972, 33978, 33981, 33982, 33984, 33986, 33991, 33992, 33996, 33999, 34003, 34012, 34023, 34026, 34031, 34032, 34033, 34034, 34039, 34098, 34042, 34043, 34045, 34050, 34051, 34055, 34060, 34062, 34064, 34076, 34078, 34082, 34083, 34084, 34085, 34087, 34090, 34091, 34095, 34099, 34100, 34102, 34111, 34118, 34127, 34128, 34129, 34130, 34131, 34134, 34137, 34140, 34141, 34142, 34143, 34144, 34145, 34146, 34148, 34155, 34159, 34169, 34170, 34171, 34173, 34175, 34177, 34181, 34182, 34185, 34187, 34188, 34191, 34195, 34200, 34205, 34207, 34208, 34210, 34213, 34215, 34228, 34230, 34231, 34232, 34236, 34237, 34238, 34239, 34242, 34247, 34250, 34251, 34254, 34221, 34264, 34266, 34271, 34272, 34278, 34280, 34285, 34291, 34294, 34300, 34303, 34304, 34308, 34309, 34317, 34318, 34320, 34321, 34322, 34328, 34329, 34331, 34334, 34337, 34343, 34345, 34358, 34360, 34362, 34364, 34365, 34368, 34370, 34374, 34386, 34387, 34390, 34391, 34392, 34393, 34397, 34400, 34401, 34402, 34403, 34404, 34409, 34412, 34415, 34421, 34422, 34423, 34426, 34445, 34449, 34454, 34456, 34458, 34460, 34465, 34470, 34471, 34472, 34477, 34481, 34483, 34484, 34485, 34487, 34488, 34489, 34495, 34496, 34497, 34499, 34501, 34513, 34514, 34517, 34519, 34522, 34524, 34528, 34531, 34533, 34535, 34440, 34554, 34556, 34557, 34564, 34565, 34567, 34571, 34574, 34575, 34576, 34579, 34580, 34585, 34590, 34591, 34593, 34595, 34600, 34606, 34607, 34609, 34610, 34617, 34618, 34620, 34621, 34622, 34624, 34627, 34629, 34637, 34648, 34653, 34657, 34660, 34661, 34671, 34673, 34674, 34683, 34691, 34692, 34693, 34694, 34695, 34696, 34697, 34699, 34700, 34704, 34707, 34709, 34711, 34712, 34713, 34718, 34720, 34723, 34727, 34732, 34733, 34734, 34737, 34741, 34750, 34751, 34753, 34760, 34761, 34762, 34766, 34773, 34774, 34777, 34778, 34780, 34783, 34786, 34787, 34788, 34794, 34795, 34797, 34801, 34803, 34808, 34810, 34815, 34817, 34819, 34822, 34825, 34826, 34827, 34832, 34841, 34834, 34835, 34836, 34840, 34842, 34843, 34844, 34846, 34847, 34856, 34861, 34862, 34864, 34866, 34869, 34874, 34876, 34881, 34883, 34885, 34888, 34889, 34890, 34891, 34894, 34897, 34901, 34902, 34904, 34906, 34908, 34911, 34912, 34916, 34921, 34929, 34937, 34939, 34944, 34968, 34970, 34971, 34972, 34975, 34976, 34984, 34986, 35002, 35005, 35006, 35008, 35018, 35019, 35020, 35021, 35022, 35025, 35026, 35027, 35035, 35038, 35047, 35055, 35056, 35057, 35061, 35063, 35073, 35078, 35085, 35086, 35087, 35093, 35094, 35096, 35097, 35098, 35100, 35104, 35110, 35111, 35112, 35120, 35121, 35122, 35125, 35129, 35130, 35134, 35136, 35138, 35141, 35142, 35145, 35151, 35154, 35159, 35162, 35163, 35164, 35169, 35170, 35171, 35179, 35182, 35184, 35187, 35189, 35194, 35195, 35196, 35197, 35209, 35213, 35216, 35220, 35221, 35227, 35228, 35231, 35232, 35237, 35248, 35252, 35253, 35254, 35255, 35260, 35284, 35285, 35286, 35287, 35288, 35301, 35305, 35307, 35309, 35313, 35315, 35318, 35321, 35325, 35327, 35332, 35333, 35335, 35343, 35345, 35346, 35348, 35349, 35358, 35360, 35362, 35364, 35366, 35371, 35372, 35375, 35381, 35383, 35389, 35390, 35392, 35395, 35397, 35399, 35401, 35405, 35406, 35411, 35414, 35415, 35416, 35420, 35421, 35425, 35429, 35431, 35445, 35446, 35447, 35449, 35450, 35451, 35454, 35455, 35456, 35459, 35462, 35467, 35471, 35472, 35474, 35478, 35479, 35481, 35487, 35495, 35497, 35502, 35503, 35507, 35510, 35511, 35515, 35518, 35523, 35526, 35528, 35529, 35530, 35537, 35539, 35540, 35541, 35543, 35549, 35551, 35564, 35568, 35572, 35573, 35574, 35580, 35583, 35589, 35590, 35595, 35601, 35612, 35614, 35615, 35594, 35629, 35632, 35639, 35644, 35650, 35651, 35652, 35653, 35654, 35656, 35666, 35667, 35668, 35673, 35661, 35678, 35683, 35693, 35702, 35704, 35705, 35708, 35710, 35713, 35716, 35717, 35723, 35725, 35727, 35732, 35733, 35740, 35742, 35743, 35896, 35897, 35901, 35902, 35909, 35911, 35913, 35915, 35919, 35921, 35923, 35924, 35927, 35928, 35931, 35933, 35929, 35939, 35940, 35942, 35944, 35945, 35949, 35955, 35957, 35958, 35963, 35966, 35974, 35975, 35979, 35984, 35986, 35987, 35993, 35995, 35996, 36004, 36025, 36026, 36037, 36038, 36041, 36043, 36047, 36054, 36053, 36057, 36061, 36065, 36072, 36076, 36079, 36080, 36082, 36085, 36087, 36088, 36094, 36095, 36097, 36099, 36105, 36114, 36119, 36123, 36197, 36201, 36204, 36206, 36223, 36226, 36228, 36232, 36237, 36240, 36241, 36245, 36254, 36255, 36256, 36262, 36267, 36268, 36271, 36274, 36277, 36279, 36281, 36283, 36288, 36293, 36294, 36295, 36296, 36298, 36302, 36305, 36308, 36309, 36311, 36313, 36324, 36325, 36327, 36332, 36336, 36284, 36337, 36338, 36340, 36349, 36353, 36356, 36357, 36358, 36363, 36369, 36372, 36374, 36384, 36385, 36386, 36387, 36390, 36391, 36401, 36403, 36406, 36407, 36408, 36409, 36413, 36416, 36417, 36427, 36429, 36430, 36431, 36436, 36443, 36444, 36445, 36446, 36449, 36450, 36457, 36460, 36461, 36463, 36464, 36465, 36473, 36474, 36475, 36482, 36483, 36489, 36496, 36498, 36501, 36506, 36507, 36509, 36510, 36514, 36519, 36521, 36525, 36526, 36531, 36533, 36538, 36539, 36544, 36545, 36547, 36548, 36551, 36559, 36561, 36564, 36572, 36584, 36590, 36592, 36593, 36599, 36601, 36602, 36589, 36608, 36610, 36615, 36616, 36623, 36624, 36630, 36631, 36632, 36638, 36640, 36641, 36643, 36645, 36647, 36648, 36652, 36653, 36654, 36660, 36661, 36662, 36663, 36666, 36672, 36673, 36675, 36679, 36687, 36689, 36690, 36691, 36692, 36693, 36696, 36701, 36702, 36709, 36765, 36768, 36769, 36772, 36773, 36774, 36789, 36790, 36792, 36798, 36800, 36801, 36806, 36810, 36811, 36813, 36816, 36818, 36819, 36821, 36832, 36835, 36836, 36840, 36846, 36849, 36853, 36854, 36859, 36862, 36866, 36868, 36872, 36876, 36888, 36891, 36904, 36905, 36911, 36906, 36908, 36909, 36915, 36916, 36919, 36927, 36931, 36932, 36940, 36955, 36957, 36962, 36966, 36967, 36972, 36976, 36980, 36985, 36997, 37e3, 37003, 37004, 37006, 37008, 37013, 37015, 37016, 37017, 37019, 37024, 37025, 37026, 37029, 37040, 37042, 37043, 37044, 37046, 37053, 37068, 37054, 37059, 37060, 37061, 37063, 37064, 37077, 37079, 37080, 37081, 37084, 37085, 37087, 37093, 37074, 37110, 37099, 37103, 37104, 37108, 37118, 37119, 37120, 37124, 37125, 37126, 37128, 37133, 37136, 37140, 37142, 37143, 37144, 37146, 37148, 37150, 37152, 37157, 37154, 37155, 37159, 37161, 37166, 37167, 37169, 37172, 37174, 37175, 37177, 37178, 37180, 37181, 37187, 37191, 37192, 37199, 37203, 37207, 37209, 37210, 37211, 37217, 37220, 37223, 37229, 37236, 37241, 37242, 37243, 37249, 37251, 37253, 37254, 37258, 37262, 37265, 37267, 37268, 37269, 37272, 37278, 37281, 37286, 37288, 37292, 37293, 37294, 37296, 37297, 37298, 37299, 37302, 37307, 37308, 37309, 37311, 37314, 37315, 37317, 37331, 37332, 37335, 37337, 37338, 37342, 37348, 37349, 37353, 37354, 37356, 37357, 37358, 37359, 37360, 37361, 37367, 37369, 37371, 37373, 37376, 37377, 37380, 37381, 37382, 37383, 37385, 37386, 37388, 37392, 37394, 37395, 37398, 37400, 37404, 37405, 37411, 37412, 37413, 37414, 37416, 37422, 37423, 37424, 37427, 37429, 37430, 37432, 37433, 37434, 37436, 37438, 37440, 37442, 37443, 37446, 37447, 37450, 37453, 37454, 37455, 37457, 37464, 37465, 37468, 37469, 37472, 37473, 37477, 37479, 37480, 37481, 37486, 37487, 37488, 37493, 37494, 37495, 37496, 37497, 37499, 37500, 37501, 37503, 37512, 37513, 37514, 37517, 37518, 37522, 37527, 37529, 37535, 37536, 37540, 37541, 37543, 37544, 37547, 37551, 37554, 37558, 37560, 37562, 37563, 37564, 37565, 37567, 37568, 37569, 37570, 37571, 37573, 37574, 37575, 37576, 37579, 37580, 37581, 37582, 37584, 37587, 37589, 37591, 37592, 37593, 37596, 37597, 37599, 37600, 37601, 37603, 37605, 37607, 37608, 37612, 37614, 37616, 37625, 37627, 37631, 37632, 37634, 37640, 37645, 37649, 37652, 37653, 37660, 37661, 37662, 37663, 37665, 37668, 37669, 37671, 37673, 37674, 37683, 37684, 37686, 37687, 37703, 37704, 37705, 37712, 37713, 37714, 37717, 37719, 37720, 37722, 37726, 37732, 37733, 37735, 37737, 37738, 37741, 37743, 37744, 37745, 37747, 37748, 37750, 37754, 37757, 37759, 37760, 37761, 37762, 37768, 37770, 37771, 37773, 37775, 37778, 37781, 37784, 37787, 37790, 37793, 37795, 37796, 37798, 37800, 37803, 37812, 37813, 37814, 37818, 37801, 37825, 37828, 37829, 37830, 37831, 37833, 37834, 37835, 37836, 37837, 37843, 37849, 37852, 37854, 37855, 37858, 37862, 37863, 37881, 37879, 37880, 37882, 37883, 37885, 37889, 37890, 37892, 37896, 37897, 37901, 37902, 37903, 37909, 37910, 37911, 37919, 37934, 37935, 37937, 37938, 37939, 37940, 37947, 37951, 37949, 37955, 37957, 37960, 37962, 37964, 37973, 37977, 37980, 37983, 37985, 37987, 37992, 37995, 37997, 37998, 37999, 38001, 38002, 38020, 38019, 38264, 38265, 38270, 38276, 38280, 38284, 38285, 38286, 38301, 38302, 38303, 38305, 38310, 38313, 38315, 38316, 38324, 38326, 38330, 38333, 38335, 38342, 38344, 38345, 38347, 38352, 38353, 38354, 38355, 38361, 38362, 38365, 38366, 38367, 38368, 38372, 38374, 38429, 38430, 38434, 38436, 38437, 38438, 38444, 38449, 38451, 38455, 38456, 38457, 38458, 38460, 38461, 38465, 38482, 38484, 38486, 38487, 38488, 38497, 38510, 38516, 38523, 38524, 38526, 38527, 38529, 38530, 38531, 38532, 38537, 38545, 38550, 38554, 38557, 38559, 38564, 38565, 38566, 38569, 38574, 38575, 38579, 38586, 38602, 38610, 23986, 38616, 38618, 38621, 38622, 38623, 38633, 38639, 38641, 38650, 38658, 38659, 38661, 38665, 38682, 38683, 38685, 38689, 38690, 38691, 38696, 38705, 38707, 38721, 38723, 38730, 38734, 38735, 38741, 38743, 38744, 38746, 38747, 38755, 38759, 38762, 38766, 38771, 38774, 38775, 38776, 38779, 38781, 38783, 38784, 38793, 38805, 38806, 38807, 38809, 38810, 38814, 38815, 38818, 38828, 38830, 38833, 38834, 38837, 38838, 38840, 38841, 38842, 38844, 38846, 38847, 38849, 38852, 38853, 38855, 38857, 38858, 38860, 38861, 38862, 38864, 38865, 38868, 38871, 38872, 38873, 38877, 38878, 38880, 38875, 38881, 38884, 38895, 38897, 38900, 38903, 38904, 38906, 38919, 38922, 38937, 38925, 38926, 38932, 38934, 38940, 38942, 38944, 38947, 38950, 38955, 38958, 38959, 38960, 38962, 38963, 38965, 38949, 38974, 38980, 38983, 38986, 38993, 38994, 38995, 38998, 38999, 39001, 39002, 39010, 39011, 39013, 39014, 39018, 39020, 39083, 39085, 39086, 39088, 39092, 39095, 39096, 39098, 39099, 39103, 39106, 39109, 39112, 39116, 39137, 39139, 39141, 39142, 39143, 39146, 39155, 39158, 39170, 39175, 39176, 39185, 39189, 39190, 39191, 39194, 39195, 39196, 39199, 39202, 39206, 39207, 39211, 39217, 39218, 39219, 39220, 39221, 39225, 39226, 39227, 39228, 39232, 39233, 39238, 39239, 39240, 39245, 39246, 39252, 39256, 39257, 39259, 39260, 39262, 39263, 39264, 39323, 39325, 39327, 39334, 39344, 39345, 39346, 39349, 39353, 39354, 39357, 39359, 39363, 39369, 39379, 39380, 39385, 39386, 39388, 39390, 39399, 39402, 39403, 39404, 39408, 39412, 39413, 39417, 39421, 39422, 39426, 39427, 39428, 39435, 39436, 39440, 39441, 39446, 39454, 39456, 39458, 39459, 39460, 39463, 39469, 39470, 39475, 39477, 39478, 39480, 39495, 39489, 39492, 39498, 39499, 39500, 39502, 39505, 39508, 39510, 39517, 39594, 39596, 39598, 39599, 39602, 39604, 39605, 39606, 39609, 39611, 39614, 39615, 39617, 39619, 39622, 39624, 39630, 39632, 39634, 39637, 39638, 39639, 39643, 39644, 39648, 39652, 39653, 39655, 39657, 39660, 39666, 39667, 39669, 39673, 39674, 39677, 39679, 39680, 39681, 39682, 39683, 39684, 39685, 39688, 39689, 39691, 39692, 39693, 39694, 39696, 39698, 39702, 39705, 39707, 39708, 39712, 39718, 39723, 39725, 39731, 39732, 39733, 39735, 39737, 39738, 39741, 39752, 39755, 39756, 39765, 39766, 39767, 39771, 39774, 39777, 39779, 39781, 39782, 39784, 39786, 39787, 39788, 39789, 39790, 39795, 39797, 39799, 39800, 39801, 39807, 39808, 39812, 39813, 39814, 39815, 39817, 39818, 39819, 39821, 39823, 39824, 39828, 39834, 39837, 39838, 39846, 39847, 39849, 39852, 39856, 39857, 39858, 39863, 39864, 39867, 39868, 39870, 39871, 39873, 39879, 39880, 39886, 39888, 39895, 39896, 39901, 39903, 39909, 39911, 39914, 39915, 39919, 39923, 39927, 39928, 39929, 39930, 39933, 39935, 39936, 39938, 39947, 39951, 39953, 39958, 39960, 39961, 39962, 39964, 39966, 39970, 39971, 39974, 39975, 39976, 39977, 39978, 39985, 39989, 39990, 39991, 39997, 40001, 40003, 40004, 40005, 40009, 40010, 40014, 40015, 40016, 40019, 40020, 40022, 40024, 40027, 40029, 40030, 40031, 40035, 40041, 40042, 40028, 40043, 40040, 40046, 40048, 40050, 40053, 40055, 40059, 40166, 40178, 40183, 40185, 40203, 40194, 40209, 40215, 40216, 40220, 40221, 40222, 40239, 40240, 40242, 40243, 40244, 40250, 40252, 40261, 40253, 40258, 40259, 40263, 40266, 40275, 40276, 40287, 40291, 40290, 40293, 40297, 40298, 40299, 40304, 40310, 40311, 40315, 40316, 40318, 40323, 40324, 40326, 40330, 40333, 40334, 40338, 40339, 40341, 40342, 40343, 40344, 40353, 40362, 40364, 40366, 40369, 40373, 40377, 40380, 40383, 40387, 40391, 40393, 40394, 40404, 40405, 40406, 40407, 40410, 40414, 40415, 40416, 40421, 40423, 40425, 40427, 40430, 40432, 40435, 40436, 40446, 40458, 40450, 40455, 40462, 40464, 40465, 40466, 40469, 40470, 40473, 40476, 40477, 40570, 40571, 40572, 40576, 40578, 40579, 40580, 40581, 40583, 40590, 40591, 40598, 40600, 40603, 40606, 40612, 40616, 40620, 40622, 40623, 40624, 40627, 40628, 40629, 40646, 40648, 40651, 40661, 40671, 40676, 40679, 40684, 40685, 40686, 40688, 40689, 40690, 40693, 40696, 40703, 40706, 40707, 40713, 40719, 40720, 40721, 40722, 40724, 40726, 40727, 40729, 40730, 40731, 40735, 40738, 40742, 40746, 40747, 40751, 40753, 40754, 40756, 40759, 40761, 40762, 40764, 40765, 40767, 40769, 40771, 40772, 40773, 40774, 40775, 40787, 40789, 40790, 40791, 40792, 40794, 40797, 40798, 40808, 40809, 40813, 40814, 40815, 40816, 40817, 40819, 40821, 40826, 40829, 40847, 40848, 40849, 40850, 40852, 40854, 40855, 40862, 40865, 40866, 40867, 40869, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "ibm866": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 9617, 9618, 9619, 9474, 9508, 9569, 9570, 9558, 9557, 9571, 9553, 9559, 9565, 9564, 9563, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 9566, 9567, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 9575, 9576, 9572, 9573, 9561, 9560, 9554, 9555, 9579, 9578, 9496, 9484, 9608, 9604, 9612, 9616, 9600, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1025, 1105, 1028, 1108, 1031, 1111, 1038, 1118, 176, 8729, 183, 8730, 8470, 164, 9632, 160],
        "iso-8859-2": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 728, 321, 164, 317, 346, 167, 168, 352, 350, 356, 377, 173, 381, 379, 176, 261, 731, 322, 180, 318, 347, 711, 184, 353, 351, 357, 378, 733, 382, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
        "iso-8859-3": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 294, 728, 163, 164, null, 292, 167, 168, 304, 350, 286, 308, 173, null, 379, 176, 295, 178, 179, 180, 181, 293, 183, 184, 305, 351, 287, 309, 189, null, 380, 192, 193, 194, null, 196, 266, 264, 199, 200, 201, 202, 203, 204, 205, 206, 207, null, 209, 210, 211, 212, 288, 214, 215, 284, 217, 218, 219, 220, 364, 348, 223, 224, 225, 226, null, 228, 267, 265, 231, 232, 233, 234, 235, 236, 237, 238, 239, null, 241, 242, 243, 244, 289, 246, 247, 285, 249, 250, 251, 252, 365, 349, 729],
        "iso-8859-4": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 312, 342, 164, 296, 315, 167, 168, 352, 274, 290, 358, 173, 381, 175, 176, 261, 731, 343, 180, 297, 316, 711, 184, 353, 275, 291, 359, 330, 382, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 298, 272, 325, 332, 310, 212, 213, 214, 215, 216, 370, 218, 219, 220, 360, 362, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 299, 273, 326, 333, 311, 244, 245, 246, 247, 248, 371, 250, 251, 252, 361, 363, 729],
        "iso-8859-5": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 173, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 8470, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 167, 1118, 1119],
        "iso-8859-6": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, null, null, 164, null, null, null, null, null, null, null, 1548, 173, null, null, null, null, null, null, null, null, null, null, null, null, null, 1563, null, null, null, 1567, null, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, null, null, null, null, null, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, null, null, null, null, null, null, null, null, null, null, null, null, null],
        "iso-8859-7": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8216, 8217, 163, 8364, 8367, 166, 167, 168, 169, 890, 171, 172, 173, null, 8213, 176, 177, 178, 179, 900, 901, 902, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
        "iso-8859-8": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, 162, 163, 164, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 8215, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
        "iso-8859-10": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 274, 290, 298, 296, 310, 167, 315, 272, 352, 358, 381, 173, 362, 330, 176, 261, 275, 291, 299, 297, 311, 183, 316, 273, 353, 359, 382, 8213, 363, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 207, 208, 325, 332, 211, 212, 213, 214, 360, 216, 370, 218, 219, 220, 221, 222, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 239, 240, 326, 333, 243, 244, 245, 246, 361, 248, 371, 250, 251, 252, 253, 254, 312],
        "iso-8859-13": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8221, 162, 163, 164, 8222, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 8220, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 8217],
        "iso-8859-14": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 7682, 7683, 163, 266, 267, 7690, 167, 7808, 169, 7810, 7691, 7922, 173, 174, 376, 7710, 7711, 288, 289, 7744, 7745, 182, 7766, 7809, 7767, 7811, 7776, 7923, 7812, 7813, 7777, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 372, 209, 210, 211, 212, 213, 214, 7786, 216, 217, 218, 219, 220, 221, 374, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 373, 241, 242, 243, 244, 245, 246, 7787, 248, 249, 250, 251, 252, 253, 375, 255],
        "iso-8859-15": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 8364, 165, 352, 167, 353, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 381, 181, 182, 183, 382, 185, 186, 187, 338, 339, 376, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
        "iso-8859-16": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 261, 321, 8364, 8222, 352, 167, 353, 169, 536, 171, 377, 173, 378, 379, 176, 177, 268, 322, 381, 8221, 182, 183, 382, 269, 537, 187, 338, 339, 376, 380, 192, 193, 194, 258, 196, 262, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 272, 323, 210, 211, 212, 336, 214, 346, 368, 217, 218, 219, 220, 280, 538, 223, 224, 225, 226, 259, 228, 263, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 273, 324, 242, 243, 244, 337, 246, 347, 369, 249, 250, 251, 252, 281, 539, 255],
        "koi8-r": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 1025, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
        "koi8-u": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 1108, 9556, 1110, 1111, 9559, 9560, 9561, 9562, 9563, 1169, 1118, 9566, 9567, 9568, 9569, 1025, 1028, 9571, 1030, 1031, 9574, 9575, 9576, 9577, 9578, 1168, 1038, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
        "macintosh": [196, 197, 199, 201, 209, 214, 220, 225, 224, 226, 228, 227, 229, 231, 233, 232, 234, 235, 237, 236, 238, 239, 241, 243, 242, 244, 246, 245, 250, 249, 251, 252, 8224, 176, 162, 163, 167, 8226, 182, 223, 174, 169, 8482, 180, 168, 8800, 198, 216, 8734, 177, 8804, 8805, 165, 181, 8706, 8721, 8719, 960, 8747, 170, 186, 937, 230, 248, 191, 161, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 192, 195, 213, 338, 339, 8211, 8212, 8220, 8221, 8216, 8217, 247, 9674, 255, 376, 8260, 8364, 8249, 8250, 64257, 64258, 8225, 183, 8218, 8222, 8240, 194, 202, 193, 203, 200, 205, 206, 207, 204, 211, 212, 63743, 210, 218, 219, 217, 305, 710, 732, 175, 728, 729, 730, 184, 733, 731, 711],
        "windows-874": [8364, 129, 130, 131, 132, 8230, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 153, 154, 155, 156, 157, 158, 159, 160, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, null, null, null, null, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, null, null, null, null],
        "windows-1250": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 352, 8249, 346, 356, 381, 377, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 353, 8250, 347, 357, 382, 378, 160, 711, 728, 321, 164, 260, 166, 167, 168, 169, 350, 171, 172, 173, 174, 379, 176, 177, 731, 322, 180, 181, 182, 183, 184, 261, 351, 187, 317, 733, 318, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
        "windows-1251": [1026, 1027, 8218, 1107, 8222, 8230, 8224, 8225, 8364, 8240, 1033, 8249, 1034, 1036, 1035, 1039, 1106, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 1113, 8250, 1114, 1116, 1115, 1119, 160, 1038, 1118, 1032, 164, 1168, 166, 167, 1025, 169, 1028, 171, 172, 173, 174, 1031, 176, 177, 1030, 1110, 1169, 181, 182, 183, 1105, 8470, 1108, 187, 1112, 1029, 1109, 1111, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103],
        "windows-1252": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
        "windows-1253": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 157, 158, 159, 160, 901, 902, 163, 164, 165, 166, 167, 168, 169, null, 171, 172, 173, 174, 8213, 176, 177, 178, 179, 900, 181, 182, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
        "windows-1254": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 286, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 304, 350, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 287, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 305, 351, 255],
        "windows-1255": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 156, 157, 158, 159, 160, 161, 162, 163, 8362, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, 191, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1520, 1521, 1522, 1523, 1524, null, null, null, null, null, null, null, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
        "windows-1256": [8364, 1662, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 1657, 8249, 338, 1670, 1688, 1672, 1711, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 1705, 8482, 1681, 8250, 339, 8204, 8205, 1722, 160, 1548, 162, 163, 164, 165, 166, 167, 168, 169, 1726, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 1563, 187, 188, 189, 190, 1567, 1729, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 215, 1591, 1592, 1593, 1594, 1600, 1601, 1602, 1603, 224, 1604, 226, 1605, 1606, 1607, 1608, 231, 232, 233, 234, 235, 1609, 1610, 238, 239, 1611, 1612, 1613, 1614, 244, 1615, 1616, 247, 1617, 249, 1618, 251, 252, 8206, 8207, 1746],
        "windows-1257": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 168, 711, 184, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 175, 731, 159, 160, null, 162, 163, 164, null, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 180, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 729],
        "windows-1258": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 258, 196, 197, 198, 199, 200, 201, 202, 203, 768, 205, 206, 207, 272, 209, 777, 211, 212, 416, 214, 215, 216, 217, 218, 219, 220, 431, 771, 223, 224, 225, 226, 259, 228, 229, 230, 231, 232, 233, 234, 235, 769, 237, 238, 239, 273, 241, 803, 243, 244, 417, 246, 247, 248, 249, 250, 251, 252, 432, 8363, 255],
        "x-mac-cyrillic": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 8224, 176, 1168, 163, 167, 8226, 182, 1030, 174, 169, 8482, 1026, 1106, 8800, 1027, 1107, 8734, 177, 8804, 8805, 1110, 181, 1169, 1032, 1028, 1108, 1031, 1111, 1033, 1113, 1034, 1114, 1112, 1029, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 1035, 1115, 1036, 1116, 1109, 8211, 8212, 8220, 8221, 8216, 8217, 247, 8222, 1038, 1118, 1039, 1119, 8470, 1025, 1105, 1103, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 8364]
      };
    })(exports2 || {});
  }
});

// node_modules/text-encoding/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/text-encoding/lib/encoding.js"(exports2, module2) {
    (function(global2) {
      "use strict";
      if (typeof module2 !== "undefined" && module2.exports && !global2["encoding-indexes"]) {
        global2["encoding-indexes"] = require_encoding_indexes()["encoding-indexes"];
      }
      function inRange(a, min, max) {
        return min <= a && a <= max;
      }
      function includes(array, item) {
        return array.indexOf(item) !== -1;
      }
      var floor = Math.floor;
      function ToDictionary(o) {
        if (o === void 0) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
      }
      function stringToCodePoints(string) {
        var s = String(string);
        var n = s.length;
        var i = 0;
        var u = [];
        while (i < n) {
          var c = s.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            u.push(c);
          } else if (56320 <= c && c <= 57343) {
            u.push(65533);
          } else if (55296 <= c && c <= 56319) {
            if (i === n - 1) {
              u.push(65533);
            } else {
              var d = s.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                var a = c & 1023;
                var b = d & 1023;
                u.push(65536 + (a << 10) + b);
                i += 1;
              } else {
                u.push(65533);
              }
            }
          }
          i += 1;
        }
        return u;
      }
      function codePointsToString(code_points) {
        var s = "";
        for (var i = 0; i < code_points.length; ++i) {
          var cp = code_points[i];
          if (cp <= 65535) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 65536;
            s += String.fromCharCode(
              (cp >> 10) + 55296,
              (cp & 1023) + 56320
            );
          }
        }
        return s;
      }
      function isASCIIByte(a) {
        return 0 <= a && a <= 127;
      }
      var isASCIICodePoint = isASCIIByte;
      var end_of_stream = -1;
      function Stream(tokens) {
        this.tokens = [].slice.call(tokens);
        this.tokens.reverse();
      }
      Stream.prototype = {
        /**
         * @return {boolean} True if end-of-stream has been hit.
         */
        endOfStream: function() {
          return !this.tokens.length;
        },
        /**
         * When a token is read from a stream, the first token in the
         * stream must be returned and subsequently removed, and
         * end-of-stream must be returned otherwise.
         *
         * @return {number} Get the next token from the stream, or
         * end_of_stream.
         */
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.pop();
        },
        /**
         * When one or more tokens are prepended to a stream, those tokens
         * must be inserted, in given order, before the first token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The token(s) to prepend to the
         * stream.
         */
        prepend: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.push(tokens.pop());
          } else {
            this.tokens.push(token);
          }
        },
        /**
         * When one or more tokens are pushed to a stream, those tokens
         * must be inserted, in given order, after the last token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The tokens(s) to push to the
         * stream.
         */
        push: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.unshift(tokens.shift());
          } else {
            this.tokens.unshift(token);
          }
        }
      };
      var finished = -1;
      function decoderError(fatal, opt_code_point) {
        if (fatal)
          throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      function encoderError(code_point) {
        throw TypeError("The code point " + code_point + " could not be encoded.");
      }
      function Decoder() {
      }
      Decoder.prototype = {
        /**
         * @param {Stream} stream The stream of bytes being decoded.
         * @param {number} bite The next byte read from the stream.
         * @return {?(number|!Array.<number>)} The next code point(s)
         *     decoded, or null if not enough data exists in the input
         *     stream to decode a complete code point, or |finished|.
         */
        handler: function(stream, bite) {
        }
      };
      function Encoder() {
      }
      Encoder.prototype = {
        /**
         * @param {Stream} stream The stream of code points being encoded.
         * @param {number} code_point Next code point read from the stream.
         * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
         */
        handler: function(stream, code_point) {
        }
      };
      function getEncoding(label) {
        label = String(label).trim().toLowerCase();
        if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
          return label_to_encoding[label];
        }
        return null;
      }
      var encodings = [
        {
          "encodings": [
            {
              "labels": [
                "unicode-1-1-utf-8",
                "utf-8",
                "utf8"
              ],
              "name": "UTF-8"
            }
          ],
          "heading": "The Encoding"
        },
        {
          "encodings": [
            {
              "labels": [
                "866",
                "cp866",
                "csibm866",
                "ibm866"
              ],
              "name": "IBM866"
            },
            {
              "labels": [
                "csisolatin2",
                "iso-8859-2",
                "iso-ir-101",
                "iso8859-2",
                "iso88592",
                "iso_8859-2",
                "iso_8859-2:1987",
                "l2",
                "latin2"
              ],
              "name": "ISO-8859-2"
            },
            {
              "labels": [
                "csisolatin3",
                "iso-8859-3",
                "iso-ir-109",
                "iso8859-3",
                "iso88593",
                "iso_8859-3",
                "iso_8859-3:1988",
                "l3",
                "latin3"
              ],
              "name": "ISO-8859-3"
            },
            {
              "labels": [
                "csisolatin4",
                "iso-8859-4",
                "iso-ir-110",
                "iso8859-4",
                "iso88594",
                "iso_8859-4",
                "iso_8859-4:1988",
                "l4",
                "latin4"
              ],
              "name": "ISO-8859-4"
            },
            {
              "labels": [
                "csisolatincyrillic",
                "cyrillic",
                "iso-8859-5",
                "iso-ir-144",
                "iso8859-5",
                "iso88595",
                "iso_8859-5",
                "iso_8859-5:1988"
              ],
              "name": "ISO-8859-5"
            },
            {
              "labels": [
                "arabic",
                "asmo-708",
                "csiso88596e",
                "csiso88596i",
                "csisolatinarabic",
                "ecma-114",
                "iso-8859-6",
                "iso-8859-6-e",
                "iso-8859-6-i",
                "iso-ir-127",
                "iso8859-6",
                "iso88596",
                "iso_8859-6",
                "iso_8859-6:1987"
              ],
              "name": "ISO-8859-6"
            },
            {
              "labels": [
                "csisolatingreek",
                "ecma-118",
                "elot_928",
                "greek",
                "greek8",
                "iso-8859-7",
                "iso-ir-126",
                "iso8859-7",
                "iso88597",
                "iso_8859-7",
                "iso_8859-7:1987",
                "sun_eu_greek"
              ],
              "name": "ISO-8859-7"
            },
            {
              "labels": [
                "csiso88598e",
                "csisolatinhebrew",
                "hebrew",
                "iso-8859-8",
                "iso-8859-8-e",
                "iso-ir-138",
                "iso8859-8",
                "iso88598",
                "iso_8859-8",
                "iso_8859-8:1988",
                "visual"
              ],
              "name": "ISO-8859-8"
            },
            {
              "labels": [
                "csiso88598i",
                "iso-8859-8-i",
                "logical"
              ],
              "name": "ISO-8859-8-I"
            },
            {
              "labels": [
                "csisolatin6",
                "iso-8859-10",
                "iso-ir-157",
                "iso8859-10",
                "iso885910",
                "l6",
                "latin6"
              ],
              "name": "ISO-8859-10"
            },
            {
              "labels": [
                "iso-8859-13",
                "iso8859-13",
                "iso885913"
              ],
              "name": "ISO-8859-13"
            },
            {
              "labels": [
                "iso-8859-14",
                "iso8859-14",
                "iso885914"
              ],
              "name": "ISO-8859-14"
            },
            {
              "labels": [
                "csisolatin9",
                "iso-8859-15",
                "iso8859-15",
                "iso885915",
                "iso_8859-15",
                "l9"
              ],
              "name": "ISO-8859-15"
            },
            {
              "labels": [
                "iso-8859-16"
              ],
              "name": "ISO-8859-16"
            },
            {
              "labels": [
                "cskoi8r",
                "koi",
                "koi8",
                "koi8-r",
                "koi8_r"
              ],
              "name": "KOI8-R"
            },
            {
              "labels": [
                "koi8-ru",
                "koi8-u"
              ],
              "name": "KOI8-U"
            },
            {
              "labels": [
                "csmacintosh",
                "mac",
                "macintosh",
                "x-mac-roman"
              ],
              "name": "macintosh"
            },
            {
              "labels": [
                "dos-874",
                "iso-8859-11",
                "iso8859-11",
                "iso885911",
                "tis-620",
                "windows-874"
              ],
              "name": "windows-874"
            },
            {
              "labels": [
                "cp1250",
                "windows-1250",
                "x-cp1250"
              ],
              "name": "windows-1250"
            },
            {
              "labels": [
                "cp1251",
                "windows-1251",
                "x-cp1251"
              ],
              "name": "windows-1251"
            },
            {
              "labels": [
                "ansi_x3.4-1968",
                "ascii",
                "cp1252",
                "cp819",
                "csisolatin1",
                "ibm819",
                "iso-8859-1",
                "iso-ir-100",
                "iso8859-1",
                "iso88591",
                "iso_8859-1",
                "iso_8859-1:1987",
                "l1",
                "latin1",
                "us-ascii",
                "windows-1252",
                "x-cp1252"
              ],
              "name": "windows-1252"
            },
            {
              "labels": [
                "cp1253",
                "windows-1253",
                "x-cp1253"
              ],
              "name": "windows-1253"
            },
            {
              "labels": [
                "cp1254",
                "csisolatin5",
                "iso-8859-9",
                "iso-ir-148",
                "iso8859-9",
                "iso88599",
                "iso_8859-9",
                "iso_8859-9:1989",
                "l5",
                "latin5",
                "windows-1254",
                "x-cp1254"
              ],
              "name": "windows-1254"
            },
            {
              "labels": [
                "cp1255",
                "windows-1255",
                "x-cp1255"
              ],
              "name": "windows-1255"
            },
            {
              "labels": [
                "cp1256",
                "windows-1256",
                "x-cp1256"
              ],
              "name": "windows-1256"
            },
            {
              "labels": [
                "cp1257",
                "windows-1257",
                "x-cp1257"
              ],
              "name": "windows-1257"
            },
            {
              "labels": [
                "cp1258",
                "windows-1258",
                "x-cp1258"
              ],
              "name": "windows-1258"
            },
            {
              "labels": [
                "x-mac-cyrillic",
                "x-mac-ukrainian"
              ],
              "name": "x-mac-cyrillic"
            }
          ],
          "heading": "Legacy single-byte encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "chinese",
                "csgb2312",
                "csiso58gb231280",
                "gb2312",
                "gb_2312",
                "gb_2312-80",
                "gbk",
                "iso-ir-58",
                "x-gbk"
              ],
              "name": "GBK"
            },
            {
              "labels": [
                "gb18030"
              ],
              "name": "gb18030"
            }
          ],
          "heading": "Legacy multi-byte Chinese (simplified) encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "big5",
                "big5-hkscs",
                "cn-big5",
                "csbig5",
                "x-x-big5"
              ],
              "name": "Big5"
            }
          ],
          "heading": "Legacy multi-byte Chinese (traditional) encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "cseucpkdfmtjapanese",
                "euc-jp",
                "x-euc-jp"
              ],
              "name": "EUC-JP"
            },
            {
              "labels": [
                "csiso2022jp",
                "iso-2022-jp"
              ],
              "name": "ISO-2022-JP"
            },
            {
              "labels": [
                "csshiftjis",
                "ms932",
                "ms_kanji",
                "shift-jis",
                "shift_jis",
                "sjis",
                "windows-31j",
                "x-sjis"
              ],
              "name": "Shift_JIS"
            }
          ],
          "heading": "Legacy multi-byte Japanese encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "cseuckr",
                "csksc56011987",
                "euc-kr",
                "iso-ir-149",
                "korean",
                "ks_c_5601-1987",
                "ks_c_5601-1989",
                "ksc5601",
                "ksc_5601",
                "windows-949"
              ],
              "name": "EUC-KR"
            }
          ],
          "heading": "Legacy multi-byte Korean encodings"
        },
        {
          "encodings": [
            {
              "labels": [
                "csiso2022kr",
                "hz-gb-2312",
                "iso-2022-cn",
                "iso-2022-cn-ext",
                "iso-2022-kr"
              ],
              "name": "replacement"
            },
            {
              "labels": [
                "utf-16be"
              ],
              "name": "UTF-16BE"
            },
            {
              "labels": [
                "utf-16",
                "utf-16le"
              ],
              "name": "UTF-16LE"
            },
            {
              "labels": [
                "x-user-defined"
              ],
              "name": "x-user-defined"
            }
          ],
          "heading": "Legacy miscellaneous encodings"
        }
      ];
      var label_to_encoding = {};
      encodings.forEach(function(category) {
        category.encodings.forEach(function(encoding) {
          encoding.labels.forEach(function(label) {
            label_to_encoding[label] = encoding;
          });
        });
      });
      var encoders = {};
      var decoders = {};
      function indexCodePointFor(pointer, index2) {
        if (!index2) return null;
        return index2[pointer] || null;
      }
      function indexPointerFor(code_point, index2) {
        var pointer = index2.indexOf(code_point);
        return pointer === -1 ? null : pointer;
      }
      function index(name) {
        if (!("encoding-indexes" in global2)) {
          throw Error("Indexes missing. Did you forget to include encoding-indexes.js first?");
        }
        return global2["encoding-indexes"][name];
      }
      function indexGB18030RangesCodePointFor(pointer) {
        if (pointer > 39419 && pointer < 189e3 || pointer > 1237575)
          return null;
        if (pointer === 7457) return 59335;
        var offset = 0;
        var code_point_offset = 0;
        var idx = index("gb18030-ranges");
        var i;
        for (i = 0; i < idx.length; ++i) {
          var entry = idx[i];
          if (entry[0] <= pointer) {
            offset = entry[0];
            code_point_offset = entry[1];
          } else {
            break;
          }
        }
        return code_point_offset + pointer - offset;
      }
      function indexGB18030RangesPointerFor(code_point) {
        if (code_point === 59335) return 7457;
        var offset = 0;
        var pointer_offset = 0;
        var idx = index("gb18030-ranges");
        var i;
        for (i = 0; i < idx.length; ++i) {
          var entry = idx[i];
          if (entry[1] <= code_point) {
            offset = entry[1];
            pointer_offset = entry[0];
          } else {
            break;
          }
        }
        return pointer_offset + code_point - offset;
      }
      function indexShiftJISPointerFor(code_point) {
        shift_jis_index = shift_jis_index || index("jis0208").map(function(code_point2, pointer) {
          return inRange(pointer, 8272, 8835) ? null : code_point2;
        });
        var index_ = shift_jis_index;
        return index_.indexOf(code_point);
      }
      var shift_jis_index;
      function indexBig5PointerFor(code_point) {
        big5_index_no_hkscs = big5_index_no_hkscs || index("big5").map(function(code_point2, pointer) {
          return pointer < (161 - 129) * 157 ? null : code_point2;
        });
        var index_ = big5_index_no_hkscs;
        if (code_point === 9552 || code_point === 9566 || code_point === 9569 || code_point === 9578 || code_point === 21313 || code_point === 21317) {
          return index_.lastIndexOf(code_point);
        }
        return indexPointerFor(code_point, index_);
      }
      var big5_index_no_hkscs;
      var DEFAULT_ENCODING = "utf-8";
      function TextDecoder(label, options) {
        if (!(this instanceof TextDecoder))
          throw TypeError("Called as a function. Did you forget 'new'?");
        label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
        options = ToDictionary(options);
        this._encoding = null;
        this._decoder = null;
        this._ignoreBOM = false;
        this._BOMseen = false;
        this._error_mode = "replacement";
        this._do_not_flush = false;
        var encoding = getEncoding(label);
        if (encoding === null || encoding.name === "replacement")
          throw RangeError("Unknown encoding: " + label);
        if (!decoders[encoding.name]) {
          throw Error("Decoder not present. Did you forget to include encoding-indexes.js first?");
        }
        var dec = this;
        dec._encoding = encoding;
        if (Boolean(options["fatal"]))
          dec._error_mode = "fatal";
        if (Boolean(options["ignoreBOM"]))
          dec._ignoreBOM = true;
        if (!Object.defineProperty) {
          this.encoding = dec._encoding.name.toLowerCase();
          this.fatal = dec._error_mode === "fatal";
          this.ignoreBOM = dec._ignoreBOM;
        }
        return dec;
      }
      if (Object.defineProperty) {
        Object.defineProperty(TextDecoder.prototype, "encoding", {
          /** @this {TextDecoder} */
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        });
        Object.defineProperty(TextDecoder.prototype, "fatal", {
          /** @this {TextDecoder} */
          get: function() {
            return this._error_mode === "fatal";
          }
        });
        Object.defineProperty(TextDecoder.prototype, "ignoreBOM", {
          /** @this {TextDecoder} */
          get: function() {
            return this._ignoreBOM;
          }
        });
      }
      TextDecoder.prototype.decode = function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._do_not_flush) {
          this._decoder = decoders[this._encoding.name]({
            fatal: this._error_mode === "fatal"
          });
          this._BOMseen = false;
        }
        this._do_not_flush = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var output = [];
        var result2;
        while (true) {
          var token = input_stream.read();
          if (token === end_of_stream)
            break;
          result2 = this._decoder.handler(input_stream, token);
          if (result2 === finished)
            break;
          if (result2 !== null) {
            if (Array.isArray(result2))
              output.push.apply(
                output,
                /**@type {!Array.<number>}*/
                result2
              );
            else
              output.push(result2);
          }
        }
        if (!this._do_not_flush) {
          do {
            result2 = this._decoder.handler(input_stream, input_stream.read());
            if (result2 === finished)
              break;
            if (result2 === null)
              continue;
            if (Array.isArray(result2))
              output.push.apply(
                output,
                /**@type {!Array.<number>}*/
                result2
              );
            else
              output.push(result2);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        function serializeStream(stream) {
          if (includes(["UTF-8", "UTF-16LE", "UTF-16BE"], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {
            if (stream.length > 0 && stream[0] === 65279) {
              this._BOMseen = true;
              stream.shift();
            } else if (stream.length > 0) {
              this._BOMseen = true;
            } else {
            }
          }
          return codePointsToString(stream);
        }
        return serializeStream.call(this, output);
      };
      function TextEncoder(label, options) {
        if (!(this instanceof TextEncoder))
          throw TypeError("Called as a function. Did you forget 'new'?");
        options = ToDictionary(options);
        this._encoding = null;
        this._encoder = null;
        this._do_not_flush = false;
        this._fatal = Boolean(options["fatal"]) ? "fatal" : "replacement";
        var enc = this;
        if (Boolean(options["NONSTANDARD_allowLegacyEncoding"])) {
          label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
          var encoding = getEncoding(label);
          if (encoding === null || encoding.name === "replacement")
            throw RangeError("Unknown encoding: " + label);
          if (!encoders[encoding.name]) {
            throw Error("Encoder not present. Did you forget to include encoding-indexes.js first?");
          }
          enc._encoding = encoding;
        } else {
          enc._encoding = getEncoding("utf-8");
          if (label !== void 0 && "console" in global2) {
            console.warn("TextEncoder constructor called with encoding label, which is ignored.");
          }
        }
        if (!Object.defineProperty)
          this.encoding = enc._encoding.name.toLowerCase();
        return enc;
      }
      if (Object.defineProperty) {
        Object.defineProperty(TextEncoder.prototype, "encoding", {
          /** @this {TextEncoder} */
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        });
      }
      TextEncoder.prototype.encode = function encode(opt_string, options) {
        opt_string = opt_string === void 0 ? "" : String(opt_string);
        options = ToDictionary(options);
        if (!this._do_not_flush)
          this._encoder = encoders[this._encoding.name]({
            fatal: this._fatal === "fatal"
          });
        this._do_not_flush = Boolean(options["stream"]);
        var input = new Stream(stringToCodePoints(opt_string));
        var output = [];
        var result2;
        while (true) {
          var token = input.read();
          if (token === end_of_stream)
            break;
          result2 = this._encoder.handler(input, token);
          if (result2 === finished)
            break;
          if (Array.isArray(result2))
            output.push.apply(
              output,
              /**@type {!Array.<number>}*/
              result2
            );
          else
            output.push(result2);
        }
        if (!this._do_not_flush) {
          while (true) {
            result2 = this._encoder.handler(input, input.read());
            if (result2 === finished)
              break;
            if (Array.isArray(result2))
              output.push.apply(
                output,
                /**@type {!Array.<number>}*/
                result2
              );
            else
              output.push(result2);
          }
          this._encoder = null;
        }
        return new Uint8Array(output);
      };
      function UTF8Decoder(options) {
        var fatal = options.fatal;
        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream)
            return finished;
          if (utf8_bytes_needed === 0) {
            if (inRange(bite, 0, 127)) {
              return bite;
            } else if (inRange(bite, 194, 223)) {
              utf8_bytes_needed = 1;
              utf8_code_point = bite & 31;
            } else if (inRange(bite, 224, 239)) {
              if (bite === 224)
                utf8_lower_boundary = 160;
              if (bite === 237)
                utf8_upper_boundary = 159;
              utf8_bytes_needed = 2;
              utf8_code_point = bite & 15;
            } else if (inRange(bite, 240, 244)) {
              if (bite === 240)
                utf8_lower_boundary = 144;
              if (bite === 244)
                utf8_upper_boundary = 143;
              utf8_bytes_needed = 3;
              utf8_code_point = bite & 7;
            } else {
              return decoderError(fatal);
            }
            return null;
          }
          if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 128;
            utf8_upper_boundary = 191;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          utf8_code_point = utf8_code_point << 6 | bite & 63;
          utf8_bytes_seen += 1;
          if (utf8_bytes_seen !== utf8_bytes_needed)
            return null;
          var code_point = utf8_code_point;
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          return code_point;
        };
      }
      function UTF8Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point))
            return code_point;
          var count, offset;
          if (inRange(code_point, 128, 2047)) {
            count = 1;
            offset = 192;
          } else if (inRange(code_point, 2048, 65535)) {
            count = 2;
            offset = 224;
          } else if (inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset = 240;
          }
          var bytes = [(code_point >> 6 * count) + offset];
          while (count > 0) {
            var temp = code_point >> 6 * (count - 1);
            bytes.push(128 | temp & 63);
            count -= 1;
          }
          return bytes;
        };
      }
      encoders["UTF-8"] = function(options) {
        return new UTF8Encoder(options);
      };
      decoders["UTF-8"] = function(options) {
        return new UTF8Decoder(options);
      };
      function SingleByteDecoder(index2, options) {
        var fatal = options.fatal;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream)
            return finished;
          if (isASCIIByte(bite))
            return bite;
          var code_point = index2[bite - 128];
          if (code_point === null)
            return decoderError(fatal);
          return code_point;
        };
      }
      function SingleByteEncoder(index2, options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point))
            return code_point;
          var pointer = indexPointerFor(code_point, index2);
          if (pointer === null)
            encoderError(code_point);
          return pointer + 128;
        };
      }
      (function() {
        if (!("encoding-indexes" in global2))
          return;
        encodings.forEach(function(category) {
          if (category.heading !== "Legacy single-byte encodings")
            return;
          category.encodings.forEach(function(encoding) {
            var name = encoding.name;
            var idx = index(name.toLowerCase());
            decoders[name] = function(options) {
              return new SingleByteDecoder(idx, options);
            };
            encoders[name] = function(options) {
              return new SingleByteEncoder(idx, options);
            };
          });
        });
      })();
      decoders["GBK"] = function(options) {
        return new GB18030Decoder(options);
      };
      encoders["GBK"] = function(options) {
        return new GB18030Encoder(options, true);
      };
      function GB18030Decoder(options) {
        var fatal = options.fatal;
        var gb18030_first = 0, gb18030_second = 0, gb18030_third = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && gb18030_first === 0 && gb18030_second === 0 && gb18030_third === 0) {
            return finished;
          }
          if (bite === end_of_stream && (gb18030_first !== 0 || gb18030_second !== 0 || gb18030_third !== 0)) {
            gb18030_first = 0;
            gb18030_second = 0;
            gb18030_third = 0;
            decoderError(fatal);
          }
          var code_point;
          if (gb18030_third !== 0) {
            code_point = null;
            if (inRange(bite, 48, 57)) {
              code_point = indexGB18030RangesCodePointFor(
                (((gb18030_first - 129) * 10 + gb18030_second - 48) * 126 + gb18030_third - 129) * 10 + bite - 48
              );
            }
            var buffer = [gb18030_second, gb18030_third, bite];
            gb18030_first = 0;
            gb18030_second = 0;
            gb18030_third = 0;
            if (code_point === null) {
              stream.prepend(buffer);
              return decoderError(fatal);
            }
            return code_point;
          }
          if (gb18030_second !== 0) {
            if (inRange(bite, 129, 254)) {
              gb18030_third = bite;
              return null;
            }
            stream.prepend([gb18030_second, bite]);
            gb18030_first = 0;
            gb18030_second = 0;
            return decoderError(fatal);
          }
          if (gb18030_first !== 0) {
            if (inRange(bite, 48, 57)) {
              gb18030_second = bite;
              return null;
            }
            var lead = gb18030_first;
            var pointer = null;
            gb18030_first = 0;
            var offset = bite < 127 ? 64 : 65;
            if (inRange(bite, 64, 126) || inRange(bite, 128, 254))
              pointer = (lead - 129) * 190 + (bite - offset);
            code_point = pointer === null ? null : indexCodePointFor(pointer, index("gb18030"));
            if (code_point === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (bite === 128)
            return 8364;
          if (inRange(bite, 129, 254)) {
            gb18030_first = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function GB18030Encoder(options, gbk_flag) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point))
            return code_point;
          if (code_point === 58853)
            return encoderError(code_point);
          if (gbk_flag && code_point === 8364)
            return 128;
          var pointer = indexPointerFor(code_point, index("gb18030"));
          if (pointer !== null) {
            var lead = floor(pointer / 190) + 129;
            var trail = pointer % 190;
            var offset = trail < 63 ? 64 : 65;
            return [lead, trail + offset];
          }
          if (gbk_flag)
            return encoderError(code_point);
          pointer = indexGB18030RangesPointerFor(code_point);
          var byte1 = floor(pointer / 10 / 126 / 10);
          pointer = pointer - byte1 * 10 * 126 * 10;
          var byte2 = floor(pointer / 10 / 126);
          pointer = pointer - byte2 * 10 * 126;
          var byte3 = floor(pointer / 10);
          var byte4 = pointer - byte3 * 10;
          return [
            byte1 + 129,
            byte2 + 48,
            byte3 + 129,
            byte4 + 48
          ];
        };
      }
      encoders["gb18030"] = function(options) {
        return new GB18030Encoder(options);
      };
      decoders["gb18030"] = function(options) {
        return new GB18030Decoder(options);
      };
      function Big5Decoder(options) {
        var fatal = options.fatal;
        var Big5_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && Big5_lead !== 0) {
            Big5_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && Big5_lead === 0)
            return finished;
          if (Big5_lead !== 0) {
            var lead = Big5_lead;
            var pointer = null;
            Big5_lead = 0;
            var offset = bite < 127 ? 64 : 98;
            if (inRange(bite, 64, 126) || inRange(bite, 161, 254))
              pointer = (lead - 129) * 157 + (bite - offset);
            switch (pointer) {
              case 1133:
                return [202, 772];
              case 1135:
                return [202, 780];
              case 1164:
                return [234, 772];
              case 1166:
                return [234, 780];
            }
            var code_point = pointer === null ? null : indexCodePointFor(pointer, index("big5"));
            if (code_point === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (inRange(bite, 129, 254)) {
            Big5_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function Big5Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point))
            return code_point;
          var pointer = indexBig5PointerFor(code_point);
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor(pointer / 157) + 129;
          if (lead < 161)
            return encoderError(code_point);
          var trail = pointer % 157;
          var offset = trail < 63 ? 64 : 98;
          return [lead, trail + offset];
        };
      }
      encoders["Big5"] = function(options) {
        return new Big5Encoder(options);
      };
      decoders["Big5"] = function(options) {
        return new Big5Decoder(options);
      };
      function EUCJPDecoder(options) {
        var fatal = options.fatal;
        var eucjp_jis0212_flag = false, eucjp_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && eucjp_lead !== 0) {
            eucjp_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && eucjp_lead === 0)
            return finished;
          if (eucjp_lead === 142 && inRange(bite, 161, 223)) {
            eucjp_lead = 0;
            return 65377 - 161 + bite;
          }
          if (eucjp_lead === 143 && inRange(bite, 161, 254)) {
            eucjp_jis0212_flag = true;
            eucjp_lead = bite;
            return null;
          }
          if (eucjp_lead !== 0) {
            var lead = eucjp_lead;
            eucjp_lead = 0;
            var code_point = null;
            if (inRange(lead, 161, 254) && inRange(bite, 161, 254)) {
              code_point = indexCodePointFor(
                (lead - 161) * 94 + (bite - 161),
                index(!eucjp_jis0212_flag ? "jis0208" : "jis0212")
              );
            }
            eucjp_jis0212_flag = false;
            if (!inRange(bite, 161, 254))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (bite === 142 || bite === 143 || inRange(bite, 161, 254)) {
            eucjp_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function EUCJPEncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point))
            return code_point;
          if (code_point === 165)
            return 92;
          if (code_point === 8254)
            return 126;
          if (inRange(code_point, 65377, 65439))
            return [142, code_point - 65377 + 161];
          if (code_point === 8722)
            code_point = 65293;
          var pointer = indexPointerFor(code_point, index("jis0208"));
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor(pointer / 94) + 161;
          var trail = pointer % 94 + 161;
          return [lead, trail];
        };
      }
      encoders["EUC-JP"] = function(options) {
        return new EUCJPEncoder(options);
      };
      decoders["EUC-JP"] = function(options) {
        return new EUCJPDecoder(options);
      };
      function ISO2022JPDecoder(options) {
        var fatal = options.fatal;
        var states = {
          ASCII: 0,
          Roman: 1,
          Katakana: 2,
          LeadByte: 3,
          TrailByte: 4,
          EscapeStart: 5,
          Escape: 6
        };
        var iso2022jp_decoder_state = states.ASCII, iso2022jp_decoder_output_state = states.ASCII, iso2022jp_lead = 0, iso2022jp_output_flag = false;
        this.handler = function(stream, bite) {
          switch (iso2022jp_decoder_state) {
            default:
            case states.ASCII:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27) {
                iso2022jp_output_flag = false;
                return bite;
              }
              if (bite === end_of_stream) {
                return finished;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.Roman:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (bite === 92) {
                iso2022jp_output_flag = false;
                return 165;
              }
              if (bite === 126) {
                iso2022jp_output_flag = false;
                return 8254;
              }
              if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27 && bite !== 92 && bite !== 126) {
                iso2022jp_output_flag = false;
                return bite;
              }
              if (bite === end_of_stream) {
                return finished;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.Katakana:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (inRange(bite, 33, 95)) {
                iso2022jp_output_flag = false;
                return 65377 - 33 + bite;
              }
              if (bite === end_of_stream) {
                return finished;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.LeadByte:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return null;
              }
              if (inRange(bite, 33, 126)) {
                iso2022jp_output_flag = false;
                iso2022jp_lead = bite;
                iso2022jp_decoder_state = states.TrailByte;
                return null;
              }
              if (bite === end_of_stream) {
                return finished;
              }
              iso2022jp_output_flag = false;
              return decoderError(fatal);
            case states.TrailByte:
              if (bite === 27) {
                iso2022jp_decoder_state = states.EscapeStart;
                return decoderError(fatal);
              }
              if (inRange(bite, 33, 126)) {
                iso2022jp_decoder_state = states.LeadByte;
                var pointer = (iso2022jp_lead - 33) * 94 + bite - 33;
                var code_point = indexCodePointFor(pointer, index("jis0208"));
                if (code_point === null)
                  return decoderError(fatal);
                return code_point;
              }
              if (bite === end_of_stream) {
                iso2022jp_decoder_state = states.LeadByte;
                stream.prepend(bite);
                return decoderError(fatal);
              }
              iso2022jp_decoder_state = states.LeadByte;
              return decoderError(fatal);
            case states.EscapeStart:
              if (bite === 36 || bite === 40) {
                iso2022jp_lead = bite;
                iso2022jp_decoder_state = states.Escape;
                return null;
              }
              stream.prepend(bite);
              iso2022jp_output_flag = false;
              iso2022jp_decoder_state = iso2022jp_decoder_output_state;
              return decoderError(fatal);
            case states.Escape:
              var lead = iso2022jp_lead;
              iso2022jp_lead = 0;
              var state = null;
              if (lead === 40 && bite === 66)
                state = states.ASCII;
              if (lead === 40 && bite === 74)
                state = states.Roman;
              if (lead === 40 && bite === 73)
                state = states.Katakana;
              if (lead === 36 && (bite === 64 || bite === 66))
                state = states.LeadByte;
              if (state !== null) {
                iso2022jp_decoder_state = iso2022jp_decoder_state = state;
                var output_flag = iso2022jp_output_flag;
                iso2022jp_output_flag = true;
                return !output_flag ? null : decoderError(fatal);
              }
              stream.prepend([lead, bite]);
              iso2022jp_output_flag = false;
              iso2022jp_decoder_state = iso2022jp_decoder_output_state;
              return decoderError(fatal);
          }
        };
      }
      function ISO2022JPEncoder(options) {
        var fatal = options.fatal;
        var states = {
          ASCII: 0,
          Roman: 1,
          jis0208: 2
        };
        var iso2022jp_state = states.ASCII;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {
            stream.prepend(code_point);
            iso2022jp_state = states.ASCII;
            return [27, 40, 66];
          }
          if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
            return finished;
          if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 14 || code_point === 15 || code_point === 27)) {
            return encoderError(65533);
          }
          if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point))
            return code_point;
          if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 92 && code_point !== 126 || (code_point == 165 || code_point == 8254))) {
            if (isASCIICodePoint(code_point))
              return code_point;
            if (code_point === 165)
              return 92;
            if (code_point === 8254)
              return 126;
          }
          if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {
            stream.prepend(code_point);
            iso2022jp_state = states.ASCII;
            return [27, 40, 66];
          }
          if ((code_point === 165 || code_point === 8254) && iso2022jp_state !== states.Roman) {
            stream.prepend(code_point);
            iso2022jp_state = states.Roman;
            return [27, 40, 74];
          }
          if (code_point === 8722)
            code_point = 65293;
          var pointer = indexPointerFor(code_point, index("jis0208"));
          if (pointer === null)
            return encoderError(code_point);
          if (iso2022jp_state !== states.jis0208) {
            stream.prepend(code_point);
            iso2022jp_state = states.jis0208;
            return [27, 36, 66];
          }
          var lead = floor(pointer / 94) + 33;
          var trail = pointer % 94 + 33;
          return [lead, trail];
        };
      }
      encoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPEncoder(options);
      };
      decoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPDecoder(options);
      };
      function ShiftJISDecoder(options) {
        var fatal = options.fatal;
        var Shift_JIS_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && Shift_JIS_lead !== 0) {
            Shift_JIS_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && Shift_JIS_lead === 0)
            return finished;
          if (Shift_JIS_lead !== 0) {
            var lead = Shift_JIS_lead;
            var pointer = null;
            Shift_JIS_lead = 0;
            var offset = bite < 127 ? 64 : 65;
            var lead_offset = lead < 160 ? 129 : 193;
            if (inRange(bite, 64, 126) || inRange(bite, 128, 252))
              pointer = (lead - lead_offset) * 188 + bite - offset;
            if (inRange(pointer, 8836, 10715))
              return 57344 - 8836 + pointer;
            var code_point = pointer === null ? null : indexCodePointFor(pointer, index("jis0208"));
            if (code_point === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite) || bite === 128)
            return bite;
          if (inRange(bite, 161, 223))
            return 65377 - 161 + bite;
          if (inRange(bite, 129, 159) || inRange(bite, 224, 252)) {
            Shift_JIS_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function ShiftJISEncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point) || code_point === 128)
            return code_point;
          if (code_point === 165)
            return 92;
          if (code_point === 8254)
            return 126;
          if (inRange(code_point, 65377, 65439))
            return code_point - 65377 + 161;
          if (code_point === 8722)
            code_point = 65293;
          var pointer = indexShiftJISPointerFor(code_point);
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor(pointer / 188);
          var lead_offset = lead < 31 ? 129 : 193;
          var trail = pointer % 188;
          var offset = trail < 63 ? 64 : 65;
          return [lead + lead_offset, trail + offset];
        };
      }
      encoders["Shift_JIS"] = function(options) {
        return new ShiftJISEncoder(options);
      };
      decoders["Shift_JIS"] = function(options) {
        return new ShiftJISDecoder(options);
      };
      function EUCKRDecoder(options) {
        var fatal = options.fatal;
        var euckr_lead = 0;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && euckr_lead !== 0) {
            euckr_lead = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream && euckr_lead === 0)
            return finished;
          if (euckr_lead !== 0) {
            var lead = euckr_lead;
            var pointer = null;
            euckr_lead = 0;
            if (inRange(bite, 65, 254))
              pointer = (lead - 129) * 190 + (bite - 65);
            var code_point = pointer === null ? null : indexCodePointFor(pointer, index("euc-kr"));
            if (pointer === null && isASCIIByte(bite))
              stream.prepend(bite);
            if (code_point === null)
              return decoderError(fatal);
            return code_point;
          }
          if (isASCIIByte(bite))
            return bite;
          if (inRange(bite, 129, 254)) {
            euckr_lead = bite;
            return null;
          }
          return decoderError(fatal);
        };
      }
      function EUCKREncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point))
            return code_point;
          var pointer = indexPointerFor(code_point, index("euc-kr"));
          if (pointer === null)
            return encoderError(code_point);
          var lead = floor(pointer / 190) + 129;
          var trail = pointer % 190 + 65;
          return [lead, trail];
        };
      }
      encoders["EUC-KR"] = function(options) {
        return new EUCKREncoder(options);
      };
      decoders["EUC-KR"] = function(options) {
        return new EUCKRDecoder(options);
      };
      function convertCodeUnitToBytes(code_unit, utf16be) {
        var byte1 = code_unit >> 8;
        var byte2 = code_unit & 255;
        if (utf16be)
          return [byte1, byte2];
        return [byte2, byte1];
      }
      function UTF16Decoder(utf16_be, options) {
        var fatal = options.fatal;
        var utf16_lead_byte = null, utf16_lead_surrogate = null;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
            return decoderError(fatal);
          }
          if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
            return finished;
          }
          if (utf16_lead_byte === null) {
            utf16_lead_byte = bite;
            return null;
          }
          var code_unit;
          if (utf16_be) {
            code_unit = (utf16_lead_byte << 8) + bite;
          } else {
            code_unit = (bite << 8) + utf16_lead_byte;
          }
          utf16_lead_byte = null;
          if (utf16_lead_surrogate !== null) {
            var lead_surrogate = utf16_lead_surrogate;
            utf16_lead_surrogate = null;
            if (inRange(code_unit, 56320, 57343)) {
              return 65536 + (lead_surrogate - 55296) * 1024 + (code_unit - 56320);
            }
            stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
            return decoderError(fatal);
          }
          if (inRange(code_unit, 55296, 56319)) {
            utf16_lead_surrogate = code_unit;
            return null;
          }
          if (inRange(code_unit, 56320, 57343))
            return decoderError(fatal);
          return code_unit;
        };
      }
      function UTF16Encoder(utf16_be, options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (inRange(code_point, 0, 65535))
            return convertCodeUnitToBytes(code_point, utf16_be);
          var lead = convertCodeUnitToBytes(
            (code_point - 65536 >> 10) + 55296,
            utf16_be
          );
          var trail = convertCodeUnitToBytes(
            (code_point - 65536 & 1023) + 56320,
            utf16_be
          );
          return lead.concat(trail);
        };
      }
      encoders["UTF-16BE"] = function(options) {
        return new UTF16Encoder(true, options);
      };
      decoders["UTF-16BE"] = function(options) {
        return new UTF16Decoder(true, options);
      };
      encoders["UTF-16LE"] = function(options) {
        return new UTF16Encoder(false, options);
      };
      decoders["UTF-16LE"] = function(options) {
        return new UTF16Decoder(false, options);
      };
      function XUserDefinedDecoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream)
            return finished;
          if (isASCIIByte(bite))
            return bite;
          return 63360 + bite - 128;
        };
      }
      function XUserDefinedEncoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (isASCIICodePoint(code_point))
            return code_point;
          if (inRange(code_point, 63360, 63487))
            return code_point - 63360 + 128;
          return encoderError(code_point);
        };
      }
      encoders["x-user-defined"] = function(options) {
        return new XUserDefinedEncoder(options);
      };
      decoders["x-user-defined"] = function(options) {
        return new XUserDefinedDecoder(options);
      };
      if (!global2["TextEncoder"])
        global2["TextEncoder"] = TextEncoder;
      if (!global2["TextDecoder"])
        global2["TextDecoder"] = TextDecoder;
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = {
          TextEncoder: global2["TextEncoder"],
          TextDecoder: global2["TextDecoder"],
          EncodingIndexes: global2["encoding-indexes"]
        };
      }
    })(exports2 || {});
  }
});

// node_modules/text-encoding/index.js
var require_text_encoding = __commonJS({
  "node_modules/text-encoding/index.js"(exports2, module2) {
    var encoding = require_encoding();
    module2.exports = {
      TextEncoder: encoding.TextEncoder,
      TextDecoder: encoding.TextDecoder
    };
  }
});

// node_modules/stream-source/read.js
var require_read = __commonJS({
  "node_modules/stream-source/read.js"(exports2, module2) {
    module2.exports = function() {
      var that = this;
      return new Promise(function read(resolve, reject) {
        var buffer = that._stream.read();
        if (buffer != null) return resolve({ done: false, value: buffer });
        that._readable.then(function(done) {
          return done ? resolve({ done: true, value: void 0 }) : read(resolve, reject);
        }).catch(reject);
      });
    };
  }
});

// node_modules/stream-source/slice.js
var require_slice = __commonJS({
  "node_modules/stream-source/slice.js"(exports2, module2) {
    module2.exports = function(length) {
      if ((length |= 0) < 0) throw new Error("invalid length");
      var that = this;
      return new Promise(function slice(resolve, reject) {
        if (length === 0) return resolve(that._stream.destroyed ? null : new Buffer(0));
        var buffer = that._stream.read(length);
        if (buffer != null) return resolve(buffer);
        that._readable.then(function(done) {
          return done ? resolve(null) : slice(resolve, reject);
        }).catch(reject);
      });
    };
  }
});

// node_modules/stream-source/cancel.js
var require_cancel = __commonJS({
  "node_modules/stream-source/cancel.js"(exports2, module2) {
    module2.exports = function() {
      var stream = this._stream;
      return new Promise(function(resolve) {
        if (stream.destroyed) return resolve();
        stream.once("close", resolve).destroy();
      });
    };
  }
});

// node_modules/stream-source/index.node.js
var require_index_node = __commonJS({
  "node_modules/stream-source/index.node.js"(exports2, module2) {
    module2.exports = function(stream) {
      return new StreamSource(stream);
    };
    function StreamSource(stream) {
      var that = this;
      that._readable = promise(that);
      that._stream = stream.on("readable", read).on("end", end).on("close", end).on("error", error);
      function read() {
        var resolve = that._resolve;
        that._readable = promise(that);
        resolve(false);
      }
      function end() {
        var resolve = that._resolve;
        that._readable = Promise.resolve(true);
        that._resolve = that._reject = noop;
        resolve(true);
      }
      function error(error2) {
        var reject = that._reject;
        that._readable = Promise.reject(error2);
        that._resolve = that._reject = noop;
        reject(error2);
      }
    }
    StreamSource.prototype.read = require_read();
    StreamSource.prototype.slice = require_slice();
    StreamSource.prototype.cancel = require_cancel();
    function noop() {
    }
    function promise(source) {
      return new Promise(function(resolve, reject) {
        source._resolve = resolve;
        source._reject = reject;
      });
    }
  }
});

// node_modules/file-source/index.js
var require_file_source = __commonJS({
  "node_modules/file-source/index.js"(exports2, module2) {
    var fs = require("fs");
    var stream = require_index_node();
    module2.exports = function(path, options) {
      var highWaterMark = 65536;
      if (options && options.highWaterMark != null) highWaterMark = options.highWaterMark;
      return new Promise(function(resolve, reject) {
        var f = fs.createReadStream(path, { highWaterMark });
        f.once("open", function() {
          resolve(stream(f));
        });
        f.once("error", reject);
      });
    };
  }
});

// node_modules/path-source/index.node.js
var require_index_node2 = __commonJS({
  "node_modules/path-source/index.node.js"(exports2, module2) {
    module2.exports = require_file_source();
  }
});

// node_modules/array-source/dist/array-source.js
var require_array_source = __commonJS({
  "node_modules/array-source/dist/array-source.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2.sources = global2.sources || {}, global2.sources.array = factory());
    })(exports2, function() {
      "use strict";
      var array_cancel = function() {
        this._array = null;
        return Promise.resolve();
      };
      var array_read = function() {
        var array2 = this._array;
        this._array = null;
        return Promise.resolve(array2 ? { done: false, value: array2 } : { done: true, value: void 0 });
      };
      function array(array2) {
        return new ArraySource(array2 instanceof Uint8Array ? array2 : new Uint8Array(array2));
      }
      function ArraySource(array2) {
        this._array = array2;
      }
      ArraySource.prototype.read = array_read;
      ArraySource.prototype.cancel = array_cancel;
      return array;
    });
  }
});

// node_modules/slice-source/dist/slice-source.js
var require_slice_source = __commonJS({
  "node_modules/slice-source/dist/slice-source.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2.sources = global2.sources || {}, global2.sources.slice = factory());
    })(exports2, function() {
      "use strict";
      var empty = new Uint8Array(0);
      function slice_cancel() {
        return this._source.cancel();
      }
      function concat(a, b) {
        if (!a.length) return b;
        if (!b.length) return a;
        var c = new Uint8Array(a.length + b.length);
        c.set(a);
        c.set(b, a.length);
        return c;
      }
      function slice_read() {
        var that = this, array = that._array.subarray(that._index);
        return that._source.read().then(function(result2) {
          that._array = empty;
          that._index = 0;
          return result2.done ? array.length > 0 ? { done: false, value: array } : { done: true, value: void 0 } : { done: false, value: concat(array, result2.value) };
        });
      }
      function slice_slice(length) {
        if ((length |= 0) < 0) throw new Error("invalid length");
        var that = this, index = this._array.length - this._index;
        if (this._index + length <= this._array.length) {
          return Promise.resolve(this._array.subarray(this._index, this._index += length));
        }
        var array = new Uint8Array(length);
        array.set(this._array.subarray(this._index));
        return function read() {
          return that._source.read().then(function(result2) {
            if (result2.done) {
              that._array = empty;
              that._index = 0;
              return index > 0 ? array.subarray(0, index) : null;
            }
            if (index + result2.value.length >= length) {
              that._array = result2.value;
              that._index = length - index;
              array.set(result2.value.subarray(0, length - index), index);
              return array;
            }
            array.set(result2.value, index);
            index += result2.value.length;
            return read();
          });
        }();
      }
      function slice(source) {
        return typeof source.slice === "function" ? source : new SliceSource(typeof source.read === "function" ? source : source.getReader());
      }
      function SliceSource(source) {
        this._source = source;
        this._array = empty;
        this._index = 0;
      }
      SliceSource.prototype.read = slice_read;
      SliceSource.prototype.slice = slice_slice;
      SliceSource.prototype.cancel = slice_cancel;
      return slice;
    });
  }
});

// node_modules/shapefile/dist/shapefile.node.js
var require_shapefile_node = __commonJS({
  "node_modules/shapefile/dist/shapefile.node.js"(exports2) {
    "use strict";
    var TextDecoder = require_text_encoding().TextDecoder;
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var path = _interopDefault(require_index_node2());
    var array = _interopDefault(require_array_source());
    var stream = _interopDefault(require_index_node());
    var slice = _interopDefault(require_slice_source());
    var dbf_cancel = function() {
      return this._source.cancel();
    };
    var readBoolean = function(value) {
      return /^[nf]$/i.test(value) ? false : /^[yt]$/i.test(value) ? true : null;
    };
    var readDate = function(value) {
      return new Date(+value.substring(0, 4), value.substring(4, 6) - 1, +value.substring(6, 8));
    };
    var readNumber = function(value) {
      return !(value = value.trim()) || isNaN(value = +value) ? null : value;
    };
    var readString = function(value) {
      return value.trim() || null;
    };
    var types = {
      B: readNumber,
      C: readString,
      D: readDate,
      F: readNumber,
      L: readBoolean,
      M: readNumber,
      N: readNumber
    };
    var dbf_read = function() {
      var that = this, i = 1;
      return that._source.slice(that._recordLength).then(function(value) {
        return value && value[0] !== 26 ? { done: false, value: that._fields.reduce(function(p, f) {
          p[f.name] = types[f.type](that._decode(value.subarray(i, i += f.length)));
          return p;
        }, {}) } : { done: true, value: void 0 };
      });
    };
    var view = function(array$$1) {
      return new DataView(array$$1.buffer, array$$1.byteOffset, array$$1.byteLength);
    };
    var dbf = function(source, decoder) {
      source = slice(source);
      return source.slice(32).then(function(array$$1) {
        var head = view(array$$1);
        return source.slice(head.getUint16(8, true) - 32).then(function(array$$12) {
          return new Dbf(source, decoder, head, view(array$$12));
        });
      });
    };
    function Dbf(source, decoder, head, body) {
      this._source = source;
      this._decode = decoder.decode.bind(decoder);
      this._recordLength = head.getUint16(10, true);
      this._fields = [];
      for (var n = 0; body.getUint8(n) !== 13; n += 32) {
        for (var j = 0; j < 11; ++j) if (body.getUint8(n + j) === 0) break;
        this._fields.push({
          name: this._decode(new Uint8Array(body.buffer, body.byteOffset + n, j)),
          type: String.fromCharCode(body.getUint8(n + 11)),
          length: body.getUint8(n + 16)
        });
      }
    }
    var prototype = Dbf.prototype;
    prototype.read = dbf_read;
    prototype.cancel = dbf_cancel;
    function cancel() {
      return this._source.cancel();
    }
    var parseMultiPoint = function(record) {
      var i = 40, j, n = record.getInt32(36, true), coordinates = new Array(n);
      for (j = 0; j < n; ++j, i += 16) coordinates[j] = [record.getFloat64(i, true), record.getFloat64(i + 8, true)];
      return { type: "MultiPoint", coordinates };
    };
    var parseNull = function() {
      return null;
    };
    var parsePoint = function(record) {
      return { type: "Point", coordinates: [record.getFloat64(4, true), record.getFloat64(12, true)] };
    };
    var parsePolygon = function(record) {
      var i = 44, j, n = record.getInt32(36, true), m = record.getInt32(40, true), parts = new Array(n), points = new Array(m), polygons = [], holes = [];
      for (j = 0; j < n; ++j, i += 4) parts[j] = record.getInt32(i, true);
      for (j = 0; j < m; ++j, i += 16) points[j] = [record.getFloat64(i, true), record.getFloat64(i + 8, true)];
      parts.forEach(function(i2, j2) {
        var ring = points.slice(i2, parts[j2 + 1]);
        if (ringClockwise(ring)) polygons.push([ring]);
        else holes.push(ring);
      });
      holes.forEach(function(hole) {
        polygons.some(function(polygon) {
          if (ringContainsSome(polygon[0], hole)) {
            polygon.push(hole);
            return true;
          }
        }) || polygons.push([hole]);
      });
      return polygons.length === 1 ? { type: "Polygon", coordinates: polygons[0] } : { type: "MultiPolygon", coordinates: polygons };
    };
    function ringClockwise(ring) {
      if ((n = ring.length) < 4) return false;
      var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area >= 0;
    }
    function ringContainsSome(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) {
        if (c = ringContains(ring, hole[i])) {
          return c > 0;
        }
      }
      return false;
    }
    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) {
          return 0;
        }
        if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
          contains = -contains;
        }
      }
      return contains;
    }
    function segmentContains(p0, p1, p2) {
      var x20 = p2[0] - p0[0], y20 = p2[1] - p0[1];
      if (x20 === 0 && y20 === 0) return true;
      var x10 = p1[0] - p0[0], y10 = p1[1] - p0[1];
      if (x10 === 0 && y10 === 0) return false;
      var t = (x20 * x10 + y20 * y10) / (x10 * x10 + y10 * y10);
      return t < 0 || t > 1 ? false : t === 0 || t === 1 ? true : t * x10 === x20 && t * y10 === y20;
    }
    var parsePolyLine = function(record) {
      var i = 44, j, n = record.getInt32(36, true), m = record.getInt32(40, true), parts = new Array(n), points = new Array(m);
      for (j = 0; j < n; ++j, i += 4) parts[j] = record.getInt32(i, true);
      for (j = 0; j < m; ++j, i += 16) points[j] = [record.getFloat64(i, true), record.getFloat64(i + 8, true)];
      return n === 1 ? { type: "LineString", coordinates: points } : { type: "MultiLineString", coordinates: parts.map(function(i2, j2) {
        return points.slice(i2, parts[j2 + 1]);
      }) };
    };
    var concat = function(a, b) {
      var ab = new Uint8Array(a.length + b.length);
      ab.set(a, 0);
      ab.set(b, a.length);
      return ab;
    };
    var shp_read = function() {
      var that = this;
      ++that._index;
      return that._source.slice(12).then(function(array$$1) {
        if (array$$1 == null) return { done: true, value: void 0 };
        var header = view(array$$1);
        function skip() {
          return that._source.slice(4).then(function(chunk) {
            if (chunk == null) return { done: true, value: void 0 };
            header = view(array$$1 = concat(array$$1.slice(4), chunk));
            return header.getInt32(0, false) !== that._index ? skip() : read2();
          });
        }
        function read2() {
          var length = header.getInt32(4, false) * 2 - 4, type = header.getInt32(8, true);
          return length < 0 || type && type !== that._type ? skip() : that._source.slice(length).then(function(chunk) {
            return { done: false, value: type ? that._parse(view(concat(array$$1.slice(8), chunk))) : null };
          });
        }
        return read2();
      });
    };
    var parsers = {
      0: parseNull,
      1: parsePoint,
      3: parsePolyLine,
      5: parsePolygon,
      8: parseMultiPoint,
      11: parsePoint,
      // PointZ
      13: parsePolyLine,
      // PolyLineZ
      15: parsePolygon,
      // PolygonZ
      18: parseMultiPoint,
      // MultiPointZ
      21: parsePoint,
      // PointM
      23: parsePolyLine,
      // PolyLineM
      25: parsePolygon,
      // PolygonM
      28: parseMultiPoint
      // MultiPointM
    };
    var shp = function(source) {
      source = slice(source);
      return source.slice(100).then(function(array$$1) {
        return new Shp(source, view(array$$1));
      });
    };
    function Shp(source, header) {
      var type = header.getInt32(32, true);
      if (!(type in parsers)) throw new Error("unsupported shape type: " + type);
      this._source = source;
      this._type = type;
      this._index = 0;
      this._parse = parsers[type];
      this.bbox = [header.getFloat64(36, true), header.getFloat64(44, true), header.getFloat64(52, true), header.getFloat64(60, true)];
    }
    var prototype$2 = Shp.prototype;
    prototype$2.read = shp_read;
    prototype$2.cancel = cancel;
    function noop() {
    }
    var shapefile_cancel = function() {
      return Promise.all([
        this._dbf && this._dbf.cancel(),
        this._shp.cancel()
      ]).then(noop);
    };
    var shapefile_read = function() {
      var that = this;
      return Promise.all([
        that._dbf ? that._dbf.read() : { value: {} },
        that._shp.read()
      ]).then(function(results) {
        var dbf2 = results[0], shp2 = results[1];
        return shp2.done ? shp2 : {
          done: false,
          value: {
            type: "Feature",
            properties: dbf2.value,
            geometry: shp2.value
          }
        };
      });
    };
    var shapefile = function(shpSource, dbfSource, decoder) {
      return Promise.all([
        shp(shpSource),
        dbfSource && dbf(dbfSource, decoder)
      ]).then(function(sources) {
        return new Shapefile(sources[0], sources[1]);
      });
    };
    function Shapefile(shp$$1, dbf$$1) {
      this._shp = shp$$1;
      this._dbf = dbf$$1;
      this.bbox = shp$$1.bbox;
    }
    var prototype$1 = Shapefile.prototype;
    prototype$1.read = shapefile_read;
    prototype$1.cancel = shapefile_cancel;
    function open(shp$$1, dbf$$1, options) {
      if (typeof dbf$$1 === "string") {
        if (!/\.dbf$/.test(dbf$$1)) dbf$$1 += ".dbf";
        dbf$$1 = path(dbf$$1, options);
      } else if (dbf$$1 instanceof ArrayBuffer || dbf$$1 instanceof Uint8Array) {
        dbf$$1 = array(dbf$$1);
      } else if (dbf$$1 != null) {
        dbf$$1 = stream(dbf$$1);
      }
      if (typeof shp$$1 === "string") {
        if (!/\.shp$/.test(shp$$1)) shp$$1 += ".shp";
        if (dbf$$1 === void 0) dbf$$1 = path(shp$$1.substring(0, shp$$1.length - 4) + ".dbf", options).catch(function() {
        });
        shp$$1 = path(shp$$1, options);
      } else if (shp$$1 instanceof ArrayBuffer || shp$$1 instanceof Uint8Array) {
        shp$$1 = array(shp$$1);
      } else {
        shp$$1 = stream(shp$$1);
      }
      return Promise.all([shp$$1, dbf$$1]).then(function(sources) {
        var shp$$12 = sources[0], dbf$$12 = sources[1], encoding = "windows-1252";
        if (options && options.encoding != null) encoding = options.encoding;
        return shapefile(shp$$12, dbf$$12, dbf$$12 && new TextDecoder(encoding));
      });
    }
    function openShp(source, options) {
      if (typeof source === "string") {
        if (!/\.shp$/.test(source)) source += ".shp";
        source = path(source, options);
      } else if (source instanceof ArrayBuffer || source instanceof Uint8Array) {
        source = array(source);
      } else {
        source = stream(source);
      }
      return Promise.resolve(source).then(shp);
    }
    function openDbf(source, options) {
      var encoding = "windows-1252";
      if (options && options.encoding != null) encoding = options.encoding;
      encoding = new TextDecoder(encoding);
      if (typeof source === "string") {
        if (!/\.dbf$/.test(source)) source += ".dbf";
        source = path(source, options);
      } else if (source instanceof ArrayBuffer || source instanceof Uint8Array) {
        source = array(source);
      } else {
        source = stream(source);
      }
      return Promise.resolve(source).then(function(source2) {
        return dbf(source2, encoding);
      });
    }
    function read(shp$$1, dbf$$1, options) {
      return open(shp$$1, dbf$$1, options).then(function(source) {
        var features = [], collection = { type: "FeatureCollection", features, bbox: source.bbox };
        return source.read().then(function read2(result2) {
          if (result2.done) return collection;
          features.push(result2.value);
          return source.read().then(read2);
        });
      });
    }
    exports2.open = open;
    exports2.openShp = openShp;
    exports2.openDbf = openDbf;
    exports2.read = read;
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (!fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (!fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = /* @__PURE__ */ function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            });
          };
        }(fs.rename);
      }
      fs.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs2.fchmod(fd, mode, function(err2) {
                fs2.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readdir(path, options, cb);
        function go$readdir(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readdir, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          });
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function") fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => err != null ? reject(err) : resolve(res)
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function") return fn.apply(this, args);
        else fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils3 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify2(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content)) content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify: stringify2, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify: stringify2, stripBom } = require_utils3();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify2(obj, options);
      await universalify.fromCallback(fs.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify2(obj, options);
      return fs.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/@lykmapipo/geo-tools/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/@lykmapipo/geo-tools/lib/index.js"(exports2) {
    "use strict";
    var env = require_lib7();
    var lodash = require_lodash();
    var async = require_async2();
    var common = require_lib5();
    var geojsonValidation = require_geojson_validation();
    var turf = require_js107();
    var fs = require("fs");
    var stream = require("stream");
    var parseCsv = require_lib10();
    var geojsonStream = require_geojson_stream();
    var shapefile = require_shapefile_node();
    var jsonfile = require_jsonfile();
    var GEO_POINT = "Point";
    var GEO_LINESTRING = "LineString";
    var GEO_POLYGON = "Polygon";
    var GEO_MULTIPOINT = "MultiPoint";
    var GEO_MULTILINESTRING = "MultiLineString";
    var GEO_MULTIPOLYGON = "MultiPolygon";
    var GEO_GEOMETRY_COLLECTION = "GeometryCollection";
    var GEO_FEATURE = "Feature";
    var GEO_FEATURE_COLLECTION = "FeatureCollection";
    var GEO_MAX_LENGTH = env.getNumber("GEO_MAX_LENGTH", 1e-4);
    var GEO_MAX_ROTATION = env.getNumber("GEO_MAX_ROTATION", Math.PI / 8);
    var GEO_BBOX = env.getNumbers("GEO_BBOX", [-180, -90, 180, 90], {
      merge: false
    });
    var composeError = (errors = []) => {
      const status = 400;
      const code = 400;
      const message = "Validation failed";
      const name = "ValidationError";
      const error = common.normalizeError(
        common.assign(new Error(message), {
          name,
          status,
          code,
          message
        })
      );
      error.errors = [...errors];
      return error;
    };
    var withCallback = (cb) => (messages) => {
      const isValid2 = lodash.isEmpty(messages);
      if (lodash.isFunction(cb)) {
        return cb(composeError(messages), isValid2);
      }
      return isValid2;
    };
    var isValid = (geojson, cb) => {
      const result2 = geojsonValidation.valid(geojson, true);
      return withCallback(cb)(result2);
    };
    var isPoint = (geojson, cb) => {
      const result2 = geojsonValidation.isPoint(geojson, true);
      return withCallback(cb)(result2);
    };
    var isMultiPoint = (geojson, cb) => {
      const result2 = geojsonValidation.isMultiPoint(geojson, true);
      return withCallback(cb)(result2);
    };
    var isLineString = (geojson, cb) => {
      const result2 = geojsonValidation.isLineString(geojson, true);
      return withCallback(cb)(result2);
    };
    var isMultiLineString = (geojson, cb) => {
      const result2 = geojsonValidation.isMultiLineString(geojson, true);
      return withCallback(cb)(result2);
    };
    var isPolygon = (geojson, cb) => {
      const result2 = geojsonValidation.isPolygon(geojson, true);
      return withCallback(cb)(result2);
    };
    var isMultiPolygon = (geojson, cb) => {
      const result2 = geojsonValidation.isMultiPolygon(geojson, true);
      return withCallback(cb)(result2);
    };
    var isGeometryCollection = (geojson, cb) => {
      const result2 = geojsonValidation.isGeometryCollection(geojson, true);
      return withCallback(cb)(result2);
    };
    var isFeature = (geojson, cb) => {
      const result2 = geojsonValidation.isFeature(geojson, true);
      return withCallback(cb)(result2);
    };
    var isFeatureCollection = (geojson, cb) => {
      const result2 = geojsonValidation.isFeatureCollection(geojson, true);
      return withCallback(cb)(result2);
    };
    var isGeometry = (geojson, cb) => {
      if (lodash.isFunction(cb)) {
        const checkIfIsGeometry = lodash.map(
          [
            isValid,
            isPoint,
            isMultiPoint,
            isLineString,
            isMultiLineString,
            isPolygon,
            isMultiPolygon,
            isGeometryCollection
          ],
          (validator) => {
            return (next) => validator(geojson, next);
          }
        );
        return async.parallel(checkIfIsGeometry, cb);
      }
      return isPoint(geojson) || isMultiPoint(geojson) || isLineString(geojson) || isMultiLineString(geojson) || isPolygon(geojson) || isMultiPolygon(geojson) || isGeometryCollection(geojson);
    };
    var centroidOf = (geojson) => {
      try {
        let centroid = turf.centroid(geojson);
        if (centroid && centroid.geometry) {
          centroid = centroid.geometry;
        }
        return centroid;
      } catch (error) {
        return void 0;
      }
    };
    var parseCoordinateString = (coords = "", optns) => {
      const { deliminator = ",", separator = " " } = common.mergeObjects(optns);
      try {
        const pairs = lodash.compact(lodash.split(coords, separator));
        const points = lodash.map(pairs, (pair) => {
          return lodash.map(lodash.split(pair, deliminator), lodash.toNumber);
        });
        if (lodash.size(points) === 1 && geojsonValidation.isPosition(lodash.first(points))) {
          const { geometry } = turf.point(lodash.first(points));
          return geometry;
        }
        if (lodash.size(points) === 2 && geojsonValidation.isPosition(lodash.first(points))) {
          const center = lodash.first(points);
          const radius = lodash.first(lodash.nth(points, 1));
          const { geometry } = radius === 0 ? turf.point(center) : turf.circle(center, radius);
          return geometry;
        }
        if (geojsonValidation.isPolygonCoor([points])) {
          const { geometry } = turf.polygon([points]);
          return geometry;
        }
        return points;
      } catch (error) {
        return void 0;
      }
    };
    var randomLongitude = (optns = {}) => {
      const { bbox = GEO_BBOX } = optns;
      const longitude = Math.random() * (bbox[2] - bbox[0]) + bbox[0];
      return longitude;
    };
    var randomLatitude = (optns = {}) => {
      const { bbox = GEO_BBOX } = optns;
      const latitude = Math.random() * (bbox[3] - bbox[1]) + bbox[1];
      return latitude;
    };
    var randomPosition = (optns = {}) => {
      const angle = (optns.angle || Math.random() * 2 * Math.PI) + (Math.random() - 0.5) * GEO_MAX_ROTATION * 2;
      const distance = optns.distance || Math.random() * GEO_MAX_LENGTH;
      const x1 = optns.longitude || randomLongitude(optns);
      const x2 = x1 + distance * Math.cos(angle);
      const y1 = optns.latitude || randomLatitude(optns);
      const y2 = y1 + distance * Math.sin(angle);
      return [x2, y2];
    };
    var randomPositions = (optns = { vertices: 2 }) => {
      const options = common.mergeObjects({ vertices: 2, bbox: GEO_BBOX }, optns);
      let coordinates = [];
      let longitude;
      let latitude;
      lodash.forEach(lodash.range(options.vertices), () => {
        const position = randomPosition(
          common.mergeObjects(options, { longitude, latitude })
        );
        [longitude, latitude] = position;
        coordinates = [...coordinates, position];
      });
      return coordinates;
    };
    var randomPoint = (optns = {}) => {
      const type = GEO_POINT;
      const coordinates = randomPosition(optns);
      return { type, coordinates };
    };
    var randomLineString = (optns = { vertices: 2 }) => {
      const type = GEO_LINESTRING;
      const coordinates = randomPositions(optns);
      return { type, coordinates };
    };
    var randomPolygon = (optns = { vertices: 3 }) => {
      const options = common.mergeObjects({ vertices: 3 }, optns);
      options.vertices = options.vertices < 3 ? 3 : options.vertices;
      const type = GEO_POLYGON;
      let coordinates = randomPositions(options);
      coordinates = [...coordinates, coordinates[0]];
      return { type, coordinates: [coordinates] };
    };
    var randomMultiPoint = (optns = { vertices: 2 }) => {
      const type = GEO_MULTIPOINT;
      const coordinates = randomPositions(optns);
      return { type, coordinates };
    };
    var randomMultiLineString = (optns = { lines: 2, vertices: 2 }) => {
      const options = common.mergeObjects({ lines: 2, vertices: 2 }, optns);
      const type = GEO_MULTILINESTRING;
      const coordinates = [
        ...lodash.map(lodash.range(options.lines), () => {
          return randomPositions(options);
        })
      ];
      return { type, coordinates };
    };
    var randomMultiPolygon = (optns = { polygons: 2, vertices: 3 }) => {
      const options = common.mergeObjects({ polygons: 2, vertices: 3 }, optns);
      const type = GEO_MULTIPOLYGON;
      const coordinates = [
        ...lodash.map(lodash.range(options.polygons), () => {
          const coords = randomPositions(options);
          return [[...coords, coords[0]]];
        })
      ];
      return { type, coordinates };
    };
    var randomGeometry = (optns = {}) => {
      const options = common.mergeObjects({ lines: 2, polygons: 2, vertices: 3 }, optns);
      const generators = [
        randomPoint,
        randomLineString,
        randomPolygon,
        randomMultiPoint,
        randomMultiLineString,
        randomMultiPolygon
      ];
      const generateGeomentry = lodash.sample(generators);
      const geometry = generateGeomentry(options);
      return geometry;
    };
    var randomGeometryCollection = (optns = {}) => {
      const options = common.mergeObjects({ lines: 2, polygons: 2, vertices: 3 }, optns);
      const generators = [
        randomPoint,
        randomLineString,
        randomPolygon,
        randomMultiPoint,
        randomMultiLineString,
        randomMultiPolygon
      ];
      const type = GEO_GEOMETRY_COLLECTION;
      const geometries = lodash.map(
        lodash.sampleSize(generators, options.vertices),
        (generateGeomentry) => {
          return generateGeomentry(options);
        }
      );
      return { type, geometries };
    };
    var readShapefile = (optns, done) => {
      const { path } = common.mergeObjects(optns);
      const results = { finished: true, feature: void 0, next: void 0 };
      const readFeature = (source, processFeature) => {
        const onFeature = ({ done: finished, value: feature }) => {
          const next = (error) => {
            if (error) {
              return processFeature(error, common.mergeObjects(results));
            }
            return source.read().then(onFeature);
          };
          if (finished) {
            return processFeature(null, common.mergeObjects(results));
          }
          return processFeature(null, {
            feature,
            finished: false,
            next
          });
        };
        return source.read().then(onFeature);
      };
      shapefile.open(path).then((source) => readFeature(source, done)).catch((error) => done(error, common.mergeObjects(results)));
    };
    var readGeoJSON = (optns, done) => {
      const { path } = common.mergeObjects(optns);
      const results = { finished: true, feature: void 0, next: void 0 };
      const readStream = fs.createReadStream(path);
      readStream.on("error", (error) => done(error, common.mergeObjects(results)));
      const parseStream = readStream.pipe(geojsonStream.parse());
      parseStream.on("error", (error) => done(error, common.mergeObjects(results)));
      const processStream = parseStream.pipe(
        new stream.Writable({
          write: (feature, encoding, callback) => {
            return done(null, { feature, finished: false, next: callback });
          },
          objectMode: true
        })
      );
      processStream.on("error", (error) => done(error, common.mergeObjects(results)));
      processStream.on("finish", () => done(null, common.mergeObjects(results)));
    };
    var readCsv = (optns, done) => {
      const parseOptns = { bom: true, columns: true, trim: true };
      const { path, ...options } = common.mergeObjects(parseOptns, optns);
      const results = { finished: true, feature: void 0, next: void 0 };
      const readStream = fs.createReadStream(path);
      readStream.on("error", (error) => done(error, common.mergeObjects(results)));
      const parseStream = readStream.pipe(parseCsv(options));
      parseStream.on("error", (error) => done(error, common.mergeObjects(results)));
      const processStream = parseStream.pipe(
        new stream.Writable({
          write: (feature, encoding, callback) => {
            return done(null, { feature, finished: false, next: callback });
          },
          objectMode: true
        })
      );
      processStream.on("error", (error) => done(error, common.mergeObjects(results)));
      processStream.on("finish", () => done(null, common.mergeObjects(results)));
    };
    var readJson = (optns, done) => {
      const { path, throws, ...options } = common.mergeObjects({ throws: true }, optns);
      return jsonfile.readFile(path, options, (error, data) => {
        if (!throws) {
          return done(null, data || {});
        }
        return done(error, data);
      });
    };
    exports2.GEO_BBOX = GEO_BBOX;
    exports2.GEO_FEATURE = GEO_FEATURE;
    exports2.GEO_FEATURE_COLLECTION = GEO_FEATURE_COLLECTION;
    exports2.GEO_GEOMETRY_COLLECTION = GEO_GEOMETRY_COLLECTION;
    exports2.GEO_LINESTRING = GEO_LINESTRING;
    exports2.GEO_MAX_LENGTH = GEO_MAX_LENGTH;
    exports2.GEO_MAX_ROTATION = GEO_MAX_ROTATION;
    exports2.GEO_MULTILINESTRING = GEO_MULTILINESTRING;
    exports2.GEO_MULTIPOINT = GEO_MULTIPOINT;
    exports2.GEO_MULTIPOLYGON = GEO_MULTIPOLYGON;
    exports2.GEO_POINT = GEO_POINT;
    exports2.GEO_POLYGON = GEO_POLYGON;
    exports2.centroidOf = centroidOf;
    exports2.isFeature = isFeature;
    exports2.isFeatureCollection = isFeatureCollection;
    exports2.isGeometry = isGeometry;
    exports2.isGeometryCollection = isGeometryCollection;
    exports2.isLineString = isLineString;
    exports2.isMultiLineString = isMultiLineString;
    exports2.isMultiPoint = isMultiPoint;
    exports2.isMultiPolygon = isMultiPolygon;
    exports2.isPoint = isPoint;
    exports2.isPolygon = isPolygon;
    exports2.isValid = isValid;
    exports2.parseCoordinateString = parseCoordinateString;
    exports2.randomGeometry = randomGeometry;
    exports2.randomGeometryCollection = randomGeometryCollection;
    exports2.randomLatitude = randomLatitude;
    exports2.randomLineString = randomLineString;
    exports2.randomLongitude = randomLongitude;
    exports2.randomMultiLineString = randomMultiLineString;
    exports2.randomMultiPoint = randomMultiPoint;
    exports2.randomMultiPolygon = randomMultiPolygon;
    exports2.randomPoint = randomPoint;
    exports2.randomPolygon = randomPolygon;
    exports2.randomPosition = randomPosition;
    exports2.randomPositions = randomPositions;
    exports2.readCsv = readCsv;
    exports2.readGeoJSON = readGeoJSON;
    exports2.readJson = readJson;
    exports2.readShapefile = readShapefile;
  }
});

// node_modules/@lykmapipo/cap-common/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@lykmapipo/cap-common/lib/index.js"(exports2) {
    "use strict";
    var env = require_lib7();
    var common = require_lib5();
    var geoTools = require_lib11();
    var CAP_DEFAULT_STATUS = env.getString("CAP_DEFAULT_STATUS", "Draft");
    var CAP_DEFAULT_MSGTYPE = env.getString("CAP_DEFAULT_MSGTYPE", "Unknown");
    var CAP_DEFAULT_SCOPE = env.getString("CAP_DEFAULT_SCOPE", "Private");
    var CAP_DEFAULT_LANGUAGE = env.getString("CAP_DEFAULT_LANGUAGE", "en");
    var CAP_DEFAULT_CATEGORY = env.getString("CAP_DEFAULT_CATEGORY", "Other");
    var CAP_DEFAULT_EVENT = env.getString("CAP_DEFAULT_EVENT", "Unknown");
    var CAP_DEFAULT_LEVEL = env.getString("CAP_DEFAULT_LEVEL", "White");
    var CAP_DEFAULT_RESPONSETYPE = env.getString(
      "CAP_DEFAULT_RESPONSETYPE",
      "None"
    );
    var CAP_DEFAULT_URGENCY = env.getString("CAP_DEFAULT_URGENCY", "Unknown");
    var CAP_DEFAULT_SEVERITY = env.getString(
      "CAP_DEFAULT_SEVERITY",
      "Unknown"
    );
    var CAP_DEFAULT_CERTAINTY = env.getString(
      "CAP_DEFAULT_CERTAINTY",
      "Unknown"
    );
    var CAP_DEFAULT_AREADESC = env.getString(
      "CAP_DEFAULT_AREADESC",
      "Unknown"
    );
    var CAP_STATUS_ACTUAL = "Actual";
    var CAP_STATUS_EXERCISE = "Exercise";
    var CAP_STATUS_SYSTEM = "System";
    var CAP_STATUS_TEST = "Test";
    var CAP_STATUS_DRAFT = "Draft";
    var CAP_STATUSES = env.getStringSet("CAP_STATUSES", [
      CAP_DEFAULT_STATUS,
      CAP_STATUS_ACTUAL,
      CAP_STATUS_EXERCISE,
      CAP_STATUS_SYSTEM,
      CAP_STATUS_TEST,
      CAP_STATUS_DRAFT
    ]);
    var CAP_MSGTYPE_ALERT = "Alert";
    var CAP_MSGTYPE_UPDATE = "Update";
    var CAP_MSGTYPE_CANCEL = "Cancel";
    var CAP_MSGTYPE_ACK = "Ack";
    var CAP_MSGTYPE_ERROR = "Error";
    var CAP_MSGTYPES = env.getStringSet("CAP_MSGTYPES", [
      CAP_DEFAULT_MSGTYPE,
      CAP_MSGTYPE_ALERT,
      CAP_MSGTYPE_UPDATE,
      CAP_MSGTYPE_CANCEL,
      CAP_MSGTYPE_ACK,
      CAP_MSGTYPE_ERROR
    ]);
    var CAP_SCOPE_PUBLIC = "Public";
    var CAP_SCOPE_RESTRICTED = "Restricted";
    var CAP_SCOPE_PRIVATE = "Private";
    var CAP_SCOPES = env.getStringSet("CAP_SCOPES", [
      CAP_DEFAULT_SCOPE,
      CAP_SCOPE_PUBLIC,
      CAP_SCOPE_RESTRICTED,
      CAP_SCOPE_PRIVATE
    ]);
    var CAP_CATEGORY_GEO = "Geo";
    var CAP_CATEGORY_MET = "Met";
    var CAP_CATEGORY_SAFETY = "Safety";
    var CAP_CATEGORY_SECURITY = "Security";
    var CAP_CATEGORY_RESCUE = "Rescue";
    var CAP_CATEGORY_FIRE = "Fire";
    var CAP_CATEGORY_HEALTH = "Health";
    var CAP_CATEGORY_ENV = "Env";
    var CAP_CATEGORY_TRANSPORT = "Transport";
    var CAP_CATEGORY_INFRA = "Infra";
    var CAP_CATEGORY_CBRNE = "CBRNE";
    var CAP_CATEGORY_OTHER = "Other";
    var CAP_CATEGORIES = env.getStringSet("CAP_CATEGORIES", [
      CAP_DEFAULT_CATEGORY,
      CAP_CATEGORY_GEO,
      CAP_CATEGORY_MET,
      CAP_CATEGORY_SAFETY,
      CAP_CATEGORY_SECURITY,
      CAP_CATEGORY_RESCUE,
      CAP_CATEGORY_FIRE,
      CAP_CATEGORY_HEALTH,
      CAP_CATEGORY_ENV,
      CAP_CATEGORY_TRANSPORT,
      CAP_CATEGORY_INFRA,
      CAP_CATEGORY_CBRNE,
      CAP_CATEGORY_OTHER
    ]);
    var CAP_RESPONSETYPE_SHELTER = "Shelter";
    var CAP_RESPONSETYPE_EVACUATE = "Evacuate";
    var CAP_RESPONSETYPE_PREPARE = "Prepare";
    var CAP_RESPONSETYPE_EXECUTE = "Execute";
    var CAP_RESPONSETYPE_AVOID = "Avoid";
    var CAP_RESPONSETYPE_MONITOR = "Monitor";
    var CAP_RESPONSETYPE_ASSESS = "Assess";
    var CAP_RESPONSETYPE_ALLCLEAR = "AllClear";
    var CAP_RESPONSETYPE_NONE = "None";
    var CAP_RESPONSETYPES = env.getStringSet("CAP_RESPONSETYPES", [
      CAP_DEFAULT_RESPONSETYPE,
      CAP_RESPONSETYPE_SHELTER,
      CAP_RESPONSETYPE_EVACUATE,
      CAP_RESPONSETYPE_PREPARE,
      CAP_RESPONSETYPE_EXECUTE,
      CAP_RESPONSETYPE_AVOID,
      CAP_RESPONSETYPE_MONITOR,
      CAP_RESPONSETYPE_ASSESS,
      CAP_RESPONSETYPE_ALLCLEAR,
      CAP_RESPONSETYPE_NONE
    ]);
    var CAP_URGENCY_IMMEDIATE = "Immediate";
    var CAP_URGENCY_EXPECTED = "Expected";
    var CAP_URGENCY_FUTURE = "Future";
    var CAP_URGENCY_PAST = "Past";
    var CAP_URGENCY_UNKNOWN = "Unknown";
    var CAP_URGENCIES = env.getStringSet("CAP_URGENCIES", [
      CAP_DEFAULT_URGENCY,
      CAP_URGENCY_IMMEDIATE,
      CAP_URGENCY_EXPECTED,
      CAP_URGENCY_FUTURE,
      CAP_URGENCY_PAST,
      CAP_URGENCY_UNKNOWN
    ]);
    var CAP_SEVERITY_EXTREME = "Extreme";
    var CAP_SEVERITY_SEVERE = "Severe";
    var CAP_SEVERITY_MODERATE = "Moderate";
    var CAP_SEVERITY_MINOR = "Minor";
    var CAP_SEVERITY_UNKNOWN = "Unknown";
    var CAP_SEVERITIES = env.getStringSet("CAP_SEVERITIES", [
      CAP_DEFAULT_SEVERITY,
      CAP_SEVERITY_EXTREME,
      CAP_SEVERITY_SEVERE,
      CAP_SEVERITY_MODERATE,
      CAP_SEVERITY_MINOR,
      CAP_SEVERITY_UNKNOWN
    ]);
    var CAP_CERTAINTY_OBSERVED = "Observed";
    var CAP_CERTAINTY_LIKELY = "Likely";
    var CAP_CERTAINTY_POSSIBLE = "Possible";
    var CAP_CERTAINTY_UNLIKELY = "Unlikely";
    var CAP_CERTAINTY_UNKNOWN = "Unknown";
    var CAP_CERTAINTIES = env.getStringSet("CAP_CERTAINTIES", [
      CAP_DEFAULT_CERTAINTY,
      CAP_CERTAINTY_OBSERVED,
      CAP_CERTAINTY_LIKELY,
      CAP_CERTAINTY_POSSIBLE,
      CAP_CERTAINTY_UNLIKELY,
      CAP_CERTAINTY_UNKNOWN
    ]);
    var EMPTY_ALERT = { info: { area: {} } };
    var DEFAULT_ALERT_AREA = { areaDesc: CAP_DEFAULT_AREADESC };
    var DEFAULT_ALERT_INFO = {
      language: CAP_DEFAULT_LANGUAGE,
      category: CAP_DEFAULT_CATEGORY,
      event: CAP_DEFAULT_EVENT,
      responseType: CAP_DEFAULT_RESPONSETYPE,
      urgency: CAP_DEFAULT_URGENCY,
      severity: CAP_DEFAULT_SEVERITY,
      certainty: CAP_DEFAULT_CERTAINTY,
      area: DEFAULT_ALERT_AREA
    };
    var DEFAULT_ALERT = {
      status: CAP_DEFAULT_STATUS,
      msgType: CAP_DEFAULT_MSGTYPE,
      scope: CAP_DEFAULT_SCOPE,
      info: DEFAULT_ALERT_INFO
    };
    var normalizeAlertDates = (alert) => {
      const normalizedAlert = common.mergeObjects(EMPTY_ALERT, alert);
      normalizedAlert.sent = common.isValue(normalizedAlert.sent) ? new Date(normalizedAlert.sent) : void 0;
      normalizedAlert.info.effective = common.isValue(normalizedAlert.info.effective) ? new Date(normalizedAlert.info.effective) : normalizedAlert.sent;
      normalizedAlert.info.onset = common.isValue(normalizedAlert.info.onset) ? new Date(normalizedAlert.info.onset) : normalizedAlert.info.effective;
      normalizedAlert.info.expires = common.isValue(normalizedAlert.info.expires) ? new Date(normalizedAlert.info.expires) : void 0;
      return normalizedAlert;
    };
    var normalizeAlertGeos = (alert) => {
      const normalizedAlert = common.mergeObjects(EMPTY_ALERT, alert);
      const coordinateString = common.firstValue(
        normalizedAlert.info.area.polygon,
        normalizedAlert.info.area.circle
      );
      const hasGeoFields = common.isValue(coordinateString);
      if (hasGeoFields) {
        const geometry = geoTools.parseCoordinateString(coordinateString);
        const centroid = geoTools.centroidOf(geometry);
        normalizedAlert.info.area.geometry = geometry;
        normalizedAlert.info.area.centroid = centroid;
      }
      return normalizedAlert;
    };
    var normalizeAlert2 = (alert) => {
      let normalizedAlert = common.mergeObjects(DEFAULT_ALERT, alert);
      normalizedAlert = normalizeAlertDates(normalizedAlert);
      normalizedAlert = normalizeAlertGeos(normalizedAlert);
      normalizedAlert.hash = common.hashOf(normalizedAlert);
      return normalizedAlert;
    };
    var isValidAlert = (alert, optns) => {
      const copyOfAlert = common.mergeObjects(EMPTY_ALERT, alert);
      const { partial = false } = common.mergeObjects(optns);
      if (partial) {
        const isPartialAlert = common.isValue(copyOfAlert.info) && common.isValue(copyOfAlert.info.event) && common.isValue(copyOfAlert.info.effective) && common.isValue(copyOfAlert.info.expires) && common.isValue(copyOfAlert.info.instruction) && common.isValue(copyOfAlert.info.area) && common.isValue(copyOfAlert.info.area.areaDesc);
        return isPartialAlert;
      }
      const isFullAlert = common.isValue(copyOfAlert.identifier) && common.isValue(copyOfAlert.sender) && common.isValue(copyOfAlert.sent) && common.isValue(copyOfAlert.status) && common.isValue(copyOfAlert.msgType) && common.isValue(copyOfAlert.scope) && common.isValue(copyOfAlert.info) && common.isValue(copyOfAlert.info.category) && common.isValue(copyOfAlert.info.event) && common.isValue(copyOfAlert.info.urgency) && common.isValue(copyOfAlert.info.severity) && common.isValue(copyOfAlert.info.certainty) && common.isValue(copyOfAlert.info.effective) && common.isValue(copyOfAlert.info.expires) && common.isValue(copyOfAlert.info.instruction) && common.isValue(copyOfAlert.info.area) && common.isValue(copyOfAlert.info.area.areaDesc);
      return isFullAlert;
    };
    exports2.CAP_CATEGORIES = CAP_CATEGORIES;
    exports2.CAP_CATEGORY_CBRNE = CAP_CATEGORY_CBRNE;
    exports2.CAP_CATEGORY_ENV = CAP_CATEGORY_ENV;
    exports2.CAP_CATEGORY_FIRE = CAP_CATEGORY_FIRE;
    exports2.CAP_CATEGORY_GEO = CAP_CATEGORY_GEO;
    exports2.CAP_CATEGORY_HEALTH = CAP_CATEGORY_HEALTH;
    exports2.CAP_CATEGORY_INFRA = CAP_CATEGORY_INFRA;
    exports2.CAP_CATEGORY_MET = CAP_CATEGORY_MET;
    exports2.CAP_CATEGORY_OTHER = CAP_CATEGORY_OTHER;
    exports2.CAP_CATEGORY_RESCUE = CAP_CATEGORY_RESCUE;
    exports2.CAP_CATEGORY_SAFETY = CAP_CATEGORY_SAFETY;
    exports2.CAP_CATEGORY_SECURITY = CAP_CATEGORY_SECURITY;
    exports2.CAP_CATEGORY_TRANSPORT = CAP_CATEGORY_TRANSPORT;
    exports2.CAP_CERTAINTIES = CAP_CERTAINTIES;
    exports2.CAP_CERTAINTY_LIKELY = CAP_CERTAINTY_LIKELY;
    exports2.CAP_CERTAINTY_OBSERVED = CAP_CERTAINTY_OBSERVED;
    exports2.CAP_CERTAINTY_POSSIBLE = CAP_CERTAINTY_POSSIBLE;
    exports2.CAP_CERTAINTY_UNKNOWN = CAP_CERTAINTY_UNKNOWN;
    exports2.CAP_CERTAINTY_UNLIKELY = CAP_CERTAINTY_UNLIKELY;
    exports2.CAP_DEFAULT_AREADESC = CAP_DEFAULT_AREADESC;
    exports2.CAP_DEFAULT_CATEGORY = CAP_DEFAULT_CATEGORY;
    exports2.CAP_DEFAULT_CERTAINTY = CAP_DEFAULT_CERTAINTY;
    exports2.CAP_DEFAULT_EVENT = CAP_DEFAULT_EVENT;
    exports2.CAP_DEFAULT_LANGUAGE = CAP_DEFAULT_LANGUAGE;
    exports2.CAP_DEFAULT_LEVEL = CAP_DEFAULT_LEVEL;
    exports2.CAP_DEFAULT_MSGTYPE = CAP_DEFAULT_MSGTYPE;
    exports2.CAP_DEFAULT_RESPONSETYPE = CAP_DEFAULT_RESPONSETYPE;
    exports2.CAP_DEFAULT_SCOPE = CAP_DEFAULT_SCOPE;
    exports2.CAP_DEFAULT_SEVERITY = CAP_DEFAULT_SEVERITY;
    exports2.CAP_DEFAULT_STATUS = CAP_DEFAULT_STATUS;
    exports2.CAP_DEFAULT_URGENCY = CAP_DEFAULT_URGENCY;
    exports2.CAP_MSGTYPES = CAP_MSGTYPES;
    exports2.CAP_MSGTYPE_ACK = CAP_MSGTYPE_ACK;
    exports2.CAP_MSGTYPE_ALERT = CAP_MSGTYPE_ALERT;
    exports2.CAP_MSGTYPE_CANCEL = CAP_MSGTYPE_CANCEL;
    exports2.CAP_MSGTYPE_ERROR = CAP_MSGTYPE_ERROR;
    exports2.CAP_MSGTYPE_UPDATE = CAP_MSGTYPE_UPDATE;
    exports2.CAP_RESPONSETYPES = CAP_RESPONSETYPES;
    exports2.CAP_RESPONSETYPE_ALLCLEAR = CAP_RESPONSETYPE_ALLCLEAR;
    exports2.CAP_RESPONSETYPE_ASSESS = CAP_RESPONSETYPE_ASSESS;
    exports2.CAP_RESPONSETYPE_AVOID = CAP_RESPONSETYPE_AVOID;
    exports2.CAP_RESPONSETYPE_EVACUATE = CAP_RESPONSETYPE_EVACUATE;
    exports2.CAP_RESPONSETYPE_EXECUTE = CAP_RESPONSETYPE_EXECUTE;
    exports2.CAP_RESPONSETYPE_MONITOR = CAP_RESPONSETYPE_MONITOR;
    exports2.CAP_RESPONSETYPE_NONE = CAP_RESPONSETYPE_NONE;
    exports2.CAP_RESPONSETYPE_PREPARE = CAP_RESPONSETYPE_PREPARE;
    exports2.CAP_RESPONSETYPE_SHELTER = CAP_RESPONSETYPE_SHELTER;
    exports2.CAP_SCOPES = CAP_SCOPES;
    exports2.CAP_SCOPE_PRIVATE = CAP_SCOPE_PRIVATE;
    exports2.CAP_SCOPE_PUBLIC = CAP_SCOPE_PUBLIC;
    exports2.CAP_SCOPE_RESTRICTED = CAP_SCOPE_RESTRICTED;
    exports2.CAP_SEVERITIES = CAP_SEVERITIES;
    exports2.CAP_SEVERITY_EXTREME = CAP_SEVERITY_EXTREME;
    exports2.CAP_SEVERITY_MINOR = CAP_SEVERITY_MINOR;
    exports2.CAP_SEVERITY_MODERATE = CAP_SEVERITY_MODERATE;
    exports2.CAP_SEVERITY_SEVERE = CAP_SEVERITY_SEVERE;
    exports2.CAP_SEVERITY_UNKNOWN = CAP_SEVERITY_UNKNOWN;
    exports2.CAP_STATUSES = CAP_STATUSES;
    exports2.CAP_STATUS_ACTUAL = CAP_STATUS_ACTUAL;
    exports2.CAP_STATUS_DRAFT = CAP_STATUS_DRAFT;
    exports2.CAP_STATUS_EXERCISE = CAP_STATUS_EXERCISE;
    exports2.CAP_STATUS_SYSTEM = CAP_STATUS_SYSTEM;
    exports2.CAP_STATUS_TEST = CAP_STATUS_TEST;
    exports2.CAP_URGENCIES = CAP_URGENCIES;
    exports2.CAP_URGENCY_EXPECTED = CAP_URGENCY_EXPECTED;
    exports2.CAP_URGENCY_FUTURE = CAP_URGENCY_FUTURE;
    exports2.CAP_URGENCY_IMMEDIATE = CAP_URGENCY_IMMEDIATE;
    exports2.CAP_URGENCY_PAST = CAP_URGENCY_PAST;
    exports2.CAP_URGENCY_UNKNOWN = CAP_URGENCY_UNKNOWN;
    exports2.isValidAlert = isValidAlert;
    exports2.normalizeAlert = normalizeAlert2;
  }
});

// node_modules/addressparser/lib/addressparser.js
var require_addressparser = __commonJS({
  "node_modules/addressparser/lib/addressparser.js"(exports2, module2) {
    "use strict";
    module2.exports = addressparser;
    function addressparser(str) {
      var tokenizer = new Tokenizer(str);
      var tokens = tokenizer.tokenize();
      var addresses = [];
      var address = [];
      var parsedAddresses = [];
      tokens.forEach(function(token) {
        if (token.type === "operator" && (token.value === "," || token.value === ";")) {
          if (address.length) {
            addresses.push(address);
          }
          address = [];
        } else {
          address.push(token);
        }
      });
      if (address.length) {
        addresses.push(address);
      }
      addresses.forEach(function(address2) {
        address2 = _handleAddress(address2);
        if (address2.length) {
          parsedAddresses = parsedAddresses.concat(address2);
        }
      });
      return parsedAddresses;
    }
    function _handleAddress(tokens) {
      var token;
      var isGroup = false;
      var state = "text";
      var address;
      var addresses = [];
      var data = {
        address: [],
        comment: [],
        group: [],
        text: []
      };
      var i;
      var len;
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if (token.type === "operator") {
          switch (token.value) {
            case "<":
              state = "address";
              break;
            case "(":
              state = "comment";
              break;
            case ":":
              state = "group";
              isGroup = true;
              break;
            default:
              state = "text";
          }
        } else if (token.value) {
          if (state === "address") {
            token.value = token.value.replace(/^[^<]*<\s*/, "");
          }
          data[state].push(token.value);
        }
      }
      if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
      }
      if (isGroup) {
        data.text = data.text.join(" ");
        addresses.push({
          name: data.text || address && address.name,
          group: data.group.length ? addressparser(data.group.join(",")) : []
        });
      } else {
        if (!data.address.length && data.text.length) {
          for (i = data.text.length - 1; i >= 0; i--) {
            if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
              data.address = data.text.splice(i, 1);
              break;
            }
          }
          var _regexHandler = function(address2) {
            if (!data.address.length) {
              data.address = [address2.trim()];
              return " ";
            } else {
              return address2;
            }
          };
          if (!data.address.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
              data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
              if (data.address.length) {
                break;
              }
            }
          }
        }
        if (!data.text.length && data.comment.length) {
          data.text = data.comment;
          data.comment = [];
        }
        if (data.address.length > 1) {
          data.text = data.text.concat(data.address.splice(1));
        }
        data.text = data.text.join(" ");
        data.address = data.address.join(" ");
        if (!data.address && isGroup) {
          return [];
        } else {
          address = {
            address: data.address || data.text || "",
            name: data.text || data.address || ""
          };
          if (address.address === address.name) {
            if ((address.address || "").match(/@/)) {
              address.name = "";
            } else {
              address.address = "";
            }
          }
          addresses.push(address);
        }
      }
      return addresses;
    }
    function Tokenizer(str) {
      this.str = (str || "").toString();
      this.operatorCurrent = "";
      this.operatorExpecting = "";
      this.node = null;
      this.escaped = false;
      this.list = [];
    }
    Tokenizer.prototype.operators = {
      '"': '"',
      "(": ")",
      "<": ">",
      ",": "",
      ":": ";",
      // Semicolons are not a legal delimiter per the RFC2822 grammar other
      // than for terminating a group, but they are also not valid for any
      // other use in this context.  Given that some mail clients have
      // historically allowed the semicolon as a delimiter equivalent to the
      // comma in their UI, it makes sense to treat them the same as a comma
      // when used outside of a group.
      ";": ""
    };
    Tokenizer.prototype.tokenize = function() {
      var chr, list = [];
      for (var i = 0, len = this.str.length; i < len; i++) {
        chr = this.str.charAt(i);
        this.checkChar(chr);
      }
      this.list.forEach(function(node) {
        node.value = (node.value || "").toString().trim();
        if (node.value) {
          list.push(node);
        }
      });
      return list;
    };
    Tokenizer.prototype.checkChar = function(chr) {
      if ((chr in this.operators || chr === "\\") && this.escaped) {
        this.escaped = false;
      } else if (this.operatorExpecting && chr === this.operatorExpecting) {
        this.node = {
          type: "operator",
          value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = "";
        this.escaped = false;
        return;
      } else if (!this.operatorExpecting && chr in this.operators) {
        this.node = {
          type: "operator",
          value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = this.operators[chr];
        this.escaped = false;
        return;
      }
      if (!this.escaped && chr === "\\") {
        this.escaped = true;
        return;
      }
      if (!this.node) {
        this.node = {
          type: "text",
          value: ""
        };
        this.list.push(this.node);
      }
      if (this.escaped && chr !== "\\") {
        this.node.value += "\\";
      }
      this.node.value += chr;
      this.escaped = false;
    };
  }
});

// node_modules/array-indexofobject/index.js
var require_array_indexofobject = __commonJS({
  "node_modules/array-indexofobject/index.js"(exports2, module2) {
    module2.exports = function indexOfObject(array, object, keys) {
      if (!keys) {
        keys = Object.keys(object);
      }
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      var i = 0, len = array.length;
      for (; i < len; i++) {
        if (keys.every(matches.bind(null, array[i], object))) {
          return i;
        }
      }
      return -1;
    };
    function matches(item, object, key) {
      return has(item, key) && has(object, key) && item[key] === object[key];
    }
    function has(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        if (this.length === 1) return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node2 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node2()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ended) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/feedparser/lib/namespaces.js
var require_namespaces = __commonJS({
  "node_modules/feedparser/lib/namespaces.js"(exports2, module2) {
    module2.exports = {
      "http://www.w3.org/2005/Atom": "atom",
      // v1.0
      "http://purl.org/atom/ns#": "atom",
      // v0.3
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf",
      "http://purl.org/rss/1.0/": "rdf",
      // rss v1.0
      "http://my.netscape.com/rdf/simple/0.9/": "rdf",
      // rss v0.90
      "http://webns.net/mvcb/": "admin",
      "http://creativecommons.org/ns#": "cc",
      "http://web.resource.org/cc/": "cc",
      "http://purl.org/rss/1.0/modules/content/": "content",
      "http://backend.userland.com/creativeCommonsRSSModule": "creativecommons",
      "http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html": "creativecommons",
      "http://purl.org/dc/elements/1.1/": "dc",
      "http://purl.org/dc/elements/1.0/": "dc",
      "http://purl.oclc.org/net/rss_2.0/enc#": "enc",
      "http://rssnamespace.org/feedburner/ext/1.0": "feedburner",
      "http://www.bradsoft.com/feeddemon/xmlns/1.0/": "fd",
      // FeedDemon
      "http://www.itunes.com/dtds/podcast-1.0.dtd": "itunes",
      "http://www.w3.org/2003/01/geo/wgs84_pos#": "geo",
      "http://www.georss.org/georss": "georss",
      "http://search.yahoo.com/mrss/": "media",
      "http://search.yahoo.com/mrss": "media",
      // commonly-used but wrong
      "http://newsgator.com/schema/extensions": "ng",
      // NewsGator
      "http://opml.org/spec2": "opml",
      // OPML 2.0
      "http://www.pheedo.com/namespace/pheedo": "pheedo",
      "http://purl.org/rss/1.0/modules/syndication/": "syn",
      "http://feedsync.org/2007/feedsync": "sx",
      // feedsync (Simple Sharing Extensions) http://feedsyncsamples.codeplex.com/
      "http://purl.org/rss/1.0/modules/taxonomy/": "taxo",
      "http://purl.org/syndication/thread/1.0": "thr",
      "http://www.w3.org/1999/xhtml": "xhtml",
      "http://www.w3.org/XML/1998/namespace": "xml"
    };
  }
});

// node_modules/lodash.has/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.has/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result2 = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result2 = !!(value + "");
        } catch (e) {
        }
      }
      return result2;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result2, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result2 = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result2) {
        return result2;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result2 = [];
      if (reLeadingDot.test(string)) {
        result2.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result2.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result2;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result2 = func.apply(this, args);
        memoized.cache = cache.set(key, result2);
        return result2;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    module2.exports = has;
  }
});

// node_modules/lodash.assign/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.assign/index.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result2 = Array(n);
      while (++index < n) {
        result2[index] = iteratee(index);
      }
      return result2;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var nonEnumShadows = !propertyIsEnumerable.call({ "valueOf": 1 }, "valueOf");
    function arrayLikeKeys(value, inherited) {
      var result2 = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result2.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result2 = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result2.push(key);
        }
      }
      return result2;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assign = createAssigner(function(object, source) {
      if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = assign;
  }
});

// node_modules/lodash.uniq/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.uniq/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result2 = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result2 = !!(value + "");
        } catch (e) {
        }
      }
      return result2;
    }
    function setToArray(set) {
      var index = -1, result2 = Array(set.size);
      set.forEach(function(value) {
        result2[++index] = value;
      });
      return result2;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result2;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result2.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result2) {
              seen.push(computed);
            }
            result2.push(value);
          }
        }
      return result2;
    }
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function noop() {
    }
    module2.exports = uniq;
  }
});

// node_modules/lodash.get/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.get/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result2 = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result2 = !!(value + "");
        } catch (e) {
        }
      }
      return result2;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result2 = [];
      if (reLeadingDot.test(string)) {
        result2.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result2.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result2;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result2 = func.apply(this, args);
        memoized.cache = cache.set(key, result2);
        return result2;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get2(object, path, defaultValue) {
      var result2 = object == null ? void 0 : baseGet(object, path);
      return result2 === void 0 ? defaultValue : result2;
    }
    module2.exports = get2;
  }
});

// node_modules/feedparser/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/feedparser/lib/utils.js"(exports2) {
    var URL2 = require("url");
    var namespaces = require_namespaces();
    exports2.has = require_lodash2();
    exports2.assign = require_lodash3();
    exports2.uniq = require_lodash4();
    var _get = require_lodash5();
    function get2(obj, subkey, defaultValue) {
      if (!subkey) {
        subkey = "#";
      }
      if (!defaultValue) {
        defaultValue = null;
      }
      if (Array.isArray(obj)) {
        return _get(obj[0], subkey, defaultValue);
      } else {
        return _get(obj, subkey, defaultValue);
      }
    }
    exports2.get = get2;
    function safeTrim(val) {
      if (typeof val === "string") {
        return val.trim();
      }
      return val;
    }
    exports2.safeTrim = safeTrim;
    function resolve(baseUrl, pathUrl) {
      if (!baseUrl || !pathUrl) return pathUrl;
      return URL2.resolve(baseUrl, pathUrl);
    }
    exports2.resolve = resolve;
    function isAbsoluteUrl(uri) {
      if (!uri || typeof uri !== "string") return false;
      var parts = URL2.parse(uri);
      return Boolean(parts.host);
    }
    exports2.isAbsoluteUrl = isAbsoluteUrl;
    function nslookup(uri, def) {
      return namespaces[uri] === def;
    }
    exports2.nslookup = nslookup;
    function nsprefix(uri) {
      return namespaces[uri];
    }
    exports2.nsprefix = nsprefix;
    function reresolve(node, baseurl) {
      if (!node || !baseurl) {
        return false;
      }
      function resolveLevel(level) {
        var els = Object.keys(level);
        els.forEach(function(el) {
          if (Array.isArray(level[el])) {
            var levelFromArray = {};
            level[el].forEach(function(attrs2) {
              levelFromArray[el] = attrs2;
              resolveLevel(levelFromArray);
            });
          } else {
            if (level[el].constructor.name === "Object") {
              if (el == "logo" || el == "icon" || el == "link") {
                if ("#" in level[el]) {
                  level[el]["#"] = URL2.resolve(baseurl, level[el]["#"]);
                }
              } else if (el == "image") {
                if ("url" in level[el] && level[el]["url"].constructor.name === "Object" && "#" in level[el]["url"]) {
                  level[el]["url"]["#"] = URL2.resolve(baseurl, level[el]["url"]["#"]);
                }
                if ("link" in level[el] && level[el]["link"].constructor.name === "Object" && "#" in level[el]["link"]) {
                  level[el]["link"]["#"] = URL2.resolve(baseurl, level[el]["link"]["#"]);
                }
              }
              if ("@" in level[el]) {
                var attrs = Object.keys(level[el]["@"]);
                attrs.forEach(function(name) {
                  if (name == "href" || name == "src" || name == "uri") {
                    if ("string" === typeof level[el]["@"][name]) {
                      level[el]["@"][name] = URL2.resolve(baseurl, level[el]["@"][name]);
                    }
                  }
                });
              }
            }
          }
        });
        return level;
      }
      return resolveLevel(node);
    }
    exports2.reresolve = reresolve;
    function stripHtml(str) {
      return str.replace(/<.*?>/g, "");
    }
    exports2.stripHtml = stripHtml;
  }
});

// node_modules/feedparser/lib/feedparser/index.js
var require_feedparser = __commonJS({
  "node_modules/feedparser/lib/feedparser/index.js"(exports2, module2) {
    var sax = require_sax();
    var addressparser = require_addressparser();
    var indexOfObject = require_array_indexofobject();
    var util = require("util");
    var TransformStream = require_readable().Transform;
    var _ = require_utils4();
    function FeedParser2(options) {
      if (!(this instanceof FeedParser2)) return new FeedParser2(options);
      TransformStream.call(this);
      this._readableState.objectMode = true;
      this._readableState.highWaterMark = 16;
      this.init();
      this.options = _.assign({}, options);
      if (!("strict" in this.options)) this.options.strict = false;
      if (!("normalize" in this.options)) this.options.normalize = true;
      if (!("addmeta" in this.options)) this.options.addmeta = true;
      if (!("resume_saxerror" in this.options)) this.options.resume_saxerror = true;
      if ("MAX_BUFFER_LENGTH" in this.options) {
        sax.MAX_BUFFER_LENGTH = this.options.MAX_BUFFER_LENGTH;
      } else {
        sax.MAX_BUFFER_LENGTH = 16 * 1024 * 1024;
      }
      if (this.options.feedurl) this.xmlbase.unshift({ "#name": "xml", "#": this.options.feedurl });
      this.stream = sax.createStream(this.options.strict, { lowercase: true, xmlns: true });
      this.stream.on("error", this.handleSaxError.bind(this));
      this.stream.on("processinginstruction", this.handleProcessingInstruction.bind(this));
      this.stream.on("opentag", this.handleOpenTag.bind(this));
      this.stream.on("closetag", this.handleCloseTag.bind(this));
      this.stream.on("text", this.handleText.bind(this));
      this.stream.on("cdata", this.handleText.bind(this));
      this.stream.on("end", this.handleEnd.bind(this));
    }
    util.inherits(FeedParser2, TransformStream);
    FeedParser2.prototype.init = function() {
      this.meta = {
        "#ns": [],
        "@": [],
        "#xml": {}
      };
      this._namespaces = {};
      this._emitted_meta = false;
      this.stack = [];
      this.xmlbase = [];
      this.in_xhtml = false;
      this.xhtml = {};
      this.errors = [];
    };
    FeedParser2.prototype.handleEnd = function() {
      if (!(this.meta && this.meta["#type"])) {
        var e = new Error("Not a feed");
        return this.handleError(e);
      }
      this.push(null);
    };
    FeedParser2.prototype.handleSaxError = function(e) {
      this.emit("error", e);
      if (this.options.resume_saxerror) {
        this.resumeSaxError();
      }
    };
    FeedParser2.prototype.resumeSaxError = function() {
      if (this.stream._parser) {
        this.stream._parser.error = null;
        this.stream._parser.resume();
      }
    };
    FeedParser2.prototype.handleError = function(e) {
      this.emit("error", e);
    };
    FeedParser2.prototype.handleProcessingInstruction = function(node) {
      if (node.name === "xml") {
        this.meta["#xml"] = node.body.trim().split(/\s+/).reduce(function(map2, attr) {
          if (attr.indexOf("=") >= 0) {
            var parts = attr.split("=");
            map2[parts[0]] = parts[1] && parts[1].length > 2 && parts[1].match(/^.(.*?).$/)[1];
          }
          return map2;
        }, this.meta["#xml"]);
      }
    };
    FeedParser2.prototype.handleOpenTag = function(node) {
      var n = {};
      n["#name"] = node.name;
      n["#prefix"] = node.prefix;
      n["#local"] = node.local;
      n["#uri"] = node.uri;
      n["@"] = {};
      n["#"] = "";
      if (Object.keys(node.attributes).length) {
        n["@"] = this.handleAttributes(node.attributes, n["#name"]);
      }
      if (this.in_xhtml && this.xhtml["#name"] != n["#name"]) {
        this.xhtml["#"] += "<" + n["#name"];
        Object.keys(n["@"]).forEach(function(name) {
          this.xhtml["#"] += " " + name + '="' + n["@"][name] + '"';
        }, this);
        this.xhtml["#"] += ">";
      } else if (this.stack.length === 0 && (n["#name"] === "rss" || n["#local"] === "rdf" && _.nslookup([n["#uri"]], "rdf") || n["#local"] === "feed" && _.nslookup([n["#uri"]], "atom"))) {
        Object.keys(n["@"]).forEach(function(name) {
          var o = {};
          if (name != "version") {
            o[name] = n["@"][name];
            this.meta["@"].push(o);
          }
        }, this);
        switch (n["#local"]) {
          case "rss":
            this.meta["#type"] = "rss";
            this.meta["#version"] = n["@"]["version"];
            break;
          case "rdf":
            this.meta["#type"] = "rdf";
            this.meta["#version"] = n["@"]["version"] || "1.0";
            break;
          case "feed":
            this.meta["#type"] = "atom";
            this.meta["#version"] = n["@"]["version"] || "1.0";
            break;
        }
      }
      this.stack.unshift(n);
    };
    FeedParser2.prototype.handleCloseTag = function(el) {
      var node = {
        "#name": el,
        "#prefix": "",
        "#local": ""
      }, stdEl, item, baseurl, isIllegallyNested = false;
      var n = this.stack.shift();
      el = el.split(":");
      if (el.length > 1 && el[0] === n["#prefix"]) {
        if (_.nslookup(n["#uri"], "atom")) {
          node["#prefix"] = el[0];
          node["#local"] = el.slice(1).join(":");
          node["#type"] = "atom";
        } else if (_.nslookup(n["#uri"], "rdf")) {
          node["#prefix"] = el[0];
          node["#local"] = el.slice(1).join(":");
          node["#type"] = "rdf";
        } else {
          node["#prefix"] = _.nsprefix(n["#uri"]) || n["#prefix"];
          node["#local"] = el.slice(1).join(":");
        }
      } else {
        node["#local"] = node["#name"];
        node["#type"] = _.nsprefix(n["#uri"]) || n["#prefix"];
      }
      delete n["#name"];
      delete n["#local"];
      delete n["#prefix"];
      delete n["#uri"];
      if (this.xmlbase && this.xmlbase.length) {
        baseurl = this.xmlbase[0]["#"];
      }
      var mayHaveResolvableUrl = (node["#local"] === "logo" || node["#local"] === "icon") && node["#type"] === "atom" || node["#local"] === "link";
      if (baseurl && mayHaveResolvableUrl) {
        n["#"] = _.resolve(baseurl, n["#"]);
      }
      if (this.xmlbase.length && el == this.xmlbase[0]["#name"]) {
        void this.xmlbase.shift();
      }
      if (this.in_xhtml) {
        if (node["#name"] == this.xhtml["#name"]) {
          n["#"] += this.xhtml["#"].trim();
          for (var key in n) {
            if (key != "@" && key != "#") {
              delete n[key];
            }
          }
          this.xhtml = {};
          this.in_xhtml = false;
        } else {
          this.xhtml["#"] += "</" + node["#name"] + ">";
        }
      }
      if ("#" in n) {
        if (n["#"].match(/^\s*$/)) {
          delete n["#"];
        } else {
          n["#"] = n["#"].trim();
          if (Object.keys(n).length === 1) {
            n = n["#"];
          }
        }
      }
      if (node["#name"] === "item" || node["#name"] === "entry" || node["#local"] === "item" && (node["#prefix"] === "" || node["#type"] === "rdf") || node["#local"] == "entry" && (node["#prefix"] === "" || node["#type"] === "atom")) {
        isIllegallyNested = node["#name"] === "item" && this.stack[0]["#name"] === "item" || node["#name"] === "entry" && this.stack[0]["#name"] === "entry" || node["#local"] === "item" && (node["#prefix"] === "" || node["#type"] === "rdf") && this.stack[0]["#name"] === "item" || node["#local"] == "entry" && (node["#prefix"] === "" || node["#type"] === "atom") && this.stack[0]["#name"] === "entry";
        if (isIllegallyNested) {
          return;
        }
        if (!this.meta.title) {
          _.assign(this.meta, this.handleMeta(this.stack[0], this.meta["#type"], this.options));
          if (!this._emitted_meta) {
            this.emit("meta", this.meta);
            this._emitted_meta = true;
          }
        }
        if (!baseurl && this.xmlbase && this.xmlbase.length) {
          n = _.reresolve(n, this.xmlbase[0]["#"]);
        }
        item = this.handleItem(n, this.meta["#type"], this.options);
        if (this.options.addmeta) {
          item.meta = this.meta;
        }
        if (this.meta.author && !item.author) item.author = this.meta.author;
        this.push(item);
      } else if (!this.meta.title && // We haven't yet parsed all the metadata
      (node["#name"] === "channel" || node["#name"] === "feed" || node["#local"] === "channel" && (node["#prefix"] === "" || node["#type"] === "rdf") || node["#local"] === "feed" && (node["#prefix"] === "" || node["#type"] === "atom"))) {
        _.assign(this.meta, this.handleMeta(n, this.meta["#type"], this.options));
        if (!this._emitted_meta) {
          this.emit("meta", this.meta);
          this._emitted_meta = true;
        }
      }
      if (this.stack.length > 0) {
        if (node["#prefix"] && node["#local"] && !node["#type"]) {
          stdEl = node["#prefix"] + ":" + node["#local"];
        } else if (node["#name"] && node["#type"] && node["#type"] !== this.meta["#type"]) {
          stdEl = node["#name"];
        } else {
          stdEl = node["#local"] || node["#name"];
        }
        if (!Object.prototype.hasOwnProperty.call(this.stack[0], stdEl)) {
          this.stack[0][stdEl] = n;
        } else if (this.stack[0][stdEl] instanceof Array) {
          this.stack[0][stdEl].push(n);
        } else {
          this.stack[0][stdEl] = [this.stack[0][stdEl], n];
        }
      }
    };
    FeedParser2.prototype.handleText = function(text) {
      if (this.in_xhtml) {
        this.xhtml["#"] += text;
      } else {
        if (this.stack.length) {
          if (this.stack[0] && "#" in this.stack[0]) {
            this.stack[0]["#"] += text;
          } else {
            this.stack[0]["#"] = text;
          }
        }
      }
    };
    FeedParser2.prototype.handleAttributes = function handleAttributes(attrs, el) {
      var basepath = "", simplifiedAttributes = {};
      if (this.xmlbase && this.xmlbase.length) {
        basepath = this.xmlbase[0]["#"];
      }
      Object.keys(attrs).forEach(function(key) {
        var attr = attrs[key], ns = {}, prefix = "";
        if (attr.prefix === "xmlns") {
          if (!(attr.name in this._namespaces)) {
            ns[attr.name] = attr.value;
            this.meta["#ns"].push(ns);
            _.assign(this._namespaces, ns);
          }
        }
        if (attr.uri && attr.prefix && !_.nslookup(attr.uri, attr.prefix) || _.nslookup(attr.uri, "xml")) {
          prefix = (_.nsprefix(attr.uri) || attr.prefix) + (attr.local ? ":" : "");
        }
        if (basepath && (attr.local == "href" || attr.local == "src" || attr.local == "uri")) {
          attr.value = _.resolve(basepath, attr.value);
        } else if (attr.local === "base" && _.nslookup(attr.uri, "xml")) {
          if (basepath) {
            attr.value = _.resolve(basepath, attr.value);
          }
          this.xmlbase.unshift({ "#name": el, "#": attr.value });
        } else if (attr.name === "type" && attr.value === "xhtml") {
          this.in_xhtml = true;
          this.xhtml = { "#name": el, "#": "" };
        }
        simplifiedAttributes[prefix + attr.local] = attr.value ? attr.value.trim() : "";
      }, this);
      return simplifiedAttributes;
    };
    FeedParser2.prototype.handleMeta = function handleMeta(node, type, options) {
      if (!type || !node) return {};
      var meta = {}, normalize2 = !options || options && options.normalize;
      if (normalize2) {
        ["title", "description", "date", "pubdate", "pubDate", "link", "xmlurl", "xmlUrl", "author", "language", "favicon", "copyright", "generator"].forEach(function(property) {
          meta[property] = null;
        });
        meta.cloud = {};
        meta.image = {};
        meta.categories = [];
      }
      Object.keys(node).forEach(function(name) {
        var el = node[name];
        if (normalize2) {
          switch (name) {
            case "title":
              meta.title = _.get(el);
              break;
            case "description":
            case "subtitle":
              meta.description = _.get(el);
              break;
            case "pubdate":
            case "lastbuilddate":
            case "published":
            case "modified":
            case "updated":
            case "dc:date":
              var date = _.get(el) ? new Date(_.get(el)) : null;
              if (!date) break;
              if (meta.pubdate === null || name == "pubdate" || name == "published")
                meta.pubdate = meta.pubDate = date;
              if (meta.date === null || name == "lastbuilddate" || name == "modified" || name == "updated")
                meta.date = date;
              break;
            case "link":
            case "atom:link":
            case "atom10:link":
              if (Array.isArray(el)) {
                el.forEach(function(link) {
                  if (link["@"]["href"]) {
                    if (_.get(link["@"], "rel")) {
                      if (link["@"]["rel"] == "alternate") {
                        if (!meta.link) meta.link = link["@"]["href"];
                      } else if (link["@"]["rel"] == "self") {
                        meta.xmlurl = meta.xmlUrl = link["@"]["href"];
                        if (_.isAbsoluteUrl(meta.xmlurl) && this.xmlbase && this.xmlbase.length === 0) {
                          this.xmlbase.unshift({ "#name": "xml", "#": meta.xmlurl });
                          this.stack[0] = _.reresolve(this.stack[0], meta.xmlurl);
                        } else if (this.xmlbase && this.xmlbase.length > 0) {
                          meta.xmlurl = meta.xmlUrl = _.resolve(_.get(this.xmlbase[0], "#"), meta.xmlurl);
                        }
                      } else if (link["@"]["rel"] == "hub" && !(meta.cloud.href || meta.cloud.domain)) {
                        meta.cloud.type = "hub";
                        meta.cloud.href = link["@"]["href"];
                      }
                    } else {
                      if (!meta.link) meta.link = link["@"]["href"];
                    }
                  } else if (Object.keys(link["@"]).length === 0) {
                    meta.link = _.get(link);
                  }
                  if (_.isAbsoluteUrl(meta.link) && this.xmlbase && this.xmlbase.length === 0) {
                    this.xmlbase.unshift({ "#name": "xml", "#": meta.link });
                    this.stack[0] = _.reresolve(this.stack[0], meta.link);
                  } else if (this.xmlbase && this.xmlbase.length > 0) {
                    meta.link = _.resolve(_.get(this.xmlbase[0], "#"), meta.link);
                  }
                }, this);
              } else {
                if (el["@"]["href"]) {
                  if (_.get(el["@"], "rel")) {
                    if (el["@"]["rel"] == "alternate") {
                      if (!meta.link) meta.link = el["@"]["href"];
                    } else if (el["@"]["rel"] == "self") {
                      meta.xmlurl = meta.xmlUrl = el["@"]["href"];
                      if (_.isAbsoluteUrl(meta.xmlurl) && this.xmlbase && this.xmlbase.length === 0) {
                        this.xmlbase.unshift({ "#name": "xml", "#": meta.xmlurl });
                        this.stack[0] = _.reresolve(this.stack[0], meta.xmlurl);
                      } else if (this.xmlbase && this.xmlbase.length > 0) {
                        meta.xmlurl = meta.xmlUrl = _.resolve(_.get(this.xmlbase[0], "#"), meta.xmlurl);
                      }
                    } else if (el["@"]["rel"] == "hub" && !(meta.cloud.href || meta.cloud.domain)) {
                      meta.cloud.type = "hub";
                      meta.cloud.href = el["@"]["href"];
                    }
                  } else {
                    meta.link = el["@"]["href"];
                  }
                } else if (Object.keys(el["@"]).length === 0) {
                  if (!meta.link) meta.link = _.get(el);
                }
                if (_.isAbsoluteUrl(meta.link) && this.xmlbase && this.xmlbase.length === 0) {
                  this.xmlbase.unshift({ "#name": "xml", "#": meta.link });
                  this.stack[0] = _.reresolve(this.stack[0], meta.link);
                } else if (this.xmlbase && this.xmlbase.length > 0) {
                  meta.link = _.resolve(_.get(this.xmlbase[0], "#"), meta.link);
                }
              }
              break;
            case "managingeditor":
            case "webmaster":
            case "author":
              var author = {};
              if (name == "author") {
                meta.author = _.get(el.name) || _.get(el.email) || _.get(el.uri);
              } else if (_.get(el)) {
                author = addressparser(_.get(el))[0];
                if (author) {
                  el["name"] = author.name;
                  el["email"] = author.address;
                }
                if (meta.author === null || name == "managingeditor") {
                  meta.author = author.name || author.address || _.get(el);
                }
              }
              break;
            case "cloud":
              meta.cloud = {};
              if (Array.isArray(el)) {
                Object.keys(el[0]["@"]).forEach(function(attr) {
                  if (_.has(el[0]["@"], attr)) {
                    meta.cloud[attr] = el[0]["@"][attr];
                  }
                });
              } else {
                Object.keys(el["@"]).forEach(function(attr) {
                  if (_.has(el["@"], attr)) {
                    meta.cloud[attr] = el["@"][attr];
                  }
                });
              }
              meta.cloud.type = "rsscloud";
              break;
            case "language":
              meta.language = _.get(el);
              break;
            case "image":
            case "logo":
              if (el.url)
                meta.image.url = _.get(el.url);
              if (el.title)
                meta.image.title = _.get(el.title);
              if (!meta.image.url && _.get(el))
                meta.image.url = _.get(el);
              break;
            case "icon":
              meta.favicon = _.get(el);
              break;
            case "copyright":
            case "rights":
            case "dc:rights":
              meta.copyright = _.get(el);
              break;
            case "generator":
              meta.generator = _.get(el);
              if (_.get(el["@"], "version"))
                meta.generator += (meta.generator ? " " : "") + "v" + el["@"].version;
              if (_.get(el["@"], "uri"))
                meta.generator += meta.generator ? " (" + el["@"].uri + ")" : el["@"].uri;
              break;
            case "category":
            case "dc:subject":
            case "itunes:category":
            case "media:category":
              var _category = "", _categories = [];
              if (Array.isArray(el)) {
                el.forEach(function(category) {
                  var _categoryValue;
                  if ("category" == name && "atom" == type) {
                    if (category["@"] && (_categoryValue = _.safeTrim(_.get(category["@"], "term")))) {
                      meta.categories.push(_categoryValue);
                    }
                  } else if ("category" == name && "rss" == type) {
                    if (_categoryValue = _.safeTrim(_.get(category))) {
                      meta.categories.push(_categoryValue);
                    }
                  } else if ("dc:subject" == name && (_categoryValue = _.safeTrim(_.get(category)))) {
                    _categories = _categoryValue.split(" ").map(function(cat) {
                      return cat.trim();
                    });
                    if (_categories.length) {
                      meta.categories = meta.categories.concat(_categories);
                    }
                  } else if ("itunes:category" == name) {
                    if (category["@"] && _.safeTrim(_.get(category["@"], "text"))) _category = _.safeTrim(_.get(category["@"], "text"));
                    if (category[name]) {
                      if (Array.isArray(category[name])) {
                        category[name].forEach(function(subcategory) {
                          var _subcategoryValue;
                          if (subcategory["@"] && (_subcategoryValue = _.safeTrim(_.get(subcategory["@"], "text")))) {
                            meta.categories.push(_category + "/" + _subcategoryValue);
                          }
                        });
                      } else if (category[name]["@"] && (_categoryValue = _.safeTrim(_.get(category[name]["@"], "text")))) {
                        meta.categories.push(_category + "/" + _categoryValue);
                      }
                    } else if (_category) {
                      meta.categories.push(_category);
                    }
                  } else if ("media:category" == name && (_categoryValue = _.safeTrim(_.get(category)))) {
                    meta.categories.push(_categoryValue);
                  }
                });
              } else {
                if ("category" == name && "atom" == type) {
                  if (_category = _.safeTrim(_.get(el["@"], "term"))) {
                    meta.categories.push(_category);
                  }
                } else if ("category" == name && "rss" == type) {
                  if (_category = _.safeTrim(_.get(el))) {
                    meta.categories.push(_category);
                  }
                } else if ("dc:subject" == name && (_category = _.safeTrim(_.get(el)))) {
                  _categories = _category.split(" ").map(function(cat) {
                    return cat.trim();
                  });
                  if (_categories.length) {
                    meta.categories = meta.categories.concat(_categories);
                  }
                } else if ("itunes:category" == name) {
                  if (el["@"] && _.safeTrim(_.get(el["@"], "text"))) _category = _.safeTrim(_.get(el["@"], "text"));
                  if (el[name]) {
                    if (Array.isArray(el[name])) {
                      el[name].forEach(function(subcategory) {
                        var _subcategoryValue;
                        if (subcategory["@"] && (_subcategoryValue = _.safeTrim(_.get(subcategory["@"], "text")))) {
                          meta.categories.push(_category + "/" + _subcategoryValue);
                        }
                      });
                    } else if (el[name]["@"] && (_category = _.safeTrim(_.get(el[name]["@"], "text")))) {
                      meta.categories.push(_category + "/" + _category);
                    }
                  } else if (_category) {
                    meta.categories.push(_category);
                  }
                } else if ("media:category" == name && (_category = _.safeTrim(_.get(el)))) {
                  meta.categories.push(_.get(el));
                }
              }
              break;
          }
        }
        if (name.indexOf("#") !== 0) {
          if (~name.indexOf(":")) meta[name] = el;
          else meta[type + ":" + name] = el;
        }
      }, this);
      if (normalize2) {
        if (!meta.description) {
          if (node["itunes:summary"]) meta.description = _.get(node["itunes:summary"]);
          else if (node["tagline"]) meta.description = _.get(node["tagline"]);
        }
        if (!meta.author) {
          if (node["itunes:author"]) meta.author = _.get(node["itunes:author"]);
          else if (node["itunes:owner"] && node["itunes:owner"]["itunes:name"]) meta.author = _.get(node["itunes:owner"]["itunes:name"]);
          else if (node["dc:creator"]) meta.author = _.get(node["dc:creator"]);
          else if (node["dc:publisher"]) meta.author = _.get(node["dc:publisher"]);
        }
        if (!meta.language) {
          if (node["@"] && node["@"]["xml:lang"]) meta.language = _.get(node["@"], "xml:lang");
          else if (node["dc:language"]) meta.language = _.get(node["dc:language"]);
        }
        if (!meta.image.url) {
          if (node["itunes:image"]) meta.image.url = _.get(node["itunes:image"]["@"], "href");
          else if (node["media:thumbnail"]) {
            if (Array.isArray(node["media:thumbnail"])) {
              node["media:thumbnail"] = node["media:thumbnail"][0];
            }
            meta.image.url = _.get(node["media:thumbnail"]["@"], "url");
          }
        }
        if (!meta.copyright) {
          if (node["media:copyright"]) meta.copyright = _.get(node["media:copyright"]);
          else if (node["dc:rights"]) meta.copyright = _.get(node["dc:rights"]);
          else if (node["creativecommons:license"]) meta.copyright = _.get(node["creativecommons:license"]);
          else if (node["cc:license"]) {
            if (Array.isArray(node["cc:license"]) && node["cc:license"][0]["@"] && node["cc:license"][0]["@"]["rdf:resource"]) {
              meta.copyright = _.get(node["cc:license"][0]["@"], "rdf:resource");
            } else if (node["cc:license"]["@"] && node["cc:license"]["@"]["rdf:resource"]) {
              meta.copyright = _.get(node["cc:license"]["@"], "rdf:resource");
            }
          }
        }
        if (!meta.generator) {
          if (node["admin:generatoragent"]) {
            if (Array.isArray(node["admin:generatoragent"]) && node["admin:generatoragent"][0]["@"] && node["admin:generatoragent"][0]["@"]["rdf:resource"]) {
              meta.generator = _.get(node["admin:generatoragent"][0]["@"], "rdf:resource");
            } else if (node["admin:generatoragent"]["@"] && node["admin:generatoragent"]["@"]["rdf:resource"]) {
              meta.generator = _.get(node["admin:generatoragent"]["@"], "rdf:resource");
            }
          }
        }
        if (meta.categories.length) {
          meta.categories = _.uniq(meta.categories);
        }
        if (!meta.link) {
          if (meta["atom:id"] && _.get(meta["atom:id"]) && /^https?:/.test(_.get(meta["atom:id"]))) {
            meta.link = _.get(meta["atom:id"]);
          }
        }
        if (!meta.xmlurl && this.options.feedurl) {
          meta.xmlurl = meta.xmlUrl = this.options.feedurl;
        }
        meta.title = meta.title && _.stripHtml(meta.title);
        meta.description = meta.description && _.stripHtml(meta.description);
      }
      return meta;
    };
    FeedParser2.prototype.handleItem = function handleItem(node, type, options) {
      if (!type || !node) return {};
      var item = {}, normalize2 = !options || options && options.normalize;
      if (normalize2) {
        ["title", "description", "summary", "date", "pubdate", "pubDate", "link", "guid", "author", "comments", "origlink"].forEach(function(property) {
          item[property] = null;
        });
        item.image = {};
        item.source = {};
        item.categories = [];
        item.enclosures = [];
      }
      Object.keys(node).forEach(function(name) {
        var el = node[name], attrs = _.get(el, "@"), enclosure;
        if (normalize2) {
          switch (name) {
            case "title":
              item.title = _.get(el);
              break;
            case "description":
            case "summary":
              item.summary = _.get(el);
              if (!item.description) item.description = _.get(el);
              break;
            case "content":
            case "content:encoded":
              item.description = _.get(el);
              break;
            case "pubdate":
            case "published":
            case "issued":
            case "modified":
            case "updated":
            case "dc:date":
              var date = _.get(el) ? new Date(_.get(el)) : null;
              if (!date) break;
              if (item.pubdate === null || name == "pubdate" || name == "published" || name == "issued")
                item.pubdate = item.pubDate = date;
              if (item.date === null || name == "modified" || name == "updated")
                item.date = date;
              break;
            case "link":
              if (Array.isArray(el)) {
                el.forEach(function(link) {
                  if (link["@"]["href"]) {
                    if (_.get(link["@"], "rel")) {
                      if (link["@"]["rel"] == "canonical") item.origlink = link["@"]["href"];
                      if (link["@"]["rel"] == "alternate") item.link = link["@"]["href"];
                      if (link["@"]["rel"] == "self" && !item.link) item.link = link["@"]["href"];
                      if (link["@"]["rel"] == "replies") item.comments = link["@"]["href"];
                      if (link["@"]["rel"] == "enclosure") {
                        enclosure = {};
                        enclosure.url = link["@"]["href"];
                        enclosure.type = _.get(link["@"], "type");
                        enclosure.length = _.get(link["@"], "length");
                        if (indexOfObject(item.enclosures, enclosure, ["url", "type"]) === -1) {
                          item.enclosures.push(enclosure);
                        }
                      }
                    } else {
                      item.link = link["@"]["href"];
                    }
                  } else if (Object.keys(link["@"]).length === 0) {
                    if (!item.link) item.link = _.get(link);
                  }
                });
              } else {
                if (el["@"]["href"]) {
                  if (_.get(el["@"], "rel")) {
                    if (el["@"]["rel"] == "canonical") item.origlink = el["@"]["href"];
                    if (el["@"]["rel"] == "alternate") item.link = el["@"]["href"];
                    if (el["@"]["rel"] == "self" && !item.link) item.link = el["@"]["href"];
                    if (el["@"]["rel"] == "replies") item.comments = el["@"]["href"];
                    if (el["@"]["rel"] == "enclosure") {
                      enclosure = {};
                      enclosure.url = el["@"]["href"];
                      enclosure.type = _.get(el["@"], "type");
                      enclosure.length = _.get(el["@"], "length");
                      if (indexOfObject(item.enclosures, enclosure, ["url", "type"]) === -1) {
                        item.enclosures.push(enclosure);
                      }
                    }
                  } else {
                    item.link = el["@"]["href"];
                  }
                } else if (Object.keys(el["@"]).length === 0) {
                  if (!item.link) item.link = _.get(el);
                }
              }
              if (!item.guid) item.guid = item.link;
              break;
            case "guid":
            case "id":
              item.guid = _.get(el);
              if (item.guid && type == "rss" && name == "guid" && !(attrs.ispermalink && attrs.ispermalink.match(/false/i))) {
                item.permalink = item.guid;
              }
              break;
            case "author":
              var author = {};
              if (_.get(el)) {
                author = addressparser(_.get(el))[0];
                if (author) {
                  el["name"] = author.name;
                  el["email"] = author.address;
                  item.author = author.name || author.address;
                } else {
                  item.author = _.get(el);
                }
              } else {
                item.author = _.get(el.name) || _.get(el.email) || _.get(el.uri);
              }
              break;
            case "dc:creator":
              item.author = _.get(el);
              break;
            case "comments":
              item.comments = _.get(el);
              break;
            case "source":
              if ("rss" == type) {
                item.source["title"] = _.get(el);
                item.source["url"] = _.get(el["@"], "url");
              } else if ("atom" == type) {
                if (el.title && _.get(el.title))
                  item.source["title"] = _.get(el.title);
                if (el.link && _.get(el.link["@"], "href"))
                  item.source["url"] = _.get(el.link["@"], "href");
              }
              if (item.source["url"] && !this.meta.xmlurl) {
                this.meta.xmlurl = this.meta.xmlUrl = item.source["url"];
                if (_.isAbsoluteUrl(item.source["url"]) && this.xmlbase && this.xmlbase.length === 0) {
                  this.xmlbase.unshift({ "#name": "xml", "#": item.source["url"] });
                  this.stack[0] = _.reresolve(this.stack[0], item.source["url"]);
                } else if (this.xmlbase && this.xmlbase.length > 0) {
                  this.meta.xmlurl = this.meta.xmlUrl = item.source["url"] = _.resolve(_.get(this.xmlbase[0], "#"), item.source["url"]);
                }
              }
              break;
            case "enclosure":
              if (Array.isArray(el)) {
                el.forEach(function(enc) {
                  enclosure = {};
                  enclosure.url = _.get(enc["@"], "url");
                  enclosure.type = _.get(enc["@"], "type");
                  enclosure.length = _.get(enc["@"], "length");
                  if (~indexOfObject(item.enclosures, enclosure, ["url", "type"])) {
                    item.enclosures.splice(indexOfObject(item.enclosures, enclosure, ["url", "type"]), 1, enclosure);
                  } else {
                    item.enclosures.push(enclosure);
                  }
                });
              } else {
                enclosure = {};
                enclosure.url = _.get(el["@"], "url");
                enclosure.type = _.get(el["@"], "type");
                enclosure.length = _.get(el["@"], "length");
                if (~indexOfObject(item.enclosures, enclosure, ["url", "type"])) {
                  item.enclosures.splice(indexOfObject(item.enclosures, enclosure, ["url", "type"]), 1, enclosure);
                } else {
                  item.enclosures.push(enclosure);
                }
              }
              break;
            case "media:content":
              var optionalAttributes = ["bitrate", "framerate", "samplingrate", "duration", "height", "width"];
              if (Array.isArray(el)) {
                el.forEach(function(enc) {
                  enclosure = {};
                  enclosure.url = _.get(enc["@"], "url");
                  enclosure.type = _.get(enc["@"], "type") || _.get(enc["@"], "medium");
                  enclosure.length = _.get(enc["@"], "filesize");
                  var index2 = indexOfObject(item.enclosures, enclosure, ["url", "type"]);
                  if (index2 !== -1) {
                    enclosure = item.enclosures[index2];
                  }
                  optionalAttributes.forEach(function(attribute) {
                    if (!enclosure[attribute] && _.get(enc["@"], attribute)) {
                      enclosure[attribute] = _.get(enc["@"], attribute);
                    }
                  });
                  if (index2 === -1) {
                    item.enclosures.push(enclosure);
                  }
                });
              } else {
                enclosure = {};
                enclosure.url = _.get(el["@"], "url");
                enclosure.type = _.get(el["@"], "type") || _.get(el["@"], "medium");
                enclosure.length = _.get(el["@"], "filesize");
                var index = indexOfObject(item.enclosures, enclosure, ["url", "type"]);
                if (index !== -1) {
                  enclosure = item.enclosures[index];
                }
                optionalAttributes.forEach(function(attribute) {
                  if (!enclosure[attribute] && _.get(el["@"], attribute)) {
                    enclosure[attribute] = _.get(el["@"], attribute);
                  }
                });
                if (index === -1) {
                  item.enclosures.push(enclosure);
                }
              }
              break;
            case "enc:enclosure":
              break;
            case "category":
            case "dc:subject":
            case "itunes:category":
            case "media:category":
              var _category = "", _categories = [];
              if (Array.isArray(el)) {
                el.forEach(function(category) {
                  if ("category" == name && "atom" == type) {
                    if (category["@"] && _.get(category["@"], "term")) item.categories.push(_.get(category["@"], "term"));
                  } else if ("category" == name && _.get(category) && "rss" == type) {
                    item.categories.push(_.get(category).trim());
                  } else if ("dc:subject" == name && _.get(category)) {
                    _categories = _.get(category).split(" ").map(function(cat) {
                      return cat.trim();
                    });
                    if (_categories.length) item.categories = item.categories.concat(_categories);
                  } else if ("itunes:category" == name) {
                    if (category["@"] && _.get(category["@"], "text")) _category = _.get(category["@"], "text");
                    if (category[name]) {
                      if (Array.isArray(category[name])) {
                        category[name].forEach(function(subcategory) {
                          if (subcategory["@"] && _.get(subcategory["@"], "text")) item.categories.push(_category + "/" + _.get(subcategory["@"], "text"));
                        });
                      } else {
                        if (category[name]["@"] && _.get(category[name]["@"], "text"))
                          item.categories.push(_category + "/" + _.get(category[name]["@"], "text"));
                      }
                    } else {
                      item.categories.push(_category);
                    }
                  } else if ("media:category" == name) {
                    item.categories.push(_.get(category));
                  }
                });
              } else {
                if ("category" == name && "atom" == type) {
                  if (_.get(el["@"], "term")) item.categories.push(_.get(el["@"], "term"));
                } else if ("category" == name && _.get(el) && "rss" == type) {
                  item.categories.push(_.get(el).trim());
                } else if ("dc:subject" == name && _.get(el)) {
                  _categories = _.get(el).split(" ").map(function(cat) {
                    return cat.trim();
                  });
                  if (_categories.length) item.categories = item.categories.concat(_categories);
                } else if ("itunes:category" == name) {
                  if (el["@"] && _.get(el["@"], "text")) _category = _.get(el["@"], "text");
                  if (el[name]) {
                    if (Array.isArray(el[name])) {
                      el[name].forEach(function(subcategory) {
                        if (subcategory["@"] && _.get(subcategory["@"], "text")) item.categories.push(_category + "/" + _.get(subcategory["@"], "text"));
                      });
                    } else {
                      if (el[name]["@"] && _.get(el[name]["@"], "text"))
                        item.categories.push(_category + "/" + _.get(el[name]["@"], "text"));
                    }
                  } else {
                    item.categories.push(_category);
                  }
                } else if ("media:category" == name) {
                  item.categories.push(_.get(el));
                }
              }
              break;
            case "feedburner:origlink":
            case "pheedo:origlink":
              if (!item.origlink) {
                item.origlink = _.get(el);
              }
              break;
          }
        }
        if (name.indexOf("#") !== 0) {
          if (~name.indexOf(":")) item[name] = el;
          else item[type + ":" + name] = el;
        }
      }, this);
      if (normalize2) {
        if (!item.description) {
          if (node["itunes:summary"]) item.description = _.get(node["itunes:summary"]);
        }
        if (!item.author) {
          if (node["itunes:author"]) item.author = _.get(node["itunes:author"]);
          else if (node["itunes:owner"] && node["itunes:owner"]["itunes:name"]) item.author = _.get(node["itunes:owner"]["itunes:name"]);
          else if (node["dc:publisher"]) item.author = _.get(node["dc:publisher"]);
        }
        if (!item.image.url) {
          if (node["itunes:image"]) item.image.url = _.get(node["itunes:image"]["@"], "href");
          else if (node["media:thumbnail"]) {
            if (Array.isArray(node["media:thumbnail"])) {
              item.image.url = _.get(node["media:thumbnail"][0]["@"], "url");
            } else {
              item.image.url = _.get(node["media:thumbnail"]["@"], "url");
            }
          } else if (node["media:content"] && node["media:content"]["media:thumbnail"]) item.image.url = _.get(node["media:content"]["media:thumbnail"]["@"], "url");
          else if (node["media:group"] && node["media:group"]["media:thumbnail"]) item.image.url = _.get(node["media:group"]["media:thumbnail"]["@"], "url");
          else if (node["media:group"] && node["media:group"]["media:content"] && node["media:group"]["media:content"]["media:thumbnail"]) item.image.url = _.get(node["media:group"]["media:content"]["media:thumbnail"]["@"], "url");
          else if (node["g:image_link"]) item.image.url = _.get(node["g:image_link"]);
        }
        if (item.categories.length) {
          item.categories = _.uniq(item.categories);
        }
        if (!item.link) {
          if (item.guid && /^https?:/.test(item.guid)) {
            item.link = item.guid;
          }
        }
        item.title = item.title && _.stripHtml(item.title);
      }
      return item;
    };
    FeedParser2.prototype._transform = function(data, encoding, done) {
      try {
        this.stream.write(data);
        done();
      } catch (e) {
        done(e);
        this.push(null);
      }
    };
    FeedParser2.prototype._flush = function(done) {
      try {
        this.stream.end();
        done();
      } catch (e) {
        done(e);
      }
    };
    exports2 = module2.exports = FeedParser2;
  }
});

// node_modules/feedparser/index.js
var require_feedparser2 = __commonJS({
  "node_modules/feedparser/index.js"(exports2, module2) {
    module2.exports = require_feedparser();
  }
});

// src/index.js
var src_exports = {};
__export(src_exports, {
  fetchAlert: () => fetchAlert,
  fetchAlerts: () => fetchAlerts,
  fetchFeed: () => fetchFeed,
  parseAlert: () => parseAlert,
  parseFeed: () => parseFeed
});
module.exports = __toCommonJS(src_exports);
var import_lodash2 = __toESM(require_lodash());
var import_common2 = __toESM(require_lib5());
var import_xml2js2 = __toESM(require_xml2js());
var import_http_client = __toESM(require_lib8());
var import_cap_common = __toESM(require_lib12());
var import_feedparser = __toESM(require_feedparser2());

// src/utils.js
var import_lodash = __toESM(require_lodash());
var import_common = __toESM(require_lib5());
var import_xml2js = __toESM(require_xml2js());
var DEFAULT_REQUEST_HEADERS = {
  accept: "*/*",
  "content-type": "application/xml",
  "user-agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"
};
var XML_PARSE_OPTIONS = {
  trim: true,
  explicitArray: false,
  explicitRoot: false,
  tagNameProcessors: [import_xml2js.processors.stripPrefix]
};
var normalize = (obj = {}) => {
  const normalized = (0, import_lodash.omitBy)(obj, (value, key) => {
    return (0, import_lodash.startsWith)(key, "rss") || (0, import_lodash.startsWith)(key, "atom") || (0, import_lodash.startsWith)(key, "#") || (0, import_lodash.startsWith)(key, "@") || (0, import_lodash.startsWith)(key, "$") || (0, import_lodash.startsWith)(key, "Signature");
  });
  return (0, import_common.mergeObjects)(normalized);
};

// src/index.js
var parseAlert = (alertXml) => {
  return (0, import_xml2js2.parseStringPromise)(alertXml, XML_PARSE_OPTIONS).then((alertJson) => {
    const alert = (0, import_cap_common.normalizeAlert)(normalize(alertJson));
    return alert;
  });
};
var parseFeed = (source) => new Promise((resolve, reject) => {
  const feedParser = new import_feedparser.default({ addmeta: false });
  const feed = { channel: {}, items: [] };
  source.on("error", (error) => reject(error));
  feedParser.on("error", (error) => reject(error));
  feedParser.on("end", () => resolve(feed));
  feedParser.on("meta", (meta) => {
    feed.channel = normalize(meta);
  });
  feedParser.on("readable", function onReadable() {
    const stream = this;
    let item;
    while ((item = stream.read()) !== null) {
      const copyOfItem = normalize(item);
      feed.items = (0, import_common2.compact)([...feed.items, copyOfItem]);
    }
  });
  source.pipe(feedParser);
});
var fetchAlert = (optns) => {
  const { url, ...options } = (0, import_common2.mergeObjects)(optns, {
    responseType: "text",
    headers: DEFAULT_REQUEST_HEADERS
  });
  return (0, import_http_client.get)(url, options).then((alertXml) => {
    return parseAlert(alertXml);
  });
};
var fetchFeed = (optns) => {
  const { url, ...options } = (0, import_common2.mergeObjects)(optns, {
    responseType: "stream",
    headers: DEFAULT_REQUEST_HEADERS
  });
  return (0, import_http_client.get)(url, options).then((response) => {
    return parseFeed(response);
  });
};
var fetchAlerts = (optns) => {
  return fetchFeed(optns).then(({ channel = {}, items = [] }) => {
    const urls = (0, import_common2.compact)((0, import_lodash2.map)([...items], (item) => item.link));
    const tasks = (0, import_lodash2.map)(urls, (url) => fetchAlert((0, import_common2.mergeObjects)(optns, { url })));
    return (0, import_http_client.all)(...tasks).then((alerts) => {
      return { channel, items: alerts };
    });
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  fetchAlert,
  fetchAlerts,
  fetchFeed,
  parseAlert,
  parseFeed
});
/**
 * @constant DEFAULT_REQUEST_HEADERS
 * @name DEFAULT_REQUEST_HEADERS
 * @description Default http request headers
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @private
 * @ignore
 */
/**
 * @constant XML_PARSE_OPTIONS
 * @name XML_PARSE_OPTIONS
 * @description Default xml parse options
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @private
 * @ignore
 */
/**
 * @function normalize
 * @name normalize
 * @description Normalize object to remove unused properties
 * @param {object} obj valid object to normalize.
 * @returns {object} normalize object
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @public
 * @example
 *
 * normalize(obj);
 * // => { ... }
 */
/**
 * @function parseAlert
 * @name parseAlert
 * @description Parse given alert from xml to json
 * @param {string} alertXml valid alert xml.
 * @returns {Promise} promise resolve with alert on success
 * or error on failure.
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @public
 * @example
 *
 * parseAlert(alertXml)
 *   .then(alert => { ... }) // => { identifier: ..., info: { ... } }
 *   .catch(error => { ... });
 */
/**
 * @function parseFeed
 * @name parseFeed
 * @description Parse given alert feed from xml to json
 * @param {object} source valid alert feed readable stream.
 * @returns {Promise} promise resolve with alert feed on success
 * or error on failure.
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @public
 * @example
 *
 * parseFeed(readableStream)
 *   .then(feed => { ... }) // => { channel: ..., items: { ... } }
 *   .catch(error => { ... });
 */
/**
 * @function fetchAlert
 * @name fetchAlert
 * @description Issue http get request to fetch specific alert.
 * @param {object} optns valid fetch options.
 * @param {string} optns.url valid alert full url.
 * @returns {Promise} promise resolve with alert in CAP format on success
 * or error on failure.
 * @see {@link http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html}
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @public
 * @example
 *
 * const optns = { url: ... };
 * fetchAlert(optns)
 *   .then(alert => { ... })
 *   .catch(error => { ... });
 */
/**
 * @function fetchFeed
 * @name fetchFeed
 * @description Issue http get request to fetch alerts feed.
 * @param {object} optns valid fetch options.
 * @param {string} optns.url valid alert feed full url.
 * @returns {Promise} promise resolve with alerts in feed format on success
 * or error on failure.
 * @see {@link https://cyber.harvard.edu/rss/rss.html}
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @public
 * @example
 *
 * const optns = { url: ... };
 * fetchFeed(optns)
 *   .then(alert => { ... })
 *   .catch(error => { ... });
 */
/**
 * @function fetchAlerts
 * @name fetchAlerts
 * @description Issue http get request to fetch alerts from feed.
 * @param {object} optns valid fetch options.
 * @param {string} optns.url valid alert feed full url.
 * @returns {Promise} promise resolve with alerts in CAP format on success
 * or error on failure.
 * @see {@link http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html}
 * @author lally elias <lallyelias87@mail.com>
 * @license MIT
 * @since 0.1.0
 * @version 0.1.0
 * @static
 * @public
 * @example
 *
 * const optns = { url: ... };
 * fetchAlerts(optns)
 *   .then(alert => { ... })
 *   .catch(error => { ... });
 */
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

inflection/lib/inflection.js:
  (*!
   * inflection
   * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
   * MIT Licensed
   *
   * @fileoverview
   * A port of inflection-js to node.js module.
   *)

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@lykmapipo/common/lib/index.js:
  (**
   * @name RESOURCE_ACTIONS
   * @description Default resource actions
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @private
   *)
  (**
   * @function isNotValue
   * @name isNotValue
   * @description Check if variable has no associated state or has empty state
   * @param {*} value variable to check
   * @returns {boolean} whether variable contain state
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.10.0
   * @version 0.3.0
   * @static
   * @public
   * @example
   *
   * const notValue = isNotValue('a');
   * // => false
   *
   * const notValue = isNotValue(null);
   * // => true
   *)
  (**
   * @function isValue
   * @name isValue
   * @description Check if variable has associated state or has no empty state
   * @param {*} value variable to check
   * @returns {boolean} whether variable contain state
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.40.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * const notValue = isValue('a');
   * // => true
   *
   * const notValue = isValue(null);
   * // => false
   *)
  (**
   * @function firstValue
   * @name firstValue
   * @description Obtain first valid value
   * @param {*} values list of values
   * @returns {*} first valid value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.36.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * firstValue('a', 'b');
   * // => 'a'
   *
   * firstValue(undefined, 'b');
   * // => 'b'
   *)
  (**
   * @function copyOf
   * @name copyOf
   * @description Recursively clone a value
   * @param {*} value valid value to clone
   * @returns {*} cloned value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.25.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const copy = copyOf('a');
   * // => 'a'
   *
   * const copy = copyOf({ 'a': 1 });
   * // => { 'a': 1 }
   *)
  (**
   * @function mapToUpper
   * @name mapToUpper
   * @description Convert list of values to upper values
   * @param {...string} values list to convert to upper
   * @returns {string[]} list of upper values
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.12.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const mapToUpper = mapToUpper('a');
   * // => ['A']
   *
   * const mapToUpper = mapToUpper(['a', 'b'], 'c');
   * // => ['A', 'B', 'C']
   *)
  (**
   * @function mapToLower
   * @name mapToLower
   * @description Convert list of values to lower values
   * @param {...string} values list to convert to lower
   * @returns {string[]} list of lower values
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.12.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const mapToLower = mapToLower('A');
   * // => ['a']
   *
   * const mapToLower = mapToLower(['A', 'B'], 'C');
   * // => ['a', 'b', 'c']
   *)
  (**
   * @function areNotEmpty
   * @name areNotEmpty
   * @description Check if provided values are not empty
   * @param {...string} values set of values to check for emptiness
   * @returns {boolean} whether values are not empty
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * const notEmpty = areNotEmpty('a', 'b', 'c');
   * // => true
   *
   * const notEmpty = areNotEmpty('a', 'b', null);
   * // => false
   *)
  (**
   * @function compact
   * @name compact
   * @description Creates new array(or object) with all falsey values removed.
   * The values false, null, 0, "", undefined, and NaN are falsey.
   * @param {Array|object} value The array(or object) to compact.
   * @returns {object|Array} new array(or object) of filtered values.
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const b = compact([null, 1, "", undefined]);
   * // => [ 1 ]
   *
   * const y = compact({a: 1, b: "", c: undefined});
   * // => { a: 1 }
   *)
  (**
   * @function uniq
   * @name uniq
   * @description Creates new duplicate-free version of array(or object).
   * @param {Array|object} value The array(or object) to inspect.
   * @returns {object|Array} new duplicate free array(or object).
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const b = uniq([null, 1, 1, "", undefined, 2]);
   * // => [ 1, 2 ]
   *
   * const y = uniq({a: 1, b: "", c: undefined});
   * // => { a: 1 }
   *)
  (**
   * @function sortedUniq
   * @name sortedUniq
   * @description Creates new duplicate-free version of sorted array(or object).
   * @param {Array|object} value The array(or object) to inspect.
   * @returns {object|Array} new duplicate free sorted array(or object).
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const b = sortedUniq([null, 1, 2, "", undefined, 1]);
   * // => [ 1, 2 ]
   *
   * const y = sortedUniq({a: 1, b: "", c: undefined});
   * // => { a: 1 }
   *)
  (**
   * @function assign
   * @name assign
   * @description Assign a list of objects into a single object
   *
   * Note:** This method mutates `object`.
   * @param {object} [object={}] destination object
   * @param {...object} objects list of objects
   * @returns {object} a merged object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.26.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const obj = { a: 1 };
   * assign(obj, { b: 1 }, { c: 2});
   * // => { a: 1, b: 1, c: 2 }
   *)
  (**
   * @function mergeObjects
   * @name mergeObjects
   * @description Merge a list of objects into a single object
   * @param {...object} objects list of objects
   * @returns {object} a merged object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.10.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const obj = mergeObjects({ a: 1 }, { b: 1 }, { c: 2}, { c: 2}, {b: null})
   * // => { a: 1, b: 1, c: 2 }
   *)
  (**
   * @function safeMergeObjects
   * @name safeMergeObjects
   * @description Merge a list of objects into a single object without
   * cloning sources
   * @param {...object} objects list of objects
   * @returns {object} a merged object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.31.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const obj = safeMergeObjects({ a: 1 }, { b: 1 }, { c: 2}, { c: 2}, {b: null})
   * // => { a: 1, b: 1, c: 2 }
   *)
  (**
   * @function pkg
   * @name pkg
   * @description Read package information
   * @param {string} [path] valid path to package.json file
   * @param {...string} field fields to pick from package
   * @returns {object} current process package information
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.3.0
   * @static
   * @public
   * @example
   *
   * const { name, version } = pkg();
   * // => { name: ..., version: ...}
   *
   * const { name, version } = pkg(__dirname);
   * // => { name: ..., version: ...}
   *)
  (**
   * @function scopesFor
   * @name scopesFor
   * @description Generate resource scopes
   * @param {...string} resources valid resources
   * @returns {string[]} resources scopes
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.6.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const scopes = scopesFor('user')
   * // => ['user:create', 'user:view']
   *)
  (**
   * @function permissionsFor
   * @name permissionsFor
   * @description Generate resource permissions
   * @param {...string} resources valid resources
   * @returns {object[]} resources permissions
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.28.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const permissions = permissionsFor('User')
   * // => [{resource: 'User', wildcard: 'user:create', action: ...}, ....];
   *)
  (**
   * @function abbreviate
   * @name abbreviate
   * @description Generate shortened form of word(s) or phrase.
   * @param {...string} words set of words to derive abbreaviation
   * @returns {string} abbreviation
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.6.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const abbreaviation = abbreviate('Ministry of Finance')
   * // => MoF
   *)
  (**
   * @function idOf
   * @name idOf
   * @description Obtain an id or a given object
   * @param {object} data object to pick id from
   * @returns {*} id of a given object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.10.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const id = idOf({ id: 1 })
   * // => 1
   *
   * const id = idOf({ _id: 1 })
   * // => 1
   *)
  (**
   * @function variableNameFor
   * @name variableNameFor
   * @description Produce camelize variable name based on passed strings
   * @param {...string} names list of strings to produce variable name
   * @returns {string} camelized variable name
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.10.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const name = variableNameFor('get', 'name');
   * // => getName
   *
   * const name = variableNameFor('pick', 'a', 'name');
   * // => pickAName
   *)
  (**
   * @function has
   * @name has
   * @description Check if value is in a collection
   * @param {Array} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @returns {boolean} whether value is in collection
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.11.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const hasValue = has([ 1, 2 ], 1);
   * // => true
   *
   * const hasValue = has([ 'a', 'b' ], 'c');
   * // => false
   *)
  (**
   * @function hasAll
   * @name hasAll
   * @description Check if all value are in a collection
   * @param {Array} collection The collection to inspect.
   * @param {*} values The values to search for.
   * @returns {boolean} whether values are in collection
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.11.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const hasValues = hasAll([ 1, 2 ], 1, 2);
   * // => true
   *
   * const hasValues = hasAll([ 1, 2 ], [ 1, 2 ]);
   * // => true
   *
   * const hasValues = hasAll([ 'a', 'b' ], 'c', 'd');
   * // => false
   *)
  (**
   * @function hasAny
   * @name hasAny
   * @description Check if any value is in a collection
   * @param {Array} collection The collection to inspect.
   * @param {*} values The values to search for.
   * @returns {boolean} whether any value is in collection
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.11.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const hasValues = hasAny([ 1, 2 ], 1, 2);
   * // => true
   *
   * const hasValues = hasAny([ 1, 2 ], [ 1, 2 ]);
   * // => true
   *
   * const hasValues = hasAny([ 'a', 'b' ], 'b', 'd');
   * // => true
   *
   * const hasValues = hasAny([ 'a', 'b' ], 'c', 'd');
   * // => false
   *)
  (**
   * @function normalizeError
   * @name normalizeError
   * @description Normalize error instance with name, code, status and message.
   *
   * Note:** This method mutates `object`.
   * @param {Error} error valid error instance
   * @param {object} [options] additional convert options
   * @param {string} [options.name=Error] default error name
   * @param {string} [options.code=500] default error code
   * @param {string} [options.status=500] default error status
   * @param {string} [options.message=500] default error message
   * @see {@link https://jsonapi.org/format/#errors}
   * @returns {Error} normalized error object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.26.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const body = normalizeError(new Error('Missing API Key'));
   * // => error.status = 500;
   *)
  (**
   * @function bagify
   * @name bagify
   * @description Normalize errors bag to light weight object
   * @param {object} errors valid errors bag
   * @returns {object} formatted errors bag
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.14.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * const body = bagify({name : new Error('Validation Error') });
   * // => { name: { name: 'Error', message: 'Name Required'}, ... }
   *)
  (**
   * @function mapErrorToObject
   * @name mapErrorToObject
   * @description Convert error instance to light weight object
   * @param {Error} error valid error instance
   * @param {object} [options] additional convert options
   * @param {string} [options.name=Error] default error name
   * @param {string} [options.code=500] default error code
   * @param {string} [options.stack=false] whether to include error stack
   * @param {string} [options.status=500] default error status
   * @see {@link https://jsonapi.org/format/#errors}
   * @returns {object} formatted error object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.13.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const body = mapErrorToObject(new Error('Missing API Key'));
   * // => { name:'Error', message: 'Missing API Key', ... }
   *)
  (**
   * @function osInfo
   * @name osInfo
   * @description Obtain operating system information
   * @returns {object} os information object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.14.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const info = osInfo();
   * // => { arch:'x64', ... }
   *)
  (**
   * @function processInfo
   * @name processInfo
   * @description Obtain current process information
   * @returns {object} current process information
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.15.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const info = processInfo();
   * // => { pid: 8989, ... }
   *)
  (**
   * @function randomColor
   * @name randomColor
   * @description Generating attractive random colors
   * @param {object} [optns] valid generator options
   * @param {string} [optns.luminosity=light] controls the luminosity of the
   * generated color. you can specify a string containing `bright`, `light` or
   * `dark`.
   * @returns {string} random color
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.18.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const color = randomColor();
   * // => #C349D8
   *)
  (**
   * @function formatDate
   * @name formatDate
   * @description Format a date using specified format
   * @param {Date} [date=new Date()] valid date instance
   * @param {string} [format='YYYY-MM-DD'] valid date format
   * @returns {string} formatted date string
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.19.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const date = formatDate(new Date(), 'YYYY-MM-DD');
   * // => 2019-05-30
   *)
  (**
   * @function parseDate
   * @name parseDate
   * @description Parse a date in UTC from specified format
   * @param {string} date valid date string
   * @param {string} [format='YYYY-MM-DD'] valid date format
   * @returns {string} parsed date object in UTC
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.41.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const date = parseDate('2019-05-30', 'YYYY-MM-DD');
   * // => Thu May 30 2019 ...
   *)
  (**
   * @function hashOf
   * @name hashOf
   * @description Generate hash of provided object
   * @param {object} object valid object to hash
   * @param {...string} [ignore] properties to ignore
   * @returns {string} valid object hash
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.21.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const hash = hashOf({ foo: 'bar' })
   * // => '67b69634f9880a282c14a0f0cb7ba20cf5d677e9'
   *)
  (**
   * @function parseTemplate
   * @name parseTemplate
   * @description Parse, format and render string based template
   * @param {string} template valid template
   * @param {object} data object valid object apply on template
   * @returns {string} formatted string
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.21.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const template = 'Hello {name}, you have {count} unread messages';
   * const formatted = parseTemplate(template, { name: 'John', count: 12 });
   * // => 'Hello John, you have 12 unread messages'
   *)
  (**
   * @function stripHtmlTags
   * @name stripHtmlTags
   * @description Strip HTML tags from a string
   * @param {string} html valid html string
   * @returns {string} string with no html tags
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.21.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const html = 'lorem ipsum <strong>dolor</strong> <em>sit</em> amet';
   * const formatted = stripHtmlTags(html);
   * // => 'lorem ipsum dolor sit amet'
   *)
  (**
   * @function stringify
   * @name stringify
   * @description Safely converts a given value to a JSON string
   * @param {*} value valid value
   * @returns {string} JSON string of a value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.22.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const value = { x: 5, y: 6 };
   * const string = stringify(value);
   * // => '{"x":5,"y":6}'
   *)
  (**
   * @function parse
   * @name parse
   * @description Safely parses a JSON string to a value
   * @param {string} value JSON string of a value
   * @returns {*} valid value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.22.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const string = '{"x":5,"y":6}';
   * const value = parse(value);
   * // => { x: 5, y: 6 }
   *)
  (**
   * @function pluralize
   * @name pluralize
   * @description Convert a given string value to its plural form
   * @param {string} value subject value
   * @returns {string} plural form of provided string
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.24.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * pluralize('person');
   * // => people
   *
   * pluralize('Hat');
   * // => Hats
   *)
  (**
   * @function singularize
   * @name singularize
   * @description Convert a given string value to its singular form
   * @param {string} value subject value
   * @returns {string} singular form of provided string
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.24.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * singularize('people');
   * // => person
   *
   * singularize('Hats');
   * // => Hat
   *)
  (**
   * @function autoParse
   * @name autoParse
   * @description Safely auto parse a given value to js object
   * @param {*} value subject to parse
   * @param {...string} [fields] subject fields to apply auto parse
   * @returns {*} valid js object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.24.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * autoParse('5');
   * // => 5
   *
   * autoParse('{"x":5,"y":6}');
   * // => { x: 5, y: 6 }
   *
   * autoParse({ a: '5', b: '6' }, 'a'))
   * // => { a: 5, b: '6' }
   *)
  (**
   * @function flat
   * @name flat
   * @description Flatten a nested object
   * @param {object} value valid object to flatten
   * @returns {object} flatten object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.27.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const value = { a: { b: { c: 2 } } };
   * flat(value);
   * // => { 'a.b.c': 2 }
   *)
  (**
   * @function unflat
   * @name unflat
   * @description Unflatten object to nested object
   * @param {object} value valid object to un flatten
   * @returns {object} nested object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.27.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const value = { 'a.b.c': 2 };
   * unflat(value);
   * // => { a: { b: { c: 2 } } };
   *)
  (**
   * @function join
   * @name join
   * @description Converts array values into a string separated by separator
   * @param {string[]} values list to convert to string
   * @param {string} [separator=', '] valid separator
   * @param {string} [property] property to pick when value is object
   * @returns {string} joined values
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.29.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const join = join('a');
   * // => 'a'
   *
   * const join = join(['a', 'b']);
   * // => 'a, b, c'
   *
   * const join = join([{ a: 'c' }, 'b'], ', ', 'c');
   * // => 'c, b'
   *)
  (**
   * @function transform
   * @name transform
   * @description Preprocess given values according to provided transformers
   * @param {*} vals value to be convert
   * @param {Function} [transformers] iteratee function which receive result
   * `value` to be transformed
   * @returns {*} resulted value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.43.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const transform = transform(['a']);
   * // => ['a']
   *
   * const transform = transform([1, '2'], _.toNumber);
   * // => [1, 2]
   *)
  (**
   * @function arrayToObject
   * @name arrayToObject
   * @description Converts array values into an object
   * @param {string[]} array array to convert to object
   * @param {Function} [transformer] iteratee function which receive result
   * `object` and current `key` to be transformed
   * @returns {object} resulted object or empty
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.33.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const arrayToObject = arrayToObject(['a']);
   * // => { a: 'a' }
   *
   * const arrayToObject = arrayToObject(['a', 'b']);
   * // => { a: 'a', b: 'b' }
   *)
  (**
   * @function parseMs
   * @name parseMs
   * @description Safely parse a given millisecond absolute value into js object
   * @param {number} ms valid millisecond value
   * @returns {object} valid js object
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.34.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * parseMs(1337000001);
   * // => {
   *     days: 15,
   *     hours: 11,
   *     minutes: 23,
   *     seconds: 20,
   *     milliseconds: 1,
   *     microseconds: 0,
   *     nanoseconds: 0,
   *   }
   *)
  (**
   * @function wrapCallback
   * @name wrapCallback
   * @description Wrap callback with default args
   * @param {Function} cb valid function to wrap
   * @param {...object} [defaultArgs] default arguments to wrapped function
   * @returns {Function} wrapped function.
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.35.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * wrapCallback(cb, defaults);
   * // => fn
   *)
  (**
   * @function classify
   * @name classify
   * @description Convert a given string value to its class name form
   * @param {string} value subject value
   * @returns {string} plural form of provided string
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.37.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * classify('Health Center');
   * // => HealthCenter
   *)
  (**
   * @function tryCatch
   * @name tryCatch
   * @description Attempts to invoke `func`, returning either the result or
   * `defaultValue` on error
   * @param {Function} func The function to attempt.
   * @param {*} defaultValue value to return on error
   * @returns {*} `func` result or `defaultValue`.
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.38.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * tryCatch(() => 1, 0);
   * //=> 1
   *
   * tryCatch(() => { throw new Error('Failed'); }, {});
   * // => {}
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

deep-extend/lib/deep-extend.js:
  (*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)

@lykmapipo/env/lib/index.js:
  (**
   * @function load
   * @name load
   * @description Load environment variables from .env file only once
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.7.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * import { load } from '@lykmapipo/env';
   * const env = load();
   *)
  (**
   * @function mapToNumber
   * @name mapToNumber
   * @description Convert provided value to number
   * @param {*} value valid value
   * @returns {number} value as number
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.7.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { mapToNumber } from '@lykmapipo/env';
   * const age = mapToNumber('3.2');
   * // => 3.2
   *)
  (**
   * @function mapToString
   * @name mapToString
   * @description Convert provided value to string
   * @param {*} value valid value
   * @returns {string} value as string
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.7.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { mapToString } from '@lykmapipo/env';
   * const age = mapToString(3.2);
   * // => '3.2'
   *)
  (**
   * @function set
   * @name set
   * @description Set environment variable
   * @param {string} key value key
   * @param {*} [value] value to set on key
   * @returns {*} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { set } from '@lykmapipo/env';
   * const BASE_PATH = set('BASE_PATH', process.cwd());
   *)
  (**
   * @function get
   * @name get
   * @description Get environment variable
   * @param {string} key value key
   * @param {*} [defaultValue] value to return if key not exists
   * @returns {*} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { get } from '@lykmapipo/env';
   * const BASE_PATH = get('BASE_PATH', process.cwd());
   *)
  (**
   * @function clear
   * @name clear
   * @description Clear environment variables
   * @param {...string} keys valid keys
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.9.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { clear } from '@lykmapipo/env';
   * clear('BASE_PATH');
   * process.env.BASE_PATH;
   * // => undefined
   *)
  (**
   * @function getArray
   * @name getArray
   * @description Get array value from environment variable
   * @param {string} key value key
   * @param {Array} [defaultValue] value to return if key not exists
   * @param {object} [optns] valid options
   * @param {boolean} [optns.merge=true] whether to merge default values
   * @param {boolean} [optns.unique=true] whether to ensure unique values
   * @returns {Array} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * import { getArray } from '@lykmapipo/env';
   * const categories = getArray('CATEGORIES');
   * // => ['Fashion', 'Technology']
   *)
  (**
   * @function getNumbers
   * @name getNumbers
   * @description Get array of numbers from environment variable
   * @param {string} key value key
   * @param {number[]} [defaultValue] value to return if key not exists
   * @param {object} [optns] valid options
   * @param {boolean} [optns.merge=true] whether to merge default values
   * @param {boolean} [optns.unique=true] whether to ensure unique values
   * @returns {number[]} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * import { getNumbers } from '@lykmapipo/env';
   * const ages = getNumbers('AGES');
   * // => [11, 18]
   *)
  (**
   * @function getNumber
   * @name getNumber
   * @description Get number value from environment variable
   * @param {string} key value key
   * @param {number} [defaultValue] value to return if key not exists
   * @returns {number} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { getNumber } from '@lykmapipo/env';
   * const defaultAge = getNumber('DEFAULT_AGE');
   * // => 11
   *)
  (**
   * @function getString
   * @name getString
   * @description Get string value from environment variable
   * @param {string} key value key
   * @param {string} [defaultValue] value to return if key not exists
   * @returns {string} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { getString } from '@lykmapipo/env';
   * const category = getString('DEFAULT_CATEGORY');
   * // => 'Fashion'
   *)
  (**
   * @function getStrings
   * @name getStrings
   * @description Get array of strings from environment variable
   * @param {string} key value key
   * @param {string[]} [defaultValue] value to return if key not exists
   * @param {object} [optns] valid options
   * @param {boolean} [optns.merge=true] whether to merge default values
   * @param {boolean} [optns.unique=true] whether to ensure unique values
   * @returns {string[]} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * import { getStrings } from '@lykmapipo/env';
   * const categories = getStrings('CATEGORIES');
   * // => ['Fashion', 'Technology']
   *)
  (**
   * @function getStringSet
   * @name getStringSet
   * @description Get array of unique sorted strings from environment variable
   * @param {string} key value key
   * @param {string[]} [defaultValue] value to return if key not exists
   * @param {object} [optns] valid options
   * @param {boolean} [optns.merge=true] whether to merge default values
   * @param {boolean} [optns.unique=true] whether to ensure unique values
   * @returns {string[]} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.11.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * import { getStringSet } from '@lykmapipo/env';
   * const categories = getStringSet('CATEGORIES');
   * // => ['Fashion', 'Technology']
   *)
  (**
   * @function getBoolean
   * @name getBoolean
   * @description Get boolean value from environment variable
   * @param {string} key value key
   * @param {boolean} [defaultValue] value to return if key not exists
   * @returns {boolean} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { getBoolean } from '@lykmapipo/env';
   * const debug = getBoolean('DEBUG');
   * // => true
   *)
  (**
   * @function getObject
   * @name getObject
   * @description Get plain object value from environment variable
   * @param {string} key value key
   * @param {object} [defaultValue={}] value to return if key not exists
   * @returns {object} environment value
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.10.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * import { getObject } from '@lykmapipo/env';
   *
   * const object = getObject('OBJECT');
   * // => { lead: { ref: 'Person' } ... }
   *
   * const object = getObject('OBJECT_NOT_EXIST');
   * // => {}
   *)
  (**
   * @function is
   * @name is
   * @description Check if node environment is same as given
   * @param {string} env value of env to test
   * @returns {boolean} true if its a tested node environment else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { is } from '@lykmapipo/env';
   * const test = is('TEST');
   * // => true
   *)
  (**
   * @function isTest
   * @name isTest
   * @description Check if node environment is test
   * @returns {boolean} true if its a test node environment else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { isTest } from '@lykmapipo/env';
   * const test = isTest();
   * // => true
   *)
  (**
   * @function isDevelopment
   * @name isDevelopment
   * @description Check if node environment is development
   * @returns {boolean} true if its a development node environment else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { isDevelopment } from '@lykmapipo/env';
   * const isDev = isDevelopment();
   * // => true
   *)
  (**
   * @function isProduction
   * @name isProduction
   * @description Check if node environment is production
   * @returns {boolean} true if its a production node environment else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { isProduction } from '@lykmapipo/env';
   * const isProd = isProduction();
   * // => true
   *)
  (**
   * @function isLocal
   * @name isLocal
   * @description Check if node environment is development or test
   * @returns {boolean} true if its a development or test node environment
   * else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { isLocal } from '@lykmapipo/env';
   * const local = isLocal();
   * // => true
   *)
  (**
   * @function isHeroku
   * @name isHeroku
   * @description Check if runtime environment is heroku
   * @returns {boolean} true if its runtime environment is heroku else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { isHeroku } from '@lykmapipo/env';
   * const heroku = isHeroku();
   * // => true
   *)
  (**
   * @function apiVersion
   * @name apiVersion
   * @description Parse api version from environment variable
   * @param {object} [optns] valid options
   * @param {string} [optns.version=1.0.0] value to use to parse api version
   * @param {string} [optns.prefix=v] prefix to set on parsed api version
   * @param {boolean} [optns.major=true] whether to allow major part
   * @param {boolean} [optns.minor=false] whether to allow minor part
   * @param {boolean} [optns.patch=false] whether to allow patch part
   * @returns {string} parsed environment api version
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { apiVersion } from '@lykmapipo/env';
   * const version = apiVersion(); // => v1
   * const version = apiVersion({ version: '2.0.0' }); // => v2
   *)
  (**
   * @function getLocale
   * @name getLocale
   * @description Obtain runtime locale
   * @param {string} [defaultLocale='sw'] valid default locale
   * @returns {string} valid runtime locale
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.9.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { getLocale } from '@lykmapipo/env';
   * const locale = getLocale();
   * // => sw
   *)
  (**
   * @function getCountryCode
   * @name getCountryCode
   * @description Obtain runtime country code
   * @param {string} [defaultCountryCode='TZ'] valid default country code
   * @returns {string} valid runtime country code
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.9.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { getCountryCode } from '@lykmapipo/env';
   * const countryCode = getCountryCode();
   * // => TZ
   *)
  (**
   * @function rcFor
   * @name rcFor
   * @description Load runtime configuration of a given module
   * @param {string} moduleName valid module name
   * @returns {object} runtime configurations
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.14.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * import { rcFor } from '@lykmapipo/env';
   * const config = rcFor('env');
   * // => { locale: 'sw', ... }
   *)

@lykmapipo/http-client/lib/index.js:
  (**
   * @function withDefaults
   * @name withDefaults
   * @description Merge provided options with defaults.
   * @param {object} [optns] provided options
   * @returns {object} merged options
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const optns = { baseUrl: ... };
   * const options = withDefaults(optns);
   * // => {baseUrl: ..., headers: { ... } };
   *)
  (**
   * @function createAgents
   * @name createAgents
   * @description Create http or https agent from options.
   * @param {object} [optns] provided request options
   * @param {object} [optns.agentOptions] valid http(s) agent options
   * @param {string} [optns.agentOptions.ca] valid ca
   * @param {string} [optns.agentOptions.cert] valid cert
   * @param {string} [optns.agentOptions.key] valid key
   * @param {string} [optns.agentOptions.passphrase] valid passphrase
   * @returns {object} valid http or https agent
   * @see {@link https://github.com/request/request#using-optionsagentoptions}
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.3.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const optns = {
   *  agentOptions: {
   *   cert: fs.readFileSync(certFilePath),
   *   key: fs.readFileSync(keyFilePath),
   *   passphrase: 'password',
   *   ca: fs.readFileSync(caFilePath),
   *   ...
   *  }
   * };
   *
   * const options = createAgents(optns);
   * // => { httpAgent: ..., httpsAgent: ... };
   *)
  (**
   * @function isFormData
   * @name isFormData
   * @description Determine if a value is a FormData
   * @param {*} value data to test
   * @returns {boolean} true if value is an FormData, otherwise false
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * isFormData({});
   * // => false;
   *
   * isFormData(new FormData());
   * // => true;
   *)
  (**
   * @function toFormData
   * @name toFormData
   * @description Convert given plain object to form data instance
   * @param {object} [data={}] valid data
   * @returns {object} valid form data instance
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const data = toFormData({ ... });
   * // => FormData{ ... };
   *)
  (**
   * @function normalizeRequest
   * @name normalizeRequest
   * @description Normalize http request with sensible config
   * @param {object} [request={}] valid request options
   * @returns {object} normalize request options
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const request = normalizeRequest({ ... }).
   * // => { ... };
   *)
  (**
   * @function mapResponseToData
   * @name mapResponseToData
   * @description Convert raw http response to data
   * @param {object} rawResponse raw http response
   * @returns {object} response data
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const data = mapResponseToData(rawResponse).
   * // => { .. };
   *)
  (**
   * @function mapResponseToError
   * @name mapResponseToError
   * @description Convert raw http response error to js native error
   * @param {object} rawResponse raw http response
   * @returns {Error} response error
   * @see {@link https://github.com/axios/axios#handling-errors}
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const error = mapResponseToError(rawResponse).
   * // => Error;
   *)
  (**
   * @function wrapRequest
   * @name wrapRequest
   * @description Wrap http request and convert raw response to error or data
   * @param {Promise} request valid http request
   * @param {boolean} [skipData=false] whether to skip map raw response to data
   * @returns {Promise} request with normalized response error and data
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const wrappedRequest = wrapRequest(request).
   * // => Promise;
   *)
  (**
   * @function createHttpClient
   * @name createHttpClient
   * @description Create http client if not exists
   * @param {object} [optns] valid http client options
   * @returns {object} instance of http client
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const optns = { baseURL: ... };
   * const httpClient = createHttpClient(optns);
   *)
  (**
   * @function disposeHttpClient
   * @name disposeHttpClient
   * @description Clear current http client in use.
   * @returns {object} null if client clear otherwise existing client;
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const httpClient = disposeHttpClient();
   * // => null
   *)
  (**
   * @function request
   * @name request
   * @description Issue http request using given options.
   * @param {object} optns valid request options
   * @returns {Promise} promise resolve with raw http response on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.2.0
   * @static
   * @public
   * @example
   *
   * request('/users')
   *   .then(response => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function spread
   * @name spread
   * @description Flattened array fullfillment to the formal parameters of
   * the fulfillment handler.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const getRoles = get('/roles');
   * const getUsers = get('/users');
   * const requests = all(getRoles(), getUsers());
   * request.then(spread((roles, users) => { ... }));
   *)
  (**
   * @function all
   * @name all
   * @description Performing multiple concurrent http requests.
   * @param {object[]} requests valid http requests
   * @returns {Promise} promise resolve with http response on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const getRoles = get('/roles');
   * const getUsers = get('/users');
   * const requests = all(getRoles(), getUsers());
   * request.then(spread((roles, users) => { ... }));
   *)
  (**
   * @function del
   * @name del
   * @description Issue http delete request to specified url.
   * @param {string} url valid http path.
   * @param {object} [optns={}] valid request options.
   * @returns {Promise} promise resolve with data on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * del('/users/5c1766243')
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function get
   * @name get
   * @description Issue http get request to specified url.
   * @param {string} url valid http path.
   * @param {object} [optns={}] valid request options.
   * @param {object} [optns.params] params that will be encoded into url
   * query params.
   * @returns {Promise} promise resolve with data on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * // list
   * const params = { age: { $in: [1, 2] } };
   * get('/users', { params })
   *   .then(users => { ... })
   *   .catch(error => { ... });
   *
   * // single
   * get('/users/5c1766243')
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function head
   * @name head
   * @description Issue http head request to specified url.
   * @param {string} url valid http path.
   * @param {object} [optns={}] valid request options.
   * @returns {Promise} promise resolve with raw http response on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * head('/users/5c1766243')
   *   .then({ headers } => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function options
   * @name options
   * @description Issue http options request to specified url.
   * @param {string} url valid http path.
   * @param {object} [optns={}] valid request options.
   * @returns {Promise} promise resolve with raw http response on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * options('/users/5c1766243')
   *   .then({ headers } => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function patch
   * @name patch
   * @description Issue http patch request to specified url.
   * @param {string} url valid http path.
   * @param {object} data request payload to be encoded on http request body
   * @param {object} [optns={}] valid request options.
   * @returns {Promise} promise resolve with data on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * // json request
   * patch('/users/5c1766243', { age: 14 })
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *
   * // multipart request
   * patch('/users/5c1766243', { age: 14 }, { multipart: true })
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *
   * // multipart request using form data
   * const form = new FormData()
   * patch('/users/5c1766243', form)
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function post
   * @name post
   * @description Issue http post request to specified url.
   * @param {string} url valid http path.
   * @param {object} data request payload to be encoded on http request body
   * @param {object} [optns={}] valid request options.
   * @returns {Promise} promise resolve with data on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * // json request
   * post('/users', { age: 14 })
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *
   * // multipart request
   * post('/users', { age: 14 }, { multipart: true })
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *
   * // multipart request using form data
   * const form = new FormData()
   * post('/users', form)
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function put
   * @name put
   * @description Issue http put request to specified url.
   * @param {string} url valid http path.
   * @param {object} data request payload to be encoded on http request body
   * @param {object} [optns={}] valid request options.
   * @returns {Promise} promise resolve with data on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * // json request
   * put('/users/5c1766243', { age: 14 })
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *
   * // multipart request
   * put('/users/5c1766243', { age: 14 }, { multipart: true })
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *
   * // multipart request using form data
   * const form = new FormData()
   * put('/users/5c1766243', form)
   *   .then(user => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function sendFile
   * @name sendFile
   * @description Issue http multipart request to specified url.
   * @param {string} url valid http path.
   * @param {object} data request payload to be encoded on http request body
   * @param {object} [optns={}] valid request options.
   * @returns {Promise} promise resolve with data on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * // send stream
   * const image = fs.createReadStream(imagePath);
   * sendFile('/files', { image })
   *   .then(file => { ... })
   *   .catch(error => { ... });
   *
   * // send buffer
   * const image = fs.readFileSync(imagePath);
   * sendFile('/files/5c1766243', { image }, { method: 'PATCH'})
   *   .then(file => { ... })
   *   .catch(error => { ... });
   *
   * // send form data
   * const image = document.getElementById('file').files[0];
   * sendFile('/files', { image })
   *   .then(file => { ... })
   *   .catch(error => { ... });
   *)
  (**
   * @function fetchFile
   * @name fetchFile
   * @description Issue http get request to fetch file from given url.
   * @param {string} url valid http path.
   * @param {object} [optns={}] valid request options.
   * @param {object} [optns.params] params that will be encoded into url
   * query params.
   * @returns {Promise} promise resolve with file stream on success
   * or error on failure.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * fetchFile('/files/5c1766243')
   *   .then(stream => { ... })
   *   .catch(error => { ... });
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@turf/isolines/dist/js/index.js:
  (**
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)

@turf/isobands/dist/js/index.js:
  (*!
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)

splaytree/dist/splay.js:
  (**
   * splaytree v3.1.0
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)

@lykmapipo/geo-tools/lib/index.js:
  (**
   * @function isValid
   * @name isValid
   * @description Determines if an object is a GeoJSON Object or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isValid(geojson);
   * // => true
   *)
  (**
   * @function isPoint
   * @name isPoint
   * @description Determines if an object is a GeoJSON Point or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isPoint(geojson);
   * // => true
   *)
  (**
   * @function isMultiPoint
   * @name isMultiPoint
   * @description Determines if an object is a GeoJSON MultiPoint or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isMultiPoint(geojson);
   * // => true
   *)
  (**
   * @function isLineString
   * @name isLineString
   * @description Determines if an object is a GeoJSON LineString or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isLineString(geojson);
   * // => true
   *)
  (**
   * @function isMultiLineString
   * @name isMultiLineString
   * @description Determines if an object is a GeoJSON MultiLineString or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isMultiLineString(geojson);
   * // => true
   *)
  (**
   * @function isPolygon
   * @name isPolygon
   * @description Determines if an object is a GeoJSON Polygon or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isPolygon(geojson);
   * // => true
   *)
  (**
   * @function isMultiPolygon
   * @name isMultiPolygon
   * @description Determines if an object is a GeoJSON MultiPolygon or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isMultiPolygon(geojson);
   * // => true
   *)
  (**
   * @function isGeometryCollection
   * @name isGeometryCollection
   * @description Determines if an object is a GeoJSON GeometryCollection or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isGeometryCollection(geojson);
   * // => true
   *)
  (**
   * @function isFeature
   * @name isFeature
   * @description Determines if an object is a GeoJSON Feature or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isFeature(geojson);
   * // => true
   *)
  (**
   * @function isFeatureCollection
   * @name isFeatureCollection
   * @description Determines if an object is a GeoJSON FeatureCollection or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isFeatureCollection(geojson);
   * // => true
   *)
  (**
   * @function isGeometry
   * @name isGeometry
   * @description Determines if an object is a GeoJSON geometry or not
   * @param {object} geojson valid geojson object
   * @param {Function} [cb] callback to invoke on success or failure
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.4.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * isGeometry(geojson);
   * // => true
   *)
  (**
   * @function centroidOf
   * @name centroidOf
   * @description Calculates the centroid of a geojson feature(s) using
   * the mean of all vertices
   * @param {object} geojson feature to be centered
   * @returns {object} an Object that can be used as centroid
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.5.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const point = centroidOf(polygon);
   * // => { type: 'Point', coordinates: [ ... ] }
   *)
  (**
   * @function parseCoordinateString
   * @name parseCoordinateString
   * @description Create geojson geometry or coordinate array from string
   * @param {string} coords string to extract geojson geometry or coordinates
   * @param {object} [optns={}] valid options
   * @param {string} [optns.delimiter=','] long, lat seperator from string
   * @param {string} [optns.separator=' '] long, lat pair seperator from string
   * @returns {object|Array|undefined} geojson geometry or coordinates
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.5.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const polygonString = '-4.7,39.3 -5.2,38.6 -6.1,40.1 -4.9,39.8 -4.7,39.3'
   * const polygon = parseCoordinateString(polygonString);
   * // => { type: 'Polygon', coordinates: [ ... ] }
   *
   * const cicleString = '-9.2,39.5 180';
   * const polygon = parseCoordinateString(cirlceString);
   * // => { type: 'Polygon', coordinates: [ ... ] }
   *)
  (**
   * @function randomLongitude
   * @name randomLongitude
   * @description Generate random longitude
   * @param {object} [optns={}] valid option
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid longitude
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * const longitude = randomLongitude();
   * // => -76.4103176657406
   *)
  (**
   * @function randomLatitude
   * @name randomLatitude
   * @description Generate random latitude
   * @param {object} [optns={}] valid option
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid latitude
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * const latitude = randomLatitude();
   * // => 67.07040223216296
   *)
  (**
   * @function randomPosition
   * @name randomPosition
   * @description Generate next random position
   * @param {object} [optns={}] valid option
   * @param {number} [optns.angle = (Math.random() * 2 * Math.PI)] valid angle in radian between points
   * @param {number} [optns.distance = (Math.random() * 0.0001)] valid distance between points
   * @param {number} [optns.longitude] valid longitude on last point
   * @param {number} [optns.latitude] valid latitude on last point
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid position
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * const position = randomPosition();
   * // => [ -76.4103176657406, 67.07040223216296 ]
   *)
  (**
   * @function randomPositions
   * @name randomPositions
   * @description Generate random positions
   * @param {object} [optns={}] valid option
   * @param {number} [optns.vertices=2] how many positions.
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid positions
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example const geo = randomPositions();
   * // => [ [-76.41031, 67.0704], ...]
   *)
  (**
   * @function randomPoint
   * @name randomPoint
   * @description Generate random GeoJSON Point
   * @param {object} [optns={}] valid option
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid GeoJSON Point
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example const geo = randomPoint();
   * // => { type: 'Point', coordinates:[ ... ] }
   *)
  (**
   * @function randomLineString
   * @name randomLineString
   * @description Generate random GeoJSON LineString
   * @param {object} [optns={}] valid option
   * @param {number} [optns.vertices=2] how many coordinates each LineString will contain.
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid GeoJSON LineString
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example const geo = randomLineString();
   * // => { type: 'LineString', coordinates:[ ... ] }
   *)
  (**
   * @function randomPolygon
   * @name randomPolygon
   * @description Generate random GeoJSON Polygon
   * @param {object} [optns={}] valid option
   * @param {number} [optns.vertices=4] how many coordinates Polygon will contain.
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid GeoJSON Polygon
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const geo = randomPolygon();
   * // => { type: 'Polygon', coordinates:[ ... ] }
   *)
  (**
   * @function randomMultiPoint
   * @name randomMultiPoint
   * @description Generate random GeoJSON MultiPoint
   * @param {object} [optns={}] valid option
   * @param {number} [optns.vertices=2] how many points MultiPoint will contain.
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid GeoJSON MultiPoint
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const geo = randomMultiPoint();
   * // => { type: 'MultiPoint', coordinates:[ ... ] }
   *)
  (**
   * @function randomMultiLineString
   * @name randomMultiLineString
   * @description Generate random GeoJSON MultiLineString
   * @param {object} [optns={}] valid option
   * @param {number} [optns.lines=2] how many LineString.
   * @param {number} [optns.vertices=2] how many coordinates each LineString will contain.
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid GeoJSON MultiLineString
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const geo = randomMultiLineString();
   * // => { type: 'MultiLineString', coordinates:[ ... ] }
   *)
  (**
   * @function randomMultiPolygon
   * @name randomMultiPolygon
   * @description Generate random GeoJSON MultiPolygon
   * @param {object} [optns={}] valid option
   * @param {number} [optns.polygons=2] how many Polygons.
   * @param {number} [optns.vertices=2] how many coordinates each Polygon will contain.
   * @param {number[]} [optns.bbox=[-180, -90, 180, 90]] a bounding box inside
   * of which geometries are placed.
   * @returns {object} valid GeoJSON MultiPolygon
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const geo = randomMultiPolygon();
   * // => {type: 'MultiPolygon', coordinates:[] }
   *)
  (**
   * @function randomGeometry
   * @name randomGeometry
   * @description Generate random GeoJSON Geometry
   * @param {object} [optns={}] valid option
   * @returns {object} valid GeoJSON Geometry
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const geo = randomGeometry();
   * // => { type: 'Point', coordinates:[ ... ] }
   *)
  (**
   * @function randomGeometryCollection
   * @name randomGeometryCollection
   * @description Generate random GeoJSON GeometryCollection
   * @param {object} [optns={}] valid option
   * @returns {object} valid GeoJSON GeometryCollection
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * const geo = randomGeometryCollection();
   * // => { type: 'GeometryCollection', geometries: [ ... ] }
   *)
  (**
   * @function readShapefile
   * @name readShapefile
   * @description Read shapefile stream
   * @param {object} optns valid options
   * @param {string} optns.path valid shapefile path
   * @param {Function} done callback to invoke on feature read
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * readShapefile(path, (error, { finished, feature, next }) => {
   *  // handle read error
   *  if(error) { ... }
   *
   *  // handle read finished
   *  else if(finished){ ... }
   *
   *  // process feature
   *  // and read next chunk
   *  else {
   *   //...
   *   return next();
   *  }
   * });
   *)
  (**
   * @function readGeoJSON
   * @name readGeoJSON
   * @description Read GeoJSON file stream
   * @param {object} optns valid options
   * @param {string} optns.path valid GeoJSON file path
   * @param {Function} done callback to invoke on feature read
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.1.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * readGeoJSON({ path }, (error, { finished, feature, next }) => {
   *  // handle read error
   *  if(error) { ... }
   *
   *  // handle read finished
   *  else if(finished){ ... }
   *
   *  // process feature
   *  // and read next chunk
   *  else {
   *   //...
   *   return next();
   *  }
   * });
   *)
  (**
   * @function readCsv
   * @name readCsv
   * @description Read csv file stream
   * @param {object} optns valid options
   * @param {string} optns.path valid csv file path
   * @param {string} optns.delimiter valid csv field delimiter
   * @param {Function} done callback to invoke on feature read
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.3.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   * readCsv({ path }, (error, { finished, feature, next }) => {
   *  // handle read error
   *  if(error) { ... }
   *
   *  // handle read finished
   *  else if(finished){ ... }
   *
   *  // process feature
   *  // and read next chunk
   *  else {
   *   //...
   *   return next();
   *  }
   * });
   *)
  (**
   * @function readJson
   * @name readJson
   * @description Read json file
   * @param {object} optns valid options
   * @param {string} optns.path valid json file path
   * @param {boolean} optns.throws whether to ignore error
   * @param {Function} done callback to invoke on success read or error
   * @returns {object|Error} error or read json data
   * @author lally elias <lallyelias87@gmail.com>
   * @license MIT
   * @since 0.6.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * readJson({ path }, (error, data) => {
   *  // handle read error
   *  if(error) { ... }
   *
   *  // process json data
   *  else { ... }
   * });
   *)

@lykmapipo/cap-common/lib/index.js:
  (**
   * @function normalizeAlertDates
   * @name normalizeAlertDates
   * @description Normalize alert dates and applying defaults
   * @param {object} alert valid alert in json format.
   * @returns {object} normalize alert.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * normalizeAlertDates(alert);
   * //=> { sent: '2020-08-09T12:48:58.000Z', ... }
   *)
  (**
   * @function normalizeAlertGeos
   * @name normalizeAlertGeos
   * @description Normalize alert geo fields and applying defaults
   * @param {object} alert valid alert in json format.
   * @returns {object} normalize alert.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * normalizeAlertGeos(alert);
   * //=> { info: { area: { geometry: ..., centroid: ... } }, ... }
   *)
  (**
   * @function normalizeAlert
   * @name normalizeAlert
   * @description Normalize a given alert by applying defaults
   * @param {object} alert valid alert in json format.
   * @returns {object} normalize alert.
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * normalizeAlert(alert);
   * //=> { status: 'Draft', ... }
   *)
  (**
   * @function isValid
   * @name isValid
   * @description Check validity of given alert after normalize
   *
   * Note: A valid alert should answer these key questions:
   * - What is happening?
   * - When is it happening?
   * - What should people do?
   * - Where do alerts go?
   * @param {object} alert valid alert in json format.
   * @param {object} [optns] validation options.
   * @param {boolean} [optns.partial=false] whether to perform partial validation
   * @returns {boolean} true if valid else false
   * @author lally elias <lallyelias87@mail.com>
   * @license MIT
   * @since 0.2.0
   * @version 0.1.0
   * @static
   * @public
   * @example
   *
   * isValid(alert);
   * //=> true
   *)
*/
